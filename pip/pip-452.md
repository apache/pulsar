# PIP-452: Customizable Topic Listing in GetTopicsOfNamespace with properties

# Motivation
Currently, the CommandGetTopicsOfNamespace logic in the Pulsar Broker is hard-coded to scan the metadata store (ZooKeeper) for all children nodes under a namespace.

This implementation limits the flexibility required for complex multi-tenant scenarios:

No Client Context: The broker cannot distinguish who is asking for the topics or why. It cannot filter topics based on client properties (This properties may be related to topic properties).

Inefficient Filtering: For namespaces with millions of topics, the broker must fetch the full list into memory before applying the topics_pattern regex. There is no way to "push down" the filtering to the data source (e.g., a database with an index).

To address these issues, I propose making the topic listing logic pluggable and extending the protocol to accept client properties.

# Goals
Protocol: Add a properties field to `CommandGetTopicsOfNamespace` to carry client-side context.

Broker: Introduce a `NamespaceTopicListingStrategy` SPI to customize how topics are retrieved.

Client: Update the Java Client to forward Consumer properties to the lookup service when using Regex subscriptions.

# High Level Design
We will modify the Pulsar Protocol to carry a properties map. On the Broker side, we will abstract the topic retrieval logic into a NamespaceTopicListingStrategy.
The default implementation will preserve the existing behavior (fetching from ZooKeeper). The Broker's connection handler will simply delegate the request to this strategy.

# Detailed Design
1. Protocol Changes
We update `PulsarApi.proto` to include the properties field.

PulsarApi.proto
```protobuf
message CommandGetTopicsOfNamespace {
    required uint64 request_id = 1;
    required string namespace = 2;
    optional Mode mode = 3 [default = PERSISTENT];
    
    // Existing fields for filtering and hash optimization
    optional string topics_pattern = 4;
    optional string topics_hash = 5;

    // New field: Context properties from the client
    repeated KeyValue properties = 6;
}
```
2. Broker Changes
New Interface: `NamespaceTopicListingStrategy`
We introduce a strategy interface in the broker.

```java
package org.apache.pulsar.broker.namespace;

import java.util.List;

public class NamespaceTopicListingResult {
    private final List<String> topics;
    
    // Indicates if the plugin has already applied the regex filtering provided in the request.
    // If true, the Broker will SKIP the subsequent filtering step.
    private final boolean filtered;

    public NamespaceTopicListingResult(List<String> topics, boolean filtered) {
        this.topics = topics;
        this.filtered = filtered;
    }

    public List<String> getTopics() {
        return topics;
    }

    public boolean isFiltered() {
        return filtered;
    }
}
```

```Java

package org.apache.pulsar.broker.namespace;

import org.apache.pulsar.common.naming.NamespaceName;
import org.apache.pulsar.common.api.proto.CommandGetTopicsOfNamespace.Mode;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public interface NamespaceTopicListingStrategy {

    /**
     * Initialize the strategy.
     * @param pulsar The PulsarService instance.
     */
    void initialize(PulsarService pulsar);

    /**
     * Retrieve the list of topics under the given namespace.
     *
     * @param namespace The namespace name.
     * @param mode The mode (PERSISTENT, NON_PERSISTENT, or ALL).
     * @param topicsPattern The regex pattern for topic filtering (optional). 
     * Implementations MAY use this for optimization, or ignore it.
     * @param properties Custom properties passed from the client (optional).
     * @return A future containing the list of topic names.
     */
    CompletableFuture<NamespaceTopicListingResult> getListOfTopics(NamespaceName namespace, 
                                                    Mode mode, 
                                                    String topicsPattern,
                                                    Map<String, String> properties);
}
```

Broker Configuration
Add a new configuration to broker.conf:

```properties
# Class name for the pluggable topic listing strategy
topicListingStrategyClassName=org.apache.pulsar.broker.namespace.DefaultNamespaceTopicListingStrategy
````

ServerCnx Logic Update
In ServerCnx.java, the method internalHandleGetTopicsOfNamespace will be updated to use this strategy.

```java
import java.util.HashMap;

// Extract context and pattern from the command
Map<String, String> properties = new HashMap<>();
command.getPropertiesList().forEach(kv -> properties.put(kv.getKey(), kv.getValue()));
String pattern = command.hasTopicsPattern() ? command.getTopicsPattern() : null;

// Delegate to the strategy
return getBrokerService().getTopicListingStrategy()
    .getListOfTopics(namespaceName, mode, pattern, context)
    .thenCompose(topicListingResult -> {
         // filter system topic
         List<String> filteredTopics = topicListingResult.getTopics();
         boolean filterTopics = topicListingResult.isFiltered();
        // 1. Calculate the actual memory size of the returned list
        long actualSize = TopicListMemoryLimiter.estimateTopicListSize(filteredTopics);

        // 2. Update Global Cache (High Water Mark Strategy)
        listSizeHolder.updateSize(actualSize);

        // 3. Adjust memory permits and proceed
        return maxTopicListInFlightLimiter.withUpdatedPermits(initialPermits, actualSize,
                isPermitRequestCancelled, permits -> {
                    // 4. Calculate Hash and Send Response
                    String hash = TopicList.calculateHash(filteredTopics);
                    boolean hashUnchanged =
                            topicsHash.isPresent() && topicsHash.get().equals(hash);
                    if (hashUnchanged) {
                        filteredTopics = Collections.emptyList();
                    }
                    return commandSender.sendGetTopicsOfNamespaceResponse(filteredTopics,
                            hash,
                            filterTopics, !hashUnchanged, requestId, ex -> {
                                log.warn("[{}] Failed to acquire direct memory permits for "
                                                + "GetTopicsOfNamespace: {}", remoteAddress,
                                        ex.getMessage());
                                commandSender.sendErrorResponse(requestId,
                                        ServerError.TooManyRequests,
                                        "Cannot acquire permits for direct memory");
                            });
}, 
                // Handle exception for permit acquisition failure
                t -> { ... }
        );
    });
```

3. Client Changes
Update LookupService
The internal LookupService interface is updated to accept the properties map.

```Java
CompletableFuture<List<String>> getTopicsUnderNamespace(
    NamespaceName namespace, 
    Mode mode, 
    String topicsPattern, 
    String topicsHash, 
    Map<String, String> properties
);
```
Update `PatternMultiTopicsConsumerImpl`
The regex consumer implementation (PatternMultiTopicsConsumerImpl) will be updated to extract the properties from ConsumerConfigurationData and pass them to the LookupService.

```Java
// In PatternMultiTopicsConsumerImpl.java
Map<String, String> contextProperties = conf.getProperties();

lookup.getTopicsUnderNamespace(
    namespace, 
    mode, 
    topicsPattern.pattern(), 
    topicsHash, 
    contextProperties // Pass properties here
).thenAccept(topics -> {
    // ... update subscriptions ...
});
```
# Backward Compatibility
Protocol: Adding an optional field (properties) to the Protobuf definition is non-breaking. Old clients will not send this field; old brokers will ignore it.

Behavior: The default strategy mimics the current behavior exactly. The Broker retains the final filtering logic, ensuring that even custom strategies cannot return topics that violate the client's requested pattern.

# Security Considerations
Input Validation: The properties map is user-supplied input. Implementers of the NamespaceTopicListingStrategy MUST validate and sanitize these inputs before using them, especially if they are used to construct database queries.

Authorization: This PIP only controls the discovery (listing) of topics. It does not bypass the Authorization Service for consuming or producing to those topics.

# Links

* Mailing List discussion thread:
* Mailing List voting thread: