# Background knowledge

The `Replication task execution process` works like this:
1. read messages from the origin cluster by Managed Cursor.
1. send the messages to the target cluster by the internal producer of Replicator one by one.

The `Messages Send Progress` works like this:
1. build message metadata and popular the message payload(build batch messages payload, compression, and encryption).
1. build the Send Command(a bytes array).
1. switch to the io thread(the connection worker thread)
1. write data and flush.

# Motivation
In the scenario replication
- there are a lot of tasks for `push into the queue` and `pop out from the queue` due to the `step-3` of `Messages Send Progress,` which leader the CPIU high load.
- there is a lot of `fd.write` due to the `step-3` of `Messages Send Progress,` which does not make good use of buffers to improve performance.

# Goals
Replicate messages in batches instead of sending them one by one.

# High-Level Design
- For `step-3` of `Messages Send Progress,` the thread is switched to perform IO operations only when there are enough messages.
- For `step-3` of `Messages Send Progress,` make full use of buffers to improve throughput.

# Detailed Design

### Design & Implementation Details
Add a new producer implementation that extends `ProducerImpl`, it caches the Cmd-Send, and does the sending in batch.

### Public API
**BatchIOProducerImpl.java**
```
class BatchIOProducerImpl extends ProducerImpl {
  @Override
  protected void processOpSendMsg(OpSendMsg op) {
     // cache Cmd-Send and do the sending in batch.
  }
}
```

**ProducerBuilder.java**
```java
void enableBatchIO(BatchIOPololicy batchIOPolicy);
```

**BatchIOPololicy..java**
```java
/** Maximum waiting time in millis. **/
long maxDelayMillis;
/** The maximum number of bytes in an IO flush. **/
long maxBatchSize;
```

**ClientBuilder.java**
```java
/** Add a limitation of memory usage for the batch IO feature. After reaching this limitation, the messages will be sent immediately **/
long maxMemoryUsageForBatchIOProducersInBytes;
```

### A demo of usage
```java
long maxDelayMillis = 100;
long maxBatchSize = 1mb;
BatchIOPololicy policy = new BatchIOPololicy(100, maxBatchSize);
Producer producer = pulsarClient.newProducer().topic(topicName).enableBatchIO(policy).create();
```

### Metrics
**pulsar_replicator_io_buffer_total_bytes**
- Description: the bytes size cost of messages which waiting to be sent by the replicator due to the batch I/O feature.
- type: Gauge
- labels: `[cluster, namespace, topic]`
- unit: bytes

**pulsar_replicator_io_per_buffer_bytes**
- Description: the data size of the replicator each sending.
- type: Histogram
- labels: `[cluster, namespace, topic]`
- unit: bytes

### Test
- [ ] Performance comparison with the original implementation

# Monitoring
If there is no backlog of the replicators, but the metrics `pulsar_replicator_io_buffer_total_bytes` is still not equal to zero, there is a bug.
