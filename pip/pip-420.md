# PIP-420: Provides an ability for Pulsar clients to integrate with third-party schema registry service

# Motivation

Apache Pulsar currently provides a built-in schema management system tightly coupled with the broker.
Pulsar clients interact with this system implicitly when creating producers and consumers.

However, many organizations already have independent schema registry services (such as Confluent Schema Registry) 
and wish to reuse their existing schema governance processes across multiple messaging systems, including Pulsar.

By enabling Pulsar clients to integrate with third-party schema registry services:
- Users can unify schema management across different platforms. 
- Pulsar brokers can be decoupled from schema storage and validation responsibilities.
- Pulsar users can integrate with ecosystems that rely on external schema registries easier.

This flexibility is particularly valuable for enterprises with strict schema validation, versioning,
and governance workflows already centralized in external registries.

# Goals

## In Scope

- Provide the ability for Pulsar clients to leverage third-party schema registry services for schema operations.

## Out Scope

- Providing built-in implementations for third-party schemas.
- Support `AutoProduceBytesSchema` and `AutoConsumeSchema`.
- Migrating existing Pulsar-managed schemas to external schema registries.

# High Level Design

- Provide a mechanism to configure the Pulsar client to use either:
  - The existing Pulsar schema registry (default)
  - Third-party schema registry implementations

# Detailed Design

## Design & Implementation Details

This PIP aims to enable the Pulsar client to directly integrate with external schema registry services for schema management.
In this model, the external schema registry is fully responsible for schema storage, retrieval, and validation.
The Pulsar broker will no longer manage schema data for topics using external schemas.

### SchemaType: EXTERNAL

Pulsar will introduce a new schema type: **SchemaType.EXTERNAL**.

- All schemas that integrate with external schema registries must declare `SchemaType.EXTERNAL`.
- When using `EXTERNAL` schema type, the Pulsar client will provide empty schema data to the broker.
- The broker will only record the schema type for topics.
- Compatibility restrictions:
  - Introduce a new compatibility check in broker side.
  - The schema type `SchemaType.EXTERNAL` can't be compatible with other Pulsar schemas
  - This prevents accidental data corruption or schema conflicts between internal and external schema management systems.
- Pulsar Geo replicator needs to transfer the schema type `SchemaType.EXTERNAL` to the remote cluster.

This design isolates external schema management and protects existing topics using Pulsar’s native schema system.

### Extensibility via Client Interfaces

To integrate with external schema registries, users can:
- Implement the `Schema` interface to define custom schema encoding and decoding logic.

#### Key `Schema` Interface Methods:
- byte[] encode(T message)
  - Serializes the message using the external schema. 
  - Implementations should throw `SchemaSerializationException` if the serialization fails.

- T decode(byte[] bytes)
  - Deserialize the message using the external schema.
  - Users should handle exceptions when get value by themselves.

- void setSchemaInfoProvider(SchemaInfoProvider schemaInfoProvider)
  - Call this method when creating schema
  - External schema can be initialized when calling this method

- close() **(New addition)**
  - Called when the producer or consumer is closed.
  - Allows external schema implementations to release resources, such as schema registry connections or caches.

#### Example Workflow:

- During producer or consumer initialization:
  The external schema info will be registered to Pulsar schema storage.

- During message send or receive:
  The `encode` and `decode` methods handle the schema-aware serialization and deserialization using the external schema registry.

#### Schema ID & Schema Version

Unlike Pulsar, which uses **schema version** to identify schemas, many external schema registry systems use **schema ID** as the primary schema identifier.

When integrating with external schema registries:
- The `schemaVersion` filed in Pulsar message metadata is used in some places, **set to `-1` to flag the message is using external schema systems**.
- The Pulsar client **needs to set the schema version to -1 and store in the message metadata**.
- Instead, the external schema implementation can manage schema ID handling internally.
- The schema ID can be embedded directly into the message payload by the external schema’s `encode` and `decode` methods.

This approach allows external schema systems to fully control schema evolution and versioning without being constrained by Pulsar’s native schema versioning mechanism.
This may impact some components that rely on schema version to deserialize messages, such as Pulsar Functions and Pulsar SQL,
they will need to be updated to support the new schema type and handle external schemas appropriately.

#### Example usage

```java
public void workWithExternalSchemaRegistry() throws Exception {
    Map<String, String> srConfig = new HashedMap<>();
    srConfig.put("schema.registry.url", "http://localhost:8001");

    String topic = "testExternalJsonSchema";
  
    Schema<User> schema = KafkaSchemas.JSON(User.class);
  
    @Cleanup
    PulsarClient pulsarClient = PulsarClient.builder()
            .serviceUrl("pulsar://localhost:" + getBrokerServicePort())
            .schemaProperties(srConfig)
            .build();
  
    @Cleanup
    Producer<User> producer = pulsarClient.newProducer(schema)
            .topic(topic)
            .create();
  
    @Cleanup
    Consumer<User> consumer = pulsarClient.newConsumer(schema)
            .topic(topic)
            .subscriptionName("sub")
            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
            .subscribe();
  
    for (int i = 0; i < 10; i++) {
      producer.send(new User("name-" + i, 10 + i));
    }
  
    for (int i = 0; i < 10; i++) {
      Message<User> message = consumer.receive();
      consumer.acknowledge(message);
      assertEquals(message.getValue().getName(), "name-" + i);
    }
}
```

## Public-facing Changes

Introduce a new SchemaType `EXTERNAL` to represent the schema types that work with external schema registry.
```java
public enum SchemaType {

    /**
     * External Schema Type.
     * <p>
     * This is used to indicate that the schema is managed externally, such as in a schema registry.
     * External schema type is not compatible with any other schema type.
     * </p>
     */
    EXTERNAL(21)

}
```

```protobuf
// File `SchemaRegistryFormat.proto`
message SchemaInfo {
    enum SchemaType {
        EXTERNAL = 22;
    }
}
```

```protobuf
// File `PulsarApi.proto`
message Schema {
    enum Type {
        External = 22;
    }
}
```

Add a new method `getConfigs` for `SchemaInfoProvider` interface to provide necessary params for external schemas connect to the schema registry service.
```java
public interface SchemaInfoProvider {

    /**
      * Returns the configs of the schema registry service, such as URL, authentication params.
      */
    default Map<String, String> getConfigs() {
        return Collections.emptyMap();
    }

}
```

The client build supports setting the `schemaProperties`.
```java
public interface ClientBuilder extends Serializable, Cloneable {

  /**
   * Set the properties used for schema.
   * <p>
   *     These properties will be used to configure the schema registry client.
   * </p>
   * @param properties schema registry properties
   */
  ClientBuilder schemaProperties(Map<String, String> properties);

}
```

The `ClientConfigurationData` supports transfer `schemaProperties`.
```java
public class ClientConfigurationData implements Serializable, Cloneable {

    private Map<String, String> schemaProperties;

}
```

The customized external schemas can get the `SchemaInfoProvider` and retrieve the configs from it, extends the interface `AutoCloseable` to support close external schema resources.
```java
public interface Schema extends Cloneable, AutoCloseable {

    @Override
    default void close() {
        // no-op
    }

    /**
     * When setting schema info provider for schema, the schema can retrieve the configs and initialize itself.
     */
    default void setSchemaInfoProvider(SchemaInfoProvider schemaInfoProvider) {
    }

}
```

# Pulsar Function

For support using third-party schema registry service in Pulsar Function,
- Support setting the `schemaProperties` while initializing the Pulsar client
- Support the `SchemaType.EXTERNAL` schema type in Pulsar Function

# Security Considerations

Users can provide schema registry security configuration in the `schemaProperties`.

# Pulsar-GEO replication impact

Integrating third-party schema registry services introduces a new approach to managing schemas for geo-replicated topics.

In the current Pulsar architecture:
- Schema definitions are stored and managed by the Pulsar brokers.
- During geo-replication, schema information must also be replicated across clusters to ensure schema consistency.

By using an external schema registry:
- **Schema management is fully decoupled from Pulsar brokers and replication mechanisms.**
- This eliminates the need for synchronizing schema data between Pulsar clusters, simplifying geo-replication processes.
- Supports a unified schema registry for cross-cluster producers and consumers

# Backward & Forward Compatibility

The new schema type `SchemaType.EXTERNAL` doesn't break any existing Pulsar topics, it's not compatible with other Pulsar schema types.

# Alternatives

Use `bytes` schema for "external" schemas, it can't provide any compatibility checks to protect topic data that use Pulsar's native schema system.

# General Notes

# Links

<!--
Updated afterwards
-->
* Mailing List discussion thread: https://lists.apache.org/thread/olx4xm8cdy43omp5c0jm44sj1gp0grcr
* Mailing List voting thread: https://lists.apache.org/thread/vhq6ox4nh2rx59yoxowftqzv8f9lnm4q
