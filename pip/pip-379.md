# PIP-379: Key_Shared Draining Hashes for Improved Message Ordering

## Background Knowledge

Apache Pulsar's Key_Shared subscription mode is designed to provide ordered message delivery on a per-key basis while allowing multiple consumers to process messages concurrently. This mode is particularly useful in scenarios where maintaining message order for specific keys is crucial, but overall throughput can be improved by parallelizing message consumption across multiple consumers.

Key concepts:
- **Key_Shared subscription**: A subscription mode that maintains message ordering per key while allowing multiple consumers.
- **Hash ranges**: In AUTO_SPLIT mode, the hash space is divided among active consumers to distribute message processing.
- **Pending messages**: Messages that have been sent to a consumer but not yet acknowledged (also called "pending acks" or "unacknowledged messages").

Key_Shared subscriptions allow multiple consumers to attach to the same subscription. Messages with the same key or same ordering key are delivered to only one consumer. There's a guarantee that messages with the same key are processed in order by a single consumer. This consumer can change only after all pending messages are acknowledged or the original consumer disconnects.

For more details on Pulsar subscriptions, see the [Pulsar documentation on Key_Shared subscription](https://pulsar.apache.org/docs/concepts-messaging/#key_shared).

## Motivation

The current implementation of Key_Shared subscriptions faces several challenges:

1. **Complexity**: The existing solution for managing "recently joined consumers" is overly complex, making the system harder to maintain and debug.
2. **Incomplete Ordering Contract Fulfillment**: The current implementation struggles to consistently prevent messages from being sent to another consumer while pending on the original consumer. While Key_Shared subscriptions aim to preserve message ordering per key, the current implementation may not always achieve this, especially during consumer changes. There's a potential corner case reported in [issue #23307](https://github.com/apache/pulsar/issues/23307).
3. **Usability Issues**: Detecting the reason why messages get blocked is time-consuming and difficult.
4. **Unnecessary Message Blocking**: The current implementation blocks delivery for all messages when any hash range is blocked, even if other keys could be processed independently. This leads to suboptimal utilization of consumers and increased latency for messages that could otherwise be processed.
5. **Observability Challenges**: The current implementation lacks clear visibility into the consuming state when processing gets stuck, making it harder to build automation for detecting and mitigating issues.

These issues lead to potential message delivery delays, unnecessary duplicate messages, and scenarios where manual intervention is required to recover from stuck consumers. Additionally, the current design doesn't allow for efficient processing of messages across all available keys when some keys are blocked, resulting in reduced overall system throughput and latency for message processing.

## Goals

### In Scope

- Implement a new "draining hashes" concept to efficiently manage message ordering in Key_Shared subscriptions.
- Clarify and fulfill the key-ordered message delivery contract for Key_Shared AUTO_SPLIT mode.
- Fix current issues where messages are sent out-of-order or when a single key is outstanding in multiple consumers at a time.
- Improve the handling of unacknowledged messages to prevent indefinite blocking and consumers getting stuck.
- Minimize memory usage for pending message tracking, eliminating PIP-282's "sent positions" tracking.
- Enhance the reliability, usability, and scalability of Key_Shared subscriptions.
- Improve observability of Key_Shared subscriptions to aid in troubleshooting and automation.
- Ensure strict ordering guarantees for messages with the same key, even during consumer changes.

### Out of Scope

- Changes to other subscription types (Exclusive, Failover, Shared).

## High-Level Design

The proposed solution introduces a "draining hashes" concept to efficiently manage message ordering in Key_Shared subscriptions:

1. When consumer hash ranges change (e.g., a consumer joins or leaves), affected hashes of pending messages are added to a "draining hashes" set.
2. Following messages with hashes in the "draining hashes" set are blocked from further delivery until pending messages are processed.
3. A reference counter tracks pending messages for each hash in the "draining hashes" set.
4. As messages are acknowledged or consumers disconnect and therefore get removed from pending messages, the reference counter is decremented.
5. When the reference counter reaches zero, the hash is removed from the set, allowing new message delivery.
6. Consumer hash assignments may change multiple times, and a draining hash might be reassigned to the original consumer. The draining hash data structure contains information about the draining consumer. When a message is attempted for delivery, the system can check if the target consumer is the same as the draining consumer. If they match, there's no need to block the hash. The implementation should also remove such hashes from the draining hashes set. This "lazy" approach reduces the need for actively scanning all draining hashes whenever hash assignments change.

This approach maintains strict ordering guarantees when required while minimizing the impact on performance and memory usage. The tracking only comes into play during transition states. When consumers have been connected for a longer duration and all draining hashes have been removed, there won't be a need to check any special rules or maintain any extra state.

## Public-facing Changes

### Topic Stats Changes & Observability

Topic stats for the removed PIP-282 "recently joined consumers"/"last sent position" solution are removed:
- `lastSentPositionWhenJoining` field for each consumer
- `consumersAfterMarkDeletePosition` field for each Key_Shared subscription
- `individuallySentPositions` field for each Key_Shared subscription

New topic stats will be added to monitor the "draining hashes" feature at the subscription level and consumer level:
1. `draining_hashes_count`: The current number of hashes in the draining state.
2. `draining_hashes_pending_messages`: The total number of pending messages for all draining hashes.
3. `draining_hashes_cleared_total`: The total number of hashes cleared from the draining state.
4. `draining_hashes`: Details at the hash level (available at the consumer level to reduce redundancy of information)
   - hash
   - number of pending messages

For improved observability, a separate REST API for listing all pending messages ("pending acks") for a consumer will be considered. This API would allow querying which messages are currently part of a draining hash, providing a way to identify specific message IDs of messages that are holding onto a specific hash and blocking delivery to another consumer.

## Backward & Forward Compatibility

The "draining hashes" feature doesn't introduce backward or forward compatibility issues. The state is handled at runtime, and the changes are on the broker side without changes to the client protocol.

## Links

- Mailing List discussion thread: https://lists.apache.org/thread/l5zjq0fb2dscys3rsn6kfl7505tbndlx
- Mailing List voting thread: [To be updated]

- [PIP-282: Change definition of the recently joined consumers position](https://github.com/apache/pulsar/blob/master/pip/pip-282.md)
- [Pulsar issue #23307: Message ordering isn't retained in Key_Shared AUTO_SPLIT mode in a rolling restart type of test scenario](https://github.com/apache/pulsar/issues/23307)
- [Pulsar issue #21199: Key_Shared subscription gets stuck after consumer reconnects](https://github.com/apache/pulsar/issues/21199)