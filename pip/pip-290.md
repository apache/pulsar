# Background knowledge

[WebSocket Proxy](https://pulsar.apache.org/docs/3.0.x/client-libraries-websocket/#run-the-websocket-service) provides a simple way to interact with Pulsar under `WSS` protocol.
- When a [wss-producer](https://pulsar.apache.org/docs/3.0.x/client-libraries-websocket/#nodejs-producer) was registered, WebSocket Proxy will create a one-to-one producer to actually send messages to the Broker.
- When a [wss-consumer](https://pulsar.apache.org/docs/3.0.x/client-libraries-websocket/#nodejs-consumer) was registered, WebSocket Proxy will create a one-to-one consumer to actually receive messages from the Broker and send them to WSS Consumer.

When a user wants to encrypt the message payload, there are two solutions:
- **Solution 1**: encrypt message payload before WSS Producer sends messages, and decrypt after WSS Consumer receives messages. If the user wants to use different encryption keys for different messages, they can set a [property](https://github.com/apache/pulsar/blob/master/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessage.java#L38) into messages to indicate the message was encrypted by which key. But this solution has a shortcoming: if the user also has consumers with Java clients, then these consumers cannot auto-decrypt the messages(Normally, java clients can [decrypt messages automatically](https://pulsar.apache.org/docs/3.0.x/security-encryption/#how-it-works-in-pulsar)). And the benefit of this solution is that the user does not need to expose the private key to WebSocket Proxy.
- **Solution 2**: In the release `2.11`, there is a [feature](https://github.com/apache/pulsar/pull/16234) that provides a way to set encrypt keys for the internal producers and consumers of WebSocket Proxy, but needs the user to upload both public key and private key into the WebSocket Proxy(in other words: user should expose the keys to WebSocket Proxy), there is a un-recommended workaround for this shortcoming<sup>[1]</sup>. The benefit is that the WSS producer and WSS consumer should not care about encryption and decryption.

# Motivation

Therefore, there is no way to enable encryption under the WSS protocol and meet the following conditions:
- WSS producer and WSS consumer did encrypt and decrypt themself and did not share private keys to WebSocket Proxy.
- Other clients(such as Java and CPP) can decrypt the messages automatically.

# Goals
Provide a way to implement WSS E2E encryption and not need to expose the private key to the WebSocket Proxy.
Note: I want to cherry-pick this feature into `branch-2.11`

# High-Level Design
Provide a config `enabledE2ECompressionAndEncryption` for the WebSocket Proxy to change the behavior like the below:
- Users do the encryption themself before the WSS producer sends messages, and the internal producer of the WebSocket Proxy just adds the encryption metadata to the message and does not encrypt the message payload.
-  The internal consumer of the WebSocket Proxy just transports the messages to the WSS consumer and does not do decryption; users do the decryption themself after receiving messages from the WSS consumer.

Since the producer does the compression before encryption, users should also do the compression themselves.

Since parsing batch messages require decoding first, so the producer can not send batch messages if turned on the config `enabledE2ECompressionAndEncryption`.

# Detailed Design

### Configuration
Add config to the config file `websocket.conf`.

```properties
# see explanation in the section High-Level Design
enabledE2ECompressionAndEncryption=false
```

### Public API
Add a new API for the [ConsumerBuilder](https://pulsar.apache.org/api/client/3.0.x/org/apache/pulsar/client/api/ConsumerBuilder.html)
```java
/**
 * Skip decompression, decryption, and parse batch messages and just respond to you the original bytes payload if set to "false"; the default value is "true." 
 * It is only used for WSS API to skip these three actions now, don't change it if you don't understand how it works.
 */
void autoDecompressDecryptionAndParseBatchMessages(boolean enabled);
```

### A quick explanation of the used components in the section Design:
- `CompressionCodec`: a component of the producer, does compression of message payload before doing encryption.
- `CompressionCodecNone`: an empty implementation of the interface `CompressionCodec`.
- `MessageCrypto`: a component of the producer,  adds encryption metadata for messages and encrypts the message payload after doing message payload compression.

### Design
- Add a new `WebSocketE2EMessageCrypto` that implements the interface `MessageCrypto`(`MessageCrypto` is used to ). It just adds encryption metadata of messages and does not encrypt the message payload.
- For all internal producers of the WebSocket Proxy
    - forcefully set the component `CompressionCodec` to `CompressionCodecNone`, and print a warning log if users set `compressionType`.
    - forcefully set the component `MessageCrypto` to `WebSocketE2EMessageCrypto`, and print a warning log if users set `encryptionKeys`.
    - forcefully set `enableBatching` to `false`, and print a warning log if users set `enableBatching`, `batchingMaxMessages`, `maxPendingMessages`, `batchingMaxPublishDelay`.
- For all internal consumers of the WebSocket Proxy, forcefully set  `autoDecompressDecryptionAndParseBatchMessages` to `false`.

### Test cases
The test cases all run under setting `enabledE2ECompressionAndEncryption` to `true`.
- Pub & Sub with WSS producer and consumer.
    - compression & decryption.
- Pub with Java client library and Sub with WSS consumers.
    - non-compression & decryption.
    - compression & non-decryption.
    - compression & decryption.
    - compression & decryption & batch send.
- Pub with WSS protocol and Sub with Java client library(verify it can auto decompression, decryption).
    - non-compression & decryption.
    - compression & non-decryption.
    - compression & decryption.

# Footnotes
**[1]**: A workaround to avoid exposing the private key to WebSocket Proxy(should expose the public key to WebSocket Proxy).
A quick background: there are three policies when a consumer cannot describe the message payload:
- CONSUME: it responds to the user's original message payload and prints a warning log.
- DISCARD: discard this message.
- FAIL: add this message into `unackMessagesTracker.` How this message is ultimately handled depends on the policy of unacknowledged messages.

**Workaround**
- Set `cryptoFailureAction` to `CONSUME` for the WSS consumer
- Make the return value `EncryptionKeyInfo` to `null` for the `CryptoKeyReader`. This will make the internal consumer of WebSocket Proxy decrypt message payload fail.

Then the flow of Pub & Sub will be executed like the following:
- Users do not encrypt message payload before the WSS producer sends messages.
- The internal producer of WebSocket does message payload encryption by the [feature: Support encryption in WebSocket Proxy](https://github.com/apache/pulsar/pull/16234)
- The decryption of the internal consumer of WebSocket Proxy message payload will be failed, and just send original message payload to the users.
- Users decrypt the message payload themself.
