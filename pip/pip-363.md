
# PIP-363: Introduce a new load balance algorithm AvgShedder

# Background knowledge

Pulsar has two load balance interfaces:
- `LoadSheddingStrategy` is an unloading strategy that identifies high load brokers and unloads some of the bundles they carry to reduce the load.
- `ModularLoadManagerStrategy` is a placement strategy responsible for assigning bundles to brokers.

## LoadSheddingStrategy
There are three available algorithms: `ThresholdShedder`, `OverloadShedder`, `UniformLoadShedder`.

### ThresholdShedder
`ThresholdShedder` uses the following method to calculate the maximum resource utilization rate for each broker,
which includes CPU, direct memory, bandwidth in, and bandwidth out.
```
    public double getMaxResourceUsageWithWeight(final double cpuWeight,
                                                final double directMemoryWeight, final double bandwidthInWeight,
                                                final double bandwidthOutWeight) {
        return max(cpu.percentUsage() * cpuWeight,
                directMemory.percentUsage() * directMemoryWeight, bandwidthIn.percentUsage() * bandwidthInWeight,
                bandwidthOut.percentUsage() * bandwidthOutWeight) / 100;
    }
```

After calculating the maximum resource utilization rate for each broker, a historical weight algorithm will
also be executed to obtain the final score.
```
historyUsage = historyUsage == null ? resourceUsage : historyUsage * historyPercentage + (1 - historyPercentage) * resourceUsage;
```
The historyPercentage is determined by configuring the `loadBalancerHistoryResourcePercentage`. 
The default value is 0.9, which means that the last calculated score accounts for 90%, 
while the current calculated score only accounts for 10%.

The introduction of this historical weight algorithm is to avoid bundle switching caused by
short-term abnormal load increase or decrease, but in fact, this algorithm will introduce some
serious problems, which will be explained in detail later.

Next, calculate the average score of all brokers in the entire cluster: `avgUsage=totalUsage/totalBrokers`. 
When the score of any broker exceeds a certain threshold of avgUsage, it is determined that the broker is overloaded.
The threshold is determined by the configuration `loadBalancerBrokerThresholdShedderPercentage`, with a default value of 10.


### OverloadShedder
`OverloadShedder` use the same method `getMaxResourceUsageWithWeight` to calculate the maximum resource utilization rate for each broker.
The difference is that `OverloadShedder` will not use the historical weight algorithm to calculate the final score, 
the final score is the current maximum resource utilization rate of the broker.

After obtaining the load score for each broker, compare it with the `loadBalancerBrokerOverloadedThresholdPercentage`. 
If the threshold is exceeded, it is considered overloaded, with a default value of 85%.

This algorithm is relatively simple, but there are many serious corner cases, so it is not recommended to use `OverloadShedder`.
Here are two cases:
- When the load on each broker in the cluster reaches the threshold, the bundle unload will continue to be executed,
   but it will only switch from one overloaded broker to another, which is meaningless.
- If there are no broker whose load reaches the threshold, adding new brokers will not balance the traffic to the new added brokers.
The impact of these two points is quite serious, so we won't talk about it next.


### UniformLoadShedder
`UniformLoadShedder` will first calculate the maximum and minimum message rates, as well as the maximum and minimum 
traffic throughput and corresponding broker. Then calculate the maximum and minimum difference, with two thresholds 
corresponding to message rate and throughput size, respectively.

- loadBalancerMsgRateDifferenceShedderThreshold

The message rate percentage threshold between the highest and lowest loaded brokers, with a default value of 50,
can trigger bundle unload when the maximum message rate is 1.5 times the minimum message rate. 
For example, broker 1 with 50K msgRate and broker 2 with 30K msgRate will have a (50-30)/30=66%>50% difference in msgRate,
and the load balancer can unload the bundle from broker 1 to broker 2.

- loadBalancerMsgThroughputMultiplierDifferenceShedderThreshold

The threshold for the message throughput multiplier between the highest and lowest loaded brokers, 
with a default value of 4, can trigger bundle unload when the maximum throughput is 4 times the minimum throughput.
For example, if the msgRate of broker 1 is 450MB, broker 2 is 100MB, and the difference in msgThrough 
is 450/100=4.5>4 times, then the load balancer can unload the bundle from broker 1 to broker 2.


After introducing the algorithm of `UniformLoadShedder`, we can clearly obtain the following information:
- `UniformLoadShedder` does not have the logic to handle load jitter. For example,
when the traffic suddenly increases or decreases. This load data point is adopted, triggering a bundle unload.
However, the traffic of this topic will soon return to normal, so it is very likely to trigger a bundle unload again.
This type of bundle unload should be avoided. This kind of scenario is very common, actually.

- `UniformLoadShedder` does not rely on indicators such as CPU usage and network card usage to determine high load
and low load brokers, but rather determines them based on message rate and traffic throughput size,
while `ThresholdShedder` and `OverloadShedder` rely on machine resource indicators such as CPU usage to determine.
If the cluster is heterogeneous, such as different machines with different hardware configurations, 
or if there are other processes sharing resources on the machine where the broker is located, 
`UniformLoadShedder` is likely to misjudge high and low load brokers, thereby migrating the load from high-performance 
but low load brokers to low-performance but high load brokers. 
Therefore, it is not recommended for users to use `UniformLoadShedder` in heterogeneous environments.

- `UniformLoadShedder` will only unload the bundle from one of the highest loaded brokers at a time,
which may take a considerable amount of time for a large cluster to complete all load balancing tasks.
For example, if there are 100 high load brokers in the current cluster and 100 new machines to be added,
it is roughly estimated that it will take 100 shedding to complete the balancing.
However, since the execution time interval of the `LoadSheddingStrategy` policy is determined by the 
configuration of `loadBalancerSheddingIntervalMinutes`, which defaults to once every 1 minute, 
so it will take 100 minutes to complete all tasks. For users using large partition topics, their tasks 
are likely to be disconnected multiple times within this 100 minutes, which greatly affects the user experience.


## ModularLoadManagerStrategy
The `LoadSheddingStrategy` strategy is used to unload bundles of high load brokers. However, in order to 
achieve a good load balancing effect, it is necessary not only to "unload" correctly, but also to "load" correctly.
The `ModularLoadManagerStrategy` strategy is responsible for assigning bundles to brokers.
The coordination between `LoadSheddingStrategy` and `ModularLoadManagerStrategy` is also a key point worth paying attention to.

### LeastLongTermMessageRate
The `LeastLongTermMessageRate` algorithm directly used the maximum resource usage of CPU and so on as the broker's score,
and reused the `OverloadShedder` configuration, `loadBalancerBrokerOverloadedThresholdPercentage`. 
If the score is greater than it (default 85%), set `score=INF`; Otherwise, update the broker's score to the sum of the 
message in and out rates obtained from the broker's long-term aggregation.
```
score = longTerm MsgIn rate+longTerm MsgOut rate, 
```
Finally, randomly select a broker from the broker with the lowest score to return. If the score of each broker is INF,
randomly select broker from all brokers.

The scoring algorithm in `LeastLongTermMessageRate` is essentially based on message rate. Although it initially examines
the maximum resource utilization, it is to exclude overloaded brokers only.
Therefore, in most cases, brokers are sorted based on the size of the message rate as a score, which results in the same
issues with heterogeneous environments, similar to `UniformLoadShedder`.


#### Effect of the combination of `LoadSheddingStrategy` and `LeastLongTermMessageRate`
Next, we will attempt to analyze the effect together with the `LoadSheddingStrategy`.
- **LeastLongTermMessageRate + OverloadShedder**
This is the initial combination, but due to some inherent flaws in `OverloadShedder`, **it is not recommended**.

- **LeastLongTermMessageRate + ThresholdShedder**
This combination is even worse than `LeastLongTermMessageRate + OverloadShedder` and **is not recommended**. 
Because `OverloadShedder` uses the maximum weighted resource usage and historical score to score brokers,
while LeastLongTermMessage Rate is scored based on message rate. Inconsistent unloading and placement criteria
can lead to incorrect load balancing execution.
This is also why a new placement strategy `LeastResourceUsageWithWeight` will be introduced later.

- **LeastLongTermMessageRate + UniformLoadShedder**
This is **recommended**. Both uninstallation and placement policy are based on message rate,
but using message rate as a standard naturally leads to issues with heterogeneous environments. 


### LeastResourceUsageWithWeight
`LeastResourceUsageWithWeight` uses the same scoring algorithm as `ThresholdShedder` to score brokers, which uses
weighted maximum resource usage and historical scores to calculate the current score.

Next, select candidate brokers based on the configuration of `loadBalancerAverageResourceUsageDifferenceThresholdPercentage`.
If a broker's score plus this threshold is still not greater than the average score, the broker will be added to the 
candidate broker list. After obtaining the candidate broker list, a broker will be randomly selected from it;
If there are no candidate brokers, randomly select from all brokers.

For example, if the resource utilization rate of broker 1 is 10%, broker 2 is 30%, and broker 3 is 80%, 
the average resource utilization rate is 40%. The placement strategy can choose Broker1 and Broker2 
as the best candidates, as the thresholds are 10, 10+10<=40, 30+10<=40. In this way, the bundles uninstalled
from broker 3 will be evenly distributed among broker 1 and broker 2, rather than being completely placed on broker 1.

#### over placement problem
In practice, it will be found that it is difficult to determine a suitable value for `loadBalancerAverageResourceUsageDifferenceThresholdPercentage`,
which often triggers a fallback global random selection logic. For example, if there are 6 brokers in the current
cluster, with scores of 40, 40, 40, 40, 69, and 70 respectively, the average score is 49.83. 
Using the default configuration, there are no candidate brokers because 40+10>49.83. 
Triggering a bottom-up global random selection logic and the bundle may be offloaded from the overloaded broker5 
to the overloaded broker6, or vice versa. This is a wrong load balancing decision, and the wrong load balancing decision
is the root cause of the cluster repeatedly performing load balancing! 
**Excellent load balancing algorithms only require one or two decisions.**

Attempting to reduce the configuration value to expand the random pool, such as setting it to 0, may also include some
overloaded brokers in the candidate broker list. For example, if there are 5 brokers in the current cluster with scores
of 10, 60, 70, 80, and 80 respectively, the average score is 60. As the configuration value is 0, then broker 1 and 
broker 2 are both candidate brokers. If broker 2 shares half of the offloaded traffic, it is highly likely to overload.

Therefore, it is difficult to configure the `LeastResourceUsageWithWeight` algorithm well to avoid incorrect load balancing.
Of course, if you want to use the `ThresholdShedder` algorithm, the combination of `ThresholdShedder+LeastResourceUsageWithWeight`
will still be superior to the combination of `ThresholdShedder+LeastLongTermMessageRate`, because at least the scoring algorithm
of `LeastResourceUsageWithWeight` is consistent with that of `ThresholdShedder`.



# Motivation

<!--
Describe the problem this proposal is trying to solve.

* Explain what is the problem you're trying to solve - current situation.
* This section is the "Why" of your proposal.
-->

# Goals

## In Scope

<!--
What this PIP intend to achieve once It's integrated into Pulsar.
Why does it benefit Pulsar.
-->

## Out of Scope

<!--
Describe what you have decided to keep out of scope, perhaps left for a different PIP/s.
-->


# High Level Design

<!--
Describe the design of your solution in *high level*.
Describe the solution end to end, from a birds-eye view.
Don't go into implementation details in this section.

I should be able to finish reading from beginning of the PIP to here (including) and understand the feature and 
how you intend to solve it, end to end.

DON'T
* Avoid code snippets, unless it's essential to explain your intent.
-->

# Detailed Design

## Design & Implementation Details

<!--
This is the section where you dive into the details. It can be:
* Concrete class names and their roles and responsibility, including methods.
* Code snippets of existing code.
* Interface names and its methods.
* ...
-->

## Public-facing Changes

<!--
Describe the additions you plan to make for each public facing component. 
Remove the sections you are not changing.
Clearly mark any changes which are BREAKING backward compatability.
-->

### Public API
<!--
When adding a new endpoint to the REST API, please make sure to document the following:

* path
* query parameters
* HTTP body parameters, usually as JSON.
* Response codes, and for each what they mean.
  For each response code, please include a detailed description of the response body JSON, specifying each field and what it means.
  This is the place to document the errors.
-->

### Binary protocol

### Configuration

### CLI

### Metrics

<!--
For each metric provide:
* Full name
* Description
* Attributes (labels)
* Unit
-->


# Monitoring

<!-- 
Describe how the changes you make in this proposal should be monitored. 
Don't describe the detailed metrics - they should be at "Public-facing Changes" / "Metrics" section.
Describe how the user will use the metrics to monitor the feature: Which alerts they should set up, which thresholds, ...
-->

# Security Considerations
<!--
A detailed description of the security details that ought to be considered for the PIP. This is most relevant for any new HTTP endpoints, new Pulsar Protocol Commands, and new security features. The goal is to describe details like which role will have permission to perform an action.

An important aspect to consider is also multi-tenancy: Does the feature I'm adding have the permissions / roles set in such a way that prevent one tenant accessing another tenant's data/configuration? For example, the Admin API to read a specific message for a topic only allows a client to read messages for the target topic. However, that was not always the case. CVE-2021-41571 (https://github.com/apache/pulsar/wiki/CVE-2021-41571) resulted because the API was incorrectly written and did not properly prevent a client from reading another topic's messages even though authorization was in place. The problem was missing input validation that verified the requested message was actually a message for that topic. The fix to CVE-2021-41571 was input validation. 

If there is uncertainty for this section, please submit the PIP and request for feedback on the mailing list.
-->

# Backward & Forward Compatibility

## Revert

<!--
Describe a cookbook detailing the steps required to revert pulsar to previous version *without* this feature.
-->

## Upgrade

<!--
Specify the list of instructions, if there are such, needed to perform before/after upgrading to Pulsar version containing this feature.
-->

# Alternatives

<!--
If there are alternatives that were already considered by the authors or, after the discussion, by the community, and were rejected, please list them here along with the reason why they were rejected.
-->

# General Notes

# Links

<!--
Updated afterwards
-->
* Mailing List discussion thread:
* Mailing List voting thread:
