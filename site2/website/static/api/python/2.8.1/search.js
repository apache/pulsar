window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pulsar", "modulename": "pulsar", "type": "module", "doc": "<p>The Pulsar Python client library is based on the existing C++ client library.\nAll the same features are exposed through the Python interface.</p>\n\n<p>Currently, the supported Python versions are 2.7, 3.5, 3.6, 3.7 and 3.8.</p>\n\n<h2 id=\"install-from-pypi\">Install from PyPI</h2>\n\n<p>Download Python wheel binary files for MacOS and Linux\ndirectly from the PyPI archive.</p>\n\n<pre><code>#!shell\n$ sudo pip install pulsar-client\n</code></pre>\n\n<h2 id=\"install-from-sources\">Install from sources</h2>\n\n<p>Follow the instructions to compile the Pulsar C++ client library. This method\nwill also build the Python binding for the library.</p>\n\n<p>To install the Python bindings:</p>\n\n<pre><code>#!shell\n$ cd pulsar-client-cpp/python\n$ sudo python setup.py install\n</code></pre>\n\n<h2 id=\"examples\">Examples</h2>\n\n<h3 id=\"producerpulsarproducer-example\"><a href=\"#pulsar.Producer\">Producer</a> example</h3>\n\n<pre><code>#!python\nimport pulsar\n\nclient = pulsar.Client('pulsar://localhost:6650')\n\nproducer = client.create_producer('my-topic')\n\nfor i in range(10):\n    producer.send(('Hello-%d' % i).encode('utf-8'))\n\nclient.close()\n</code></pre>\n\n<h4 id=\"consumerpulsarconsumer-example\"><a href=\"#pulsar.Consumer\">Consumer</a> Example</h4>\n\n<pre><code>#!python\nimport pulsar\n\nclient = pulsar.Client('pulsar://localhost:6650')\nconsumer = client.subscribe('my-topic', 'my-subscription')\n\nwhile True:\n    msg = consumer.receive()\n    try:\n        print(\"Received message '%s' id='%s'\", msg.data().decode('utf-8'), msg.message_id())\n        consumer.acknowledge(msg)\n    except:\n        consumer.negative_acknowledge(msg)\n\nclient.close()\n</code></pre>\n\n<h3 id=\"async-producerpulsarproducersend_async-example\"><a href=\"#pulsar.Producer.send_async\">Async producer</a> example</h3>\n\n<pre><code>#!python\nimport pulsar\n\nclient = pulsar.Client('pulsar://localhost:6650')\n\nproducer = client.create_producer(\n                'my-topic',\n                block_if_queue_full=True,\n                batching_enabled=True,\n                batching_max_publish_delay_ms=10\n            )\n\ndef send_callback(res, msg_id):\n    print('Message published res=%s', res)\n\nwhile True:\n    producer.send_async(('Hello-%d' % i).encode('utf-8'), send_callback)\n\nclient.close()\n</code></pre>\n"}, {"fullname": "pulsar.MessageId", "modulename": "pulsar", "qualname": "MessageId", "type": "class", "doc": "<p>Represents a message id</p>\n"}, {"fullname": "pulsar.MessageId.__init__", "modulename": "pulsar", "qualname": "MessageId.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, partition=-1, ledger_id=-1, entry_id=-1, batch_index=-1)", "funcdef": "def"}, {"fullname": "pulsar.MessageId.earliest", "modulename": "pulsar", "qualname": "MessageId.earliest", "type": "variable", "doc": "<p>Represents the latest message published on a topic</p>\n", "default_value": " = <_pulsar.MessageId object>"}, {"fullname": "pulsar.MessageId.latest", "modulename": "pulsar", "qualname": "MessageId.latest", "type": "variable", "doc": "<p></p>\n", "default_value": " = <_pulsar.MessageId object>"}, {"fullname": "pulsar.MessageId.ledger_id", "modulename": "pulsar", "qualname": "MessageId.ledger_id", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageId.entry_id", "modulename": "pulsar", "qualname": "MessageId.entry_id", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageId.batch_index", "modulename": "pulsar", "qualname": "MessageId.batch_index", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageId.partition", "modulename": "pulsar", "qualname": "MessageId.partition", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageId.serialize", "modulename": "pulsar", "qualname": "MessageId.serialize", "type": "function", "doc": "<p>Returns a bytes representation of the message id.\nThis bytes sequence can be stored and later deserialized.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageId.deserialize", "modulename": "pulsar", "qualname": "MessageId.deserialize", "type": "function", "doc": "<p>Deserialize a message id object from a previously\nserialized bytes sequence.</p>\n", "signature": "(message_id_bytes)", "funcdef": "def"}, {"fullname": "pulsar.Message", "modulename": "pulsar", "qualname": "Message", "type": "class", "doc": "<p>Message objects are returned by a consumer, either by calling <code>receive</code> or\nthrough a listener.</p>\n"}, {"fullname": "pulsar.Message.__init__", "modulename": "pulsar", "qualname": "Message.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.Message.data", "modulename": "pulsar", "qualname": "Message.data", "type": "function", "doc": "<p>Returns object typed bytes with the payload of the message.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.value", "modulename": "pulsar", "qualname": "Message.value", "type": "function", "doc": "<p>Returns object with the de-serialized version of the message content</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.properties", "modulename": "pulsar", "qualname": "Message.properties", "type": "function", "doc": "<p>Return the properties attached to the message. Properties are\napplication-defined key/value pairs that will be attached to the\nmessage.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.partition_key", "modulename": "pulsar", "qualname": "Message.partition_key", "type": "function", "doc": "<p>Get the partitioning key for the message.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.publish_timestamp", "modulename": "pulsar", "qualname": "Message.publish_timestamp", "type": "function", "doc": "<p>Get the timestamp in milliseconds with the message publish time.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.event_timestamp", "modulename": "pulsar", "qualname": "Message.event_timestamp", "type": "function", "doc": "<p>Get the timestamp in milliseconds with the message event time.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.message_id", "modulename": "pulsar", "qualname": "Message.message_id", "type": "function", "doc": "<p>The message ID that can be used to refere to this particular message.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.topic_name", "modulename": "pulsar", "qualname": "Message.topic_name", "type": "function", "doc": "<p>Get the topic Name from which this message originated from</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.redelivery_count", "modulename": "pulsar", "qualname": "Message.redelivery_count", "type": "function", "doc": "<p>Get the redelivery count for this message</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Message.schema_version", "modulename": "pulsar", "qualname": "Message.schema_version", "type": "function", "doc": "<p>Get the schema version for this message</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageBatch", "modulename": "pulsar", "qualname": "MessageBatch", "type": "class", "doc": "<p></p>\n"}, {"fullname": "pulsar.MessageBatch.__init__", "modulename": "pulsar", "qualname": "MessageBatch.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.MessageBatch.with_message_id", "modulename": "pulsar", "qualname": "MessageBatch.with_message_id", "type": "function", "doc": "<p></p>\n", "signature": "(self, msg_id)", "funcdef": "def"}, {"fullname": "pulsar.MessageBatch.parse_from", "modulename": "pulsar", "qualname": "MessageBatch.parse_from", "type": "function", "doc": "<p></p>\n", "signature": "(self, data, size)", "funcdef": "def"}, {"fullname": "pulsar.Authentication", "modulename": "pulsar", "qualname": "Authentication", "type": "class", "doc": "<p>Authentication provider object. Used to load authentication from an external\nshared library.</p>\n"}, {"fullname": "pulsar.Authentication.__init__", "modulename": "pulsar", "qualname": "Authentication.__init__", "type": "function", "doc": "<p>Create the authentication provider instance.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>dynamicLibPath</code>: Path to the authentication provider shared library\n(such as <code>tls.so</code>)</li>\n<li><code>authParamsString</code>: Comma-separated list of provider-specific\nconfiguration params</li>\n</ul>\n", "signature": "(self, dynamicLibPath, authParamsString)", "funcdef": "def"}, {"fullname": "pulsar.AuthenticationTLS", "modulename": "pulsar", "qualname": "AuthenticationTLS", "type": "class", "doc": "<p>TLS Authentication implementation</p>\n", "bases": "Authentication"}, {"fullname": "pulsar.AuthenticationTLS.__init__", "modulename": "pulsar", "qualname": "AuthenticationTLS.__init__", "type": "function", "doc": "<p>Create the TLS authentication provider instance.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>certificatePath</code>: Path to the public certificate</li>\n<li><code>privateKeyPath</code>: Path to private TLS key</li>\n</ul>\n", "signature": "(self, certificate_path, private_key_path)", "funcdef": "def"}, {"fullname": "pulsar.AuthenticationToken", "modulename": "pulsar", "qualname": "AuthenticationToken", "type": "class", "doc": "<p>Token based authentication implementation</p>\n", "bases": "Authentication"}, {"fullname": "pulsar.AuthenticationToken.__init__", "modulename": "pulsar", "qualname": "AuthenticationToken.__init__", "type": "function", "doc": "<p>Create the token authentication provider instance.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>token</code>: A string containing the token or a functions that provides a\n       string with the token</li>\n</ul>\n", "signature": "(self, token)", "funcdef": "def"}, {"fullname": "pulsar.AuthenticationAthenz", "modulename": "pulsar", "qualname": "AuthenticationAthenz", "type": "class", "doc": "<p>Athenz Authentication implementation</p>\n", "bases": "Authentication"}, {"fullname": "pulsar.AuthenticationAthenz.__init__", "modulename": "pulsar", "qualname": "AuthenticationAthenz.__init__", "type": "function", "doc": "<p>Create the Athenz authentication provider instance.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>auth_params_string</code>: JSON encoded configuration for Athenz client</li>\n</ul>\n", "signature": "(self, auth_params_string)", "funcdef": "def"}, {"fullname": "pulsar.AuthenticationOauth2", "modulename": "pulsar", "qualname": "AuthenticationOauth2", "type": "class", "doc": "<p>Oauth2 Authentication implementation</p>\n", "bases": "Authentication"}, {"fullname": "pulsar.AuthenticationOauth2.__init__", "modulename": "pulsar", "qualname": "AuthenticationOauth2.__init__", "type": "function", "doc": "<p>Create the Oauth2 authentication provider instance.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>auth_params_string</code>: JSON encoded configuration for Oauth2 client</li>\n</ul>\n", "signature": "(self, auth_params_string)", "funcdef": "def"}, {"fullname": "pulsar.Client", "modulename": "pulsar", "qualname": "Client", "type": "class", "doc": "<p>The Pulsar client. A single client instance can be used to create producers\nand consumers on multiple topics.</p>\n\n<p>The client will share the same connection pool and threads across all\nproducers and consumers.</p>\n"}, {"fullname": "pulsar.Client.__init__", "modulename": "pulsar", "qualname": "Client.__init__", "type": "function", "doc": "<p>Create a new Pulsar client instance.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>service_url</code>: The Pulsar service url eg: pulsar://my-broker.com:6650/</li>\n</ul>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>authentication</code>:\nSet the authentication provider to be used with the broker. For example:\n<code>AuthenticationTls</code>, AuthenticaionToken, <code>AuthenticationAthenz</code>or <code>AuthenticationOauth2</code></li>\n<li><code>operation_timeout_seconds</code>:\nSet timeout on client operations (subscribe, create producer, close,\nunsubscribe).</li>\n<li><code>io_threads</code>:\nSet the number of IO threads to be used by the Pulsar client.</li>\n<li><code>message_listener_threads</code>:\nSet the number of threads to be used by the Pulsar client when\ndelivering messages through message listener. The default is 1 thread\nper Pulsar client. If using more than 1 thread, messages for distinct\n<code>message_listener</code>s will be delivered in different threads, however a\nsingle <code>MessageListener</code> will always be assigned to the same thread.</li>\n<li><code>concurrent_lookup_requests</code>:\nNumber of concurrent lookup-requests allowed on each broker connection\nto prevent overload on the broker.</li>\n<li><code>log_conf_file_path</code>:\nInitialize log4cxx from a configuration file.</li>\n<li><code>use_tls</code>:\nConfigure whether to use TLS encryption on the connection. This setting\nis deprecated. TLS will be automatically enabled if the <code>serviceUrl</code> is\nset to <code>pulsar+ssl://</code> or <code>https://</code></li>\n<li><code>tls_trust_certs_file_path</code>:\nSet the path to the trusted TLS certificate file. If empty defaults to\ncertifi.</li>\n<li><code>tls_allow_insecure_connection</code>:\nConfigure whether the Pulsar client accepts untrusted TLS certificates\nfrom the broker.</li>\n<li><code>tls_validate_hostname</code>:\nConfigure whether the Pulsar client validates that the hostname of the\nendpoint, matches the common name on the TLS certificate presented by\nthe endpoint.</li>\n<li><code>logger</code>:\nSet a Python logger for this Pulsar client. Should be an instance of <code>logging.Logger</code>.</li>\n<li><code>connection_timeout_ms</code>:\nSet timeout in milliseconds on TCP connections.</li>\n</ul>\n", "signature": "(\n    self,\n    service_url,\n    authentication=None,\n    operation_timeout_seconds=30,\n    io_threads=1,\n    message_listener_threads=1,\n    concurrent_lookup_requests=50000,\n    log_conf_file_path=None,\n    use_tls=False,\n    tls_trust_certs_file_path=None,\n    tls_allow_insecure_connection=False,\n    tls_validate_hostname=False,\n    logger=None,\n    connection_timeout_ms=10000\n)", "funcdef": "def"}, {"fullname": "pulsar.Client.create_producer", "modulename": "pulsar", "qualname": "Client.create_producer", "type": "function", "doc": "<p>Create a new producer on a given topic.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>topic</code>:\nThe topic name</li>\n</ul>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>producer_name</code>:\nSpecify a name for the producer. If not assigned,\nthe system will generate a globally unique name which can be accessed\nwith <code>Producer.producer_name()</code>. When specifying a name, it is app to\nthe user to ensure that, for a given topic, the producer name is unique\nacross all Pulsar's clusters.</li>\n<li><code>schema</code>:\nDefine the schema of the data that will be published by this producer.\nThe schema will be used for two purposes:\n<ul>\n<li>Validate the data format against the topic defined schema</li>\n<li>Perform serialization/deserialization between data and objects\nAn example for this parameter would be to pass <code>schema=JsonSchema(MyRecordClass)</code>.</li>\n</ul></li>\n<li><code>initial_sequence_id</code>:\nSet the baseline for the sequence ids for messages\npublished by the producer. First message will be using\n`(initialSequenceId + 1)`` as its sequence id and subsequent messages will\nbe assigned incremental sequence ids, if not otherwise specified.</li>\n<li><code>send_timeout_millis</code>:\nIf a message is not acknowledged by the server before the\n<code>send_timeout</code> expires, an error will be reported.</li>\n<li><code>compression_type</code>:\nSet the compression type for the producer. By default, message\npayloads are not compressed. Supported compression types are\n<code>CompressionType.LZ4</code>, <code>CompressionType.ZLib</code>, <code>CompressionType.ZSTD</code> and <code>CompressionType.SNAPPY</code>.\nZSTD is supported since Pulsar 2.3. Consumers will need to be at least at that\nrelease in order to be able to receive messages compressed with ZSTD.\nSNAPPY is supported since Pulsar 2.4. Consumers will need to be at least at that\nrelease in order to be able to receive messages compressed with SNAPPY.</li>\n<li><code>max_pending_messages</code>:\nSet the max size of the queue holding the messages pending to receive\nan acknowledgment from the broker.</li>\n<li><code>max_pending_messages_across_partitions</code>:\nSet the max size of the queue holding the messages pending to receive\nan acknowledgment across partitions from the broker.</li>\n<li><code>block_if_queue_full</code>: Set whether <code>send_async</code> operations should\nblock when the outgoing message queue is full.</li>\n<li><code>message_routing_mode</code>:\nSet the message routing mode for the partitioned producer. Default is <code>PartitionsRoutingMode.RoundRobinDistribution</code>,\nother option is <code>PartitionsRoutingMode.UseSinglePartition</code></li>\n<li><code>properties</code>:\nSets the properties for the producer. The properties associated with a producer\ncan be used for identify a producer at broker side.</li>\n<li><p><code>batching_type</code>:\nSets the batching type for the producer.\nThere are two batching type: DefaultBatching and KeyBasedBatching.</p>\n\n<ul>\n<li><p>Default batching\nincoming single messages:\n(k1, v1), (k2, v1), (k3, v1), (k1, v2), (k2, v2), (k3, v2), (k1, v3), (k2, v3), (k3, v3)\nbatched into single batch message:\n[(k1, v1), (k2, v1), (k3, v1), (k1, v2), (k2, v2), (k3, v2), (k1, v3), (k2, v3), (k3, v3)]</p></li>\n<li><p>KeyBasedBatching\nincoming single messages:\n(k1, v1), (k2, v1), (k3, v1), (k1, v2), (k2, v2), (k3, v2), (k1, v3), (k2, v3), (k3, v3)\nbatched into single batch message:\n[(k1, v1), (k1, v2), (k1, v3)], [(k2, v1), (k2, v2), (k2, v3)], [(k3, v1), (k3, v2), (k3, v3)]</p></li>\n</ul></li>\n<li>encryption_key:\nThe key used for symmetric encryption, configured on the producer side</li>\n<li>crypto_key_reader:\nSymmetric encryption class implementation, configuring public key encryption messages for the producer\nand private key decryption messages for the consumer</li>\n</ul>\n", "signature": "(\n    self,\n    topic,\n    producer_name=None,\n    schema=<pulsar.schema.schema.BytesSchema object>,\n    initial_sequence_id=None,\n    send_timeout_millis=30000,\n    compression_type=_pulsar.CompressionType.NONE,\n    max_pending_messages=1000,\n    max_pending_messages_across_partitions=50000,\n    block_if_queue_full=False,\n    batching_enabled=False,\n    batching_max_messages=1000,\n    batching_max_allowed_size_in_bytes=131072,\n    batching_max_publish_delay_ms=10,\n    message_routing_mode=_pulsar.PartitionsRoutingMode.RoundRobinDistribution,\n    properties=None,\n    batching_type=_pulsar.BatchingType.Default,\n    encryption_key=None,\n    crypto_key_reader=None\n)", "funcdef": "def"}, {"fullname": "pulsar.Client.subscribe", "modulename": "pulsar", "qualname": "Client.subscribe", "type": "function", "doc": "<p>Subscribe to the given topic and subscription combination.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>topic</code>: The name of the topic, list of topics or regex pattern.\n      This method will accept these forms:\n        - <code>topic='my-topic'</code>\n        - <code>topic=['topic-1', 'topic-2', 'topic-3']</code>\n        - <code>topic=re.compile('persistent://public/default/topic-*')</code></li>\n<li><code>subscription</code>: The name of the subscription.</li>\n</ul>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>consumer_type</code>:\nSelect the subscription type to be used when subscribing to the topic.</li>\n<li><code>schema</code>:\nDefine the schema of the data that will be received by this consumer.</li>\n<li><p><code>message_listener</code>:\nSets a message listener for the consumer. When the listener is set,\nthe application will receive messages through it. Calls to\n<code>consumer.receive()</code> will not be allowed. The listener function needs\nto accept (consumer, message), for example:</p>\n\n<pre><code>#!python\ndef my_listener(consumer, message):\n    # process message\n    consumer.acknowledge(message)\n</code></pre></li>\n<li><p><code>receiver_queue_size</code>:\nSets the size of the consumer receive queue. The consumer receive\nqueue controls how many messages can be accumulated by the consumer\nbefore the application calls <code>receive()</code>. Using a higher value could\npotentially increase the consumer throughput at the expense of higher\nmemory utilization. Setting the consumer queue size to zero decreases\nthe throughput of the consumer by disabling pre-fetching of messages.\nThis approach improves the message distribution on shared subscription\nby pushing messages only to those consumers that are ready to process\nthem. Neither receive with timeout nor partitioned topics can be used\nif the consumer queue size is zero. The <code>receive()</code> function call\nshould not be interrupted when the consumer queue size is zero. The\ndefault value is 1000 messages and should work well for most use\ncases.</p></li>\n<li><code>max_total_receiver_queue_size_across_partitions</code>\nSet the max total receiver queue size across partitions.\nThis setting will be used to reduce the receiver queue size for individual partitions</li>\n<li><code>consumer_name</code>:\nSets the consumer name.</li>\n<li><code>unacked_messages_timeout_ms</code>:\nSets the timeout in milliseconds for unacknowledged messages. The\ntimeout needs to be greater than 10 seconds. An exception is thrown if\nthe given value is less than 10 seconds. If a successful\nacknowledgement is not sent within the timeout, all the unacknowledged\nmessages are redelivered.</li>\n<li><code>negative_ack_redelivery_delay_ms</code>:\nThe delay after which to redeliver the messages that failed to be\nprocessed (with the <code>consumer.negative_acknowledge()</code>)</li>\n<li><code>broker_consumer_stats_cache_time_ms</code>:\nSets the time duration for which the broker-side consumer stats will\nbe cached in the client.</li>\n<li><code>is_read_compacted</code>:\nSelects whether to read the compacted version of the topic</li>\n<li><code>properties</code>:\nSets the properties for the consumer. The properties associated with a consumer\ncan be used for identify a consumer at broker side.</li>\n<li><code>pattern_auto_discovery_period</code>:\nPeriods of seconds for consumer to auto discover match topics.</li>\n<li><code>initial_position</code>:\nSet the initial position of a consumer  when subscribing to the topic.\nIt could be either: <code>InitialPosition.Earliest</code> or <code>InitialPosition.Latest</code>.\nDefault: <code>Latest</code>.</li>\n<li>crypto_key_reader:\nSymmetric encryption class implementation, configuring public key encryption messages for the producer\nand private key decryption messages for the consumer</li>\n<li>replicate_subscription_state_enabled:\nSet whether the subscription status should be replicated.\nDefault: <code>False</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    topic,\n    subscription_name,\n    consumer_type=_pulsar.ConsumerType.Exclusive,\n    schema=<pulsar.schema.schema.BytesSchema object>,\n    message_listener=None,\n    receiver_queue_size=1000,\n    max_total_receiver_queue_size_across_partitions=50000,\n    consumer_name=None,\n    unacked_messages_timeout_ms=None,\n    broker_consumer_stats_cache_time_ms=30000,\n    negative_ack_redelivery_delay_ms=60000,\n    is_read_compacted=False,\n    properties=None,\n    pattern_auto_discovery_period=60,\n    initial_position=_pulsar.InitialPosition.Latest,\n    crypto_key_reader=None,\n    replicate_subscription_state_enabled=False\n)", "funcdef": "def"}, {"fullname": "pulsar.Client.create_reader", "modulename": "pulsar", "qualname": "Client.create_reader", "type": "function", "doc": "<p>Create a reader on a particular topic</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>topic</code>: The name of the topic.</li>\n<li><p><code>start_message_id</code>: The initial reader positioning is done by specifying a message id.\nThe options are:</p>\n\n<ul>\n<li><code>MessageId.earliest</code>: Start reading from the earliest message available in the topic</li>\n<li><code>MessageId.latest</code>: Start reading from the end topic, only getting messages published\nafter the reader was created</li>\n<li><p><code>MessageId</code>: When passing a particular message id, the reader will position itself on\nthat specific position. The first message to be read will be the message next to the\nspecified messageId. Message id can be serialized into a string and deserialized\nback into a <code>MessageId</code> object:</p>\n\n<p># Serialize to string\n   s = msg.message_id().serialize()</p>\n\n<p># Deserialize from string\n   msg_id = MessageId.deserialize(s)</p></li>\n</ul></li>\n</ul>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>schema</code>:\nDefine the schema of the data that will be received by this reader.</li>\n<li><p><code>reader_listener</code>:\nSets a message listener for the reader. When the listener is set,\nthe application will receive messages through it. Calls to\n<code>reader.read_next()</code> will not be allowed. The listener function needs\nto accept (reader, message), for example:</p>\n\n<pre><code>def my_listener(reader, message):\n    # process message\n    pass\n</code></pre></li>\n<li><p><code>receiver_queue_size</code>:\nSets the size of the reader receive queue. The reader receive\nqueue controls how many messages can be accumulated by the reader\nbefore the application calls <code>read_next()</code>. Using a higher value could\npotentially increase the reader throughput at the expense of higher\nmemory utilization.</p></li>\n<li><code>reader_name</code>:\nSets the reader name.</li>\n<li><code>subscription_role_prefix</code>:\nSets the subscription role prefix.</li>\n<li><code>is_read_compacted</code>:\nSelects whether to read the compacted version of the topic</li>\n</ul>\n", "signature": "(\n    self,\n    topic,\n    start_message_id,\n    schema=<pulsar.schema.schema.BytesSchema object>,\n    reader_listener=None,\n    receiver_queue_size=1000,\n    reader_name=None,\n    subscription_role_prefix=None,\n    is_read_compacted=False\n)", "funcdef": "def"}, {"fullname": "pulsar.Client.get_topic_partitions", "modulename": "pulsar", "qualname": "Client.get_topic_partitions", "type": "function", "doc": "<p>Get the list of partitions for a given topic.</p>\n\n<p>If the topic is partitioned, this will return a list of partition names. If the topic is not\npartitioned, the returned list will contain the topic name itself.</p>\n\n<p>This can be used to discover the partitions and create Reader, Consumer or Producer\ninstances directly on a particular partition.\n:param topic: the topic name to lookup\n:return: a list of partition name</p>\n", "signature": "(self, topic)", "funcdef": "def"}, {"fullname": "pulsar.Client.close", "modulename": "pulsar", "qualname": "Client.close", "type": "function", "doc": "<p>Close the client and all the associated producers and consumers</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Producer", "modulename": "pulsar", "qualname": "Producer", "type": "class", "doc": "<p>The Pulsar message producer, used to publish messages on a topic.</p>\n"}, {"fullname": "pulsar.Producer.__init__", "modulename": "pulsar", "qualname": "Producer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.Producer.topic", "modulename": "pulsar", "qualname": "Producer.topic", "type": "function", "doc": "<p>Return the topic which producer is publishing to</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Producer.producer_name", "modulename": "pulsar", "qualname": "Producer.producer_name", "type": "function", "doc": "<p>Return the producer name which could have been assigned by the\nsystem or specified by the client</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Producer.last_sequence_id", "modulename": "pulsar", "qualname": "Producer.last_sequence_id", "type": "function", "doc": "<p>Get the last sequence id that was published by this producer.</p>\n\n<p>This represent either the automatically assigned or custom sequence id\n(set on the <code>MessageBuilder</code>) that was published and acknowledged by the broker.</p>\n\n<p>After recreating a producer with the same producer name, this will return the\nlast message that was published in the previous producer session, or -1 if\nthere no message was ever published.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Producer.send", "modulename": "pulsar", "qualname": "Producer.send", "type": "function", "doc": "<p>Publish a message on the topic. Blocks until the message is acknowledged</p>\n\n<p>Returns a <code>MessageId</code> object that represents where the message is persisted.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>content</code>:\nA <code>bytes</code> object with the message payload.</li>\n</ul>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>properties</code>:\nA dict of application-defined string properties.</li>\n<li><code>partition_key</code>:\nSets the partition key for message routing. A hash of this key is used\nto determine the message's topic partition.</li>\n<li><code>sequence_id</code>:\nSpecify a custom sequence id for the message being published.</li>\n<li><code>replication_clusters</code>:\nOverride namespace replication clusters. Note that it is the caller's\nresponsibility to provide valid cluster names and that all clusters\nhave been previously configured as topics. Given an empty list,\nthe message will replicate according to the namespace configuration.</li>\n<li><code>disable_replication</code>:\nDo not replicate this message.</li>\n<li><code>event_timestamp</code>:\nTimestamp in millis of the timestamp of event creation</li>\n<li><code>deliver_at</code>:\nSpecify the this message should not be delivered earlier than the\nspecified timestamp.\nThe timestamp is milliseconds and based on UTC</li>\n<li><code>deliver_after</code>:\nSpecify a delay in timedelta for the delivery of the messages.</li>\n</ul>\n", "signature": "(\n    self,\n    content,\n    properties=None,\n    partition_key=None,\n    sequence_id=None,\n    replication_clusters=None,\n    disable_replication=False,\n    event_timestamp=None,\n    deliver_at=None,\n    deliver_after=None\n)", "funcdef": "def"}, {"fullname": "pulsar.Producer.send_async", "modulename": "pulsar", "qualname": "Producer.send_async", "type": "function", "doc": "<p>Send a message asynchronously.</p>\n\n<p>The <code>callback</code> will be invoked once the message has been acknowledged\nby the broker.</p>\n\n<p>Example:</p>\n\n<pre><code>#!python\ndef callback(res, msg_id):\n    print('Message published: %s' % res)\n\nproducer.send_async(msg, callback)\n</code></pre>\n\n<p>When the producer queue is full, by default the message will be rejected\nand the callback invoked with an error code.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>content</code>:\nA <code>bytes</code> object with the message payload.</li>\n</ul>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>properties</code>:\nA dict of application0-defined string properties.</li>\n<li><code>partition_key</code>:\nSets the partition key for the message routing. A hash of this key is\nused to determine the message's topic partition.</li>\n<li><code>sequence_id</code>:\nSpecify a custom sequence id for the message being published.</li>\n<li><code>replication_clusters</code>: Override namespace replication clusters. Note\nthat it is the caller's responsibility to provide valid cluster names\nand that all clusters have been previously configured as topics.\nGiven an empty list, the message will replicate per the namespace\nconfiguration.</li>\n<li><code>disable_replication</code>:\nDo not replicate this message.</li>\n<li><code>event_timestamp</code>:\nTimestamp in millis of the timestamp of event creation</li>\n<li><code>deliver_at</code>:\nSpecify the this message should not be delivered earlier than the\nspecified timestamp.\nThe timestamp is milliseconds and based on UTC</li>\n<li><code>deliver_after</code>:\nSpecify a delay in timedelta for the delivery of the messages.</li>\n</ul>\n", "signature": "(\n    self,\n    content,\n    callback,\n    properties=None,\n    partition_key=None,\n    sequence_id=None,\n    replication_clusters=None,\n    disable_replication=False,\n    event_timestamp=None,\n    deliver_at=None,\n    deliver_after=None\n)", "funcdef": "def"}, {"fullname": "pulsar.Producer.flush", "modulename": "pulsar", "qualname": "Producer.flush", "type": "function", "doc": "<p>Flush all the messages buffered in the client and wait until all messages have been\nsuccessfully persisted</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Producer.close", "modulename": "pulsar", "qualname": "Producer.close", "type": "function", "doc": "<p>Close the producer.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer", "modulename": "pulsar", "qualname": "Consumer", "type": "class", "doc": "<p>Pulsar consumer.</p>\n"}, {"fullname": "pulsar.Consumer.__init__", "modulename": "pulsar", "qualname": "Consumer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.Consumer.topic", "modulename": "pulsar", "qualname": "Consumer.topic", "type": "function", "doc": "<p>Return the topic this consumer is subscribed to.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.subscription_name", "modulename": "pulsar", "qualname": "Consumer.subscription_name", "type": "function", "doc": "<p>Return the subscription name.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.unsubscribe", "modulename": "pulsar", "qualname": "Consumer.unsubscribe", "type": "function", "doc": "<p>Unsubscribe the current consumer from the topic.</p>\n\n<p>This method will block until the operation is completed. Once the\nconsumer is unsubscribed, no more messages will be received and\nsubsequent new messages will not be retained for this consumer.</p>\n\n<p>This consumer object cannot be reused.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.receive", "modulename": "pulsar", "qualname": "Consumer.receive", "type": "function", "doc": "<p>Receive a single message.</p>\n\n<p>If a message is not immediately available, this method will block until\na new message is available.</p>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>timeout_millis</code>:\nIf specified, the receive will raise an exception if a message is not\navailable within the timeout.</li>\n</ul>\n", "signature": "(self, timeout_millis=None)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.acknowledge", "modulename": "pulsar", "qualname": "Consumer.acknowledge", "type": "function", "doc": "<p>Acknowledge the reception of a single message.</p>\n\n<p>This method will block until an acknowledgement is sent to the broker.\nAfter that, the message will not be re-delivered to this consumer.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>message</code>:\nThe received message or message id.</li>\n</ul>\n", "signature": "(self, message)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.acknowledge_cumulative", "modulename": "pulsar", "qualname": "Consumer.acknowledge_cumulative", "type": "function", "doc": "<p>Acknowledge the reception of all the messages in the stream up to (and\nincluding) the provided message.</p>\n\n<p>This method will block until an acknowledgement is sent to the broker.\nAfter that, the messages will not be re-delivered to this consumer.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>message</code>:\nThe received message or message id.</li>\n</ul>\n", "signature": "(self, message)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.negative_acknowledge", "modulename": "pulsar", "qualname": "Consumer.negative_acknowledge", "type": "function", "doc": "<p>Acknowledge the failure to process a single message.</p>\n\n<p>When a message is \"negatively acked\" it will be marked for redelivery after\nsome fixed delay. The delay is configurable when constructing the consumer\nwith {@link ConsumerConfiguration#setNegativeAckRedeliveryDelayMs}.</p>\n\n<p>This call is not blocking.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>message</code>:\nThe received message or message id.</li>\n</ul>\n", "signature": "(self, message)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.pause_message_listener", "modulename": "pulsar", "qualname": "Consumer.pause_message_listener", "type": "function", "doc": "<p>Pause receiving messages via the <code>message_listener</code> until\n<code>resume_message_listener()</code> is called.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.resume_message_listener", "modulename": "pulsar", "qualname": "Consumer.resume_message_listener", "type": "function", "doc": "<p>Resume receiving the messages via the message listener.\nAsynchronously receive all the messages enqueued from the time\n<code>pause_message_listener()</code> was called.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.redeliver_unacknowledged_messages", "modulename": "pulsar", "qualname": "Consumer.redeliver_unacknowledged_messages", "type": "function", "doc": "<p>Redelivers all the unacknowledged messages. In failover mode, the\nrequest is ignored if the consumer is not active for the given topic. In\nshared mode, the consumer's messages to be redelivered are distributed\nacross all the connected consumers. This is a non-blocking call and\ndoesn't throw an exception. In case the connection breaks, the messages\nare redelivered after reconnect.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.seek", "modulename": "pulsar", "qualname": "Consumer.seek", "type": "function", "doc": "<p>Reset the subscription associated with this consumer to a specific message id or publish timestamp.\nThe message id can either be a specific message or represent the first or last messages in the topic.\nNote: this operation can only be done on non-partitioned topics. For these, one can rather perform the\nseek() on the individual partitions.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>message</code>:\nThe message id for seek, OR an integer event time to seek to</li>\n</ul>\n", "signature": "(self, messageid)", "funcdef": "def"}, {"fullname": "pulsar.Consumer.close", "modulename": "pulsar", "qualname": "Consumer.close", "type": "function", "doc": "<p>Close the consumer.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Reader", "modulename": "pulsar", "qualname": "Reader", "type": "class", "doc": "<p>Pulsar topic reader.</p>\n"}, {"fullname": "pulsar.Reader.__init__", "modulename": "pulsar", "qualname": "Reader.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.Reader.topic", "modulename": "pulsar", "qualname": "Reader.topic", "type": "function", "doc": "<p>Return the topic this reader is reading from.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Reader.read_next", "modulename": "pulsar", "qualname": "Reader.read_next", "type": "function", "doc": "<p>Read a single message.</p>\n\n<p>If a message is not immediately available, this method will block until\na new message is available.</p>\n\n<p><strong>Options</strong></p>\n\n<ul>\n<li><code>timeout_millis</code>:\nIf specified, the receive will raise an exception if a message is not\navailable within the timeout.</li>\n</ul>\n", "signature": "(self, timeout_millis=None)", "funcdef": "def"}, {"fullname": "pulsar.Reader.has_message_available", "modulename": "pulsar", "qualname": "Reader.has_message_available", "type": "function", "doc": "<p>Check if there is any message available to read from the current position.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.Reader.seek", "modulename": "pulsar", "qualname": "Reader.seek", "type": "function", "doc": "<p>Reset this reader to a specific message id or publish timestamp.\nThe message id can either be a specific message or represent the first or last messages in the topic.\nNote: this operation can only be done on non-partitioned topics. For these, one can rather perform the\nseek() on the individual partitions.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>message</code>:\nThe message id for seek, OR an integer event time to seek to</li>\n</ul>\n", "signature": "(self, messageid)", "funcdef": "def"}, {"fullname": "pulsar.Reader.close", "modulename": "pulsar", "qualname": "Reader.close", "type": "function", "doc": "<p>Close the reader.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.CryptoKeyReader", "modulename": "pulsar", "qualname": "CryptoKeyReader", "type": "class", "doc": "<p>Default crypto key reader implementation</p>\n"}, {"fullname": "pulsar.CryptoKeyReader.__init__", "modulename": "pulsar", "qualname": "CryptoKeyReader.__init__", "type": "function", "doc": "<p>Create crypto key reader.</p>\n\n<p><strong>Args</strong></p>\n\n<ul>\n<li><code>public_key_path</code>: Path to the public key</li>\n<li><code>private_key_path</code>: Path to private key</li>\n</ul>\n", "signature": "(self, public_key_path, private_key_path)", "funcdef": "def"}, {"fullname": "pulsar.exceptions", "modulename": "pulsar.exceptions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pulsar.functions", "modulename": "pulsar.functions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pulsar.functions.context", "modulename": "pulsar.functions.context", "type": "module", "doc": "<p>context.py: Context defines context information available during</p>\n\n<h1 id=\"processing-of-a-request\">processing of a request.</h1>\n"}, {"fullname": "pulsar.functions.context.Context", "modulename": "pulsar.functions.context", "qualname": "Context", "type": "class", "doc": "<p>Interface defining information available at process time</p>\n"}, {"fullname": "pulsar.functions.context.Context.__init__", "modulename": "pulsar.functions.context", "qualname": "Context.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_message_id", "modulename": "pulsar.functions.context", "qualname": "Context.get_message_id", "type": "function", "doc": "<p>Return the messageid of the current message that we are processing</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_message_key", "modulename": "pulsar.functions.context", "qualname": "Context.get_message_key", "type": "function", "doc": "<p>Return the key of the current message that we are processing</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_message_eventtime", "modulename": "pulsar.functions.context", "qualname": "Context.get_message_eventtime", "type": "function", "doc": "<p>Return the event time of the current message that we are processing</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_message_properties", "modulename": "pulsar.functions.context", "qualname": "Context.get_message_properties", "type": "function", "doc": "<p>Return the message properties kv map of the current message that we are processing</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_current_message_topic_name", "modulename": "pulsar.functions.context", "qualname": "Context.get_current_message_topic_name", "type": "function", "doc": "<p>Returns the topic name of the message that we are processing</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_function_tenant", "modulename": "pulsar.functions.context", "qualname": "Context.get_function_tenant", "type": "function", "doc": "<p>Returns the tenant of the message that's being processed</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_function_namespace", "modulename": "pulsar.functions.context", "qualname": "Context.get_function_namespace", "type": "function", "doc": "<p>Returns the namespace of the message that's being processed</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_function_name", "modulename": "pulsar.functions.context", "qualname": "Context.get_function_name", "type": "function", "doc": "<p>Returns the function name that we are a part of</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_function_id", "modulename": "pulsar.functions.context", "qualname": "Context.get_function_id", "type": "function", "doc": "<p>Returns the function id that we are a part of</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_instance_id", "modulename": "pulsar.functions.context", "qualname": "Context.get_instance_id", "type": "function", "doc": "<p>Returns the instance id that is executing the function</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_function_version", "modulename": "pulsar.functions.context", "qualname": "Context.get_function_version", "type": "function", "doc": "<p>Returns the version of function that we are executing</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_logger", "modulename": "pulsar.functions.context", "qualname": "Context.get_logger", "type": "function", "doc": "<p>Returns the logger object that can be used to do logging</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_user_config_value", "modulename": "pulsar.functions.context", "qualname": "Context.get_user_config_value", "type": "function", "doc": "<p>Returns the value of the user-defined config. If the key doesn't exist, None is returned</p>\n", "signature": "(self, key)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_user_config_map", "modulename": "pulsar.functions.context", "qualname": "Context.get_user_config_map", "type": "function", "doc": "<p>Returns the entire user-defined config as a dict (the dict will be empty if no user-defined config is supplied)</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_secret", "modulename": "pulsar.functions.context", "qualname": "Context.get_secret", "type": "function", "doc": "<p>Returns the secret value associated with the name. None if nothing was found</p>\n", "signature": "(self, secret_name)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_partition_key", "modulename": "pulsar.functions.context", "qualname": "Context.get_partition_key", "type": "function", "doc": "<p>Returns partition key of the input message is one exists</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.record_metric", "modulename": "pulsar.functions.context", "qualname": "Context.record_metric", "type": "function", "doc": "<p>Records the metric_value. metric_value has to satisfy isinstance(metric_value, numbers.Number)</p>\n", "signature": "(self, metric_name, metric_value)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.publish", "modulename": "pulsar.functions.context", "qualname": "Context.publish", "type": "function", "doc": "<p>Publishes message to topic_name by first serializing the message using serde_class_name serde\nThe message will have properties specified if any</p>\n\n<p>The available options for message_conf:</p>\n\n<p>properties,\n  partition_key,\n  sequence_id,\n  replication_clusters,\n  disable_replication,\n  event_timestamp</p>\n", "signature": "(\n    self,\n    topic_name,\n    message,\n    serde_class_name='serde.IdentitySerDe',\n    properties=None,\n    compression_type=None,\n    callback=None,\n    message_conf=None\n)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_input_topics", "modulename": "pulsar.functions.context", "qualname": "Context.get_input_topics", "type": "function", "doc": "<p>Returns the input topics of function</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_output_topic", "modulename": "pulsar.functions.context", "qualname": "Context.get_output_topic", "type": "function", "doc": "<p>Returns the output topic of function</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_output_serde_class_name", "modulename": "pulsar.functions.context", "qualname": "Context.get_output_serde_class_name", "type": "function", "doc": "<p>return output Serde class</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.ack", "modulename": "pulsar.functions.context", "qualname": "Context.ack", "type": "function", "doc": "<p>ack this message id</p>\n", "signature": "(self, msgid, topic)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.incr_counter", "modulename": "pulsar.functions.context", "qualname": "Context.incr_counter", "type": "function", "doc": "<p>incr the counter of a given key in the managed state</p>\n", "signature": "(self, key, amount)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_counter", "modulename": "pulsar.functions.context", "qualname": "Context.get_counter", "type": "function", "doc": "<p>get the counter of a given key in the managed state</p>\n", "signature": "(self, key)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.del_counter", "modulename": "pulsar.functions.context", "qualname": "Context.del_counter", "type": "function", "doc": "<p>delete the counter of a given key in the managed state</p>\n", "signature": "(self, key)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.put_state", "modulename": "pulsar.functions.context", "qualname": "Context.put_state", "type": "function", "doc": "<p>update the value of a given key in the managed state</p>\n", "signature": "(self, key, value)", "funcdef": "def"}, {"fullname": "pulsar.functions.context.Context.get_state", "modulename": "pulsar.functions.context", "qualname": "Context.get_state", "type": "function", "doc": "<p>get the value of a given key in the managed state</p>\n", "signature": "(self, key)", "funcdef": "def"}, {"fullname": "pulsar.functions.function", "modulename": "pulsar.functions.function", "type": "module", "doc": "<p>function.py: This is the core interface of the function api.</p>\n\n<h1 id=\"the-process-method-is-called-for-every-message-of-the-input-topic-of-the\">The process method is called for every message of the input topic of the</h1>\n\n<h1 id=\"function-the-incoming-input-bytes-are-deserialized-using-the-serde\">function. The incoming input bytes are deserialized using the serde.</h1>\n\n<h1 id=\"the-process-function-can-optionally-emit-an-output\">The process function can optionally emit an output</h1>\n"}, {"fullname": "pulsar.functions.function.Function", "modulename": "pulsar.functions.function", "qualname": "Function", "type": "class", "doc": "<p>Interface for Pulsar Function</p>\n"}, {"fullname": "pulsar.functions.function.Function.__init__", "modulename": "pulsar.functions.function", "qualname": "Function.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.functions.function.Function.process", "modulename": "pulsar.functions.function", "qualname": "Function.process", "type": "function", "doc": "<p>Process input message</p>\n", "signature": "(self, input, context)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde", "modulename": "pulsar.functions.serde", "type": "module", "doc": "<p>serde.py: SerDe defines the interface for serialization/deserialization.</p>\n\n<h1 id=\"everytime-a-message-is-read-from-pulsar-topic-the-serde-is-invoked-to\">Everytime a message is read from pulsar topic, the serde is invoked to</h1>\n\n<h1 id=\"serialize-the-bytes-into-an-object-before-invoking-the-process-method\">serialize the bytes into an object before invoking the process method.</h1>\n\n<h1 id=\"anytime-a-python-object-needs-to-be-written-back-to-pulsar-it-is\">Anytime a python object needs to be written back to pulsar, it is</h1>\n\n<h1 id=\"serialized-into-bytes-before-writing\">serialized into bytes before writing.</h1>\n"}, {"fullname": "pulsar.functions.serde.SerDe", "modulename": "pulsar.functions.serde", "qualname": "SerDe", "type": "class", "doc": "<p>Interface for Serialization/Deserialization</p>\n"}, {"fullname": "pulsar.functions.serde.SerDe.__init__", "modulename": "pulsar.functions.serde", "qualname": "SerDe.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.SerDe.serialize", "modulename": "pulsar.functions.serde", "qualname": "SerDe.serialize", "type": "function", "doc": "<p>Serialize input message into bytes</p>\n", "signature": "(self, input)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.SerDe.deserialize", "modulename": "pulsar.functions.serde", "qualname": "SerDe.deserialize", "type": "function", "doc": "<p>Serialize input_bytes into an object</p>\n", "signature": "(self, input_bytes)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.PickleSerDe", "modulename": "pulsar.functions.serde", "qualname": "PickleSerDe", "type": "class", "doc": "<p>Pickle based serializer</p>\n", "bases": "SerDe"}, {"fullname": "pulsar.functions.serde.PickleSerDe.__init__", "modulename": "pulsar.functions.serde", "qualname": "PickleSerDe.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.PickleSerDe.serialize", "modulename": "pulsar.functions.serde", "qualname": "PickleSerDe.serialize", "type": "function", "doc": "<p>Serialize input message into bytes</p>\n", "signature": "(self, input)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.PickleSerDe.deserialize", "modulename": "pulsar.functions.serde", "qualname": "PickleSerDe.deserialize", "type": "function", "doc": "<p>Serialize input_bytes into an object</p>\n", "signature": "(self, input_bytes)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.IdentitySerDe", "modulename": "pulsar.functions.serde", "qualname": "IdentitySerDe", "type": "class", "doc": "<p>Simple Serde that just conversion to string and back</p>\n", "bases": "SerDe"}, {"fullname": "pulsar.functions.serde.IdentitySerDe.__init__", "modulename": "pulsar.functions.serde", "qualname": "IdentitySerDe.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.IdentitySerDe.serialize", "modulename": "pulsar.functions.serde", "qualname": "IdentitySerDe.serialize", "type": "function", "doc": "<p>Serialize input message into bytes</p>\n", "signature": "(self, input)", "funcdef": "def"}, {"fullname": "pulsar.functions.serde.IdentitySerDe.deserialize", "modulename": "pulsar.functions.serde", "qualname": "IdentitySerDe.deserialize", "type": "function", "doc": "<p>Serialize input_bytes into an object</p>\n", "signature": "(self, input_bytes)", "funcdef": "def"}, {"fullname": "pulsar.schema", "modulename": "pulsar.schema", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.definition", "modulename": "pulsar.schema.definition", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.definition.RecordMeta", "modulename": "pulsar.schema.definition", "qualname": "RecordMeta", "type": "class", "doc": "<p>type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type</p>\n", "bases": "builtins.type"}, {"fullname": "pulsar.schema.definition.Record", "modulename": "pulsar.schema.definition", "qualname": "Record", "type": "class", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.definition.Record.__init__", "modulename": "pulsar.schema.definition", "qualname": "Record.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    default=None,\n    required_default=False,\n    required=False,\n    *args,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.schema", "modulename": "pulsar.schema.definition", "qualname": "Record.schema", "type": "function", "doc": "<p></p>\n", "signature": "(cls)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.schema_info", "modulename": "pulsar.schema.definition", "qualname": "Record.schema_info", "type": "function", "doc": "<p></p>\n", "signature": "(cls, defined_names)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.type", "modulename": "pulsar.schema.definition", "qualname": "Record.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.python_type", "modulename": "pulsar.schema.definition", "qualname": "Record.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.validate_type", "modulename": "pulsar.schema.definition", "qualname": "Record.validate_type", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, val)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.default", "modulename": "pulsar.schema.definition", "qualname": "Record.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Record.required_default", "modulename": "pulsar.schema.definition", "qualname": "Record.required_default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field", "modulename": "pulsar.schema.definition", "qualname": "Field", "type": "class", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.definition.Field.__init__", "modulename": "pulsar.schema.definition", "qualname": "Field.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, default=None, required=False, required_default=False)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.type", "modulename": "pulsar.schema.definition", "qualname": "Field.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.python_type", "modulename": "pulsar.schema.definition", "qualname": "Field.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.validate_type", "modulename": "pulsar.schema.definition", "qualname": "Field.validate_type", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, val)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.schema", "modulename": "pulsar.schema.definition", "qualname": "Field.schema", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.schema_info", "modulename": "pulsar.schema.definition", "qualname": "Field.schema_info", "type": "function", "doc": "<p></p>\n", "signature": "(self, defined_names)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.default", "modulename": "pulsar.schema.definition", "qualname": "Field.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Field.required_default", "modulename": "pulsar.schema.definition", "qualname": "Field.required_default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Null", "modulename": "pulsar.schema.definition", "qualname": "Null", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Null.type", "modulename": "pulsar.schema.definition", "qualname": "Null.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Null.python_type", "modulename": "pulsar.schema.definition", "qualname": "Null.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Null.validate_type", "modulename": "pulsar.schema.definition", "qualname": "Null.validate_type", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, val)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Boolean", "modulename": "pulsar.schema.definition", "qualname": "Boolean", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Boolean.type", "modulename": "pulsar.schema.definition", "qualname": "Boolean.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Boolean.python_type", "modulename": "pulsar.schema.definition", "qualname": "Boolean.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Boolean.default", "modulename": "pulsar.schema.definition", "qualname": "Boolean.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Integer", "modulename": "pulsar.schema.definition", "qualname": "Integer", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Integer.type", "modulename": "pulsar.schema.definition", "qualname": "Integer.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Integer.python_type", "modulename": "pulsar.schema.definition", "qualname": "Integer.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Integer.default", "modulename": "pulsar.schema.definition", "qualname": "Integer.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Long", "modulename": "pulsar.schema.definition", "qualname": "Long", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Long.type", "modulename": "pulsar.schema.definition", "qualname": "Long.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Long.python_type", "modulename": "pulsar.schema.definition", "qualname": "Long.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Long.default", "modulename": "pulsar.schema.definition", "qualname": "Long.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Float", "modulename": "pulsar.schema.definition", "qualname": "Float", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Float.type", "modulename": "pulsar.schema.definition", "qualname": "Float.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Float.python_type", "modulename": "pulsar.schema.definition", "qualname": "Float.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Float.default", "modulename": "pulsar.schema.definition", "qualname": "Float.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Double", "modulename": "pulsar.schema.definition", "qualname": "Double", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Double.type", "modulename": "pulsar.schema.definition", "qualname": "Double.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Double.python_type", "modulename": "pulsar.schema.definition", "qualname": "Double.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Double.default", "modulename": "pulsar.schema.definition", "qualname": "Double.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Bytes", "modulename": "pulsar.schema.definition", "qualname": "Bytes", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Bytes.type", "modulename": "pulsar.schema.definition", "qualname": "Bytes.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Bytes.python_type", "modulename": "pulsar.schema.definition", "qualname": "Bytes.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Bytes.default", "modulename": "pulsar.schema.definition", "qualname": "Bytes.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.String", "modulename": "pulsar.schema.definition", "qualname": "String", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.String.type", "modulename": "pulsar.schema.definition", "qualname": "String.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.String.python_type", "modulename": "pulsar.schema.definition", "qualname": "String.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.String.validate_type", "modulename": "pulsar.schema.definition", "qualname": "String.validate_type", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, val)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.String.default", "modulename": "pulsar.schema.definition", "qualname": "String.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array", "modulename": "pulsar.schema.definition", "qualname": "Array", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Array.__init__", "modulename": "pulsar.schema.definition", "qualname": "Array.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    array_type,\n    default=None,\n    required=False,\n    required_default=False\n)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array.type", "modulename": "pulsar.schema.definition", "qualname": "Array.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array.python_type", "modulename": "pulsar.schema.definition", "qualname": "Array.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array.validate_type", "modulename": "pulsar.schema.definition", "qualname": "Array.validate_type", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, val)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array.schema", "modulename": "pulsar.schema.definition", "qualname": "Array.schema", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array.schema_info", "modulename": "pulsar.schema.definition", "qualname": "Array.schema_info", "type": "function", "doc": "<p></p>\n", "signature": "(self, defined_names)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Array.default", "modulename": "pulsar.schema.definition", "qualname": "Array.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map", "modulename": "pulsar.schema.definition", "qualname": "Map", "type": "class", "doc": "<p></p>\n", "bases": "Field"}, {"fullname": "pulsar.schema.definition.Map.__init__", "modulename": "pulsar.schema.definition", "qualname": "Map.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    value_type,\n    default=None,\n    required=False,\n    required_default=False\n)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map.type", "modulename": "pulsar.schema.definition", "qualname": "Map.type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map.python_type", "modulename": "pulsar.schema.definition", "qualname": "Map.python_type", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map.validate_type", "modulename": "pulsar.schema.definition", "qualname": "Map.validate_type", "type": "function", "doc": "<p></p>\n", "signature": "(self, name, val)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map.schema", "modulename": "pulsar.schema.definition", "qualname": "Map.schema", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map.schema_info", "modulename": "pulsar.schema.definition", "qualname": "Map.schema_info", "type": "function", "doc": "<p></p>\n", "signature": "(self, defined_names)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.Map.default", "modulename": "pulsar.schema.definition", "qualname": "Map.default", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.definition.is_unicode", "modulename": "pulsar.schema.definition", "qualname": "is_unicode", "type": "function", "doc": "<p></p>\n", "signature": "(x)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema", "modulename": "pulsar.schema.schema", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.schema.Schema", "modulename": "pulsar.schema.schema", "qualname": "Schema", "type": "class", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.schema.Schema.__init__", "modulename": "pulsar.schema.schema", "qualname": "Schema.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, record_cls, schema_type, schema_definition, schema_name)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.Schema.encode", "modulename": "pulsar.schema.schema", "qualname": "Schema.encode", "type": "function", "doc": "<p></p>\n", "signature": "(self, obj)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.Schema.decode", "modulename": "pulsar.schema.schema", "qualname": "Schema.decode", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.Schema.schema_info", "modulename": "pulsar.schema.schema", "qualname": "Schema.schema_info", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.BytesSchema", "modulename": "pulsar.schema.schema", "qualname": "BytesSchema", "type": "class", "doc": "<p></p>\n", "bases": "Schema"}, {"fullname": "pulsar.schema.schema.BytesSchema.__init__", "modulename": "pulsar.schema.schema", "qualname": "BytesSchema.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.BytesSchema.encode", "modulename": "pulsar.schema.schema", "qualname": "BytesSchema.encode", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.BytesSchema.decode", "modulename": "pulsar.schema.schema", "qualname": "BytesSchema.decode", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.StringSchema", "modulename": "pulsar.schema.schema", "qualname": "StringSchema", "type": "class", "doc": "<p></p>\n", "bases": "Schema"}, {"fullname": "pulsar.schema.schema.StringSchema.__init__", "modulename": "pulsar.schema.schema", "qualname": "StringSchema.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.StringSchema.encode", "modulename": "pulsar.schema.schema", "qualname": "StringSchema.encode", "type": "function", "doc": "<p></p>\n", "signature": "(self, obj)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.StringSchema.decode", "modulename": "pulsar.schema.schema", "qualname": "StringSchema.decode", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.JsonSchema", "modulename": "pulsar.schema.schema", "qualname": "JsonSchema", "type": "class", "doc": "<p></p>\n", "bases": "Schema"}, {"fullname": "pulsar.schema.schema.JsonSchema.__init__", "modulename": "pulsar.schema.schema", "qualname": "JsonSchema.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, record_cls)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.JsonSchema.encode", "modulename": "pulsar.schema.schema", "qualname": "JsonSchema.encode", "type": "function", "doc": "<p></p>\n", "signature": "(self, obj)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema.JsonSchema.decode", "modulename": "pulsar.schema.schema", "qualname": "JsonSchema.decode", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema_avro", "modulename": "pulsar.schema.schema_avro", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pulsar.schema.schema_avro.AvroSchema", "modulename": "pulsar.schema.schema_avro", "qualname": "AvroSchema", "type": "class", "doc": "<p></p>\n", "bases": "pulsar.schema.schema.Schema"}, {"fullname": "pulsar.schema.schema_avro.AvroSchema.__init__", "modulename": "pulsar.schema.schema_avro", "qualname": "AvroSchema.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, record_cls)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema_avro.AvroSchema.encode", "modulename": "pulsar.schema.schema_avro", "qualname": "AvroSchema.encode", "type": "function", "doc": "<p></p>\n", "signature": "(self, obj)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema_avro.AvroSchema.encode_dict", "modulename": "pulsar.schema.schema_avro", "qualname": "AvroSchema.encode_dict", "type": "function", "doc": "<p></p>\n", "signature": "(self, d)", "funcdef": "def"}, {"fullname": "pulsar.schema.schema_avro.AvroSchema.decode", "modulename": "pulsar.schema.schema_avro", "qualname": "AvroSchema.decode", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();