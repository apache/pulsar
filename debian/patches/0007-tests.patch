From: HelgiSaga <bglegb@gmail.com>
Date: Tue, 21 Jan 2026 13:00:00 +0300
Subject: [PATCH] debian: Update integration tests, resources, and certificates

Description: Update integration tests, resources, and certificates
Origin: other, https://github.com/HelgiSaga/pulsar/tree/debian
Bug-Debian: no
Forwarded: no
Author: HelgiSaga <bglegb@gmail.com>
Last-Update: 2026-01-21

---
 tests/bc_2_0_0/pom.xml                             |  216 +-
 .../pulsar/tests/integration/PulsarContainer.java  |  104 +-
 .../apache/pulsar/tests/integration/SmokeTest.java |  168 +-
 tests/bc_2_0_0/src/test/resources/pulsar.xml       |   54 +-
 tests/bc_2_0_1/pom.xml                             |  216 +-
 .../pulsar/tests/integration/PulsarContainer.java  |  104 +-
 .../apache/pulsar/tests/integration/SmokeTest.java |  168 +-
 tests/bc_2_0_1/src/test/resources/pulsar.xml       |   54 +-
 tests/bc_2_6_0/pom.xml                             |  234 +-
 .../pulsar/tests/integration/PulsarContainer.java  |  104 +-
 .../apache/pulsar/tests/integration/SmokeTest.java |  168 +-
 .../src/test/resources/backwards-client.xml        |   54 +-
 tests/certificate-authority/.gitignore             |    6 +-
 tests/certificate-authority/RemoveJksPassword.java |   88 +-
 tests/certificate-authority/certs/ca.cert.pem      |   58 +-
 .../client-keys/admin.cert.pem                     |   52 +-
 .../client-keys/admin.csr.pem                      |   30 +-
 .../client-keys/admin.key-pk8.pem                  |   56 +-
 .../client-keys/admin.key.pem                      |   54 +-
 .../client-keys/proxy.cert.pem                     |   52 +-
 .../client-keys/proxy.csr.pem                      |   30 +-
 .../client-keys/proxy.key-pk8.pem                  |   56 +-
 .../client-keys/proxy.key.pem                      |   54 +-
 .../client-keys/randouser.cert.pem                 |   38 +-
 .../client-keys/randouser.key-pk8.pem              |   56 +-
 .../client-keys/randouser.key.pem                  |   56 +-
 .../client-keys/superproxy.cert.pem                |   52 +-
 .../client-keys/superproxy.csr.pem                 |   30 +-
 .../client-keys/superproxy.key-pk8.pem             |   56 +-
 .../client-keys/superproxy.key.pem                 |   54 +-
 .../client-keys/user1.cert.pem                     |   52 +-
 .../client-keys/user1.csr.pem                      |   30 +-
 .../client-keys/user1.key-pk8.pem                  |   56 +-
 .../client-keys/user1.key.pem                      |   54 +-
 .../ec/broker_client.cert.pem                      |   18 +-
 .../certificate-authority/ec/broker_client.csr.pem |   14 +-
 .../ec/broker_client.key-pk8.pem                   |   10 +-
 .../certificate-authority/ec/broker_client.key.pem |   16 +-
 tests/certificate-authority/ec/ca.cert.pem         |   20 +-
 tests/certificate-authority/ec/ca.cert.srl         |    2 +-
 tests/certificate-authority/ec/ca.key.pem          |   16 +-
 .../ec/certificate_generation.txt                  |   68 +-
 tests/certificate-authority/ec/client.cert.pem     |   16 +-
 tests/certificate-authority/ec/client.csr.pem      |   14 +-
 tests/certificate-authority/ec/client.key-pk8.pem  |   10 +-
 tests/certificate-authority/ec/client.key.pem      |   16 +-
 .../ec/jks/broker_client.signed.cert.pem           |   22 +-
 tests/certificate-authority/ec/jks/ca.cert.pem     |   20 +-
 tests/certificate-authority/ec/jks/ca.cert.srl     |    2 +-
 tests/certificate-authority/ec/jks/ca.key.pem      |   16 +-
 .../ec/jks/client.signed.cert.pem                  |   20 +-
 .../ec/jks/key_store_generation.txt                |   64 +-
 .../ec/jks/server.signed.cert.pem                  |   20 +-
 tests/certificate-authority/ec/server.cert.pem     |   26 +-
 tests/certificate-authority/ec/server.conf         |   80 +-
 tests/certificate-authority/ec/server.csr.pem      |   14 +-
 tests/certificate-authority/ec/server.key-pk8.pem  |   10 +-
 tests/certificate-authority/ec/server.key.pem      |   16 +-
 tests/certificate-authority/generate_keystore.sh   |  126 +-
 tests/certificate-authority/index.txt              |   18 +-
 .../jks/broker.truststore.pem                      |  146 +-
 tests/certificate-authority/newcerts/1000.pem      |   54 +-
 tests/certificate-authority/newcerts/1001.pem      |   52 +-
 tests/certificate-authority/newcerts/1002.pem      |   52 +-
 tests/certificate-authority/newcerts/1003.pem      |   52 +-
 tests/certificate-authority/newcerts/1004.pem      |   52 +-
 tests/certificate-authority/newcerts/1005.pem      |   52 +-
 tests/certificate-authority/newcerts/1006.pem      |   54 +-
 tests/certificate-authority/newcerts/1007.pem      |  222 +-
 tests/certificate-authority/newcerts/1008.pem      |  220 +-
 tests/certificate-authority/openssl.cnf            |  256 +-
 tests/certificate-authority/private/ca.key.pem     |  108 +-
 tests/certificate-authority/serial                 |    2 +-
 .../server-keys/broker.cert.pem                    |  222 +-
 .../server-keys/broker.csr.pem                     |   30 +-
 .../server-keys/broker.key-pk8.pem                 |   56 +-
 .../server-keys/broker.key.pem                     |   54 +-
 .../server-keys/proxy.cert.pem                     |  220 +-
 .../server-keys/proxy.csr.pem                      |   30 +-
 .../server-keys/proxy.key-pk8.pem                  |   56 +-
 .../server-keys/proxy.key.pem                      |   54 +-
 tests/compose/multi/docker-compose.yml             |  334 +-
 tests/compose/simple/docker-compose.yml            |  172 +-
 tests/compose/tls/docker-compose.yml               |  240 +-
 tests/docker-images/java-test-functions/pom.xml    |  212 +-
 .../integration/functions/ExceptionFunction.java   |   70 +-
 .../functions/GenericObjectFunction.java           |  128 +-
 .../functions/RemoveAvroFieldFunction.java         |  332 +-
 .../functions/RemoveAvroFieldRecordFunction.java   |  326 +-
 .../tests/integration/functions/package-info.java  |   38 +-
 .../tests/integration/io/GenericRecordSource.java  |  176 +-
 .../tests/integration/io/TestByteStateSource.java  |  108 +-
 .../integration/io/TestGenericObjectSink.java      |  236 +-
 .../tests/integration/io/TestLoggingSink.java      |  148 +-
 .../tests/integration/io/TestPropertySource.java   |  112 +-
 .../pulsar/tests/integration/io/TestStateSink.java |  100 +-
 .../tests/integration/io/TestStateSource.java      |  102 +-
 .../pulsar/tests/integration/io/package-info.java  |   38 +-
 tests/docker-images/java-test-image/Dockerfile     |   86 +-
 tests/docker-images/java-test-image/pom.xml        |  356 +-
 tests/docker-images/java-test-plugins/pom.xml      |   98 +-
 .../integration/plugins/EchoChannelHandler.java    |   74 +-
 .../integration/plugins/EchoProtocolHandler.java   |  194 +-
 .../plugins/LoggingBrokerInterceptor.java          |  264 +-
 .../integration/plugins/PatternEntryFilter.java    |  122 +-
 .../plugins/RandomAdditionalServlet.java           |  144 +-
 .../tests/integration/plugins/package-info.java    |   36 +-
 .../META-INF/services/additional_servlet.yml       |   42 +-
 .../META-INF/services/broker_interceptor.yml       |   44 +-
 .../resources/META-INF/services/entry_filter.yml   |   44 +-
 .../META-INF/services/pulsar-protocol-handler.yml  |   44 +-
 .../docker-images/latest-version-image/Dockerfile  |  218 +-
 .../latest-version-image/conf/bookie.conf          |   56 +-
 .../latest-version-image/conf/broker.conf          |   56 +-
 .../conf/functions_worker.conf                     |   54 +-
 .../latest-version-image/conf/global-zk.conf       |   54 +-
 .../latest-version-image/conf/local-zk.conf        |   54 +-
 .../latest-version-image/conf/proxy.conf           |   54 +-
 .../latest-version-image/conf/supervisord.conf     |   80 +-
 .../latest-version-image/conf/websocket.conf       |   54 +-
 tests/docker-images/latest-version-image/pom.xml   |  374 +-
 .../python-examples/consumer_schema.py             |   98 +-
 .../python-examples/exception_function.py          |   54 +-
 .../python-examples/exclamation_lib.py             |   40 +-
 .../python-examples/exclamation_with_extra_deps.py |   60 +-
 .../python-examples/producer_schema.py             |   90 +-
 .../latest-version-image/scripts/func-lib.sh       |   62 +
 .../latest-version-image/scripts/run-bookie.sh     |   66 +-
 .../latest-version-image/scripts/run-broker.sh     |   58 +-
 .../scripts/run-functions-worker.sh                |   60 +-
 .../latest-version-image/scripts/run-global-zk.sh  |   58 +-
 .../latest-version-image/scripts/run-local-zk.sh   |   58 +-
 .../latest-version-image/scripts/run-proxy.sh      |   56 +-
 .../latest-version-image/scripts/run-standalone.sh |   40 +-
 .../latest-version-image/scripts/run-websocket.sh  |   56 +-
 tests/docker-images/pom.xml                        |  142 +-
 tests/integration/pom.xml                          |  724 +--
 .../pulsar/tests/integration/admin/AdminTest.java  |  148 +-
 .../token/PulsarTokenAuthenticationBaseSuite.java  |  788 ++--
 .../auth/token/TokenAuthWithPublicPrivateKeys.java |  196 +-
 .../auth/token/TokenAuthWithSymmetricKeys.java     |  164 +-
 .../backwardscompatibility/ClientTest22.java       |   74 +-
 .../backwardscompatibility/ClientTest23.java       |   74 +-
 .../backwardscompatibility/ClientTest24.java       |   74 +-
 .../backwardscompatibility/ClientTest25.java       |  182 +-
 .../PulsarStandaloneTestSuite22.java               |   56 +-
 .../PulsarStandaloneTestSuite23.java               |   54 +-
 .../PulsarStandaloneTestSuite24.java               |   56 +-
 .../PulsarStandaloneTestSuite25.java               |   56 +-
 .../backwardscompatibility/SmokeTest22.java        |   70 +-
 .../backwardscompatibility/SmokeTest23.java        |   70 +-
 .../backwardscompatibility/SmokeTest24.java        |   80 +-
 .../backwardscompatibility/SmokeTest25.java        |   80 +-
 ...BookkeeperInstallWithHttpServerEnabledTest.java |  184 +-
 ...erInstallWithEntryMetadataInterceptorsTest.java |  170 +-
 .../tests/integration/cli/AdminMultiHostTest.java  |  196 +-
 .../pulsar/tests/integration/cli/CLITest.java      | 1198 ++---
 .../tests/integration/cli/ClientToolTest.java      |  200 +-
 .../cli/ClusterMetadataTearDownTest.java           |  464 +-
 .../integration/cli/FileSystemPackagesCliTest.java |  260 +-
 .../tests/integration/cli/FunctionsCLITest.java    |  182 +-
 .../tests/integration/cli/HealthCheckTest.java     |  236 +-
 .../tests/integration/cli/PackagesCliTest.java     |  288 +-
 .../pulsar/tests/integration/cli/PerfToolTest.java |  234 +-
 .../tests/integration/cli/PulsarVersionTest.java   |  152 +-
 .../integration/cli/SchemaUpdateStrategyTest.java  | 1004 ++---
 .../tests/integration/cli/tenant/TenantTest.java   |  242 +-
 .../SchemaCompatibilityStrategyTest.java           |  180 +-
 .../integration/compaction/TestCompaction.java     |  752 ++--
 .../tests/integration/containers/BKContainer.java  |   76 +-
 .../integration/containers/BrokerContainer.java    |  100 +-
 .../tests/integration/containers/CSContainer.java  |   94 +-
 .../integration/containers/CassandraContainer.java |  104 +-
 .../integration/containers/ChaosContainer.java     |  294 +-
 .../containers/DebeziumMongoDbContainer.java       |  102 +-
 .../containers/DebeziumMsSqlContainer.java         |  140 +-
 .../containers/DebeziumMySQLContainer.java         |  112 +-
 .../containers/DebeziumOracleDbContainer.java      |  122 +-
 .../containers/DebeziumPostgreSqlContainer.java    |  108 +-
 .../integration/containers/HdfsContainer.java      |  102 +-
 .../OpenTelemetryCollectorContainer.java           |  126 +-
 .../integration/containers/ProxyContainer.java     |   90 +-
 .../integration/containers/PulsarContainer.java    |  720 +--
 .../containers/PulsarInitMetadataContainer.java    |  152 +-
 .../integration/containers/RabbitMQContainer.java  |   92 +-
 .../tests/integration/containers/S3Container.java  |  108 +-
 .../integration/containers/ScyllaDBContainer.java  |   65 +
 .../containers/StandaloneContainer.java            |  136 +-
 .../integration/containers/WebSocketContainer.java |   82 +-
 .../integration/containers/WorkerContainer.java    |  104 +-
 .../tests/integration/containers/ZKContainer.java  |   96 +-
 .../tests/integration/containers/package-info.java |   42 +-
 .../integration/docker/ContainerExecException.java |   64 +-
 .../integration/docker/ContainerExecResult.java    |   96 +-
 .../docker/ContainerExecResultBytes.java           |   66 +-
 .../functions/PulsarBKStateStoreTest.java          |   54 +-
 .../integration/functions/PulsarFunctionsTest.java | 4622 ++++++++++----------
 .../functions/PulsarFunctionsTestBase.java         |  320 +-
 .../functions/PulsarMetadataStateStoreTest.java    |  120 +-
 .../integration/functions/PulsarStateTest.java     | 1454 +++---
 .../functions/go/PulsarFunctionsGoProcessTest.java |   58 +-
 .../functions/go/PulsarFunctionsGoTest.java        |   84 +-
 .../functions/go/PulsarFunctionsGoThreadTest.java  |   56 +-
 .../java/PulsarFunctionsJavaProcessTest.java       |   58 +-
 .../functions/java/PulsarFunctionsJavaTest.java    |  570 +--
 .../java/PulsarFunctionsJavaThreadTest.java        |   56 +-
 .../PulsarWorkerRebalanceDrainProcessTest.java     |   56 +-
 .../java/PulsarWorkerRebalanceDrainTest.java       |  798 ++--
 .../java/PulsarWorkerRebalanceDrainThreadTest.java |   56 +-
 .../functions/k8s/PulsarFunctionsK8STest.java      |  187 +
 .../python/PulsarFunctionsPythonProcessTest.java   |   56 +-
 .../python/PulsarFunctionsPythonTest.java          |  178 +-
 .../python/PulsarFunctionsPythonThreadTest.java    |   56 +-
 .../functions/utils/CommandGenerator.java          |  836 ++--
 .../utils/UploadDownloadCommandGenerator.java      |  148 +-
 .../io/PulsarGenericObjectSinkTest.java            |  674 +--
 .../tests/integration/io/PulsarIOTestBase.java     |  150 +-
 .../tests/integration/io/PulsarIOTestRunner.java   |  188 +-
 .../tests/integration/io/RabbitMQSinkTester.java   |  226 +-
 .../tests/integration/io/RabbitMQSourceTester.java |  190 +-
 .../io/SinkWithTransformFunctionTest.java          |  740 ++--
 .../integration/io/sinks/CassandraSinkTester.java  |  300 +-
 .../io/sinks/ElasticSearch7SinkTester.java         |   82 +-
 .../io/sinks/ElasticSearch8SinkTester.java         |   84 +-
 .../io/sinks/ElasticSearchSinkTester.java          |  416 +-
 .../tests/integration/io/sinks/HdfsSinkTester.java |  124 +-
 .../io/sinks/JdbcPostgresSinkTester.java           |  402 +-
 .../integration/io/sinks/KafkaSinkTester.java      |  268 +-
 .../integration/io/sinks/KinesisSinkTester.java    |  580 +--
 .../integration/io/sinks/OpenSearchSinkTester.java |  180 +-
 .../integration/io/sinks/PulsarIOSinkRunner.java   |  916 ++--
 .../integration/io/sinks/PulsarSinksTest.java      |  188 +-
 .../integration/io/sinks/ScyllaDBSinkTester.java   |  168 +
 .../tests/integration/io/sinks/SinkTester.java     |  258 +-
 .../io/sources/AvroKafkaSourceTest.java            | 1030 ++---
 .../integration/io/sources/BatchSourceTest.java    |  444 +-
 .../io/sources/DataGeneratorSourceTest.java        |  492 +--
 .../io/sources/GenericRecordSourceTest.java        |  514 +--
 .../integration/io/sources/KafkaSourceTester.java  |  306 +-
 .../integration/io/sources/MongoSourceTester.java  |  312 +-
 .../io/sources/PulsarIOSourceRunner.java           |  620 +--
 .../io/sources/PulsarSourcePropertyTest.java       |  324 +-
 .../tests/integration/io/sources/SourceTester.java |  392 +-
 .../debezium/DebeziumMongoDbSourceTester.java      |  252 +-
 .../debezium/DebeziumMsSqlSourceTester.java        |  340 +-
 .../debezium/DebeziumMySqlSourceTester.java        |  270 +-
 .../debezium/DebeziumOracleDbSourceTester.java     |  516 +--
 .../debezium/DebeziumPostgreSqlSourceTester.java   |  334 +-
 .../debezium/PulsarDebeziumOracleSourceTest.java   |  214 +-
 .../debezium/PulsarDebeziumSourcesTest.java        |  542 +--
 .../debezium/PulsarIODebeziumSourceRunner.java     |  264 +-
 .../k8s/AbstractPulsarStandaloneK8STest.java       |  411 ++
 .../loadbalance/ExtensibleLoadManagerTest.java     |  976 ++---
 .../integration/messaging/DelayMessagingTest.java  |  212 +-
 .../integration/messaging/GeoReplicationTest.java  |  256 +-
 .../tests/integration/messaging/MessagingBase.java |  336 +-
 .../integration/messaging/MessagingSmokeTest.java  |  214 +-
 .../messaging/NonDurableConsumerMessagingTest.java |  140 +-
 .../messaging/NonPersistentTopicMessagingTest.java |  134 +-
 .../messaging/PersistentTopicMessagingTest.java    |  136 +-
 .../integration/messaging/ReaderMessagingTest.java |  284 +-
 .../integration/messaging/TopicMessagingBase.java  |  896 ++--
 .../metrics/OpenTelemetrySanityTest.java           |  342 +-
 .../tests/integration/offload/TestBaseOffload.java |  934 ++--
 .../integration/offload/TestFileSystemOffload.java |  118 +-
 .../integration/offload/TestOffloadDeletionFS.java |  288 +-
 .../tests/integration/offload/TestS3Offload.java   |  176 +-
 .../offload/TestUniversalConfigurations.java       |  172 +-
 .../tests/integration/oxia/OxiaContainer.java      |  144 +-
 .../tests/integration/oxia/OxiaSmokeTest.java      |   96 +-
 .../plugins/TestAdditionalServlets.java            |  198 +-
 .../plugins/TestBrokerInterceptors.java            |  226 +-
 .../integration/plugins/TestEntryFilters.java      |  196 +-
 .../integration/plugins/TestProtocolHandlers.java  |  138 +-
 .../integration/profiling/PulsarProfilingTest.java |  324 ++
 .../pulsar/tests/integration/proxy/TestProxy.java  |  244 +-
 .../tests/integration/python/PythonSchemaTest.java |  242 +-
 .../tests/integration/schema/JodaTimeTest.java     |  276 +-
 .../tests/integration/schema/SchemaTest.java       |  668 +--
 .../pulsar/tests/integration/schema/Schemas.java   |  290 +-
 .../tests/integration/semantics/SemanticsTest.java |  584 +--
 .../tests/integration/standalone/SmokeTest.java    |   62 +-
 .../integration/suites/PulsarCliTestSuite.java     |   80 +-
 .../suites/PulsarStandaloneTestSuite.java          |  118 +-
 .../tests/integration/suites/PulsarTestSuite.java  |  126 +-
 .../suites/PulsarTieredStorageTestSuite.java       |  138 +-
 .../ClientTlsAbsoluteAdvertisedAddressTest.java    |   64 +-
 .../tests/integration/tls/ClientTlsTest.java       |  182 +-
 .../integration/topics/TestTopicDeletion.java      |  362 +-
 .../integration/topologies/ClientTestBase.java     |  160 +-
 .../topologies/FunctionRuntimeType.java            |   54 +-
 .../integration/topologies/PulsarCluster.java      | 1526 +++----
 .../integration/topologies/PulsarClusterSpec.java  |  404 +-
 .../topologies/PulsarClusterTestBase.java          |  336 +-
 .../integration/topologies/PulsarGeoCluster.java   |  164 +-
 .../topologies/PulsarGeoClusterTestBase.java       |  182 +-
 .../topologies/PulsarStandaloneTestBase.java       |  268 +-
 .../integration/topologies/PulsarTestBase.java     |  392 +-
 .../integration/transaction/TransactionTest.java   |  322 +-
 .../transaction/TransactionTestBase.java           |  196 +-
 .../upgrade/PulsarUpgradeDowngradeTest.java        |  352 +-
 .../integration/upgrade/PulsarZKDowngradeTest.java |  228 +-
 .../tests/integration/utils/DockerUtils.java       |  842 ++--
 .../tests/integration/websocket/TestWebSocket.java |  148 +-
 .../integration/websocket/WebSocketTestSuite.java  |  296 +-
 .../containers/otel-collector-config.yaml          |   86 +-
 .../src/test/resources/kafka-zookeeper.properties  |   70 +-
 .../integration/src/test/resources/pulsar-auth.xml |   54 +-
 .../resources/pulsar-backwards-compatibility.xml   |   68 +-
 .../integration/src/test/resources/pulsar-cli.xml  |   78 +-
 .../src/test/resources/pulsar-function.xml         |   64 +-
 .../src/test/resources/pulsar-io-ora-source.xml    |   56 +-
 .../src/test/resources/pulsar-io-sinks.xml         |   54 +-
 .../src/test/resources/pulsar-io-sources.xml       |   60 +-
 .../integration/src/test/resources/pulsar-k8s.xml  |   28 +
 .../src/test/resources/pulsar-loadbalance.xml      |   54 +-
 .../src/test/resources/pulsar-messaging.xml        |   72 +-
 .../src/test/resources/pulsar-metrics.xml          |   56 +-
 .../src/test/resources/pulsar-plugin.xml           |   62 +-
 .../src/test/resources/pulsar-process.xml          |   64 +-
 .../src/test/resources/pulsar-proxy.xml            |   54 +-
 .../src/test/resources/pulsar-python.xml           |   56 +-
 .../src/test/resources/pulsar-schema.xml           |   60 +-
 .../src/test/resources/pulsar-semantics.xml        |   56 +-
 .../src/test/resources/pulsar-standalone.xml       |   54 +-
 .../src/test/resources/pulsar-thread.xml           |   62 +-
 .../integration/src/test/resources/pulsar-tls.xml  |   56 +-
 .../src/test/resources/pulsar-transaction.xml      |   56 +-
 .../src/test/resources/pulsar-upgrade.xml          |   56 +-
 .../src/test/resources/pulsar-websocket.xml        |   54 +-
 tests/integration/src/test/resources/pulsar.xml    |   84 +-
 .../test/resources/tiered-filesystem-storage.xml   |   54 +-
 .../src/test/resources/tiered-jcloud-storage.xml   |   54 +-
 tests/pom.xml                                      |  230 +-
 tests/pulsar-client-admin-shade-test/pom.xml       |  246 +-
 .../pulsar/tests/integration/PulsarContainer.java  |  112 +-
 .../integration/SimpleProducerConsumerTest.java    | 1218 +++---
 .../apache/pulsar/tests/integration/SmokeTest.java |  198 +-
 .../src/test/resources/certificate/client.crt      |   40 +-
 .../src/test/resources/certificate/client.csr      |   34 +-
 .../src/test/resources/certificate/client.key      |   56 +-
 .../certificate/private-key.client-ecdsa.pem       |   26 +-
 .../private-key.client-mismatch-rsa.pem            |   58 +-
 .../certificate/private-key.client-rsa.pem         |   54 +-
 .../certificate/public-key.client-ecdsa.pem        |   14 +-
 .../certificate/public-key.client-mismatch-rsa.pem |   18 +-
 .../certificate/public-key.client-rsa.pem          |   18 +-
 .../src/test/resources/certificate/server.crt      |   40 +-
 .../src/test/resources/certificate/server.csr      |   34 +-
 .../src/test/resources/certificate/server.key      |   56 +-
 .../src/test/resources/pulsar.xml                  |   58 +-
 tests/pulsar-client-all-shade-test/pom.xml         |  244 +-
 .../pulsar/tests/integration/PulsarContainer.java  |  112 +-
 .../integration/SimpleProducerConsumerTest.java    | 1216 ++---
 .../apache/pulsar/tests/integration/SmokeTest.java |  198 +-
 .../src/test/resources/certificate/client.crt      |   40 +-
 .../src/test/resources/certificate/client.csr      |   34 +-
 .../src/test/resources/certificate/client.key      |   56 +-
 .../certificate/private-key.client-ecdsa.pem       |   26 +-
 .../private-key.client-mismatch-rsa.pem            |   58 +-
 .../certificate/private-key.client-rsa.pem         |   54 +-
 .../certificate/public-key.client-ecdsa.pem        |   14 +-
 .../certificate/public-key.client-mismatch-rsa.pem |   18 +-
 .../certificate/public-key.client-rsa.pem          |   18 +-
 .../src/test/resources/certificate/server.crt      |   40 +-
 .../src/test/resources/certificate/server.csr      |   34 +-
 .../src/test/resources/certificate/server.key      |   56 +-
 .../src/test/resources/pulsar.xml                  |   58 +-
 tests/pulsar-client-shade-test/pom.xml             |  234 +-
 .../pulsar/tests/integration/PulsarContainer.java  |  112 +-
 .../integration/SimpleProducerConsumerTest.java    | 1212 ++---
 .../apache/pulsar/tests/integration/SmokeTest.java |  168 +-
 .../src/test/resources/certificate/client.crt      |   40 +-
 .../src/test/resources/certificate/client.csr      |   34 +-
 .../src/test/resources/certificate/client.key      |   56 +-
 .../certificate/private-key.client-ecdsa.pem       |   26 +-
 .../private-key.client-mismatch-rsa.pem            |   58 +-
 .../certificate/private-key.client-rsa.pem         |   54 +-
 .../certificate/public-key.client-ecdsa.pem        |   14 +-
 .../certificate/public-key.client-mismatch-rsa.pem |   18 +-
 .../certificate/public-key.client-rsa.pem          |   18 +-
 .../src/test/resources/certificate/server.crt      |   40 +-
 .../src/test/resources/certificate/server.csr      |   34 +-
 .../src/test/resources/certificate/server.key      |   56 +-
 .../src/test/resources/pulsar.xml                  |   58 +-
 tests/scripts/post-integ-tests.sh                  |   44 +-
 tests/scripts/pre-integ-tests.sh                   |   68 +-
 387 files changed, 37009 insertions(+), 35764 deletions(-)

diff --git a/tests/bc_2_0_0/pom.xml b/tests/bc_2_0_0/pom.xml
index 115768c672..66aa345e5a 100644
--- a/tests/bc_2_0_0/pom.xml
+++ b/tests/bc_2_0_0/pom.xml
@@ -1,108 +1,108 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>org.apache.pulsar.tests</groupId>
-        <artifactId>tests-parent</artifactId>
-        <version>4.1.2</version>
-    </parent>
-
-    <artifactId>bc_2_0_0</artifactId>
-    <packaging>jar</packaging>
-    <name>Apache Pulsar :: Tests :: Backwards Client Compatibility 2.0.0-rc1-incubating</name>
-
-    <dependencies>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client</artifactId>
-            <version>2.0.0-rc1-incubating</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.testcontainers</groupId>
-            <artifactId>testcontainers</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <configuration>
-                    <!-- only run tests when -DintegrationTests is specified //-->
-                    <skipTests>true</skipTests>
-                    <systemPropertyVariables>
-                        <currentVersion>${project.version}</currentVersion>
-                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-                    </systemPropertyVariables>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-    <profiles>
-        <profile>
-            <id>BackwardsCompatTests</id>
-            <activation>
-                <property>
-                    <name>BackwardsCompatTests</name>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
-                                ${test.additional.args}
-                            </argLine>
-                            <skipTests>false</skipTests>
-                            <suiteXmlFiles>
-                                <file>src/test/resources/pulsar.xml</file>
-                            </suiteXmlFiles>
-                            <forkCount>1</forkCount>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.pulsar.tests</groupId>
+        <artifactId>tests-parent</artifactId>
+        <version>4.1.2</version>
+    </parent>
+
+    <artifactId>bc_2_0_0</artifactId>
+    <packaging>jar</packaging>
+    <name>Apache Pulsar :: Tests :: Backwards Client Compatibility 2.0.0-rc1-incubating</name>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client</artifactId>
+            <version>2.0.0-rc1-incubating</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>test-jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <!-- only run tests when -DintegrationTests is specified //-->
+                    <skipTests>true</skipTests>
+                    <systemPropertyVariables>
+                        <currentVersion>${project.version}</currentVersion>
+                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+                    </systemPropertyVariables>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>
+        <profile>
+            <id>BackwardsCompatTests</id>
+            <activation>
+                <property>
+                    <name>BackwardsCompatTests</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
+                                ${test.additional.args}
+                            </argLine>
+                            <skipTests>false</skipTests>
+                            <suiteXmlFiles>
+                                <file>src/test/resources/pulsar.xml</file>
+                            </suiteXmlFiles>
+                            <forkCount>1</forkCount>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+</project>
diff --git a/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java b/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
index 8c20c23543..5c923f8d60 100644
--- a/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
+++ b/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
@@ -1,52 +1,52 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-public class PulsarContainer extends GenericContainer<PulsarContainer> {
-
-    public static final int PULSAR_PORT = 6650;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-
-    public PulsarContainer() {
-        this(DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(final String pulsarVersion) {
-        super(pulsarVersion);
-        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
-        withCommand("/pulsar/bin/pulsar standalone");
-        waitingFor(new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS)));
-    }
-
-    public String getPlainTextPulsarBrokerUrl() {
-        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+public class PulsarContainer extends GenericContainer<PulsarContainer> {
+
+    public static final int PULSAR_PORT = 6650;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+
+    public PulsarContainer() {
+        this(DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(final String pulsarVersion) {
+        super(pulsarVersion);
+        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
+        withCommand("/pulsar/bin/pulsar standalone");
+        waitingFor(new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS)));
+    }
+
+    public String getPlainTextPulsarBrokerUrl() {
+        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
+    }
+
+}
diff --git a/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java b/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
index 3c4c0c3ac9..5fe7dac2f4 100644
--- a/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
+++ b/tests/bc_2_0_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
@@ -1,84 +1,84 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends TestRetrySupport {
-
-    private PulsarContainer pulsarContainer;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup(){
-        incrementSetupNumber();
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-    }
-
-    @Test
-    public void checkMessages() throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String inputTopic = "input";
-
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .enableBatching(false)
-                .create();
-
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(inputTopic)
-                .subscriptionName("test-subs")
-                .ackTimeout(10, TimeUnit.SECONDS)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-
-        producer.send("Hello!");
-        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
-
-        Assert.assertEquals(message.getValue(), "Hello!");
-
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup(){
-        markCurrentSetupNumberCleaned();
-        pulsarContainer.stop();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends TestRetrySupport {
+
+    private PulsarContainer pulsarContainer;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup(){
+        incrementSetupNumber();
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+    }
+
+    @Test
+    public void checkMessages() throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String inputTopic = "input";
+
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .enableBatching(false)
+                .create();
+
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(inputTopic)
+                .subscriptionName("test-subs")
+                .ackTimeout(10, TimeUnit.SECONDS)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+
+        producer.send("Hello!");
+        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
+
+        Assert.assertEquals(message.getValue(), "Hello!");
+
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup(){
+        markCurrentSetupNumberCleaned();
+        pulsarContainer.stop();
+    }
+
+}
diff --git a/tests/bc_2_0_0/src/test/resources/pulsar.xml b/tests/bc_2_0_0/src/test/resources/pulsar.xml
index 43dfaea158..5c507f6453 100644
--- a/tests/bc_2_0_0/src/test/resources/pulsar.xml
+++ b/tests/bc_2_0_0/src/test/resources/pulsar.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-standalone-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-standalone-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/bc_2_0_1/pom.xml b/tests/bc_2_0_1/pom.xml
index 8c1a75057d..fb4df327f7 100644
--- a/tests/bc_2_0_1/pom.xml
+++ b/tests/bc_2_0_1/pom.xml
@@ -1,108 +1,108 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>org.apache.pulsar.tests</groupId>
-        <artifactId>tests-parent</artifactId>
-        <version>4.1.2</version>
-    </parent>
-
-    <artifactId>bc_2_0_1</artifactId>
-    <packaging>jar</packaging>
-    <name>Apache Pulsar :: Tests :: Backwards Client Compatibility 2.0.1-incubating</name>
-
-    <dependencies>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client</artifactId>
-            <version>2.0.1-incubating</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.testcontainers</groupId>
-            <artifactId>testcontainers</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <configuration>
-                    <!-- only run tests when -DintegrationTests is specified //-->
-                    <skipTests>true</skipTests>
-                    <systemPropertyVariables>
-                        <currentVersion>${project.version}</currentVersion>
-                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-                    </systemPropertyVariables>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-    <profiles>
-        <profile>
-            <id>BackwardsCompatTests</id>
-            <activation>
-                <property>
-                    <name>BackwardsCompatTests</name>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
-                                ${test.additional.args}
-                            </argLine>
-                            <skipTests>false</skipTests>
-                            <suiteXmlFiles>
-                                <file>src/test/resources/pulsar.xml</file>
-                            </suiteXmlFiles>
-                            <forkCount>1</forkCount>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.pulsar.tests</groupId>
+        <artifactId>tests-parent</artifactId>
+        <version>4.1.2</version>
+    </parent>
+
+    <artifactId>bc_2_0_1</artifactId>
+    <packaging>jar</packaging>
+    <name>Apache Pulsar :: Tests :: Backwards Client Compatibility 2.0.1-incubating</name>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client</artifactId>
+            <version>2.0.1-incubating</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>test-jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <!-- only run tests when -DintegrationTests is specified //-->
+                    <skipTests>true</skipTests>
+                    <systemPropertyVariables>
+                        <currentVersion>${project.version}</currentVersion>
+                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+                    </systemPropertyVariables>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>
+        <profile>
+            <id>BackwardsCompatTests</id>
+            <activation>
+                <property>
+                    <name>BackwardsCompatTests</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
+                                ${test.additional.args}
+                            </argLine>
+                            <skipTests>false</skipTests>
+                            <suiteXmlFiles>
+                                <file>src/test/resources/pulsar.xml</file>
+                            </suiteXmlFiles>
+                            <forkCount>1</forkCount>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+</project>
diff --git a/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java b/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
index 8c20c23543..5c923f8d60 100644
--- a/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
+++ b/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
@@ -1,52 +1,52 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-public class PulsarContainer extends GenericContainer<PulsarContainer> {
-
-    public static final int PULSAR_PORT = 6650;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-
-    public PulsarContainer() {
-        this(DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(final String pulsarVersion) {
-        super(pulsarVersion);
-        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
-        withCommand("/pulsar/bin/pulsar standalone");
-        waitingFor(new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS)));
-    }
-
-    public String getPlainTextPulsarBrokerUrl() {
-        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+public class PulsarContainer extends GenericContainer<PulsarContainer> {
+
+    public static final int PULSAR_PORT = 6650;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+
+    public PulsarContainer() {
+        this(DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(final String pulsarVersion) {
+        super(pulsarVersion);
+        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
+        withCommand("/pulsar/bin/pulsar standalone");
+        waitingFor(new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS)));
+    }
+
+    public String getPlainTextPulsarBrokerUrl() {
+        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
+    }
+
+}
diff --git a/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java b/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
index 3c4c0c3ac9..5fe7dac2f4 100644
--- a/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
+++ b/tests/bc_2_0_1/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
@@ -1,84 +1,84 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends TestRetrySupport {
-
-    private PulsarContainer pulsarContainer;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup(){
-        incrementSetupNumber();
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-    }
-
-    @Test
-    public void checkMessages() throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String inputTopic = "input";
-
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .enableBatching(false)
-                .create();
-
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(inputTopic)
-                .subscriptionName("test-subs")
-                .ackTimeout(10, TimeUnit.SECONDS)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-
-        producer.send("Hello!");
-        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
-
-        Assert.assertEquals(message.getValue(), "Hello!");
-
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup(){
-        markCurrentSetupNumberCleaned();
-        pulsarContainer.stop();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends TestRetrySupport {
+
+    private PulsarContainer pulsarContainer;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup(){
+        incrementSetupNumber();
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+    }
+
+    @Test
+    public void checkMessages() throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String inputTopic = "input";
+
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .enableBatching(false)
+                .create();
+
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(inputTopic)
+                .subscriptionName("test-subs")
+                .ackTimeout(10, TimeUnit.SECONDS)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+
+        producer.send("Hello!");
+        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
+
+        Assert.assertEquals(message.getValue(), "Hello!");
+
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup(){
+        markCurrentSetupNumberCleaned();
+        pulsarContainer.stop();
+    }
+
+}
diff --git a/tests/bc_2_0_1/src/test/resources/pulsar.xml b/tests/bc_2_0_1/src/test/resources/pulsar.xml
index 43dfaea158..5c507f6453 100644
--- a/tests/bc_2_0_1/src/test/resources/pulsar.xml
+++ b/tests/bc_2_0_1/src/test/resources/pulsar.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-standalone-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-standalone-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/bc_2_6_0/pom.xml b/tests/bc_2_6_0/pom.xml
index a49be7d0d7..35d81ea640 100644
--- a/tests/bc_2_6_0/pom.xml
+++ b/tests/bc_2_6_0/pom.xml
@@ -1,117 +1,117 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.apache.pulsar.tests</groupId>
-        <artifactId>tests-parent</artifactId>
-        <version>4.1.2</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-
-    <artifactId>bc_2_6_0</artifactId>
-    <packaging>jar</packaging>
-    <name>Apache Pulsar :: Tests :: Backwards Client Compatibility 2.6.0</name>
-
-    <dependencies>
-
-        <dependency>
-            <groupId>com.google.code.gson</groupId>
-            <artifactId>gson</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client</artifactId>
-            <version>2.6.0</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.testcontainers</groupId>
-            <artifactId>testcontainers</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <configuration>
-                    <!-- only run tests when -DintegrationTests is specified //-->
-                    <skipTests>true</skipTests>
-                    <systemPropertyVariables>
-                        <currentVersion>${project.version}</currentVersion>
-                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-                    </systemPropertyVariables>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-    <profiles>
-        <profile>
-            <id>BackwardsCompatTests</id>
-            <activation>
-                <property>
-                    <name>BackwardsCompatTests</name>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
-                                ${test.additional.args}
-                            </argLine>
-                            <skipTests>false</skipTests>
-                            <suiteXmlFiles>
-                                <file>src/test/resources/backwards-client.xml</file>
-                            </suiteXmlFiles>
-                            <forkCount>1</forkCount>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-
-
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <groupId>org.apache.pulsar.tests</groupId>
+        <artifactId>tests-parent</artifactId>
+        <version>4.1.2</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>bc_2_6_0</artifactId>
+    <packaging>jar</packaging>
+    <name>Apache Pulsar :: Tests :: Backwards Client Compatibility 2.6.0</name>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client</artifactId>
+            <version>2.6.0</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>test-jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <!-- only run tests when -DintegrationTests is specified //-->
+                    <skipTests>true</skipTests>
+                    <systemPropertyVariables>
+                        <currentVersion>${project.version}</currentVersion>
+                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+                    </systemPropertyVariables>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>
+        <profile>
+            <id>BackwardsCompatTests</id>
+            <activation>
+                <property>
+                    <name>BackwardsCompatTests</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
+                                ${test.additional.args}
+                            </argLine>
+                            <skipTests>false</skipTests>
+                            <suiteXmlFiles>
+                                <file>src/test/resources/backwards-client.xml</file>
+                            </suiteXmlFiles>
+                            <forkCount>1</forkCount>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+
+
+</project>
diff --git a/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java b/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
index 8c20c23543..5c923f8d60 100644
--- a/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
+++ b/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
@@ -1,52 +1,52 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-public class PulsarContainer extends GenericContainer<PulsarContainer> {
-
-    public static final int PULSAR_PORT = 6650;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-
-    public PulsarContainer() {
-        this(DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(final String pulsarVersion) {
-        super(pulsarVersion);
-        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
-        withCommand("/pulsar/bin/pulsar standalone");
-        waitingFor(new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS)));
-    }
-
-    public String getPlainTextPulsarBrokerUrl() {
-        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+public class PulsarContainer extends GenericContainer<PulsarContainer> {
+
+    public static final int PULSAR_PORT = 6650;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+
+    public PulsarContainer() {
+        this(DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(final String pulsarVersion) {
+        super(pulsarVersion);
+        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
+        withCommand("/pulsar/bin/pulsar standalone");
+        waitingFor(new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS)));
+    }
+
+    public String getPlainTextPulsarBrokerUrl() {
+        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
+    }
+
+}
diff --git a/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java b/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
index 3c4c0c3ac9..5fe7dac2f4 100644
--- a/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
+++ b/tests/bc_2_6_0/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
@@ -1,84 +1,84 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends TestRetrySupport {
-
-    private PulsarContainer pulsarContainer;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup(){
-        incrementSetupNumber();
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-    }
-
-    @Test
-    public void checkMessages() throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String inputTopic = "input";
-
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .enableBatching(false)
-                .create();
-
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(inputTopic)
-                .subscriptionName("test-subs")
-                .ackTimeout(10, TimeUnit.SECONDS)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-
-        producer.send("Hello!");
-        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
-
-        Assert.assertEquals(message.getValue(), "Hello!");
-
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup(){
-        markCurrentSetupNumberCleaned();
-        pulsarContainer.stop();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends TestRetrySupport {
+
+    private PulsarContainer pulsarContainer;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup(){
+        incrementSetupNumber();
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+    }
+
+    @Test
+    public void checkMessages() throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String inputTopic = "input";
+
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .enableBatching(false)
+                .create();
+
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(inputTopic)
+                .subscriptionName("test-subs")
+                .ackTimeout(10, TimeUnit.SECONDS)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+
+        producer.send("Hello!");
+        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
+
+        Assert.assertEquals(message.getValue(), "Hello!");
+
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup(){
+        markCurrentSetupNumberCleaned();
+        pulsarContainer.stop();
+    }
+
+}
diff --git a/tests/bc_2_6_0/src/test/resources/backwards-client.xml b/tests/bc_2_6_0/src/test/resources/backwards-client.xml
index 43dfaea158..5c507f6453 100644
--- a/tests/bc_2_6_0/src/test/resources/backwards-client.xml
+++ b/tests/bc_2_6_0/src/test/resources/backwards-client.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-standalone-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-standalone-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/certificate-authority/.gitignore b/tests/certificate-authority/.gitignore
index de3be75463..dfaf8cdf6b 100644
--- a/tests/certificate-authority/.gitignore
+++ b/tests/certificate-authority/.gitignore
@@ -1,3 +1,3 @@
-# Files generated when running openssl
-*.old
-*.attr
+# Files generated when running openssl
+*.old
+*.attr
diff --git a/tests/certificate-authority/RemoveJksPassword.java b/tests/certificate-authority/RemoveJksPassword.java
index e6c22c81d3..8af3c56238 100644
--- a/tests/certificate-authority/RemoveJksPassword.java
+++ b/tests/certificate-authority/RemoveJksPassword.java
@@ -1,44 +1,44 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package main;
-
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.security.KeyStore;
-
-// RemoveJksPassword removes the password from the keystore or truststore
-public class RemoveJksPassword {
-    public static void main(String[] args) {
-        if (args.length != 3) {
-            System.out.println("USAGE: RemoveJksPassword.java [input] [password] [output]");
-            return;
-        }
-
-        String path = args[0];
-        String password = args[1];
-        String outputPath = args[2];
-        try {
-            KeyStore instance = KeyStore.getInstance("JKS");
-            instance.load(new FileInputStream(path), password.toCharArray());
-            instance.store(new FileOutputStream(outputPath), "".toCharArray());
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package main;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.security.KeyStore;
+
+// RemoveJksPassword removes the password from the keystore or truststore
+public class RemoveJksPassword {
+    public static void main(String[] args) {
+        if (args.length != 3) {
+            System.out.println("USAGE: RemoveJksPassword.java [input] [password] [output]");
+            return;
+        }
+
+        String path = args[0];
+        String password = args[1];
+        String outputPath = args[2];
+        try {
+            KeyStore instance = KeyStore.getInstance("JKS");
+            instance.load(new FileInputStream(path), password.toCharArray());
+            instance.store(new FileOutputStream(outputPath), "".toCharArray());
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/tests/certificate-authority/certs/ca.cert.pem b/tests/certificate-authority/certs/ca.cert.pem
index 0446700135..1d879d5245 100644
--- a/tests/certificate-authority/certs/ca.cert.pem
+++ b/tests/certificate-authority/certs/ca.cert.pem
@@ -1,29 +1,29 @@
------BEGIN CERTIFICATE-----
-MIIFCDCCAvCgAwIBAgIJANfih0+geeIMMA0GCSqGSIb3DQEBCwUAMBExDzANBgNV
-BAMMBmZvb2JhcjAeFw0xODA2MjIwODQ2MjFaFw0zODA2MTcwODQ2MjFaMBExDzAN
-BgNVBAMMBmZvb2JhcjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOVU
-UpTPeXCeyfUiQS824l9s9krZd4R6TA4D97eQ9EWm2D7ppV4gPApHO8j5f+joo/b6
-Iso4aFlHpJ8VV2a5Ol7rjQw43MJHaBgwDxB1XWgsNdfoI7ebtp/BWg2nM3r8wm+Z
-gKenf9d1/1Ol+6yFUehkLkIXUvldiVegmmje8FnwhcDNE1eTrh66XqSJXEXqgBKu
-NqsoYcVak72OyOO1/N8CESoSdyBkbSiH5vJyo0AUCjn7tULga7fxojmqBZDog9Pg
-e5Fi/hbCrdinbxBrMgIxQ7wqXw2sw6iOWu4FU8Ih/CuF4xaQy2YP7MEk4Ff0LCY0
-KMhFMWU7550r/fz/C2l7fKhREyCQPa/bVE+dfxgZ/gCZ+p7vQ154hCCjpd+5bECv
-SN1bcVIPG6ngQu4vMXa7QRBi/Od40jSVGVJXYY6kXvrYatad7035w2GGGGkvMsQm
-y53yh4tqQfH7ulHqB0J5LebTQRp6nRizWigVCLjNkxJYI+Dj51qvT1zdyWEegKr1
-CthBfYzXlfjeH3xri1f0UABeC12n24Wkacd9af7zs7S3rYntEK444w/3fB0F62Lh
-SESfMLAmUH0dF5plRShrFUXz23nUeS8EYgWmnGkpf/HDzB67vdfAK0tfJEtmmY78
-q06OSgMr+AOOqaomh4Ez2ZQG592bS71G8MrE7r2/AgMBAAGjYzBhMB0GA1UdDgQW
-BBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAfBgNVHSMEGDAWgBRXC+nLI+i/Rz5Qej9F
-fqEYQ50VJzAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG
-9w0BAQsFAAOCAgEAYd2PxdV+YOaWcmMG1fK7CGwSzDOGsgC7hi4gWPiNsVbz6fwQ
-m5Ac7Zw76dzin8gzOPKST7B8WIoc7ZWrMnyh3G6A3u29Ec8iWahqGa91NPA3bOIl
-0ldXnXfa416+JL/Q5utpiV6W2XDaB53v9GqpMk4rOTS9kCFOiuH5ZU8P69jp9mq6
-7pI/+hWFr+21ibmXH6ANxRLd/5+AqojRUYowAu2997Z+xmbpwx/2Svciq3LNY/Vz
-s9DudUHCBHj/DPgNxsEUt8QNohjQkRbFTY0a1aXodJ/pm0Ehk2kf9KwYYYduR7ak
-6UmPIPrZg6FePNahxwMZ0RtgX7EXmpiiIH1q9BsulddWkrFQclevsWO3ONQVrDs2
-gwY0HQuCRCJ+xgS2cyGiGohW5MkIsg1aI0i0j5GIUSppCIYgirAGCairARbCjhcx
-pbMe8RTuBhCqO3R2wZ0wXu7P7/ArI/Ltm1dU6IeHUAUmeneVj5ie0SdA19mHTS2o
-lG77N0jy6eq2zyEwJE6tuS/tyP1xrxdzXCYY7f6X9aNfsuPVQTcnrFajvDv8R6uD
-YnRStVCdS6fZEP0JzsLrqp9bgLIRRsiqsVVBCgJdK1I/X59qk2EyCLXWSgk8T9XZ
-iux8LlPpskt30YYt1KhlWB9zVz7k0uYAwits5foU6RfCRDPAyOa1q/QOXk0=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIFCDCCAvCgAwIBAgIJANfih0+geeIMMA0GCSqGSIb3DQEBCwUAMBExDzANBgNV
+BAMMBmZvb2JhcjAeFw0xODA2MjIwODQ2MjFaFw0zODA2MTcwODQ2MjFaMBExDzAN
+BgNVBAMMBmZvb2JhcjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOVU
+UpTPeXCeyfUiQS824l9s9krZd4R6TA4D97eQ9EWm2D7ppV4gPApHO8j5f+joo/b6
+Iso4aFlHpJ8VV2a5Ol7rjQw43MJHaBgwDxB1XWgsNdfoI7ebtp/BWg2nM3r8wm+Z
+gKenf9d1/1Ol+6yFUehkLkIXUvldiVegmmje8FnwhcDNE1eTrh66XqSJXEXqgBKu
+NqsoYcVak72OyOO1/N8CESoSdyBkbSiH5vJyo0AUCjn7tULga7fxojmqBZDog9Pg
+e5Fi/hbCrdinbxBrMgIxQ7wqXw2sw6iOWu4FU8Ih/CuF4xaQy2YP7MEk4Ff0LCY0
+KMhFMWU7550r/fz/C2l7fKhREyCQPa/bVE+dfxgZ/gCZ+p7vQ154hCCjpd+5bECv
+SN1bcVIPG6ngQu4vMXa7QRBi/Od40jSVGVJXYY6kXvrYatad7035w2GGGGkvMsQm
+y53yh4tqQfH7ulHqB0J5LebTQRp6nRizWigVCLjNkxJYI+Dj51qvT1zdyWEegKr1
+CthBfYzXlfjeH3xri1f0UABeC12n24Wkacd9af7zs7S3rYntEK444w/3fB0F62Lh
+SESfMLAmUH0dF5plRShrFUXz23nUeS8EYgWmnGkpf/HDzB67vdfAK0tfJEtmmY78
+q06OSgMr+AOOqaomh4Ez2ZQG592bS71G8MrE7r2/AgMBAAGjYzBhMB0GA1UdDgQW
+BBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAfBgNVHSMEGDAWgBRXC+nLI+i/Rz5Qej9F
+fqEYQ50VJzAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG
+9w0BAQsFAAOCAgEAYd2PxdV+YOaWcmMG1fK7CGwSzDOGsgC7hi4gWPiNsVbz6fwQ
+m5Ac7Zw76dzin8gzOPKST7B8WIoc7ZWrMnyh3G6A3u29Ec8iWahqGa91NPA3bOIl
+0ldXnXfa416+JL/Q5utpiV6W2XDaB53v9GqpMk4rOTS9kCFOiuH5ZU8P69jp9mq6
+7pI/+hWFr+21ibmXH6ANxRLd/5+AqojRUYowAu2997Z+xmbpwx/2Svciq3LNY/Vz
+s9DudUHCBHj/DPgNxsEUt8QNohjQkRbFTY0a1aXodJ/pm0Ehk2kf9KwYYYduR7ak
+6UmPIPrZg6FePNahxwMZ0RtgX7EXmpiiIH1q9BsulddWkrFQclevsWO3ONQVrDs2
+gwY0HQuCRCJ+xgS2cyGiGohW5MkIsg1aI0i0j5GIUSppCIYgirAGCairARbCjhcx
+pbMe8RTuBhCqO3R2wZ0wXu7P7/ArI/Ltm1dU6IeHUAUmeneVj5ie0SdA19mHTS2o
+lG77N0jy6eq2zyEwJE6tuS/tyP1xrxdzXCYY7f6X9aNfsuPVQTcnrFajvDv8R6uD
+YnRStVCdS6fZEP0JzsLrqp9bgLIRRsiqsVVBCgJdK1I/X59qk2EyCLXWSgk8T9XZ
+iux8LlPpskt30YYt1KhlWB9zVz7k0uYAwits5foU6RfCRDPAyOa1q/QOXk0=
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/client-keys/admin.cert.pem b/tests/certificate-authority/client-keys/admin.cert.pem
index 0665edbdc1..ff2fd7a126 100644
--- a/tests/certificate-authority/client-keys/admin.cert.pem
+++ b/tests/certificate-authority/client-keys/admin.cert.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEZTCCAk2gAwIBAgICEAEwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyMjA4NTcwNloYDzIyOTIwNDA2MDg1NzA2WjAQMQ4wDAYDVQQD
-DAVhZG1pbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJw3Jfbn0xkW
-36kqQjES6Hn+YTZ2jXS5Co2MzsGBsIY0qJ2BbWHSSaMrja4IERUaCQp16SWxPmZ0
-srMm6ErDoap+O70CWXLT3ybYMV5aVwv3ca4uxsedzaw9MpFXfUDsJJ3yre1JpO+t
-A/QzJEGq1d6NN49InUP5kB1Rpay3vaxx8hduzqTO+E/Lptv92p6GjOpXi2icSjiA
-pgaan2ldGGKEKv2Sc2bfdIDkTq1yDyNmuPET0yD2dci106EW/mPyj81umPKG/o4K
-5W18yG/IhXw5W1zlgO1fWCuqva8NCBdu7s1c7hUX8DBx7km4/I7dllz/nYHIfCEQ
-Dmj38oQjYk8CAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
-oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
-ZmljYXRlMB0GA1UdDgQWBBQTMzAAOJ9gXvQSS7Be3+qmrb1kVDAfBgNVHSMEGDAW
-gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
-FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQAwy8f6hsG0
-85e3SOIztbUnaVxS7wzDeDzR3vCjpXpm4vTToYzN9zx3JHKSdJrB12emVxItwW/7
-bXqBk0n2EdQjRHCuebnY05eFMNGagMEEMVmSLOproQD7VsyALNxCss1JAyRikh70
-W7wgOVeAhqE53UqqrkzTE7Q+8Bag9t3FytHxApY17XglbWkiVcFpQwSURe9Emi3E
-aCJCryGJXrBNuCFXGzetSygDEy27+2FeH8S2XsMwUEGLqDDehzvMenVz1xjXtq+s
-KPkofAde52NHd4lLkSeBMSFnKe3V7Xxax2OEUsoQRF3bkbpcJSWsKS9ZAA2yrtuy
-Nz/aA1F42LuSFPAYQr1kcZ8eSS918RWz+BiJYU2JuUOPd1XUmJXVvZ4CJurWaC7+
-ZD51YdD8E245xd55fsA6/qLx3eE/Kp0dVq+Hxuz6b4yLET0zkGunOe4A3hnRgkOA
-XolXCL+VthhWtFGXn8CjpxDnzjahq69Io+dINehqd5aJEgvnHZIK2s7FTqqBBodU
-HhyAE94f64z7ziuRhEG54bmBF+MoGyPf6dVn1Mp3+o+YeQ5q6XlKgh+u8jMgmqRO
-ikdsVdMqopt/FXh9eFzvQrwOZFLK6JE/edUgb6xvS1jMF5zi2lIlIkq1RBQOr4HT
-XDwX4vRtfpDxpsetGVpeq9O07fbMvp+mkw==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEZTCCAk2gAwIBAgICEAEwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyMjA4NTcwNloYDzIyOTIwNDA2MDg1NzA2WjAQMQ4wDAYDVQQD
+DAVhZG1pbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJw3Jfbn0xkW
+36kqQjES6Hn+YTZ2jXS5Co2MzsGBsIY0qJ2BbWHSSaMrja4IERUaCQp16SWxPmZ0
+srMm6ErDoap+O70CWXLT3ybYMV5aVwv3ca4uxsedzaw9MpFXfUDsJJ3yre1JpO+t
+A/QzJEGq1d6NN49InUP5kB1Rpay3vaxx8hduzqTO+E/Lptv92p6GjOpXi2icSjiA
+pgaan2ldGGKEKv2Sc2bfdIDkTq1yDyNmuPET0yD2dci106EW/mPyj81umPKG/o4K
+5W18yG/IhXw5W1zlgO1fWCuqva8NCBdu7s1c7hUX8DBx7km4/I7dllz/nYHIfCEQ
+Dmj38oQjYk8CAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
+oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
+ZmljYXRlMB0GA1UdDgQWBBQTMzAAOJ9gXvQSS7Be3+qmrb1kVDAfBgNVHSMEGDAW
+gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
+FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQAwy8f6hsG0
+85e3SOIztbUnaVxS7wzDeDzR3vCjpXpm4vTToYzN9zx3JHKSdJrB12emVxItwW/7
+bXqBk0n2EdQjRHCuebnY05eFMNGagMEEMVmSLOproQD7VsyALNxCss1JAyRikh70
+W7wgOVeAhqE53UqqrkzTE7Q+8Bag9t3FytHxApY17XglbWkiVcFpQwSURe9Emi3E
+aCJCryGJXrBNuCFXGzetSygDEy27+2FeH8S2XsMwUEGLqDDehzvMenVz1xjXtq+s
+KPkofAde52NHd4lLkSeBMSFnKe3V7Xxax2OEUsoQRF3bkbpcJSWsKS9ZAA2yrtuy
+Nz/aA1F42LuSFPAYQr1kcZ8eSS918RWz+BiJYU2JuUOPd1XUmJXVvZ4CJurWaC7+
+ZD51YdD8E245xd55fsA6/qLx3eE/Kp0dVq+Hxuz6b4yLET0zkGunOe4A3hnRgkOA
+XolXCL+VthhWtFGXn8CjpxDnzjahq69Io+dINehqd5aJEgvnHZIK2s7FTqqBBodU
+HhyAE94f64z7ziuRhEG54bmBF+MoGyPf6dVn1Mp3+o+YeQ5q6XlKgh+u8jMgmqRO
+ikdsVdMqopt/FXh9eFzvQrwOZFLK6JE/edUgb6xvS1jMF5zi2lIlIkq1RBQOr4HT
+XDwX4vRtfpDxpsetGVpeq9O07fbMvp+mkw==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/client-keys/admin.csr.pem b/tests/certificate-authority/client-keys/admin.csr.pem
index 8f16dfcebf..4e191b08e1 100644
--- a/tests/certificate-authority/client-keys/admin.csr.pem
+++ b/tests/certificate-authority/client-keys/admin.csr.pem
@@ -1,15 +1,15 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICVTCCAT0CAQAwEDEOMAwGA1UEAwwFYWRtaW4wggEiMA0GCSqGSIb3DQEBAQUA
-A4IBDwAwggEKAoIBAQCcNyX259MZFt+pKkIxEuh5/mE2do10uQqNjM7BgbCGNKid
-gW1h0kmjK42uCBEVGgkKdeklsT5mdLKzJuhKw6Gqfju9Ally098m2DFeWlcL93Gu
-LsbHnc2sPTKRV31A7CSd8q3tSaTvrQP0MyRBqtXejTePSJ1D+ZAdUaWst72scfIX
-bs6kzvhPy6bb/dqehozqV4tonEo4gKYGmp9pXRhihCr9knNm33SA5E6tcg8jZrjx
-E9Mg9nXItdOhFv5j8o/Nbpjyhv6OCuVtfMhvyIV8OVtc5YDtX1grqr2vDQgXbu7N
-XO4VF/Awce5JuPyO3ZZc/52ByHwhEA5o9/KEI2JPAgMBAAGgADANBgkqhkiG9w0B
-AQsFAAOCAQEAUTaUYcnkBD7q6WeD2Yd0vJZCi0ZtSXNoG+dkhxRo3O3i+yjD3Aqi
-Syesv9Hljrh2B+QU/xwizKIxAtBEVbLlhX2ceCx+GGSc+ARayElOVTnkxQW9HNR3
-n86sUapSeaXYYt37kGnVag8+gqUiYTrHPNxpnRfeAqQZv9ztBSitlyGJigXQRDaM
-umAjeOfw34hfsCPIkUKoZ9UobZzE3QN4f36Exf1f5/ftnJXEVNxGuTMkYNT2Py9N
-nySLMQZE8YlZbkTdBGrFH0Vqpi2twgga/C8JRnOWwkK581sTW2aEHWpBRNFc30Cy
-41QFI1tceUIQtAjnRcdgVlTp5D1SUrnALw==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICVTCCAT0CAQAwEDEOMAwGA1UEAwwFYWRtaW4wggEiMA0GCSqGSIb3DQEBAQUA
+A4IBDwAwggEKAoIBAQCcNyX259MZFt+pKkIxEuh5/mE2do10uQqNjM7BgbCGNKid
+gW1h0kmjK42uCBEVGgkKdeklsT5mdLKzJuhKw6Gqfju9Ally098m2DFeWlcL93Gu
+LsbHnc2sPTKRV31A7CSd8q3tSaTvrQP0MyRBqtXejTePSJ1D+ZAdUaWst72scfIX
+bs6kzvhPy6bb/dqehozqV4tonEo4gKYGmp9pXRhihCr9knNm33SA5E6tcg8jZrjx
+E9Mg9nXItdOhFv5j8o/Nbpjyhv6OCuVtfMhvyIV8OVtc5YDtX1grqr2vDQgXbu7N
+XO4VF/Awce5JuPyO3ZZc/52ByHwhEA5o9/KEI2JPAgMBAAGgADANBgkqhkiG9w0B
+AQsFAAOCAQEAUTaUYcnkBD7q6WeD2Yd0vJZCi0ZtSXNoG+dkhxRo3O3i+yjD3Aqi
+Syesv9Hljrh2B+QU/xwizKIxAtBEVbLlhX2ceCx+GGSc+ARayElOVTnkxQW9HNR3
+n86sUapSeaXYYt37kGnVag8+gqUiYTrHPNxpnRfeAqQZv9ztBSitlyGJigXQRDaM
+umAjeOfw34hfsCPIkUKoZ9UobZzE3QN4f36Exf1f5/ftnJXEVNxGuTMkYNT2Py9N
+nySLMQZE8YlZbkTdBGrFH0Vqpi2twgga/C8JRnOWwkK581sTW2aEHWpBRNFc30Cy
+41QFI1tceUIQtAjnRcdgVlTp5D1SUrnALw==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/client-keys/admin.key-pk8.pem b/tests/certificate-authority/client-keys/admin.key-pk8.pem
index 6aaa22c44d..791691bfe5 100644
--- a/tests/certificate-authority/client-keys/admin.key-pk8.pem
+++ b/tests/certificate-authority/client-keys/admin.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCcNyX259MZFt+p
-KkIxEuh5/mE2do10uQqNjM7BgbCGNKidgW1h0kmjK42uCBEVGgkKdeklsT5mdLKz
-JuhKw6Gqfju9Ally098m2DFeWlcL93GuLsbHnc2sPTKRV31A7CSd8q3tSaTvrQP0
-MyRBqtXejTePSJ1D+ZAdUaWst72scfIXbs6kzvhPy6bb/dqehozqV4tonEo4gKYG
-mp9pXRhihCr9knNm33SA5E6tcg8jZrjxE9Mg9nXItdOhFv5j8o/Nbpjyhv6OCuVt
-fMhvyIV8OVtc5YDtX1grqr2vDQgXbu7NXO4VF/Awce5JuPyO3ZZc/52ByHwhEA5o
-9/KEI2JPAgMBAAECggEAP+Ipq2Q4puz8wGBgu1LhMWp+9Nfcl1xI3YQ01VulBe0o
-+2h/g96McKcSBJaV7cw84ENB+kEWpK2amrsRiemhBmkjIvOAAv50Jp2I6u4E5Qbn
-PXUxo1Z8UrCgKmHd/hvUCafByuUwBzf5AvebHyOu3JlhnD302mSHtAW8u/pUHd3D
-sxJaw1zwQvmlD5ryM2IVYSji7NYCXF0H6V7HfyohTCrQFEWEAdqEDcFR1BUwbPCE
-raq7sAiEy+cBUnfV3IOEAffOZy0vSR90/WwERcwrzCdZmpWpTqtbcqtdBPqsSQzX
-shDvXd0e43+FSJzCtQsSQ8WzIrp3rgKJUDA1pJQW4QKBgQDJdTcB6qZz8r+4q9gc
-q1KAJyMy01Vio1yaqYzXr0C9Z5FW1GhL+4fwer2y9JyD45sb/lP4reFj9S193BNR
-C8cdxM5GrWEpzaQ0Dt1s8P1UbU8G6r4NqwI6ORF3CxXZKfXivQcgqBurJGrBdjIC
-NwqAzSkX5flBbhfTlJuUH87k3wKBgQDGgjzdIWXab7FZfdUzzrtEwNooBiSEFixm
-UAwP5sxL8VkM9wzAKPEVDDQBBoKIga9OESif4S9UUo4tu65AYfxF9Om26K4QrVj8
-HT/U+lfT7xFmPd/GINIbeTSmW0w7Ehpj8SbcQI4Sb2lVE562FlHh7QbHZd0/X/2J
-nbgT9MRAkQKBgQCVPAN3o/+SPOzRPFtnQXJoBJYKfIrv+twKpjbzP5vRsvrzO33X
-a4kUF5iXDKU0/lJUtl42BXjFt0Xvyit1CiiCYNv9d0pW0UMmXSyiGxNOi3rTQOlw
-7pFD2Cqb6NZSfMbtI+I3ytBUQzHiBlCdW3CoYVJjpbSzR37W+WsWm0mEOQKBgQCq
-ANObFYUjA1DBMZCrY7rhcL/kUw5myI6RuK/71k7UIwd+oP0cfHOq8N6AmlCkE1xM
-4UkHU1SzRFhbNkZPARuJ1etqJ+8afTqd/3axMQyShkVCaG8CQQ1vVegPKFUqqaBM
-QzRioC6L/zoYEEt16buKXvHVRpmqMszxVE9XV+HS4QKBgDvs5qloOowS5kcWInrj
-yecu5MJvFf2IZpMw7EiKV8VUPeKaiUlqgFj9d9cotUIMauXgBq6f5NBRg7Ike60t
-/JJrPtqXY+gdFLjxcKMUVYhomFlQYYg/RJZUBrtkyKBP68abopCYmb59r3ixeNNf
-qA1F36mmFtzdjSdtH/dTTecN
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCcNyX259MZFt+p
+KkIxEuh5/mE2do10uQqNjM7BgbCGNKidgW1h0kmjK42uCBEVGgkKdeklsT5mdLKz
+JuhKw6Gqfju9Ally098m2DFeWlcL93GuLsbHnc2sPTKRV31A7CSd8q3tSaTvrQP0
+MyRBqtXejTePSJ1D+ZAdUaWst72scfIXbs6kzvhPy6bb/dqehozqV4tonEo4gKYG
+mp9pXRhihCr9knNm33SA5E6tcg8jZrjxE9Mg9nXItdOhFv5j8o/Nbpjyhv6OCuVt
+fMhvyIV8OVtc5YDtX1grqr2vDQgXbu7NXO4VF/Awce5JuPyO3ZZc/52ByHwhEA5o
+9/KEI2JPAgMBAAECggEAP+Ipq2Q4puz8wGBgu1LhMWp+9Nfcl1xI3YQ01VulBe0o
++2h/g96McKcSBJaV7cw84ENB+kEWpK2amrsRiemhBmkjIvOAAv50Jp2I6u4E5Qbn
+PXUxo1Z8UrCgKmHd/hvUCafByuUwBzf5AvebHyOu3JlhnD302mSHtAW8u/pUHd3D
+sxJaw1zwQvmlD5ryM2IVYSji7NYCXF0H6V7HfyohTCrQFEWEAdqEDcFR1BUwbPCE
+raq7sAiEy+cBUnfV3IOEAffOZy0vSR90/WwERcwrzCdZmpWpTqtbcqtdBPqsSQzX
+shDvXd0e43+FSJzCtQsSQ8WzIrp3rgKJUDA1pJQW4QKBgQDJdTcB6qZz8r+4q9gc
+q1KAJyMy01Vio1yaqYzXr0C9Z5FW1GhL+4fwer2y9JyD45sb/lP4reFj9S193BNR
+C8cdxM5GrWEpzaQ0Dt1s8P1UbU8G6r4NqwI6ORF3CxXZKfXivQcgqBurJGrBdjIC
+NwqAzSkX5flBbhfTlJuUH87k3wKBgQDGgjzdIWXab7FZfdUzzrtEwNooBiSEFixm
+UAwP5sxL8VkM9wzAKPEVDDQBBoKIga9OESif4S9UUo4tu65AYfxF9Om26K4QrVj8
+HT/U+lfT7xFmPd/GINIbeTSmW0w7Ehpj8SbcQI4Sb2lVE562FlHh7QbHZd0/X/2J
+nbgT9MRAkQKBgQCVPAN3o/+SPOzRPFtnQXJoBJYKfIrv+twKpjbzP5vRsvrzO33X
+a4kUF5iXDKU0/lJUtl42BXjFt0Xvyit1CiiCYNv9d0pW0UMmXSyiGxNOi3rTQOlw
+7pFD2Cqb6NZSfMbtI+I3ytBUQzHiBlCdW3CoYVJjpbSzR37W+WsWm0mEOQKBgQCq
+ANObFYUjA1DBMZCrY7rhcL/kUw5myI6RuK/71k7UIwd+oP0cfHOq8N6AmlCkE1xM
+4UkHU1SzRFhbNkZPARuJ1etqJ+8afTqd/3axMQyShkVCaG8CQQ1vVegPKFUqqaBM
+QzRioC6L/zoYEEt16buKXvHVRpmqMszxVE9XV+HS4QKBgDvs5qloOowS5kcWInrj
+yecu5MJvFf2IZpMw7EiKV8VUPeKaiUlqgFj9d9cotUIMauXgBq6f5NBRg7Ike60t
+/JJrPtqXY+gdFLjxcKMUVYhomFlQYYg/RJZUBrtkyKBP68abopCYmb59r3ixeNNf
+qA1F36mmFtzdjSdtH/dTTecN
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/admin.key.pem b/tests/certificate-authority/client-keys/admin.key.pem
index ff0546f60d..0156fa6916 100644
--- a/tests/certificate-authority/client-keys/admin.key.pem
+++ b/tests/certificate-authority/client-keys/admin.key.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEpAIBAAKCAQEAnDcl9ufTGRbfqSpCMRLoef5hNnaNdLkKjYzOwYGwhjSonYFt
-YdJJoyuNrggRFRoJCnXpJbE+ZnSysyboSsOhqn47vQJZctPfJtgxXlpXC/dxri7G
-x53NrD0ykVd9QOwknfKt7Umk760D9DMkQarV3o03j0idQ/mQHVGlrLe9rHHyF27O
-pM74T8um2/3anoaM6leLaJxKOICmBpqfaV0YYoQq/ZJzZt90gOROrXIPI2a48RPT
-IPZ1yLXToRb+Y/KPzW6Y8ob+jgrlbXzIb8iFfDlbXOWA7V9YK6q9rw0IF27uzVzu
-FRfwMHHuSbj8jt2WXP+dgch8IRAOaPfyhCNiTwIDAQABAoIBAD/iKatkOKbs/MBg
-YLtS4TFqfvTX3JdcSN2ENNVbpQXtKPtof4PejHCnEgSWle3MPOBDQfpBFqStmpq7
-EYnpoQZpIyLzgAL+dCadiOruBOUG5z11MaNWfFKwoCph3f4b1AmnwcrlMAc3+QL3
-mx8jrtyZYZw99Npkh7QFvLv6VB3dw7MSWsNc8EL5pQ+a8jNiFWEo4uzWAlxdB+le
-x38qIUwq0BRFhAHahA3BUdQVMGzwhK2qu7AIhMvnAVJ31dyDhAH3zmctL0kfdP1s
-BEXMK8wnWZqVqU6rW3KrXQT6rEkM17IQ713dHuN/hUicwrULEkPFsyK6d64CiVAw
-NaSUFuECgYEAyXU3Aeqmc/K/uKvYHKtSgCcjMtNVYqNcmqmM169AvWeRVtRoS/uH
-8Hq9svScg+ObG/5T+K3hY/UtfdwTUQvHHcTORq1hKc2kNA7dbPD9VG1PBuq+DasC
-OjkRdwsV2Sn14r0HIKgbqyRqwXYyAjcKgM0pF+X5QW4X05SblB/O5N8CgYEAxoI8
-3SFl2m+xWX3VM867RMDaKAYkhBYsZlAMD+bMS/FZDPcMwCjxFQw0AQaCiIGvThEo
-n+EvVFKOLbuuQGH8RfTptuiuEK1Y/B0/1PpX0+8RZj3fxiDSG3k0pltMOxIaY/Em
-3ECOEm9pVROethZR4e0Gx2XdP1/9iZ24E/TEQJECgYEAlTwDd6P/kjzs0TxbZ0Fy
-aASWCnyK7/rcCqY28z+b0bL68zt912uJFBeYlwylNP5SVLZeNgV4xbdF78ordQoo
-gmDb/XdKVtFDJl0sohsTTot600DpcO6RQ9gqm+jWUnzG7SPiN8rQVEMx4gZQnVtw
-qGFSY6W0s0d+1vlrFptJhDkCgYEAqgDTmxWFIwNQwTGQq2O64XC/5FMOZsiOkbiv
-+9ZO1CMHfqD9HHxzqvDegJpQpBNcTOFJB1NUs0RYWzZGTwEbidXraifvGn06nf92
-sTEMkoZFQmhvAkENb1XoDyhVKqmgTEM0YqAui/86GBBLdem7il7x1UaZqjLM8VRP
-V1fh0uECgYA77OapaDqMEuZHFiJ648nnLuTCbxX9iGaTMOxIilfFVD3imolJaoBY
-/XfXKLVCDGrl4Aaun+TQUYOyJHutLfySaz7al2PoHRS48XCjFFWIaJhZUGGIP0SW
-VAa7ZMigT+vGm6KQmJm+fa94sXjTX6gNRd+pphbc3Y0nbR/3U03nDQ==
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAnDcl9ufTGRbfqSpCMRLoef5hNnaNdLkKjYzOwYGwhjSonYFt
+YdJJoyuNrggRFRoJCnXpJbE+ZnSysyboSsOhqn47vQJZctPfJtgxXlpXC/dxri7G
+x53NrD0ykVd9QOwknfKt7Umk760D9DMkQarV3o03j0idQ/mQHVGlrLe9rHHyF27O
+pM74T8um2/3anoaM6leLaJxKOICmBpqfaV0YYoQq/ZJzZt90gOROrXIPI2a48RPT
+IPZ1yLXToRb+Y/KPzW6Y8ob+jgrlbXzIb8iFfDlbXOWA7V9YK6q9rw0IF27uzVzu
+FRfwMHHuSbj8jt2WXP+dgch8IRAOaPfyhCNiTwIDAQABAoIBAD/iKatkOKbs/MBg
+YLtS4TFqfvTX3JdcSN2ENNVbpQXtKPtof4PejHCnEgSWle3MPOBDQfpBFqStmpq7
+EYnpoQZpIyLzgAL+dCadiOruBOUG5z11MaNWfFKwoCph3f4b1AmnwcrlMAc3+QL3
+mx8jrtyZYZw99Npkh7QFvLv6VB3dw7MSWsNc8EL5pQ+a8jNiFWEo4uzWAlxdB+le
+x38qIUwq0BRFhAHahA3BUdQVMGzwhK2qu7AIhMvnAVJ31dyDhAH3zmctL0kfdP1s
+BEXMK8wnWZqVqU6rW3KrXQT6rEkM17IQ713dHuN/hUicwrULEkPFsyK6d64CiVAw
+NaSUFuECgYEAyXU3Aeqmc/K/uKvYHKtSgCcjMtNVYqNcmqmM169AvWeRVtRoS/uH
+8Hq9svScg+ObG/5T+K3hY/UtfdwTUQvHHcTORq1hKc2kNA7dbPD9VG1PBuq+DasC
+OjkRdwsV2Sn14r0HIKgbqyRqwXYyAjcKgM0pF+X5QW4X05SblB/O5N8CgYEAxoI8
+3SFl2m+xWX3VM867RMDaKAYkhBYsZlAMD+bMS/FZDPcMwCjxFQw0AQaCiIGvThEo
+n+EvVFKOLbuuQGH8RfTptuiuEK1Y/B0/1PpX0+8RZj3fxiDSG3k0pltMOxIaY/Em
+3ECOEm9pVROethZR4e0Gx2XdP1/9iZ24E/TEQJECgYEAlTwDd6P/kjzs0TxbZ0Fy
+aASWCnyK7/rcCqY28z+b0bL68zt912uJFBeYlwylNP5SVLZeNgV4xbdF78ordQoo
+gmDb/XdKVtFDJl0sohsTTot600DpcO6RQ9gqm+jWUnzG7SPiN8rQVEMx4gZQnVtw
+qGFSY6W0s0d+1vlrFptJhDkCgYEAqgDTmxWFIwNQwTGQq2O64XC/5FMOZsiOkbiv
++9ZO1CMHfqD9HHxzqvDegJpQpBNcTOFJB1NUs0RYWzZGTwEbidXraifvGn06nf92
+sTEMkoZFQmhvAkENb1XoDyhVKqmgTEM0YqAui/86GBBLdem7il7x1UaZqjLM8VRP
+V1fh0uECgYA77OapaDqMEuZHFiJ648nnLuTCbxX9iGaTMOxIilfFVD3imolJaoBY
+/XfXKLVCDGrl4Aaun+TQUYOyJHutLfySaz7al2PoHRS48XCjFFWIaJhZUGGIP0SW
+VAa7ZMigT+vGm6KQmJm+fa94sXjTX6gNRd+pphbc3Y0nbR/3U03nDQ==
+-----END RSA PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/proxy.cert.pem b/tests/certificate-authority/client-keys/proxy.cert.pem
index 6c2f4295c9..caa2051ba5 100644
--- a/tests/certificate-authority/client-keys/proxy.cert.pem
+++ b/tests/certificate-authority/client-keys/proxy.cert.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEZTCCAk2gAwIBAgICEAMwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyNTEzNTYwNFoYDzIyOTIwNDA5MTM1NjA0WjAQMQ4wDAYDVQQD
-DAVwcm94eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMieX78Yj8OW
-eBHAneRaCCoO8Qrpj8zGo7h9lCdmi1lBDh1uR2sDbotiHGfJzQn836WcYmyeAvfn
-qvgr9HCXmXdLgmJ3GT/LVu5GEm6msSDiZQPr9so5lQVioisK4UwJROQsE/J52cyR
-9o3H6M4FKb6QpoobKa62fSfTumwwulaYaDJuRRGoGIkcRuUQ59EWAaDkD3IcDpAn
-9mTbnE4Iz+JxSrsZ5DJ3X/m/AqyLWtj6GAfyK9a1dhNdlf2x4JZT1QNtojiBXt95
-OIZyRBNbHMFniq5gel6wdBkmJWutfcTct7wKa2LCxLpKoDIc1HWoL3+RUzOKxYIP
-0qXEQ3bmONkCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
-oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
-ZmljYXRlMB0GA1UdDgQWBBSgsgfmDbXEkrrpHUC9GnDDjxaKizAfBgNVHSMEGDAW
-gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
-FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQB+uZ2OWR+G
-sRqYHEeVqUI8G2p8Np8eC/onGpBL8Gj9SGxIQcIPtqHPUlCe9fd/96JOptOGRYEB
-BmUCaCmQ4IgMW6e6fArka5IB4XXIgHFXyQ6ImTvjDavzlVw06zn9S4dLwVzsRBg+
-GS9svtq23W+f5rEN5N+7LhtcbclfiG4VCCqDG5VhkzEok+SRamDI8rDRZtodMw0O
-/+L+xaaQPUPjX8KUlKn4uVpCDbxUzHonlCPzbkHHm5su0D4ysjJIy3/y3yow6JE/
-02L7PZkmkmw3/V+84T3X8/GD15sVUv/3v1gXEBxYwAs+RNTJ0APvMEMSvCq0AMfF
-bPMZBuAGNBG7lv7TovzHgGFKXT7du5OFF/qjAsEffhbo224CB96fgwvvndwHHBFh
-J06BvHZG1i9dDVhUKoB1owkWrE4RZv2ZKEtZYgizzSmzZRHtARo0t1Byc5djx1tX
-TkJOHshNqJZOY1ER0DPaVQgKI+PRTbEdj/xPGRX3ebSqDmilAfPXshqgElfch6Yl
-f2V58TyCnjXOibvkG9D5OyCdWLEECumOZgYar0KZgNfrvTOi1OKXnX1fsbh29fWA
-ICZRcdmjkz79zQXY2SuzCWlskuXPKAmW1AMqs+l6ormmKfzIUx3Yriy4LqIIYY1v
-uQD5vghZmd9HUg2KaXfSGD9stGCD8KhntA==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEZTCCAk2gAwIBAgICEAMwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyNTEzNTYwNFoYDzIyOTIwNDA5MTM1NjA0WjAQMQ4wDAYDVQQD
+DAVwcm94eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMieX78Yj8OW
+eBHAneRaCCoO8Qrpj8zGo7h9lCdmi1lBDh1uR2sDbotiHGfJzQn836WcYmyeAvfn
+qvgr9HCXmXdLgmJ3GT/LVu5GEm6msSDiZQPr9so5lQVioisK4UwJROQsE/J52cyR
+9o3H6M4FKb6QpoobKa62fSfTumwwulaYaDJuRRGoGIkcRuUQ59EWAaDkD3IcDpAn
+9mTbnE4Iz+JxSrsZ5DJ3X/m/AqyLWtj6GAfyK9a1dhNdlf2x4JZT1QNtojiBXt95
+OIZyRBNbHMFniq5gel6wdBkmJWutfcTct7wKa2LCxLpKoDIc1HWoL3+RUzOKxYIP
+0qXEQ3bmONkCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
+oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
+ZmljYXRlMB0GA1UdDgQWBBSgsgfmDbXEkrrpHUC9GnDDjxaKizAfBgNVHSMEGDAW
+gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
+FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQB+uZ2OWR+G
+sRqYHEeVqUI8G2p8Np8eC/onGpBL8Gj9SGxIQcIPtqHPUlCe9fd/96JOptOGRYEB
+BmUCaCmQ4IgMW6e6fArka5IB4XXIgHFXyQ6ImTvjDavzlVw06zn9S4dLwVzsRBg+
+GS9svtq23W+f5rEN5N+7LhtcbclfiG4VCCqDG5VhkzEok+SRamDI8rDRZtodMw0O
+/+L+xaaQPUPjX8KUlKn4uVpCDbxUzHonlCPzbkHHm5su0D4ysjJIy3/y3yow6JE/
+02L7PZkmkmw3/V+84T3X8/GD15sVUv/3v1gXEBxYwAs+RNTJ0APvMEMSvCq0AMfF
+bPMZBuAGNBG7lv7TovzHgGFKXT7du5OFF/qjAsEffhbo224CB96fgwvvndwHHBFh
+J06BvHZG1i9dDVhUKoB1owkWrE4RZv2ZKEtZYgizzSmzZRHtARo0t1Byc5djx1tX
+TkJOHshNqJZOY1ER0DPaVQgKI+PRTbEdj/xPGRX3ebSqDmilAfPXshqgElfch6Yl
+f2V58TyCnjXOibvkG9D5OyCdWLEECumOZgYar0KZgNfrvTOi1OKXnX1fsbh29fWA
+ICZRcdmjkz79zQXY2SuzCWlskuXPKAmW1AMqs+l6ormmKfzIUx3Yriy4LqIIYY1v
+uQD5vghZmd9HUg2KaXfSGD9stGCD8KhntA==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/client-keys/proxy.csr.pem b/tests/certificate-authority/client-keys/proxy.csr.pem
index aad01801c4..4f87422a5a 100644
--- a/tests/certificate-authority/client-keys/proxy.csr.pem
+++ b/tests/certificate-authority/client-keys/proxy.csr.pem
@@ -1,15 +1,15 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICVTCCAT0CAQAwEDEOMAwGA1UEAwwFcHJveHkwggEiMA0GCSqGSIb3DQEBAQUA
-A4IBDwAwggEKAoIBAQDInl+/GI/DlngRwJ3kWggqDvEK6Y/MxqO4fZQnZotZQQ4d
-bkdrA26LYhxnyc0J/N+lnGJsngL356r4K/Rwl5l3S4Jidxk/y1buRhJuprEg4mUD
-6/bKOZUFYqIrCuFMCUTkLBPyednMkfaNx+jOBSm+kKaKGymutn0n07psMLpWmGgy
-bkURqBiJHEblEOfRFgGg5A9yHA6QJ/Zk25xOCM/icUq7GeQyd1/5vwKsi1rY+hgH
-8ivWtXYTXZX9seCWU9UDbaI4gV7feTiGckQTWxzBZ4quYHpesHQZJiVrrX3E3Le8
-CmtiwsS6SqAyHNR1qC9/kVMzisWCD9KlxEN25jjZAgMBAAGgADANBgkqhkiG9w0B
-AQsFAAOCAQEAkW2koDlfwjf2nfq7pPWn9pePa3asV/1vURsHftMzUgvfvuM5X+Ss
-VyRZrbbcBIauRtumsB1r/vJDe0JzpQDVm3k/la9Muh6FZwiEjzl13JU1grdqBibs
-Ckd09R80VeJxQlYgIUA8nhURZQIDUVA6SQnQ8tw7lfCnPkM/iCCV3R4Zi0nD28SI
-HcFQ5pbpCiBLnQuGwgCMtq0s4iZfsBth4WvdSFmw+zoBG3XdrUBIidCXL1sIyc1v
-w4doOspzsiQvDN25nS5c1BwqYDeLhRSUJPm1rOWSL2Q7w3PHH/PqiRphRgI4ADbz
-96rhQoWIs4PoKgPpNU22CeEcEcMU9ws3Ow==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICVTCCAT0CAQAwEDEOMAwGA1UEAwwFcHJveHkwggEiMA0GCSqGSIb3DQEBAQUA
+A4IBDwAwggEKAoIBAQDInl+/GI/DlngRwJ3kWggqDvEK6Y/MxqO4fZQnZotZQQ4d
+bkdrA26LYhxnyc0J/N+lnGJsngL356r4K/Rwl5l3S4Jidxk/y1buRhJuprEg4mUD
+6/bKOZUFYqIrCuFMCUTkLBPyednMkfaNx+jOBSm+kKaKGymutn0n07psMLpWmGgy
+bkURqBiJHEblEOfRFgGg5A9yHA6QJ/Zk25xOCM/icUq7GeQyd1/5vwKsi1rY+hgH
+8ivWtXYTXZX9seCWU9UDbaI4gV7feTiGckQTWxzBZ4quYHpesHQZJiVrrX3E3Le8
+CmtiwsS6SqAyHNR1qC9/kVMzisWCD9KlxEN25jjZAgMBAAGgADANBgkqhkiG9w0B
+AQsFAAOCAQEAkW2koDlfwjf2nfq7pPWn9pePa3asV/1vURsHftMzUgvfvuM5X+Ss
+VyRZrbbcBIauRtumsB1r/vJDe0JzpQDVm3k/la9Muh6FZwiEjzl13JU1grdqBibs
+Ckd09R80VeJxQlYgIUA8nhURZQIDUVA6SQnQ8tw7lfCnPkM/iCCV3R4Zi0nD28SI
+HcFQ5pbpCiBLnQuGwgCMtq0s4iZfsBth4WvdSFmw+zoBG3XdrUBIidCXL1sIyc1v
+w4doOspzsiQvDN25nS5c1BwqYDeLhRSUJPm1rOWSL2Q7w3PHH/PqiRphRgI4ADbz
+96rhQoWIs4PoKgPpNU22CeEcEcMU9ws3Ow==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/client-keys/proxy.key-pk8.pem b/tests/certificate-authority/client-keys/proxy.key-pk8.pem
index 70e0107f27..034809fa26 100644
--- a/tests/certificate-authority/client-keys/proxy.key-pk8.pem
+++ b/tests/certificate-authority/client-keys/proxy.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDInl+/GI/DlngR
-wJ3kWggqDvEK6Y/MxqO4fZQnZotZQQ4dbkdrA26LYhxnyc0J/N+lnGJsngL356r4
-K/Rwl5l3S4Jidxk/y1buRhJuprEg4mUD6/bKOZUFYqIrCuFMCUTkLBPyednMkfaN
-x+jOBSm+kKaKGymutn0n07psMLpWmGgybkURqBiJHEblEOfRFgGg5A9yHA6QJ/Zk
-25xOCM/icUq7GeQyd1/5vwKsi1rY+hgH8ivWtXYTXZX9seCWU9UDbaI4gV7feTiG
-ckQTWxzBZ4quYHpesHQZJiVrrX3E3Le8CmtiwsS6SqAyHNR1qC9/kVMzisWCD9Kl
-xEN25jjZAgMBAAECggEAJJyCbKVW1yLGlrbIGbw0cTh41Lz6+SvnBOwl9WrJU2iD
-4usVLXpa2iT1ehthx8jWJ6r6a0gK0qL8mH2tBj8kSpkFGmMRwIqjOqifBIJ3IMEw
-Hh8Z0p3fjDQL1D8QDohCgkFpAn8qOCMLE6S/35khnR1Yxytd1/yFqpcBFm1uFA85
-dYisjPqWm/IZIU5rH0zgKAIhtvl9abnoi93443EHsKpRAW1gwRXx9Aak7TV768bZ
-tELBsaTnXnNzamDiaimmxEOlqR9O0W8JE/31KFL26JcVmsTRG7sMpoUxCEMjOuGZ
-J30bXFZUW6NrDpFsQ7uTqD6TNn2971N8KFCLnC/JYQKBgQDo82axC7L7n7BYTu18
-dupeT7n5dTBD/I3l0KtT05xiZA8GZr2i+pt+/aWzCzK4/Ee4jb4/o8CRQRB5v5mo
-c9lc+BaoAIQiwiw+aufT+UojrcijrOMEL5Zk3zdZ2rcEoAsVvqtejNnwLCGI9Rnl
-gp7n9oRhwDIv9Fu09snUougE3wKBgQDceAGKUB8pGd3eEya/0jU9J60LsKbcJSsN
-4v1S5LiPtHOyhr0g4x/LibMP2PJhG3tJ1bgpaGmn9du2D20M6ukRhIYyn/7G+N+A
-oqryyvO1MMYnhc4IEQvWrzDnBM0hV2bdjp4s/1ASVHVRwk8+orqxysIJ1D75nnRX
-Tyfl6HgBRwKBgQCfVlWIhiMPv6OkU6BXgRNAHTJs8f5okmgQqNF3jgequRwZ2c6e
-muIfU6myNNel9lGsZ6+Y4g4GjMWTMT4OHeewkrUUhv3atIwEyaT2tc5DZ0wUwF2r
-cE1jg9bdbB/BVyMd5YRcMOWlRNpPTq8+8EB3E4RrREZPzMmplyBohGFFawKBgGjc
-P0dM8nU3E1rj2wNTdPUAYQL1Y3fDyeWR+BEsLkhTeNAJ2/y/akkB1oQMGMRtMMee
-ejhfrBkyC+1dCu4g8PffA4EirihvCMcDF7HhK+cbKrRzpNobWXkj3GuU0ggwrQFm
-Kv+V87y0JRTdCZnuBkQ3/vBz3fwWDJnWUVC9sA5TAoGBAN4t2gJCZax5yInUgyWi
-Tgumb2qVWsGBBLMTKIsrkK/KphzgAhHcVhDCybA79TmIM2FfIlpf6TE7Mv4NI055
-ZJzHX+GMT5Czy2Ku9MJD3PLTFN5MjYb6g92fKViLDMI6fwzTHB8xPJ7Ob9bV2srS
-ZlmKNXTkZFk3/orK4WdCZufz
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDInl+/GI/DlngR
+wJ3kWggqDvEK6Y/MxqO4fZQnZotZQQ4dbkdrA26LYhxnyc0J/N+lnGJsngL356r4
+K/Rwl5l3S4Jidxk/y1buRhJuprEg4mUD6/bKOZUFYqIrCuFMCUTkLBPyednMkfaN
+x+jOBSm+kKaKGymutn0n07psMLpWmGgybkURqBiJHEblEOfRFgGg5A9yHA6QJ/Zk
+25xOCM/icUq7GeQyd1/5vwKsi1rY+hgH8ivWtXYTXZX9seCWU9UDbaI4gV7feTiG
+ckQTWxzBZ4quYHpesHQZJiVrrX3E3Le8CmtiwsS6SqAyHNR1qC9/kVMzisWCD9Kl
+xEN25jjZAgMBAAECggEAJJyCbKVW1yLGlrbIGbw0cTh41Lz6+SvnBOwl9WrJU2iD
+4usVLXpa2iT1ehthx8jWJ6r6a0gK0qL8mH2tBj8kSpkFGmMRwIqjOqifBIJ3IMEw
+Hh8Z0p3fjDQL1D8QDohCgkFpAn8qOCMLE6S/35khnR1Yxytd1/yFqpcBFm1uFA85
+dYisjPqWm/IZIU5rH0zgKAIhtvl9abnoi93443EHsKpRAW1gwRXx9Aak7TV768bZ
+tELBsaTnXnNzamDiaimmxEOlqR9O0W8JE/31KFL26JcVmsTRG7sMpoUxCEMjOuGZ
+J30bXFZUW6NrDpFsQ7uTqD6TNn2971N8KFCLnC/JYQKBgQDo82axC7L7n7BYTu18
+dupeT7n5dTBD/I3l0KtT05xiZA8GZr2i+pt+/aWzCzK4/Ee4jb4/o8CRQRB5v5mo
+c9lc+BaoAIQiwiw+aufT+UojrcijrOMEL5Zk3zdZ2rcEoAsVvqtejNnwLCGI9Rnl
+gp7n9oRhwDIv9Fu09snUougE3wKBgQDceAGKUB8pGd3eEya/0jU9J60LsKbcJSsN
+4v1S5LiPtHOyhr0g4x/LibMP2PJhG3tJ1bgpaGmn9du2D20M6ukRhIYyn/7G+N+A
+oqryyvO1MMYnhc4IEQvWrzDnBM0hV2bdjp4s/1ASVHVRwk8+orqxysIJ1D75nnRX
+Tyfl6HgBRwKBgQCfVlWIhiMPv6OkU6BXgRNAHTJs8f5okmgQqNF3jgequRwZ2c6e
+muIfU6myNNel9lGsZ6+Y4g4GjMWTMT4OHeewkrUUhv3atIwEyaT2tc5DZ0wUwF2r
+cE1jg9bdbB/BVyMd5YRcMOWlRNpPTq8+8EB3E4RrREZPzMmplyBohGFFawKBgGjc
+P0dM8nU3E1rj2wNTdPUAYQL1Y3fDyeWR+BEsLkhTeNAJ2/y/akkB1oQMGMRtMMee
+ejhfrBkyC+1dCu4g8PffA4EirihvCMcDF7HhK+cbKrRzpNobWXkj3GuU0ggwrQFm
+Kv+V87y0JRTdCZnuBkQ3/vBz3fwWDJnWUVC9sA5TAoGBAN4t2gJCZax5yInUgyWi
+Tgumb2qVWsGBBLMTKIsrkK/KphzgAhHcVhDCybA79TmIM2FfIlpf6TE7Mv4NI055
+ZJzHX+GMT5Czy2Ku9MJD3PLTFN5MjYb6g92fKViLDMI6fwzTHB8xPJ7Ob9bV2srS
+ZlmKNXTkZFk3/orK4WdCZufz
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/proxy.key.pem b/tests/certificate-authority/client-keys/proxy.key.pem
index 1f73f970eb..6180f8c2c7 100644
--- a/tests/certificate-authority/client-keys/proxy.key.pem
+++ b/tests/certificate-authority/client-keys/proxy.key.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEpAIBAAKCAQEAyJ5fvxiPw5Z4EcCd5FoIKg7xCumPzMajuH2UJ2aLWUEOHW5H
-awNui2IcZ8nNCfzfpZxibJ4C9+eq+Cv0cJeZd0uCYncZP8tW7kYSbqaxIOJlA+v2
-yjmVBWKiKwrhTAlE5CwT8nnZzJH2jcfozgUpvpCmihsprrZ9J9O6bDC6VphoMm5F
-EagYiRxG5RDn0RYBoOQPchwOkCf2ZNucTgjP4nFKuxnkMndf+b8CrIta2PoYB/Ir
-1rV2E12V/bHgllPVA22iOIFe33k4hnJEE1scwWeKrmB6XrB0GSYla619xNy3vApr
-YsLEukqgMhzUdagvf5FTM4rFgg/SpcRDduY42QIDAQABAoIBACScgmylVtcixpa2
-yBm8NHE4eNS8+vkr5wTsJfVqyVNog+LrFS16Wtok9XobYcfI1ieq+mtICtKi/Jh9
-rQY/JEqZBRpjEcCKozqonwSCdyDBMB4fGdKd34w0C9Q/EA6IQoJBaQJ/KjgjCxOk
-v9+ZIZ0dWMcrXdf8haqXARZtbhQPOXWIrIz6lpvyGSFOax9M4CgCIbb5fWm56Ivd
-+ONxB7CqUQFtYMEV8fQGpO01e+vG2bRCwbGk515zc2pg4moppsRDpakfTtFvCRP9
-9ShS9uiXFZrE0Ru7DKaFMQhDIzrhmSd9G1xWVFujaw6RbEO7k6g+kzZ9ve9TfChQ
-i5wvyWECgYEA6PNmsQuy+5+wWE7tfHbqXk+5+XUwQ/yN5dCrU9OcYmQPBma9ovqb
-fv2lswsyuPxHuI2+P6PAkUEQeb+ZqHPZXPgWqACEIsIsPmrn0/lKI63Io6zjBC+W
-ZN83Wdq3BKALFb6rXozZ8CwhiPUZ5YKe5/aEYcAyL/RbtPbJ1KLoBN8CgYEA3HgB
-ilAfKRnd3hMmv9I1PSetC7Cm3CUrDeL9UuS4j7Rzsoa9IOMfy4mzD9jyYRt7SdW4
-KWhpp/Xbtg9tDOrpEYSGMp/+xvjfgKKq8srztTDGJ4XOCBEL1q8w5wTNIVdm3Y6e
-LP9QElR1UcJPPqK6scrCCdQ++Z50V08n5eh4AUcCgYEAn1ZViIYjD7+jpFOgV4ET
-QB0ybPH+aJJoEKjRd44HqrkcGdnOnpriH1OpsjTXpfZRrGevmOIOBozFkzE+Dh3n
-sJK1FIb92rSMBMmk9rXOQ2dMFMBdq3BNY4PW3WwfwVcjHeWEXDDlpUTaT06vPvBA
-dxOEa0RGT8zJqZcgaIRhRWsCgYBo3D9HTPJ1NxNa49sDU3T1AGEC9WN3w8nlkfgR
-LC5IU3jQCdv8v2pJAdaEDBjEbTDHnno4X6wZMgvtXQruIPD33wOBIq4obwjHAxex
-4SvnGyq0c6TaG1l5I9xrlNIIMK0BZir/lfO8tCUU3QmZ7gZEN/7wc938FgyZ1lFQ
-vbAOUwKBgQDeLdoCQmWseciJ1IMlok4Lpm9qlVrBgQSzEyiLK5CvyqYc4AIR3FYQ
-wsmwO/U5iDNhXyJaX+kxOzL+DSNOeWScx1/hjE+Qs8tirvTCQ9zy0xTeTI2G+oPd
-nylYiwzCOn8M0xwfMTyezm/W1drK0mZZijV05GRZN/6KyuFnQmbn8w==
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEAyJ5fvxiPw5Z4EcCd5FoIKg7xCumPzMajuH2UJ2aLWUEOHW5H
+awNui2IcZ8nNCfzfpZxibJ4C9+eq+Cv0cJeZd0uCYncZP8tW7kYSbqaxIOJlA+v2
+yjmVBWKiKwrhTAlE5CwT8nnZzJH2jcfozgUpvpCmihsprrZ9J9O6bDC6VphoMm5F
+EagYiRxG5RDn0RYBoOQPchwOkCf2ZNucTgjP4nFKuxnkMndf+b8CrIta2PoYB/Ir
+1rV2E12V/bHgllPVA22iOIFe33k4hnJEE1scwWeKrmB6XrB0GSYla619xNy3vApr
+YsLEukqgMhzUdagvf5FTM4rFgg/SpcRDduY42QIDAQABAoIBACScgmylVtcixpa2
+yBm8NHE4eNS8+vkr5wTsJfVqyVNog+LrFS16Wtok9XobYcfI1ieq+mtICtKi/Jh9
+rQY/JEqZBRpjEcCKozqonwSCdyDBMB4fGdKd34w0C9Q/EA6IQoJBaQJ/KjgjCxOk
+v9+ZIZ0dWMcrXdf8haqXARZtbhQPOXWIrIz6lpvyGSFOax9M4CgCIbb5fWm56Ivd
++ONxB7CqUQFtYMEV8fQGpO01e+vG2bRCwbGk515zc2pg4moppsRDpakfTtFvCRP9
+9ShS9uiXFZrE0Ru7DKaFMQhDIzrhmSd9G1xWVFujaw6RbEO7k6g+kzZ9ve9TfChQ
+i5wvyWECgYEA6PNmsQuy+5+wWE7tfHbqXk+5+XUwQ/yN5dCrU9OcYmQPBma9ovqb
+fv2lswsyuPxHuI2+P6PAkUEQeb+ZqHPZXPgWqACEIsIsPmrn0/lKI63Io6zjBC+W
+ZN83Wdq3BKALFb6rXozZ8CwhiPUZ5YKe5/aEYcAyL/RbtPbJ1KLoBN8CgYEA3HgB
+ilAfKRnd3hMmv9I1PSetC7Cm3CUrDeL9UuS4j7Rzsoa9IOMfy4mzD9jyYRt7SdW4
+KWhpp/Xbtg9tDOrpEYSGMp/+xvjfgKKq8srztTDGJ4XOCBEL1q8w5wTNIVdm3Y6e
+LP9QElR1UcJPPqK6scrCCdQ++Z50V08n5eh4AUcCgYEAn1ZViIYjD7+jpFOgV4ET
+QB0ybPH+aJJoEKjRd44HqrkcGdnOnpriH1OpsjTXpfZRrGevmOIOBozFkzE+Dh3n
+sJK1FIb92rSMBMmk9rXOQ2dMFMBdq3BNY4PW3WwfwVcjHeWEXDDlpUTaT06vPvBA
+dxOEa0RGT8zJqZcgaIRhRWsCgYBo3D9HTPJ1NxNa49sDU3T1AGEC9WN3w8nlkfgR
+LC5IU3jQCdv8v2pJAdaEDBjEbTDHnno4X6wZMgvtXQruIPD33wOBIq4obwjHAxex
+4SvnGyq0c6TaG1l5I9xrlNIIMK0BZir/lfO8tCUU3QmZ7gZEN/7wc938FgyZ1lFQ
+vbAOUwKBgQDeLdoCQmWseciJ1IMlok4Lpm9qlVrBgQSzEyiLK5CvyqYc4AIR3FYQ
+wsmwO/U5iDNhXyJaX+kxOzL+DSNOeWScx1/hjE+Qs8tirvTCQ9zy0xTeTI2G+oPd
+nylYiwzCOn8M0xwfMTyezm/W1drK0mZZijV05GRZN/6KyuFnQmbn8w==
+-----END RSA PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/randouser.cert.pem b/tests/certificate-authority/client-keys/randouser.cert.pem
index 01b69eacc3..8dd13cbab1 100644
--- a/tests/certificate-authority/client-keys/randouser.cert.pem
+++ b/tests/certificate-authority/client-keys/randouser.cert.pem
@@ -1,19 +1,19 @@
------BEGIN CERTIFICATE-----
-MIIDCDCCAfCgAwIBAgIJAMPzPm3QygzRMA0GCSqGSIb3DQEBCwUAMBAxDjAMBgNV
-BAMMBXJhbmRvMCAXDTE4MDYyNzA5MDA0OVoYDzIyOTIwNDExMDkwMDQ5WjAQMQ4w
-DAYDVQQDDAVyYW5kbzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALKR
-nN1y/aBrhbNM6kDfBmWTaKFuANEZ+VST++AVImssN+FyOL2ukxuT74JW0b9g9scl
-aTYzUBbKuTrMIf77RPIJY6R5E6JWn12UhDpnLa9eYGOkyPyoSp5hdyJj3spElWkl
-eGRY8g9zsWJO6QDpTL4g2VAtWTjFIVI3l3enNgNp3hJnJkdvxyBuRN7Szg9hGPmQ
-Tp9rsKkZQD4SJ9/WMAlqSqeB6rSn20rydMJCnI92TT8hlv1wZcVXSVrJypzZb27t
-aAi5o9GEtag3aXalR8zL9DiUk64338A0fYgf2/GSjomZehcg17h8tElYMFV6hJqS
-95gM18nfwldttbihjKMCAwEAAaNjMGEwHQYDVR0OBBYEFAzmiWmqQIB10sSoSAzb
-claQvBPtMB8GA1UdIwQYMBaAFAzmiWmqQIB10sSoSAzbclaQvBPtMA8GA1UdEwEB
-/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IBAQCN7nup
-rGd4sVuP2vvcRbhGo1JCWDS4Uwe7nbSR/4QTAlyUYK8KIwTvfxeEeO4yBGmiDzOE
-+W2y0i22qVnShNCBZ50Evm+FkIEcwlnLtAJt6zIrE4cWdqW1a6CMp9MJkONjACOx
-3Y560SlqQuoKa41PtXUnk8tFT8Asz7b3NtEfmrBlZJpSSM5exBOCH/Enwzac890u
-zJuweTz4aO8aefunkPMKlBPliJ6EkEYclrjJqxi+4VrEMtAIRxwKXPvnHnXESaF7
-yUE4qrjQa4B+Bn1DWqfLcHJCVDxqYrXiEAN/YtX0UOqxZvGd49eNIs2vQkET0+55
-J3hW25OLSnPjAO/j
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDCDCCAfCgAwIBAgIJAMPzPm3QygzRMA0GCSqGSIb3DQEBCwUAMBAxDjAMBgNV
+BAMMBXJhbmRvMCAXDTE4MDYyNzA5MDA0OVoYDzIyOTIwNDExMDkwMDQ5WjAQMQ4w
+DAYDVQQDDAVyYW5kbzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALKR
+nN1y/aBrhbNM6kDfBmWTaKFuANEZ+VST++AVImssN+FyOL2ukxuT74JW0b9g9scl
+aTYzUBbKuTrMIf77RPIJY6R5E6JWn12UhDpnLa9eYGOkyPyoSp5hdyJj3spElWkl
+eGRY8g9zsWJO6QDpTL4g2VAtWTjFIVI3l3enNgNp3hJnJkdvxyBuRN7Szg9hGPmQ
+Tp9rsKkZQD4SJ9/WMAlqSqeB6rSn20rydMJCnI92TT8hlv1wZcVXSVrJypzZb27t
+aAi5o9GEtag3aXalR8zL9DiUk64338A0fYgf2/GSjomZehcg17h8tElYMFV6hJqS
+95gM18nfwldttbihjKMCAwEAAaNjMGEwHQYDVR0OBBYEFAzmiWmqQIB10sSoSAzb
+claQvBPtMB8GA1UdIwQYMBaAFAzmiWmqQIB10sSoSAzbclaQvBPtMA8GA1UdEwEB
+/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IBAQCN7nup
+rGd4sVuP2vvcRbhGo1JCWDS4Uwe7nbSR/4QTAlyUYK8KIwTvfxeEeO4yBGmiDzOE
++W2y0i22qVnShNCBZ50Evm+FkIEcwlnLtAJt6zIrE4cWdqW1a6CMp9MJkONjACOx
+3Y560SlqQuoKa41PtXUnk8tFT8Asz7b3NtEfmrBlZJpSSM5exBOCH/Enwzac890u
+zJuweTz4aO8aefunkPMKlBPliJ6EkEYclrjJqxi+4VrEMtAIRxwKXPvnHnXESaF7
+yUE4qrjQa4B+Bn1DWqfLcHJCVDxqYrXiEAN/YtX0UOqxZvGd49eNIs2vQkET0+55
+J3hW25OLSnPjAO/j
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/client-keys/randouser.key-pk8.pem b/tests/certificate-authority/client-keys/randouser.key-pk8.pem
index 86a7fa387a..ea73ad4655 100644
--- a/tests/certificate-authority/client-keys/randouser.key-pk8.pem
+++ b/tests/certificate-authority/client-keys/randouser.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCykZzdcv2ga4Wz
-TOpA3wZlk2ihbgDRGflUk/vgFSJrLDfhcji9rpMbk++CVtG/YPbHJWk2M1AWyrk6
-zCH++0TyCWOkeROiVp9dlIQ6Zy2vXmBjpMj8qEqeYXciY97KRJVpJXhkWPIPc7Fi
-TukA6Uy+INlQLVk4xSFSN5d3pzYDad4SZyZHb8cgbkTe0s4PYRj5kE6fa7CpGUA+
-Eiff1jAJakqngeq0p9tK8nTCQpyPdk0/IZb9cGXFV0laycqc2W9u7WgIuaPRhLWo
-N2l2pUfMy/Q4lJOuN9/ANH2IH9vxko6JmXoXINe4fLRJWDBVeoSakveYDNfJ38JX
-bbW4oYyjAgMBAAECggEAf8cSqKQQOSq3kYYIWkM9IJJK3LkKfJZJg+wg4Eg/SNFr
-azeAwrqZKbLCQFI/5OJNtFNg5hfxx11pDlnkOcEzpL5zPs4k7pVtlFkiBWivmD3A
-W40fBSynuI2l4kX0tmg9QfA+JhA/pi7zT5WHxc8ryyFWX7kTjzwAjASbrlNIo0d7
-e5SMGcZUeH7m/+pCw626nhpexAJ5Fm9/uc0Zwh4xrzS6j2xoqhOqvQb175V/Iv6/
-8nBq/VjE5LqoP57gqw/Cs4zwwBFayr/WaitGVikga2eZI3q/GFMtez27cdMxEZhI
-9ZP1y8kzlzs1QPjdJQUxIE+/zIm3w8IL4iO0SQE5AQKBgQDmSYazZBkmixUzvBhg
-8tGTWJOAG0NhgBamkbaR6s1L8ou9A5MGbFbRBbc5zRmiyMC2Q4D6Xu0ut2N93tUr
-DkxZa35dt3HWMRmNByjHtpMzapYnmDpuF4k7dy+81GkUbd2ZDYadnknjiaFaDZ7j
-9JxUENIwzzLhFMx7emBQ1+3zewKBgQDGgcewYthAsCTAcBtGKw6G39jAYCpr2N7X
-/B5W5n4VXVHKq35wK1bHRnHj7dkm4sH572XB1tPoMrnQ7j9i+XSkc1Ixo0iHr9H0
-QauVQKQqzkvI5cSaWS5N6ZRk6GOGxI0SwYcNNdqJzEEJuYHCTUpff4d6utMgpTZ6
-SQJw8u0O+QKBgE2VEcNYAr0geDkgslnfFEn+ulqbVL0BSSA+0PIh154xjXBVRvAQ
-CcOLmGnptixIU9xTq50t49wsPmGGc+x4ebJaa40pIznU+tWvRsbZtIfK7eFTAMRc
-O4iEI9oK+Ye/Z7uLegGZ9SyqDmjnU9NaclxD+nwlIfAAcM9csBwsUucHAoGABjJ7
-B3iug6Z8Hz3gvBoQBAns/GSELoXAv0FxuQjNGuGk8gzUj6/qr6H1YEZGpz4hDCp7
-JMgOKYub3XfypqZfC9tFz6LnWsUUaum575jrByMVnpn9v0vVdD08ksHmiYiNVu6P
-xsvNnMuxpBoUgPpkvgJ/Okem27gMsViiKOCMohECgYEAt3MwlVILN0t6RPBCpTKB
-nrh6cxx8kQ2TI1UP44WciBkGVvIQOEbl+1955lt/LAECzooiBJOkKubcPK22sJPS
-MZauEwdAqRQj/uUs3oRISUjo0H/IKGI3O23jhIAI2XC/zkQTE6dKjhXxJIl+5a8f
-v9VhnIlgSfaxu3R0l7SvQlo=
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCykZzdcv2ga4Wz
+TOpA3wZlk2ihbgDRGflUk/vgFSJrLDfhcji9rpMbk++CVtG/YPbHJWk2M1AWyrk6
+zCH++0TyCWOkeROiVp9dlIQ6Zy2vXmBjpMj8qEqeYXciY97KRJVpJXhkWPIPc7Fi
+TukA6Uy+INlQLVk4xSFSN5d3pzYDad4SZyZHb8cgbkTe0s4PYRj5kE6fa7CpGUA+
+Eiff1jAJakqngeq0p9tK8nTCQpyPdk0/IZb9cGXFV0laycqc2W9u7WgIuaPRhLWo
+N2l2pUfMy/Q4lJOuN9/ANH2IH9vxko6JmXoXINe4fLRJWDBVeoSakveYDNfJ38JX
+bbW4oYyjAgMBAAECggEAf8cSqKQQOSq3kYYIWkM9IJJK3LkKfJZJg+wg4Eg/SNFr
+azeAwrqZKbLCQFI/5OJNtFNg5hfxx11pDlnkOcEzpL5zPs4k7pVtlFkiBWivmD3A
+W40fBSynuI2l4kX0tmg9QfA+JhA/pi7zT5WHxc8ryyFWX7kTjzwAjASbrlNIo0d7
+e5SMGcZUeH7m/+pCw626nhpexAJ5Fm9/uc0Zwh4xrzS6j2xoqhOqvQb175V/Iv6/
+8nBq/VjE5LqoP57gqw/Cs4zwwBFayr/WaitGVikga2eZI3q/GFMtez27cdMxEZhI
+9ZP1y8kzlzs1QPjdJQUxIE+/zIm3w8IL4iO0SQE5AQKBgQDmSYazZBkmixUzvBhg
+8tGTWJOAG0NhgBamkbaR6s1L8ou9A5MGbFbRBbc5zRmiyMC2Q4D6Xu0ut2N93tUr
+DkxZa35dt3HWMRmNByjHtpMzapYnmDpuF4k7dy+81GkUbd2ZDYadnknjiaFaDZ7j
+9JxUENIwzzLhFMx7emBQ1+3zewKBgQDGgcewYthAsCTAcBtGKw6G39jAYCpr2N7X
+/B5W5n4VXVHKq35wK1bHRnHj7dkm4sH572XB1tPoMrnQ7j9i+XSkc1Ixo0iHr9H0
+QauVQKQqzkvI5cSaWS5N6ZRk6GOGxI0SwYcNNdqJzEEJuYHCTUpff4d6utMgpTZ6
+SQJw8u0O+QKBgE2VEcNYAr0geDkgslnfFEn+ulqbVL0BSSA+0PIh154xjXBVRvAQ
+CcOLmGnptixIU9xTq50t49wsPmGGc+x4ebJaa40pIznU+tWvRsbZtIfK7eFTAMRc
+O4iEI9oK+Ye/Z7uLegGZ9SyqDmjnU9NaclxD+nwlIfAAcM9csBwsUucHAoGABjJ7
+B3iug6Z8Hz3gvBoQBAns/GSELoXAv0FxuQjNGuGk8gzUj6/qr6H1YEZGpz4hDCp7
+JMgOKYub3XfypqZfC9tFz6LnWsUUaum575jrByMVnpn9v0vVdD08ksHmiYiNVu6P
+xsvNnMuxpBoUgPpkvgJ/Okem27gMsViiKOCMohECgYEAt3MwlVILN0t6RPBCpTKB
+nrh6cxx8kQ2TI1UP44WciBkGVvIQOEbl+1955lt/LAECzooiBJOkKubcPK22sJPS
+MZauEwdAqRQj/uUs3oRISUjo0H/IKGI3O23jhIAI2XC/zkQTE6dKjhXxJIl+5a8f
+v9VhnIlgSfaxu3R0l7SvQlo=
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/randouser.key.pem b/tests/certificate-authority/client-keys/randouser.key.pem
index 86a7fa387a..ea73ad4655 100644
--- a/tests/certificate-authority/client-keys/randouser.key.pem
+++ b/tests/certificate-authority/client-keys/randouser.key.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCykZzdcv2ga4Wz
-TOpA3wZlk2ihbgDRGflUk/vgFSJrLDfhcji9rpMbk++CVtG/YPbHJWk2M1AWyrk6
-zCH++0TyCWOkeROiVp9dlIQ6Zy2vXmBjpMj8qEqeYXciY97KRJVpJXhkWPIPc7Fi
-TukA6Uy+INlQLVk4xSFSN5d3pzYDad4SZyZHb8cgbkTe0s4PYRj5kE6fa7CpGUA+
-Eiff1jAJakqngeq0p9tK8nTCQpyPdk0/IZb9cGXFV0laycqc2W9u7WgIuaPRhLWo
-N2l2pUfMy/Q4lJOuN9/ANH2IH9vxko6JmXoXINe4fLRJWDBVeoSakveYDNfJ38JX
-bbW4oYyjAgMBAAECggEAf8cSqKQQOSq3kYYIWkM9IJJK3LkKfJZJg+wg4Eg/SNFr
-azeAwrqZKbLCQFI/5OJNtFNg5hfxx11pDlnkOcEzpL5zPs4k7pVtlFkiBWivmD3A
-W40fBSynuI2l4kX0tmg9QfA+JhA/pi7zT5WHxc8ryyFWX7kTjzwAjASbrlNIo0d7
-e5SMGcZUeH7m/+pCw626nhpexAJ5Fm9/uc0Zwh4xrzS6j2xoqhOqvQb175V/Iv6/
-8nBq/VjE5LqoP57gqw/Cs4zwwBFayr/WaitGVikga2eZI3q/GFMtez27cdMxEZhI
-9ZP1y8kzlzs1QPjdJQUxIE+/zIm3w8IL4iO0SQE5AQKBgQDmSYazZBkmixUzvBhg
-8tGTWJOAG0NhgBamkbaR6s1L8ou9A5MGbFbRBbc5zRmiyMC2Q4D6Xu0ut2N93tUr
-DkxZa35dt3HWMRmNByjHtpMzapYnmDpuF4k7dy+81GkUbd2ZDYadnknjiaFaDZ7j
-9JxUENIwzzLhFMx7emBQ1+3zewKBgQDGgcewYthAsCTAcBtGKw6G39jAYCpr2N7X
-/B5W5n4VXVHKq35wK1bHRnHj7dkm4sH572XB1tPoMrnQ7j9i+XSkc1Ixo0iHr9H0
-QauVQKQqzkvI5cSaWS5N6ZRk6GOGxI0SwYcNNdqJzEEJuYHCTUpff4d6utMgpTZ6
-SQJw8u0O+QKBgE2VEcNYAr0geDkgslnfFEn+ulqbVL0BSSA+0PIh154xjXBVRvAQ
-CcOLmGnptixIU9xTq50t49wsPmGGc+x4ebJaa40pIznU+tWvRsbZtIfK7eFTAMRc
-O4iEI9oK+Ye/Z7uLegGZ9SyqDmjnU9NaclxD+nwlIfAAcM9csBwsUucHAoGABjJ7
-B3iug6Z8Hz3gvBoQBAns/GSELoXAv0FxuQjNGuGk8gzUj6/qr6H1YEZGpz4hDCp7
-JMgOKYub3XfypqZfC9tFz6LnWsUUaum575jrByMVnpn9v0vVdD08ksHmiYiNVu6P
-xsvNnMuxpBoUgPpkvgJ/Okem27gMsViiKOCMohECgYEAt3MwlVILN0t6RPBCpTKB
-nrh6cxx8kQ2TI1UP44WciBkGVvIQOEbl+1955lt/LAECzooiBJOkKubcPK22sJPS
-MZauEwdAqRQj/uUs3oRISUjo0H/IKGI3O23jhIAI2XC/zkQTE6dKjhXxJIl+5a8f
-v9VhnIlgSfaxu3R0l7SvQlo=
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCykZzdcv2ga4Wz
+TOpA3wZlk2ihbgDRGflUk/vgFSJrLDfhcji9rpMbk++CVtG/YPbHJWk2M1AWyrk6
+zCH++0TyCWOkeROiVp9dlIQ6Zy2vXmBjpMj8qEqeYXciY97KRJVpJXhkWPIPc7Fi
+TukA6Uy+INlQLVk4xSFSN5d3pzYDad4SZyZHb8cgbkTe0s4PYRj5kE6fa7CpGUA+
+Eiff1jAJakqngeq0p9tK8nTCQpyPdk0/IZb9cGXFV0laycqc2W9u7WgIuaPRhLWo
+N2l2pUfMy/Q4lJOuN9/ANH2IH9vxko6JmXoXINe4fLRJWDBVeoSakveYDNfJ38JX
+bbW4oYyjAgMBAAECggEAf8cSqKQQOSq3kYYIWkM9IJJK3LkKfJZJg+wg4Eg/SNFr
+azeAwrqZKbLCQFI/5OJNtFNg5hfxx11pDlnkOcEzpL5zPs4k7pVtlFkiBWivmD3A
+W40fBSynuI2l4kX0tmg9QfA+JhA/pi7zT5WHxc8ryyFWX7kTjzwAjASbrlNIo0d7
+e5SMGcZUeH7m/+pCw626nhpexAJ5Fm9/uc0Zwh4xrzS6j2xoqhOqvQb175V/Iv6/
+8nBq/VjE5LqoP57gqw/Cs4zwwBFayr/WaitGVikga2eZI3q/GFMtez27cdMxEZhI
+9ZP1y8kzlzs1QPjdJQUxIE+/zIm3w8IL4iO0SQE5AQKBgQDmSYazZBkmixUzvBhg
+8tGTWJOAG0NhgBamkbaR6s1L8ou9A5MGbFbRBbc5zRmiyMC2Q4D6Xu0ut2N93tUr
+DkxZa35dt3HWMRmNByjHtpMzapYnmDpuF4k7dy+81GkUbd2ZDYadnknjiaFaDZ7j
+9JxUENIwzzLhFMx7emBQ1+3zewKBgQDGgcewYthAsCTAcBtGKw6G39jAYCpr2N7X
+/B5W5n4VXVHKq35wK1bHRnHj7dkm4sH572XB1tPoMrnQ7j9i+XSkc1Ixo0iHr9H0
+QauVQKQqzkvI5cSaWS5N6ZRk6GOGxI0SwYcNNdqJzEEJuYHCTUpff4d6utMgpTZ6
+SQJw8u0O+QKBgE2VEcNYAr0geDkgslnfFEn+ulqbVL0BSSA+0PIh154xjXBVRvAQ
+CcOLmGnptixIU9xTq50t49wsPmGGc+x4ebJaa40pIznU+tWvRsbZtIfK7eFTAMRc
+O4iEI9oK+Ye/Z7uLegGZ9SyqDmjnU9NaclxD+nwlIfAAcM9csBwsUucHAoGABjJ7
+B3iug6Z8Hz3gvBoQBAns/GSELoXAv0FxuQjNGuGk8gzUj6/qr6H1YEZGpz4hDCp7
+JMgOKYub3XfypqZfC9tFz6LnWsUUaum575jrByMVnpn9v0vVdD08ksHmiYiNVu6P
+xsvNnMuxpBoUgPpkvgJ/Okem27gMsViiKOCMohECgYEAt3MwlVILN0t6RPBCpTKB
+nrh6cxx8kQ2TI1UP44WciBkGVvIQOEbl+1955lt/LAECzooiBJOkKubcPK22sJPS
+MZauEwdAqRQj/uUs3oRISUjo0H/IKGI3O23jhIAI2XC/zkQTE6dKjhXxJIl+5a8f
+v9VhnIlgSfaxu3R0l7SvQlo=
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/superproxy.cert.pem b/tests/certificate-authority/client-keys/superproxy.cert.pem
index 9656e2c8ba..a9c8a7fb91 100644
--- a/tests/certificate-authority/client-keys/superproxy.cert.pem
+++ b/tests/certificate-authority/client-keys/superproxy.cert.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEajCCAlKgAwIBAgICEAQwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyNjEzMjUxN1oYDzIyOTIwNDEwMTMyNTE3WjAVMRMwEQYDVQQD
-DApzdXBlcnByb3h5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA43Sn
-ys/h3wxJ/IBEzbJdQAKCxU4of5KgTDzFoOaS8C63Nwbjgy0qcWYdRDceP4lJIKSA
-1+JZ+R1opyrfVIC2D9oDJFIJTFfXy9G9VYDccwAONPgAamvRzBnYcEu8fqM+Ohle
-kZltKktAHnX3WtG3RyxEL5nYzlMlGwUXJu3Rxc9SlkYSxERzjWHikGqGmXLX2qB0
-k6oyxTrK+4+EHk3khbEIqyQZSOFbD7NMfnRy0CWFv/9T1shgjAIBCake6jY7lwaT
-S7JvbLfG6ABf5xHMxoWLXa2qwb+Ar43Ff9g8kKZwFOxMeGcwkzyJPBbWytFxaWn+
-R2RHhTaVCGc22CjdfQIDAQABo4HFMIHCMAkGA1UdEwQCMAAwEQYJYIZIAYb4QgEB
-BAQDAgWgMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRlZCBDbGllbnQg
-Q2VydGlmaWNhdGUwHQYDVR0OBBYEFHEgLhfH0Z1QlLxeQbG7YZyBlz1MMB8GA1Ud
-IwQYMBaAFFcL6csj6L9HPlB6P0V+oRhDnRUnMA4GA1UdDwEB/wQEAwIF4DAdBgNV
-HSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwQwDQYJKoZIhvcNAQELBQADggIBAK9q
-3YnEa99Cq3Vo3g6PE/A/xOE97seVNuavqyBcVv9PrTydb5XG4jPkYU3xOYXIc8rA
-A4gzd+AsGO9rjGMPGGjQJI3JO/3BCeBJMkn50C/rM1yWVMHnVyFcJlg16xaWtj1e
-2Jk8egJW2gSYyF+N2TdzI7tOb002GNr36posnqO+IOoLapyHFBxxUjsPDRoo8fJn
-myWsV1Y9oRUZyJlfIAJsu85ew7gDBY2jaiEiopzour3uU3C0N7gYni2OmVwfr6J8
-R2/Jp43BSD5sYOW9RAJIEEXef+InYtz9HTJvKu2LsWwIBkaztk29tJcDE+1La6Sw
-0dF0YkUwnXoGQFjiV+8pXX3TF5glXKj1rU8WfNazF6lqslB6DmdgR3/FQ6Z2sE86
-d9hVtayZIGlzU0rWmBBtr++7Wo88nmzAtd/xbZMFG8U//+Q2AvJT2oVGtqM48+al
-rnsN/gYrLDr7RC14bHIuO1v6ZL/rAi7SPKrKYAyQVTAcRuW516SxxR6S1Xa1ITnh
-rwgKg13eQuwu3iigguIS9XL6nAXabBIxBxMl6o2YlyIPekKYIcQmpqhkavJ6VOgX
-iq9VdY6fIJVfmxNZuwM3/28k7UeUAfhI2SSVH4ZURbPiGGH2wukc1QkmtZ2cNa35
-C1y79aqJbIa3ErqLFPj/fM+34x8L7QHPq6RfaODa
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEajCCAlKgAwIBAgICEAQwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyNjEzMjUxN1oYDzIyOTIwNDEwMTMyNTE3WjAVMRMwEQYDVQQD
+DApzdXBlcnByb3h5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA43Sn
+ys/h3wxJ/IBEzbJdQAKCxU4of5KgTDzFoOaS8C63Nwbjgy0qcWYdRDceP4lJIKSA
+1+JZ+R1opyrfVIC2D9oDJFIJTFfXy9G9VYDccwAONPgAamvRzBnYcEu8fqM+Ohle
+kZltKktAHnX3WtG3RyxEL5nYzlMlGwUXJu3Rxc9SlkYSxERzjWHikGqGmXLX2qB0
+k6oyxTrK+4+EHk3khbEIqyQZSOFbD7NMfnRy0CWFv/9T1shgjAIBCake6jY7lwaT
+S7JvbLfG6ABf5xHMxoWLXa2qwb+Ar43Ff9g8kKZwFOxMeGcwkzyJPBbWytFxaWn+
+R2RHhTaVCGc22CjdfQIDAQABo4HFMIHCMAkGA1UdEwQCMAAwEQYJYIZIAYb4QgEB
+BAQDAgWgMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRlZCBDbGllbnQg
+Q2VydGlmaWNhdGUwHQYDVR0OBBYEFHEgLhfH0Z1QlLxeQbG7YZyBlz1MMB8GA1Ud
+IwQYMBaAFFcL6csj6L9HPlB6P0V+oRhDnRUnMA4GA1UdDwEB/wQEAwIF4DAdBgNV
+HSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwQwDQYJKoZIhvcNAQELBQADggIBAK9q
+3YnEa99Cq3Vo3g6PE/A/xOE97seVNuavqyBcVv9PrTydb5XG4jPkYU3xOYXIc8rA
+A4gzd+AsGO9rjGMPGGjQJI3JO/3BCeBJMkn50C/rM1yWVMHnVyFcJlg16xaWtj1e
+2Jk8egJW2gSYyF+N2TdzI7tOb002GNr36posnqO+IOoLapyHFBxxUjsPDRoo8fJn
+myWsV1Y9oRUZyJlfIAJsu85ew7gDBY2jaiEiopzour3uU3C0N7gYni2OmVwfr6J8
+R2/Jp43BSD5sYOW9RAJIEEXef+InYtz9HTJvKu2LsWwIBkaztk29tJcDE+1La6Sw
+0dF0YkUwnXoGQFjiV+8pXX3TF5glXKj1rU8WfNazF6lqslB6DmdgR3/FQ6Z2sE86
+d9hVtayZIGlzU0rWmBBtr++7Wo88nmzAtd/xbZMFG8U//+Q2AvJT2oVGtqM48+al
+rnsN/gYrLDr7RC14bHIuO1v6ZL/rAi7SPKrKYAyQVTAcRuW516SxxR6S1Xa1ITnh
+rwgKg13eQuwu3iigguIS9XL6nAXabBIxBxMl6o2YlyIPekKYIcQmpqhkavJ6VOgX
+iq9VdY6fIJVfmxNZuwM3/28k7UeUAfhI2SSVH4ZURbPiGGH2wukc1QkmtZ2cNa35
+C1y79aqJbIa3ErqLFPj/fM+34x8L7QHPq6RfaODa
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/client-keys/superproxy.csr.pem b/tests/certificate-authority/client-keys/superproxy.csr.pem
index 316aeb2686..1d8b3668bd 100644
--- a/tests/certificate-authority/client-keys/superproxy.csr.pem
+++ b/tests/certificate-authority/client-keys/superproxy.csr.pem
@@ -1,15 +1,15 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICWjCCAUICAQAwFTETMBEGA1UEAwwKc3VwZXJwcm94eTCCASIwDQYJKoZIhvcN
-AQEBBQADggEPADCCAQoCggEBAON0p8rP4d8MSfyARM2yXUACgsVOKH+SoEw8xaDm
-kvAutzcG44MtKnFmHUQ3Hj+JSSCkgNfiWfkdaKcq31SAtg/aAyRSCUxX18vRvVWA
-3HMADjT4AGpr0cwZ2HBLvH6jPjoZXpGZbSpLQB5191rRt0csRC+Z2M5TJRsFFybt
-0cXPUpZGEsREc41h4pBqhply19qgdJOqMsU6yvuPhB5N5IWxCKskGUjhWw+zTH50
-ctAlhb//U9bIYIwCAQmpHuo2O5cGk0uyb2y3xugAX+cRzMaFi12tqsG/gK+NxX/Y
-PJCmcBTsTHhnMJM8iTwW1srRcWlp/kdkR4U2lQhnNtgo3X0CAwEAAaAAMA0GCSqG
-SIb3DQEBCwUAA4IBAQDJtfKA9F+OCFnq3VTBCJAxPxFjic0X6VfvtSVqpL9JHXvs
-cRuNj95a8SR9XHQbMkJKpf4yU6xihPUnkazM7skoZOhKzqC9inBa+pAVdvxuzsG8
-G03rD2VEfLE0qHzwm06NVyP0gEjfmGOuizBGZkK82VeEUHSUqvqtzSlsxyFMqZk/
-X+ypHE3DFPS09IxxdDRdLapBhm0zvHaXArpiKpPUPWuPeb5VSPzT+/ru4MJRqZBL
-eToD1JP6dKPlKIFOSSwqyCGPZuE1HhEvY2B41oxAPt3wCSl6zOXaZ9RU/0HN3zgv
-zHoah245BIPzkU/7XBxjvijiTJIzJny5gpzhwu/L
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICWjCCAUICAQAwFTETMBEGA1UEAwwKc3VwZXJwcm94eTCCASIwDQYJKoZIhvcN
+AQEBBQADggEPADCCAQoCggEBAON0p8rP4d8MSfyARM2yXUACgsVOKH+SoEw8xaDm
+kvAutzcG44MtKnFmHUQ3Hj+JSSCkgNfiWfkdaKcq31SAtg/aAyRSCUxX18vRvVWA
+3HMADjT4AGpr0cwZ2HBLvH6jPjoZXpGZbSpLQB5191rRt0csRC+Z2M5TJRsFFybt
+0cXPUpZGEsREc41h4pBqhply19qgdJOqMsU6yvuPhB5N5IWxCKskGUjhWw+zTH50
+ctAlhb//U9bIYIwCAQmpHuo2O5cGk0uyb2y3xugAX+cRzMaFi12tqsG/gK+NxX/Y
+PJCmcBTsTHhnMJM8iTwW1srRcWlp/kdkR4U2lQhnNtgo3X0CAwEAAaAAMA0GCSqG
+SIb3DQEBCwUAA4IBAQDJtfKA9F+OCFnq3VTBCJAxPxFjic0X6VfvtSVqpL9JHXvs
+cRuNj95a8SR9XHQbMkJKpf4yU6xihPUnkazM7skoZOhKzqC9inBa+pAVdvxuzsG8
+G03rD2VEfLE0qHzwm06NVyP0gEjfmGOuizBGZkK82VeEUHSUqvqtzSlsxyFMqZk/
+X+ypHE3DFPS09IxxdDRdLapBhm0zvHaXArpiKpPUPWuPeb5VSPzT+/ru4MJRqZBL
+eToD1JP6dKPlKIFOSSwqyCGPZuE1HhEvY2B41oxAPt3wCSl6zOXaZ9RU/0HN3zgv
+zHoah245BIPzkU/7XBxjvijiTJIzJny5gpzhwu/L
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/client-keys/superproxy.key-pk8.pem b/tests/certificate-authority/client-keys/superproxy.key-pk8.pem
index 2e4140b8fb..606aac0c37 100644
--- a/tests/certificate-authority/client-keys/superproxy.key-pk8.pem
+++ b/tests/certificate-authority/client-keys/superproxy.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDjdKfKz+HfDEn8
-gETNsl1AAoLFTih/kqBMPMWg5pLwLrc3BuODLSpxZh1ENx4/iUkgpIDX4ln5HWin
-Kt9UgLYP2gMkUglMV9fL0b1VgNxzAA40+ABqa9HMGdhwS7x+oz46GV6RmW0qS0Ae
-dfda0bdHLEQvmdjOUyUbBRcm7dHFz1KWRhLERHONYeKQaoaZctfaoHSTqjLFOsr7
-j4QeTeSFsQirJBlI4VsPs0x+dHLQJYW//1PWyGCMAgEJqR7qNjuXBpNLsm9st8bo
-AF/nEczGhYtdrarBv4CvjcV/2DyQpnAU7Ex4ZzCTPIk8FtbK0XFpaf5HZEeFNpUI
-ZzbYKN19AgMBAAECggEBAM1JAwuD1drmj3wKFI8F1S2pVndXFCwXnP9RthiDIckO
-kKNkX0CMKgtQ20cu6+jyMgL5FaRCkWvJxCNkCU6OIENsQ3urYuL5QTWeZeBevhg4
-y5m43z8tcptgFD09zbEKCmaLcRO9wo3yfrs/QvE/58efxyajFs8YsZuSW5Px/msl
-AFN8qGY0q0lQbQPK8cPYT4OnW9isqEjkvHq1Q+ryv4cxsGWtBZYmJVeLVHzClihi
-lODdN6YsDcu9jLwsA8o2WSBRsbLHK6caW4FdEwgOLckc0EGGEU64VEB9ZOwgcwYQ
-M9mZDs2w7qk63YnDH4KmpoP0Oc8N+bG7Pkifd7f8HqECgYEA8esMQya6Qln4O7Qo
-aI8X9t5gCpq+bh/P+7vYdBR/9St5VtE/P0yuaQdT2e5t+Ei4ujqHvJ0GTPmqYIJf
-2DNvJMu8EnXv+nqKQCsyMc/nqQN1CcRGqZssH1V/ZIQLRUA0cN4hzE0eHITwp6U9
-vD/WaE3mKX/XHthIjc8hnuoajOkCgYEA8LIYMgyD3wClWOKe5TkBumI0KvA9tP90
-IFHu1wLNl0tKBpsXkzzxiav1FMX3K7B29vxukrs946KRESHzRg4c5ULPnMmwcQyx
-AortKJWrGVsna/QDWPRutXSN1XmnjKWsHmTpQQqLfaRvLW+Hd34+EVdVh9sVt/y9
-RucnBvxcX3UCgYBebm/U7pMaP2BkfcigN+sU1G0M9qaK+iQHkaXGehIQs62js/5K
-STZzjQawNR/8IPbqytodR/YjqflVvs6G6FzkMhrx4dORJLA+qB3pz8wP72eKLnGe
-1xF8EbWumNSFbbCKtkrfIuM0IriF2Dym9QxOnsnPPTXNtoNrx4TKMXu3sQKBgBq9
-noSI8WmoF7adTsvmnnOHj4YptKFUNCGXGLLYg+DII4xCVMct4SPLb+oD6Gb5Lu5X
-sy0oEkMk/3roy68/yCQMXSZtHeYhY9UFfD2jCyRBBUswC+MpHNeaAFv0LRIqIcoq
-qeNo+YBW8WcZ2fIDm3+vtTfntiz/rkOfUK2tAdI1AoGAL2LVDF5e1meSRocEoy8e
-gqrshrhg+KBqYmcjtd4Iup4WvR6uyH4qE9yFLLHFZ04pZzXLHcPfqgOSP8qTxgH3
-h0uqtcYmejS/yl6PbC9OPXcSkMgntRkTbU9Ug05ijfN9NRnW+8WXvi8Z6DKed1P1
-9PxwA75P9o0h00mMk8PQitQ=
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDjdKfKz+HfDEn8
+gETNsl1AAoLFTih/kqBMPMWg5pLwLrc3BuODLSpxZh1ENx4/iUkgpIDX4ln5HWin
+Kt9UgLYP2gMkUglMV9fL0b1VgNxzAA40+ABqa9HMGdhwS7x+oz46GV6RmW0qS0Ae
+dfda0bdHLEQvmdjOUyUbBRcm7dHFz1KWRhLERHONYeKQaoaZctfaoHSTqjLFOsr7
+j4QeTeSFsQirJBlI4VsPs0x+dHLQJYW//1PWyGCMAgEJqR7qNjuXBpNLsm9st8bo
+AF/nEczGhYtdrarBv4CvjcV/2DyQpnAU7Ex4ZzCTPIk8FtbK0XFpaf5HZEeFNpUI
+ZzbYKN19AgMBAAECggEBAM1JAwuD1drmj3wKFI8F1S2pVndXFCwXnP9RthiDIckO
+kKNkX0CMKgtQ20cu6+jyMgL5FaRCkWvJxCNkCU6OIENsQ3urYuL5QTWeZeBevhg4
+y5m43z8tcptgFD09zbEKCmaLcRO9wo3yfrs/QvE/58efxyajFs8YsZuSW5Px/msl
+AFN8qGY0q0lQbQPK8cPYT4OnW9isqEjkvHq1Q+ryv4cxsGWtBZYmJVeLVHzClihi
+lODdN6YsDcu9jLwsA8o2WSBRsbLHK6caW4FdEwgOLckc0EGGEU64VEB9ZOwgcwYQ
+M9mZDs2w7qk63YnDH4KmpoP0Oc8N+bG7Pkifd7f8HqECgYEA8esMQya6Qln4O7Qo
+aI8X9t5gCpq+bh/P+7vYdBR/9St5VtE/P0yuaQdT2e5t+Ei4ujqHvJ0GTPmqYIJf
+2DNvJMu8EnXv+nqKQCsyMc/nqQN1CcRGqZssH1V/ZIQLRUA0cN4hzE0eHITwp6U9
+vD/WaE3mKX/XHthIjc8hnuoajOkCgYEA8LIYMgyD3wClWOKe5TkBumI0KvA9tP90
+IFHu1wLNl0tKBpsXkzzxiav1FMX3K7B29vxukrs946KRESHzRg4c5ULPnMmwcQyx
+AortKJWrGVsna/QDWPRutXSN1XmnjKWsHmTpQQqLfaRvLW+Hd34+EVdVh9sVt/y9
+RucnBvxcX3UCgYBebm/U7pMaP2BkfcigN+sU1G0M9qaK+iQHkaXGehIQs62js/5K
+STZzjQawNR/8IPbqytodR/YjqflVvs6G6FzkMhrx4dORJLA+qB3pz8wP72eKLnGe
+1xF8EbWumNSFbbCKtkrfIuM0IriF2Dym9QxOnsnPPTXNtoNrx4TKMXu3sQKBgBq9
+noSI8WmoF7adTsvmnnOHj4YptKFUNCGXGLLYg+DII4xCVMct4SPLb+oD6Gb5Lu5X
+sy0oEkMk/3roy68/yCQMXSZtHeYhY9UFfD2jCyRBBUswC+MpHNeaAFv0LRIqIcoq
+qeNo+YBW8WcZ2fIDm3+vtTfntiz/rkOfUK2tAdI1AoGAL2LVDF5e1meSRocEoy8e
+gqrshrhg+KBqYmcjtd4Iup4WvR6uyH4qE9yFLLHFZ04pZzXLHcPfqgOSP8qTxgH3
+h0uqtcYmejS/yl6PbC9OPXcSkMgntRkTbU9Ug05ijfN9NRnW+8WXvi8Z6DKed1P1
+9PxwA75P9o0h00mMk8PQitQ=
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/superproxy.key.pem b/tests/certificate-authority/client-keys/superproxy.key.pem
index b9dab246e3..1c892f0ab6 100644
--- a/tests/certificate-authority/client-keys/superproxy.key.pem
+++ b/tests/certificate-authority/client-keys/superproxy.key.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEA43Snys/h3wxJ/IBEzbJdQAKCxU4of5KgTDzFoOaS8C63Nwbj
-gy0qcWYdRDceP4lJIKSA1+JZ+R1opyrfVIC2D9oDJFIJTFfXy9G9VYDccwAONPgA
-amvRzBnYcEu8fqM+OhlekZltKktAHnX3WtG3RyxEL5nYzlMlGwUXJu3Rxc9SlkYS
-xERzjWHikGqGmXLX2qB0k6oyxTrK+4+EHk3khbEIqyQZSOFbD7NMfnRy0CWFv/9T
-1shgjAIBCake6jY7lwaTS7JvbLfG6ABf5xHMxoWLXa2qwb+Ar43Ff9g8kKZwFOxM
-eGcwkzyJPBbWytFxaWn+R2RHhTaVCGc22CjdfQIDAQABAoIBAQDNSQMLg9Xa5o98
-ChSPBdUtqVZ3VxQsF5z/UbYYgyHJDpCjZF9AjCoLUNtHLuvo8jIC+RWkQpFrycQj
-ZAlOjiBDbEN7q2Li+UE1nmXgXr4YOMuZuN8/LXKbYBQ9Pc2xCgpmi3ETvcKN8n67
-P0LxP+fHn8cmoxbPGLGbkluT8f5rJQBTfKhmNKtJUG0DyvHD2E+Dp1vYrKhI5Lx6
-tUPq8r+HMbBlrQWWJiVXi1R8wpYoYpTg3TemLA3LvYy8LAPKNlkgUbGyxyunGluB
-XRMIDi3JHNBBhhFOuFRAfWTsIHMGEDPZmQ7NsO6pOt2Jwx+CpqaD9DnPDfmxuz5I
-n3e3/B6hAoGBAPHrDEMmukJZ+Du0KGiPF/beYAqavm4fz/u72HQUf/UreVbRPz9M
-rmkHU9nubfhIuLo6h7ydBkz5qmCCX9gzbyTLvBJ17/p6ikArMjHP56kDdQnERqmb
-LB9Vf2SEC0VANHDeIcxNHhyE8KelPbw/1mhN5il/1x7YSI3PIZ7qGozpAoGBAPCy
-GDIMg98ApVjinuU5AbpiNCrwPbT/dCBR7tcCzZdLSgabF5M88Ymr9RTF9yuwdvb8
-bpK7PeOikREh80YOHOVCz5zJsHEMsQKK7SiVqxlbJ2v0A1j0brV0jdV5p4ylrB5k
-6UEKi32kby1vh3d+PhFXVYfbFbf8vUbnJwb8XF91AoGAXm5v1O6TGj9gZH3IoDfr
-FNRtDPamivokB5GlxnoSELOto7P+Skk2c40GsDUf/CD26sraHUf2I6n5Vb7Ohuhc
-5DIa8eHTkSSwPqgd6c/MD+9nii5xntcRfBG1rpjUhW2wirZK3yLjNCK4hdg8pvUM
-Tp7Jzz01zbaDa8eEyjF7t7ECgYAavZ6EiPFpqBe2nU7L5p5zh4+GKbShVDQhlxiy
-2IPgyCOMQlTHLeEjy2/qA+hm+S7uV7MtKBJDJP966MuvP8gkDF0mbR3mIWPVBXw9
-owskQQVLMAvjKRzXmgBb9C0SKiHKKqnjaPmAVvFnGdnyA5t/r7U357Ys/65Dn1Ct
-rQHSNQKBgC9i1QxeXtZnkkaHBKMvHoKq7Ia4YPigamJnI7XeCLqeFr0ersh+KhPc
-hSyxxWdOKWc1yx3D36oDkj/Kk8YB94dLqrXGJno0v8pej2wvTj13EpDIJ7UZE21P
-VINOYo3zfTUZ1vvFl74vGegynndT9fT8cAO+T/aNIdNJjJPD0IrU
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEA43Snys/h3wxJ/IBEzbJdQAKCxU4of5KgTDzFoOaS8C63Nwbj
+gy0qcWYdRDceP4lJIKSA1+JZ+R1opyrfVIC2D9oDJFIJTFfXy9G9VYDccwAONPgA
+amvRzBnYcEu8fqM+OhlekZltKktAHnX3WtG3RyxEL5nYzlMlGwUXJu3Rxc9SlkYS
+xERzjWHikGqGmXLX2qB0k6oyxTrK+4+EHk3khbEIqyQZSOFbD7NMfnRy0CWFv/9T
+1shgjAIBCake6jY7lwaTS7JvbLfG6ABf5xHMxoWLXa2qwb+Ar43Ff9g8kKZwFOxM
+eGcwkzyJPBbWytFxaWn+R2RHhTaVCGc22CjdfQIDAQABAoIBAQDNSQMLg9Xa5o98
+ChSPBdUtqVZ3VxQsF5z/UbYYgyHJDpCjZF9AjCoLUNtHLuvo8jIC+RWkQpFrycQj
+ZAlOjiBDbEN7q2Li+UE1nmXgXr4YOMuZuN8/LXKbYBQ9Pc2xCgpmi3ETvcKN8n67
+P0LxP+fHn8cmoxbPGLGbkluT8f5rJQBTfKhmNKtJUG0DyvHD2E+Dp1vYrKhI5Lx6
+tUPq8r+HMbBlrQWWJiVXi1R8wpYoYpTg3TemLA3LvYy8LAPKNlkgUbGyxyunGluB
+XRMIDi3JHNBBhhFOuFRAfWTsIHMGEDPZmQ7NsO6pOt2Jwx+CpqaD9DnPDfmxuz5I
+n3e3/B6hAoGBAPHrDEMmukJZ+Du0KGiPF/beYAqavm4fz/u72HQUf/UreVbRPz9M
+rmkHU9nubfhIuLo6h7ydBkz5qmCCX9gzbyTLvBJ17/p6ikArMjHP56kDdQnERqmb
+LB9Vf2SEC0VANHDeIcxNHhyE8KelPbw/1mhN5il/1x7YSI3PIZ7qGozpAoGBAPCy
+GDIMg98ApVjinuU5AbpiNCrwPbT/dCBR7tcCzZdLSgabF5M88Ymr9RTF9yuwdvb8
+bpK7PeOikREh80YOHOVCz5zJsHEMsQKK7SiVqxlbJ2v0A1j0brV0jdV5p4ylrB5k
+6UEKi32kby1vh3d+PhFXVYfbFbf8vUbnJwb8XF91AoGAXm5v1O6TGj9gZH3IoDfr
+FNRtDPamivokB5GlxnoSELOto7P+Skk2c40GsDUf/CD26sraHUf2I6n5Vb7Ohuhc
+5DIa8eHTkSSwPqgd6c/MD+9nii5xntcRfBG1rpjUhW2wirZK3yLjNCK4hdg8pvUM
+Tp7Jzz01zbaDa8eEyjF7t7ECgYAavZ6EiPFpqBe2nU7L5p5zh4+GKbShVDQhlxiy
+2IPgyCOMQlTHLeEjy2/qA+hm+S7uV7MtKBJDJP966MuvP8gkDF0mbR3mIWPVBXw9
+owskQQVLMAvjKRzXmgBb9C0SKiHKKqnjaPmAVvFnGdnyA5t/r7U357Ys/65Dn1Ct
+rQHSNQKBgC9i1QxeXtZnkkaHBKMvHoKq7Ia4YPigamJnI7XeCLqeFr0ersh+KhPc
+hSyxxWdOKWc1yx3D36oDkj/Kk8YB94dLqrXGJno0v8pej2wvTj13EpDIJ7UZE21P
+VINOYo3zfTUZ1vvFl74vGegynndT9fT8cAO+T/aNIdNJjJPD0IrU
+-----END RSA PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/user1.cert.pem b/tests/certificate-authority/client-keys/user1.cert.pem
index 072f2867fe..3646d0feae 100644
--- a/tests/certificate-authority/client-keys/user1.cert.pem
+++ b/tests/certificate-authority/client-keys/user1.cert.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEZTCCAk2gAwIBAgICEAUwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyNzA4NDAyNVoYDzIyOTIwNDExMDg0MDI1WjAQMQ4wDAYDVQQD
-DAV1c2VyMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM5iqgr4PUUZ
-AW9MDGP5cBaSJALSPV63m6M/IoovrMWJ9CGtcQfZTUHwDorIlXgQ6H/KufmsHW0Y
-OQbChLSTDB14D0jSMtyv6+ibSoE1ZEl2SbB1miLd0P5AS9YmzzEW2+bx0zJORLYD
-PzJ1Nh3/kQlRs04IECki291WZiVRzX2JRoL7kMtOAoKJqQfsT14Oi9EAw39VhLeB
-uc/Mx6Jsutq/YdXakoZtQbfZka2MMfLXgMDLIPDqbU+09q7au2dq8RjGzrWnxnOX
-o/XQssrIbwzJJYASBsgAAtnAw7bPzCX6+cL6PZVRyiEZov0HKXyRyvrbQ5hyEMuS
-3dHqoKt0fKMCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
-oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
-ZmljYXRlMB0GA1UdDgQWBBQ7NSD6lx6Vq38cEoD5l7FHs1Ej8DAfBgNVHSMEGDAW
-gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
-FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQC+cU7ctY7o
-eTW+oHTq9EGJUMwW1fOww4QDrHtgZT4OYkO88zxQV2Cr050p8eaV5dHXZBf9/bRV
-7hPNV5+HpQhb9TZ9xK2WRZ2QV7a/UDyUnksVKGSK9tNZMZPueOEB19e4bIBcgnQa
-5i9sgZr93na7pFOY7lBQy6gfaOcnejYHmvVqIGaZBVH8rkEsGhhkJxy7qkpFNKgf
-PGiIRo9L0WYqDCSiaICeCiteJwIfjsUFJKF0YnpXZq1kFfQscnleg60MWZAXvacp
-tAciE51Ow60cqQWER66iwqnBSPD4l91SxAaGQAmalgCioGsYSbojXcOvRidhYJ2T
-3YwCpqlC0qC9D2ZmNoukb1a0Pi03MuSJwD/8v9eqwEW9dFAzdnWDzTZMN9CfdjVh
-2qiO5o5Si/X1Dmjdk2F/EM62YJQBAlkZBetFJ0o2QPGTSD+zrpfITIW8Pu+/5zcC
-MZdzyUf0p1GO2Kn7wmqPQjz59zABagmxCNks8HeqPnzmWuADMaggb0nOmrBACE2x
-b9XR6/xaXpwTRf0h5N3evivzUHo6XVw8A3gVUNoBm9Of3PlAsjM4I4SWFb6nrwYv
-RnI04c+R95Su1fMc2wky0PmW+iWRTaEN/cUdX1SF6jo1nRLELGcbMSGUI6UI8kff
-crvCz7uLu7Lr5/CKnEm2bSCZ4eIQpOs4nQ==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEZTCCAk2gAwIBAgICEAUwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyNzA4NDAyNVoYDzIyOTIwNDExMDg0MDI1WjAQMQ4wDAYDVQQD
+DAV1c2VyMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM5iqgr4PUUZ
+AW9MDGP5cBaSJALSPV63m6M/IoovrMWJ9CGtcQfZTUHwDorIlXgQ6H/KufmsHW0Y
+OQbChLSTDB14D0jSMtyv6+ibSoE1ZEl2SbB1miLd0P5AS9YmzzEW2+bx0zJORLYD
+PzJ1Nh3/kQlRs04IECki291WZiVRzX2JRoL7kMtOAoKJqQfsT14Oi9EAw39VhLeB
+uc/Mx6Jsutq/YdXakoZtQbfZka2MMfLXgMDLIPDqbU+09q7au2dq8RjGzrWnxnOX
+o/XQssrIbwzJJYASBsgAAtnAw7bPzCX6+cL6PZVRyiEZov0HKXyRyvrbQ5hyEMuS
+3dHqoKt0fKMCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
+oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
+ZmljYXRlMB0GA1UdDgQWBBQ7NSD6lx6Vq38cEoD5l7FHs1Ej8DAfBgNVHSMEGDAW
+gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
+FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQC+cU7ctY7o
+eTW+oHTq9EGJUMwW1fOww4QDrHtgZT4OYkO88zxQV2Cr050p8eaV5dHXZBf9/bRV
+7hPNV5+HpQhb9TZ9xK2WRZ2QV7a/UDyUnksVKGSK9tNZMZPueOEB19e4bIBcgnQa
+5i9sgZr93na7pFOY7lBQy6gfaOcnejYHmvVqIGaZBVH8rkEsGhhkJxy7qkpFNKgf
+PGiIRo9L0WYqDCSiaICeCiteJwIfjsUFJKF0YnpXZq1kFfQscnleg60MWZAXvacp
+tAciE51Ow60cqQWER66iwqnBSPD4l91SxAaGQAmalgCioGsYSbojXcOvRidhYJ2T
+3YwCpqlC0qC9D2ZmNoukb1a0Pi03MuSJwD/8v9eqwEW9dFAzdnWDzTZMN9CfdjVh
+2qiO5o5Si/X1Dmjdk2F/EM62YJQBAlkZBetFJ0o2QPGTSD+zrpfITIW8Pu+/5zcC
+MZdzyUf0p1GO2Kn7wmqPQjz59zABagmxCNks8HeqPnzmWuADMaggb0nOmrBACE2x
+b9XR6/xaXpwTRf0h5N3evivzUHo6XVw8A3gVUNoBm9Of3PlAsjM4I4SWFb6nrwYv
+RnI04c+R95Su1fMc2wky0PmW+iWRTaEN/cUdX1SF6jo1nRLELGcbMSGUI6UI8kff
+crvCz7uLu7Lr5/CKnEm2bSCZ4eIQpOs4nQ==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/client-keys/user1.csr.pem b/tests/certificate-authority/client-keys/user1.csr.pem
index 0e645fd42e..397277dded 100644
--- a/tests/certificate-authority/client-keys/user1.csr.pem
+++ b/tests/certificate-authority/client-keys/user1.csr.pem
@@ -1,15 +1,15 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICVTCCAT0CAQAwEDEOMAwGA1UEAwwFdXNlcjEwggEiMA0GCSqGSIb3DQEBAQUA
-A4IBDwAwggEKAoIBAQDOYqoK+D1FGQFvTAxj+XAWkiQC0j1et5ujPyKKL6zFifQh
-rXEH2U1B8A6KyJV4EOh/yrn5rB1tGDkGwoS0kwwdeA9I0jLcr+vom0qBNWRJdkmw
-dZoi3dD+QEvWJs8xFtvm8dMyTkS2Az8ydTYd/5EJUbNOCBApItvdVmYlUc19iUaC
-+5DLTgKCiakH7E9eDovRAMN/VYS3gbnPzMeibLrav2HV2pKGbUG32ZGtjDHy14DA
-yyDw6m1PtPau2rtnavEYxs61p8Zzl6P10LLKyG8MySWAEgbIAALZwMO2z8wl+vnC
-+j2VUcohGaL9Byl8kcr620OYchDLkt3R6qCrdHyjAgMBAAGgADANBgkqhkiG9w0B
-AQsFAAOCAQEAr4Gv4Zwmyz1uPN7bJ3aNZE6/fzIV4DZhFnb3vU5fkgQ5lxDMTVFw
-1HDkACwL11jIdIiwyXgHG9JX+ZPleG/YYUWxTx+D9gAkXcGCPVDjQHjCUINprH2/
-RjpLV9sH+Ha2CzomJ/xG2BkexI5oPbs0vqYvEQELiY5IAuppr/yevJS334mIpWPN
-cJiCCuKetCrVwjf0isPBb8QxeuNYNQjEkV/LbEd6JStUhz2mWzngYh9p8joN01MI
-BTtjye/la6iDzZZCgRzO5CJfhEztsr31VC+0fmvcQ4u9lnH8DutQRw9aDi7+2rYd
-mfosy+BIBsslPC0LPClC7O8fUhfWtq7ZgQ==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICVTCCAT0CAQAwEDEOMAwGA1UEAwwFdXNlcjEwggEiMA0GCSqGSIb3DQEBAQUA
+A4IBDwAwggEKAoIBAQDOYqoK+D1FGQFvTAxj+XAWkiQC0j1et5ujPyKKL6zFifQh
+rXEH2U1B8A6KyJV4EOh/yrn5rB1tGDkGwoS0kwwdeA9I0jLcr+vom0qBNWRJdkmw
+dZoi3dD+QEvWJs8xFtvm8dMyTkS2Az8ydTYd/5EJUbNOCBApItvdVmYlUc19iUaC
++5DLTgKCiakH7E9eDovRAMN/VYS3gbnPzMeibLrav2HV2pKGbUG32ZGtjDHy14DA
+yyDw6m1PtPau2rtnavEYxs61p8Zzl6P10LLKyG8MySWAEgbIAALZwMO2z8wl+vnC
++j2VUcohGaL9Byl8kcr620OYchDLkt3R6qCrdHyjAgMBAAGgADANBgkqhkiG9w0B
+AQsFAAOCAQEAr4Gv4Zwmyz1uPN7bJ3aNZE6/fzIV4DZhFnb3vU5fkgQ5lxDMTVFw
+1HDkACwL11jIdIiwyXgHG9JX+ZPleG/YYUWxTx+D9gAkXcGCPVDjQHjCUINprH2/
+RjpLV9sH+Ha2CzomJ/xG2BkexI5oPbs0vqYvEQELiY5IAuppr/yevJS334mIpWPN
+cJiCCuKetCrVwjf0isPBb8QxeuNYNQjEkV/LbEd6JStUhz2mWzngYh9p8joN01MI
+BTtjye/la6iDzZZCgRzO5CJfhEztsr31VC+0fmvcQ4u9lnH8DutQRw9aDi7+2rYd
+mfosy+BIBsslPC0LPClC7O8fUhfWtq7ZgQ==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/client-keys/user1.key-pk8.pem b/tests/certificate-authority/client-keys/user1.key-pk8.pem
index eec5c94c06..9436ae446c 100644
--- a/tests/certificate-authority/client-keys/user1.key-pk8.pem
+++ b/tests/certificate-authority/client-keys/user1.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOYqoK+D1FGQFv
-TAxj+XAWkiQC0j1et5ujPyKKL6zFifQhrXEH2U1B8A6KyJV4EOh/yrn5rB1tGDkG
-woS0kwwdeA9I0jLcr+vom0qBNWRJdkmwdZoi3dD+QEvWJs8xFtvm8dMyTkS2Az8y
-dTYd/5EJUbNOCBApItvdVmYlUc19iUaC+5DLTgKCiakH7E9eDovRAMN/VYS3gbnP
-zMeibLrav2HV2pKGbUG32ZGtjDHy14DAyyDw6m1PtPau2rtnavEYxs61p8Zzl6P1
-0LLKyG8MySWAEgbIAALZwMO2z8wl+vnC+j2VUcohGaL9Byl8kcr620OYchDLkt3R
-6qCrdHyjAgMBAAECggEBAK8J8QvytAxJg/T/+7ZC1PTfp1kZNGGDuaV/o2ytuIul
-T//MGQQ+IY8d6Ud9jX9SX84agxalCiP/mkYIbgK0gF7x94yccfTH433ZTxw8yzye
-7SqS41JU7K7mmysaqTkKGSFK0gNlbFMud8f0rxxMJ5dOypMQtZwd63lSkLlwIqcn
-YhKcAdXM4WGv07MFdwAXvrK2trhBBkCA08ZzyVy4lWE+cVfEkwH6O8EdGchl7g4U
-LqIkYzufQWKdH9frt6N3qEV/qs0s1qipVzV07GaPpEdK/G5exJ7NjZaXJkHOuMbt
-7ae1zJBexW41/++fjzsWSYljvSEphjqwrGYrr+tMGNECgYEA+Sg1sHcYO4Bg16qG
-c8XM9g8DFL396X4MnMh+AFrDV8dbdz39x9fFtpKEfqaAZrG6I8fW3RkMLsJvJ4GI
-KDJNz2ezEMbNKlXE9UzvAsrdvWNWDGJvrDu0CbJg2wtBeVEBIUYetSdNHoEwY7ZJ
-QHnwbxYYrUFIJ34rI0SQ17/Z4vsCgYEA1A27jYTWr86JmvjQDUiJcJsbhpa/6OzZ
-n3KTu0n0oCvl7uvvjUfhlzmcq7kyY0oO1C5TQHLiqBaI5hXw+iYwnESLIn7BwhMX
-dcxglvXx95h1NqHYX9GnURl2QtrjmuY5yx+itfmZCRkRPO3c5e9uZyf01CeE4uwl
-hDNh0RrSXHkCgYBvlQhmXQ+nJhk4vI+2LXFbCOISWfvqo562YDu9oOg22Xsm7cZH
-x2QuHXPk3GBInXOFLqwVHHCOSFlLUgFOLykVp5VUABRFz1+Dk86+a2fetywEI9lr
-QtmgNhiWQHY0BIkDA8ogytcIwEaRgUNQ8sswlK68eK39sc1T4BMV7D+CHQKBgG3g
-+8lWBwSsKgOCYBQx/P27caTo4mJosE99yG0o4jhI5ulJmiSEFbINqVAWM7TdQBfU
-NVFU9nuQybknr2l/dnrSzaG/Otk8mVBx6a7vnETm2/3GGV91PJS6c9wqnfu6xkGp
-j99piVH8ikEfI/KFgZi0TJnOLH6FTN9W3J3EnzJJAoGAE4ZLLi+2RP4ZYXI11CJC
-BSM1AEpqemgTUSidZyTiJJMGGrC7tyEba+4TIqeGgvD74p57XFbN7LOJWmnAiK8b
-BLhQqPgOCXqrna00GnNKKx7AzgYHqlq03tGlX858aH18rkSRVk3UhkTkGTSr3iQn
-aJeN/0HbpGr67bimf4bqlCY=
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDOYqoK+D1FGQFv
+TAxj+XAWkiQC0j1et5ujPyKKL6zFifQhrXEH2U1B8A6KyJV4EOh/yrn5rB1tGDkG
+woS0kwwdeA9I0jLcr+vom0qBNWRJdkmwdZoi3dD+QEvWJs8xFtvm8dMyTkS2Az8y
+dTYd/5EJUbNOCBApItvdVmYlUc19iUaC+5DLTgKCiakH7E9eDovRAMN/VYS3gbnP
+zMeibLrav2HV2pKGbUG32ZGtjDHy14DAyyDw6m1PtPau2rtnavEYxs61p8Zzl6P1
+0LLKyG8MySWAEgbIAALZwMO2z8wl+vnC+j2VUcohGaL9Byl8kcr620OYchDLkt3R
+6qCrdHyjAgMBAAECggEBAK8J8QvytAxJg/T/+7ZC1PTfp1kZNGGDuaV/o2ytuIul
+T//MGQQ+IY8d6Ud9jX9SX84agxalCiP/mkYIbgK0gF7x94yccfTH433ZTxw8yzye
+7SqS41JU7K7mmysaqTkKGSFK0gNlbFMud8f0rxxMJ5dOypMQtZwd63lSkLlwIqcn
+YhKcAdXM4WGv07MFdwAXvrK2trhBBkCA08ZzyVy4lWE+cVfEkwH6O8EdGchl7g4U
+LqIkYzufQWKdH9frt6N3qEV/qs0s1qipVzV07GaPpEdK/G5exJ7NjZaXJkHOuMbt
+7ae1zJBexW41/++fjzsWSYljvSEphjqwrGYrr+tMGNECgYEA+Sg1sHcYO4Bg16qG
+c8XM9g8DFL396X4MnMh+AFrDV8dbdz39x9fFtpKEfqaAZrG6I8fW3RkMLsJvJ4GI
+KDJNz2ezEMbNKlXE9UzvAsrdvWNWDGJvrDu0CbJg2wtBeVEBIUYetSdNHoEwY7ZJ
+QHnwbxYYrUFIJ34rI0SQ17/Z4vsCgYEA1A27jYTWr86JmvjQDUiJcJsbhpa/6OzZ
+n3KTu0n0oCvl7uvvjUfhlzmcq7kyY0oO1C5TQHLiqBaI5hXw+iYwnESLIn7BwhMX
+dcxglvXx95h1NqHYX9GnURl2QtrjmuY5yx+itfmZCRkRPO3c5e9uZyf01CeE4uwl
+hDNh0RrSXHkCgYBvlQhmXQ+nJhk4vI+2LXFbCOISWfvqo562YDu9oOg22Xsm7cZH
+x2QuHXPk3GBInXOFLqwVHHCOSFlLUgFOLykVp5VUABRFz1+Dk86+a2fetywEI9lr
+QtmgNhiWQHY0BIkDA8ogytcIwEaRgUNQ8sswlK68eK39sc1T4BMV7D+CHQKBgG3g
++8lWBwSsKgOCYBQx/P27caTo4mJosE99yG0o4jhI5ulJmiSEFbINqVAWM7TdQBfU
+NVFU9nuQybknr2l/dnrSzaG/Otk8mVBx6a7vnETm2/3GGV91PJS6c9wqnfu6xkGp
+j99piVH8ikEfI/KFgZi0TJnOLH6FTN9W3J3EnzJJAoGAE4ZLLi+2RP4ZYXI11CJC
+BSM1AEpqemgTUSidZyTiJJMGGrC7tyEba+4TIqeGgvD74p57XFbN7LOJWmnAiK8b
+BLhQqPgOCXqrna00GnNKKx7AzgYHqlq03tGlX858aH18rkSRVk3UhkTkGTSr3iQn
+aJeN/0HbpGr67bimf4bqlCY=
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/client-keys/user1.key.pem b/tests/certificate-authority/client-keys/user1.key.pem
index 311d64141f..89c2374830 100644
--- a/tests/certificate-authority/client-keys/user1.key.pem
+++ b/tests/certificate-authority/client-keys/user1.key.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEAzmKqCvg9RRkBb0wMY/lwFpIkAtI9Xreboz8iii+sxYn0Ia1x
-B9lNQfAOisiVeBDof8q5+awdbRg5BsKEtJMMHXgPSNIy3K/r6JtKgTVkSXZJsHWa
-It3Q/kBL1ibPMRbb5vHTMk5EtgM/MnU2Hf+RCVGzTggQKSLb3VZmJVHNfYlGgvuQ
-y04CgompB+xPXg6L0QDDf1WEt4G5z8zHomy62r9h1dqShm1Bt9mRrYwx8teAwMsg
-8OptT7T2rtq7Z2rxGMbOtafGc5ej9dCyyshvDMklgBIGyAAC2cDDts/MJfr5wvo9
-lVHKIRmi/QcpfJHK+ttDmHIQy5Ld0eqgq3R8owIDAQABAoIBAQCvCfEL8rQMSYP0
-//u2QtT036dZGTRhg7mlf6NsrbiLpU//zBkEPiGPHelHfY1/Ul/OGoMWpQoj/5pG
-CG4CtIBe8feMnHH0x+N92U8cPMs8nu0qkuNSVOyu5psrGqk5ChkhStIDZWxTLnfH
-9K8cTCeXTsqTELWcHet5UpC5cCKnJ2ISnAHVzOFhr9OzBXcAF76ytra4QQZAgNPG
-c8lcuJVhPnFXxJMB+jvBHRnIZe4OFC6iJGM7n0FinR/X67ejd6hFf6rNLNaoqVc1
-dOxmj6RHSvxuXsSezY2WlyZBzrjG7e2ntcyQXsVuNf/vn487FkmJY70hKYY6sKxm
-K6/rTBjRAoGBAPkoNbB3GDuAYNeqhnPFzPYPAxS9/el+DJzIfgBaw1fHW3c9/cfX
-xbaShH6mgGaxuiPH1t0ZDC7CbyeBiCgyTc9nsxDGzSpVxPVM7wLK3b1jVgxib6w7
-tAmyYNsLQXlRASFGHrUnTR6BMGO2SUB58G8WGK1BSCd+KyNEkNe/2eL7AoGBANQN
-u42E1q/OiZr40A1IiXCbG4aWv+js2Z9yk7tJ9KAr5e7r741H4Zc5nKu5MmNKDtQu
-U0By4qgWiOYV8PomMJxEiyJ+wcITF3XMYJb18feYdTah2F/Rp1EZdkLa45rmOcsf
-orX5mQkZETzt3OXvbmcn9NQnhOLsJYQzYdEa0lx5AoGAb5UIZl0PpyYZOLyPti1x
-WwjiEln76qOetmA7vaDoNtl7Ju3GR8dkLh1z5NxgSJ1zhS6sFRxwjkhZS1IBTi8p
-FaeVVAAURc9fg5POvmtn3rcsBCPZa0LZoDYYlkB2NASJAwPKIMrXCMBGkYFDUPLL
-MJSuvHit/bHNU+ATFew/gh0CgYBt4PvJVgcErCoDgmAUMfz9u3Gk6OJiaLBPfcht
-KOI4SObpSZokhBWyDalQFjO03UAX1DVRVPZ7kMm5J69pf3Z60s2hvzrZPJlQcemu
-75xE5tv9xhlfdTyUunPcKp37usZBqY/faYlR/IpBHyPyhYGYtEyZzix+hUzfVtyd
-xJ8ySQKBgBOGSy4vtkT+GWFyNdQiQgUjNQBKanpoE1EonWck4iSTBhqwu7chG2vu
-EyKnhoLw++Kee1xWzeyziVppwIivGwS4UKj4Dgl6q52tNBpzSisewM4GB6patN7R
-pV/OfGh9fK5EkVZN1IZE5Bk0q94kJ2iXjf9B26Rq+u24pn+G6pQm
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEAzmKqCvg9RRkBb0wMY/lwFpIkAtI9Xreboz8iii+sxYn0Ia1x
+B9lNQfAOisiVeBDof8q5+awdbRg5BsKEtJMMHXgPSNIy3K/r6JtKgTVkSXZJsHWa
+It3Q/kBL1ibPMRbb5vHTMk5EtgM/MnU2Hf+RCVGzTggQKSLb3VZmJVHNfYlGgvuQ
+y04CgompB+xPXg6L0QDDf1WEt4G5z8zHomy62r9h1dqShm1Bt9mRrYwx8teAwMsg
+8OptT7T2rtq7Z2rxGMbOtafGc5ej9dCyyshvDMklgBIGyAAC2cDDts/MJfr5wvo9
+lVHKIRmi/QcpfJHK+ttDmHIQy5Ld0eqgq3R8owIDAQABAoIBAQCvCfEL8rQMSYP0
+//u2QtT036dZGTRhg7mlf6NsrbiLpU//zBkEPiGPHelHfY1/Ul/OGoMWpQoj/5pG
+CG4CtIBe8feMnHH0x+N92U8cPMs8nu0qkuNSVOyu5psrGqk5ChkhStIDZWxTLnfH
+9K8cTCeXTsqTELWcHet5UpC5cCKnJ2ISnAHVzOFhr9OzBXcAF76ytra4QQZAgNPG
+c8lcuJVhPnFXxJMB+jvBHRnIZe4OFC6iJGM7n0FinR/X67ejd6hFf6rNLNaoqVc1
+dOxmj6RHSvxuXsSezY2WlyZBzrjG7e2ntcyQXsVuNf/vn487FkmJY70hKYY6sKxm
+K6/rTBjRAoGBAPkoNbB3GDuAYNeqhnPFzPYPAxS9/el+DJzIfgBaw1fHW3c9/cfX
+xbaShH6mgGaxuiPH1t0ZDC7CbyeBiCgyTc9nsxDGzSpVxPVM7wLK3b1jVgxib6w7
+tAmyYNsLQXlRASFGHrUnTR6BMGO2SUB58G8WGK1BSCd+KyNEkNe/2eL7AoGBANQN
+u42E1q/OiZr40A1IiXCbG4aWv+js2Z9yk7tJ9KAr5e7r741H4Zc5nKu5MmNKDtQu
+U0By4qgWiOYV8PomMJxEiyJ+wcITF3XMYJb18feYdTah2F/Rp1EZdkLa45rmOcsf
+orX5mQkZETzt3OXvbmcn9NQnhOLsJYQzYdEa0lx5AoGAb5UIZl0PpyYZOLyPti1x
+WwjiEln76qOetmA7vaDoNtl7Ju3GR8dkLh1z5NxgSJ1zhS6sFRxwjkhZS1IBTi8p
+FaeVVAAURc9fg5POvmtn3rcsBCPZa0LZoDYYlkB2NASJAwPKIMrXCMBGkYFDUPLL
+MJSuvHit/bHNU+ATFew/gh0CgYBt4PvJVgcErCoDgmAUMfz9u3Gk6OJiaLBPfcht
+KOI4SObpSZokhBWyDalQFjO03UAX1DVRVPZ7kMm5J69pf3Z60s2hvzrZPJlQcemu
+75xE5tv9xhlfdTyUunPcKp37usZBqY/faYlR/IpBHyPyhYGYtEyZzix+hUzfVtyd
+xJ8ySQKBgBOGSy4vtkT+GWFyNdQiQgUjNQBKanpoE1EonWck4iSTBhqwu7chG2vu
+EyKnhoLw++Kee1xWzeyziVppwIivGwS4UKj4Dgl6q52tNBpzSisewM4GB6patN7R
+pV/OfGh9fK5EkVZN1IZE5Bk0q94kJ2iXjf9B26Rq+u24pn+G6pQm
+-----END RSA PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/broker_client.cert.pem b/tests/certificate-authority/ec/broker_client.cert.pem
index 2993ed41ad..6aa5479fad 100644
--- a/tests/certificate-authority/ec/broker_client.cert.pem
+++ b/tests/certificate-authority/ec/broker_client.cert.pem
@@ -1,9 +1,9 @@
------BEGIN CERTIFICATE-----
-MIIBIjCBygIUSAxJKNrIEmn3SVyw5rcYhwhKulwwCgYIKoZIzj0EAwIwETEPMA0G
-A1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTE1M1oXDTMzMTEyMTExNTE1M1owGDEW
-MBQGA1UEAwwNYnJva2VyX2NsaWVudDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA
-BGxRL4naRhrTZ9T2WdMBkCNmiamkrzEiDO55RVjhpHGWIoqPOvzs8i97vCVx39GV
-vV/9agDp2nSuXYW8ax3UKnkwCgYIKoZIzj0EAwIDRwAwRAIge8qxnGgmv5h+Yw3Y
-Ab/6xFD5QWERGMlfIl4ZCO3o6S0CICS/4jj45GfAPZS9QPfuo15rEa9Rbvvmmi+K
-yY0JA0SP
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBIjCBygIUSAxJKNrIEmn3SVyw5rcYhwhKulwwCgYIKoZIzj0EAwIwETEPMA0G
+A1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTE1M1oXDTMzMTEyMTExNTE1M1owGDEW
+MBQGA1UEAwwNYnJva2VyX2NsaWVudDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA
+BGxRL4naRhrTZ9T2WdMBkCNmiamkrzEiDO55RVjhpHGWIoqPOvzs8i97vCVx39GV
+vV/9agDp2nSuXYW8ax3UKnkwCgYIKoZIzj0EAwIDRwAwRAIge8qxnGgmv5h+Yw3Y
+Ab/6xFD5QWERGMlfIl4ZCO3o6S0CICS/4jj45GfAPZS9QPfuo15rEa9Rbvvmmi+K
+yY0JA0SP
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/broker_client.csr.pem b/tests/certificate-authority/ec/broker_client.csr.pem
index 1f10a3c77f..9da45cdaa9 100644
--- a/tests/certificate-authority/ec/broker_client.csr.pem
+++ b/tests/certificate-authority/ec/broker_client.csr.pem
@@ -1,7 +1,7 @@
------BEGIN CERTIFICATE REQUEST-----
-MIHTMHoCAQAwGDEWMBQGA1UEAwwNYnJva2VyX2NsaWVudDBZMBMGByqGSM49AgEG
-CCqGSM49AwEHA0IABGxRL4naRhrTZ9T2WdMBkCNmiamkrzEiDO55RVjhpHGWIoqP
-Ovzs8i97vCVx39GVvV/9agDp2nSuXYW8ax3UKnmgADAKBggqhkjOPQQDAgNJADBG
-AiEA8sGFcbQuUGIUTCXTQ0z9b0eIYFIDVOcGSInQ+0unMJMCIQCmH0GlXZRGB2lx
-HtfIz76HNnVu153LsHE11AEx7d/j2g==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIHTMHoCAQAwGDEWMBQGA1UEAwwNYnJva2VyX2NsaWVudDBZMBMGByqGSM49AgEG
+CCqGSM49AwEHA0IABGxRL4naRhrTZ9T2WdMBkCNmiamkrzEiDO55RVjhpHGWIoqP
+Ovzs8i97vCVx39GVvV/9agDp2nSuXYW8ax3UKnmgADAKBggqhkjOPQQDAgNJADBG
+AiEA8sGFcbQuUGIUTCXTQ0z9b0eIYFIDVOcGSInQ+0unMJMCIQCmH0GlXZRGB2lx
+HtfIz76HNnVu153LsHE11AEx7d/j2g==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/ec/broker_client.key-pk8.pem b/tests/certificate-authority/ec/broker_client.key-pk8.pem
index 124073b024..bebd7d6598 100644
--- a/tests/certificate-authority/ec/broker_client.key-pk8.pem
+++ b/tests/certificate-authority/ec/broker_client.key-pk8.pem
@@ -1,5 +1,5 @@
------BEGIN PRIVATE KEY-----
-MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgA92tkFXxKHYUJbeB
-vvnMaGBnP2IenpF66Fikb06xbUKhRANCAARsUS+J2kYa02fU9lnTAZAjZomppK8x
-IgzueUVY4aRxliKKjzr87PIve7wlcd/Rlb1f/WoA6dp0rl2FvGsd1Cp5
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgA92tkFXxKHYUJbeB
+vvnMaGBnP2IenpF66Fikb06xbUKhRANCAARsUS+J2kYa02fU9lnTAZAjZomppK8x
+IgzueUVY4aRxliKKjzr87PIve7wlcd/Rlb1f/WoA6dp0rl2FvGsd1Cp5
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/broker_client.key.pem b/tests/certificate-authority/ec/broker_client.key.pem
index 4d4b5163b1..f32ef8a26b 100644
--- a/tests/certificate-authority/ec/broker_client.key.pem
+++ b/tests/certificate-authority/ec/broker_client.key.pem
@@ -1,8 +1,8 @@
------BEGIN EC PARAMETERS-----
-BggqhkjOPQMBBw==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MHcCAQEEIAPdrZBV8Sh2FCW3gb75zGhgZz9iHp6ReuhYpG9OsW1CoAoGCCqGSM49
-AwEHoUQDQgAEbFEvidpGGtNn1PZZ0wGQI2aJqaSvMSIM7nlFWOGkcZYiio86/Ozy
-L3u8JXHf0ZW9X/1qAOnadK5dhbxrHdQqeQ==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+BggqhkjOPQMBBw==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIAPdrZBV8Sh2FCW3gb75zGhgZz9iHp6ReuhYpG9OsW1CoAoGCCqGSM49
+AwEHoUQDQgAEbFEvidpGGtNn1PZZ0wGQI2aJqaSvMSIM7nlFWOGkcZYiio86/Ozy
+L3u8JXHf0ZW9X/1qAOnadK5dhbxrHdQqeQ==
+-----END EC PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/ca.cert.pem b/tests/certificate-authority/ec/ca.cert.pem
index c10385d997..e503378bb9 100644
--- a/tests/certificate-authority/ec/ca.cert.pem
+++ b/tests/certificate-authority/ec/ca.cert.pem
@@ -1,10 +1,10 @@
------BEGIN CERTIFICATE-----
-MIIBeDCCAR2gAwIBAgIUKRGzcPm3RVuI7tXdPDAZZ7Vhqs8wCgYIKoZIzj0EAwIw
-ETEPMA0GA1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTExNVoXDTMzMTEyMTExNTEx
-NVowETEPMA0GA1UEAwwGQ0FSb290MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
-kOKZaL45B7PUB+G25GLP1PPfTkio/DaHUML+KJjxpdCnSmq+mt/EAQWlqNPB1hJv
-6kOJ52vSxKe02BMeuROed6NTMFEwHQYDVR0OBBYEFDkqfvrnJ7PJhxJ7FTA7o8+b
-f+CRMB8GA1UdIwQYMBaAFDkqfvrnJ7PJhxJ7FTA7o8+bf+CRMA8GA1UdEwEB/wQF
-MAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhAN9+TWNNbIz8rMdkf4LGoIeQzYcAEyGJ
-90ORM5JciBdaAiEA8UsuQBD4wO1t6plnRydkGMTeb1dNDEnhsuXOXBps8fE=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBeDCCAR2gAwIBAgIUKRGzcPm3RVuI7tXdPDAZZ7Vhqs8wCgYIKoZIzj0EAwIw
+ETEPMA0GA1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTExNVoXDTMzMTEyMTExNTEx
+NVowETEPMA0GA1UEAwwGQ0FSb290MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
+kOKZaL45B7PUB+G25GLP1PPfTkio/DaHUML+KJjxpdCnSmq+mt/EAQWlqNPB1hJv
+6kOJ52vSxKe02BMeuROed6NTMFEwHQYDVR0OBBYEFDkqfvrnJ7PJhxJ7FTA7o8+b
+f+CRMB8GA1UdIwQYMBaAFDkqfvrnJ7PJhxJ7FTA7o8+bf+CRMA8GA1UdEwEB/wQF
+MAMBAf8wCgYIKoZIzj0EAwIDSQAwRgIhAN9+TWNNbIz8rMdkf4LGoIeQzYcAEyGJ
+90ORM5JciBdaAiEA8UsuQBD4wO1t6plnRydkGMTeb1dNDEnhsuXOXBps8fE=
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/ca.cert.srl b/tests/certificate-authority/ec/ca.cert.srl
index a30f44e979..d61bb4689e 100644
--- a/tests/certificate-authority/ec/ca.cert.srl
+++ b/tests/certificate-authority/ec/ca.cert.srl
@@ -1 +1 @@
-480C4928DAC81269F7495CB0E6B71887084ABA5D
+480C4928DAC81269F7495CB0E6B71887084ABA5D
diff --git a/tests/certificate-authority/ec/ca.key.pem b/tests/certificate-authority/ec/ca.key.pem
index 1255354584..3371cd954b 100644
--- a/tests/certificate-authority/ec/ca.key.pem
+++ b/tests/certificate-authority/ec/ca.key.pem
@@ -1,8 +1,8 @@
------BEGIN EC PARAMETERS-----
-BggqhkjOPQMBBw==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MHcCAQEEIPT1Jap2sJ7NUGWT6q0fnSRoVRNNryWe/JHPwttyQke4oAoGCCqGSM49
-AwEHoUQDQgAEkOKZaL45B7PUB+G25GLP1PPfTkio/DaHUML+KJjxpdCnSmq+mt/E
-AQWlqNPB1hJv6kOJ52vSxKe02BMeuROedw==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+BggqhkjOPQMBBw==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIPT1Jap2sJ7NUGWT6q0fnSRoVRNNryWe/JHPwttyQke4oAoGCCqGSM49
+AwEHoUQDQgAEkOKZaL45B7PUB+G25GLP1PPfTkio/DaHUML+KJjxpdCnSmq+mt/E
+AQWlqNPB1hJv6kOJ52vSxKe02BMeuROedw==
+-----END EC PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/certificate_generation.txt b/tests/certificate-authority/ec/certificate_generation.txt
index 7a6caa7b8f..6820fbad4f 100644
--- a/tests/certificate-authority/ec/certificate_generation.txt
+++ b/tests/certificate-authority/ec/certificate_generation.txt
@@ -1,34 +1,34 @@
-# CA Private Key
-openssl ecparam -name secp256r1 -genkey  -out ca.key.pem
-# Request certificate
-openssl req -x509 -new -nodes -key ca.key.pem -subj "/CN=CARoot" -days 3650 -out ca.cert.pem
-
-# Server Private Key
-openssl ecparam -name secp256r1 -genkey  -out server.key.pem
-# Convert to pkcs8
-openssl pkcs8 -topk8 -inform PEM -outform PEM -in server.key.pem -out server.key-pk8.pem -nocrypt
-# Request certificate  
-openssl req -new -config server.conf -key server.key.pem -out server.csr.pem -sha256
-# Sign with CA
-openssl x509 -req -in server.csr.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out server.cert.pem -days 3650 -extensions v3_ext -extfile server.conf -sha256
-
-# Broker internal client Private Key
-openssl ecparam -name secp256r1 -genkey  -out broker_client.key.pem
-# Convert to pkcs8
-openssl pkcs8 -topk8 -inform PEM -outform PEM -in broker_client.key.pem -out broker_client.key-pk8.pem -nocrypt
-# Request certificate
-openssl req -new -subj "/CN=broker_client" -key broker_client.key.pem -out broker_client.csr.pem -sha256
-# Sign with CA
-openssl x509 -req -in broker_client.csr.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out broker_client.cert.pem -days 3650 -sha256
-
-
-# Client Private Key
-openssl ecparam -name secp256r1 -genkey  -out client.key.pem
-# Convert to pkcs8
-openssl pkcs8 -topk8 -inform PEM -outform PEM -in client.key.pem -out client.key-pk8.pem -nocrypt
-# Request certificate
-openssl req -new -subj "/CN=client" -key client.key.pem -out client.csr.pem -sha256
-# Sign with CA
-openssl x509 -req -in client.csr.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out client.cert.pem -days 3650 -sha256
-
-
+# CA Private Key
+openssl ecparam -name secp256r1 -genkey  -out ca.key.pem
+# Request certificate
+openssl req -x509 -new -nodes -key ca.key.pem -subj "/CN=CARoot" -days 3650 -out ca.cert.pem
+
+# Server Private Key
+openssl ecparam -name secp256r1 -genkey  -out server.key.pem
+# Convert to pkcs8
+openssl pkcs8 -topk8 -inform PEM -outform PEM -in server.key.pem -out server.key-pk8.pem -nocrypt
+# Request certificate  
+openssl req -new -config server.conf -key server.key.pem -out server.csr.pem -sha256
+# Sign with CA
+openssl x509 -req -in server.csr.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out server.cert.pem -days 3650 -extensions v3_ext -extfile server.conf -sha256
+
+# Broker internal client Private Key
+openssl ecparam -name secp256r1 -genkey  -out broker_client.key.pem
+# Convert to pkcs8
+openssl pkcs8 -topk8 -inform PEM -outform PEM -in broker_client.key.pem -out broker_client.key-pk8.pem -nocrypt
+# Request certificate
+openssl req -new -subj "/CN=broker_client" -key broker_client.key.pem -out broker_client.csr.pem -sha256
+# Sign with CA
+openssl x509 -req -in broker_client.csr.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out broker_client.cert.pem -days 3650 -sha256
+
+
+# Client Private Key
+openssl ecparam -name secp256r1 -genkey  -out client.key.pem
+# Convert to pkcs8
+openssl pkcs8 -topk8 -inform PEM -outform PEM -in client.key.pem -out client.key-pk8.pem -nocrypt
+# Request certificate
+openssl req -new -subj "/CN=client" -key client.key.pem -out client.csr.pem -sha256
+# Sign with CA
+openssl x509 -req -in client.csr.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out client.cert.pem -days 3650 -sha256
+
+
diff --git a/tests/certificate-authority/ec/client.cert.pem b/tests/certificate-authority/ec/client.cert.pem
index 87701a6938..ed88438e0f 100644
--- a/tests/certificate-authority/ec/client.cert.pem
+++ b/tests/certificate-authority/ec/client.cert.pem
@@ -1,8 +1,8 @@
------BEGIN CERTIFICATE-----
-MIIBHDCBwwIUSAxJKNrIEmn3SVyw5rcYhwhKul0wCgYIKoZIzj0EAwIwETEPMA0G
-A1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTIwNVoXDTMzMTEyMTExNTIwNVowETEP
-MA0GA1UEAwwGY2xpZW50MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4QZJuqZS
-mSDbjkoFGKvtYmSVaJ3IjtmgWsgQio4F5phIXpM6IZZfcLkJToY0b9W2jGhODK55
-jA+zkRxHrICkwTAKBggqhkjOPQQDAgNIADBFAiEA0iGNqg4t16SxFdZJu7o9gK8R
-XVXphQ/9XAtw4XqfCUYCIGLoExE9XKdkzZ+sahFOpKD6YLZ1GgPRBPpBJFBGTYu7
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBHDCBwwIUSAxJKNrIEmn3SVyw5rcYhwhKul0wCgYIKoZIzj0EAwIwETEPMA0G
+A1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTIwNVoXDTMzMTEyMTExNTIwNVowETEP
+MA0GA1UEAwwGY2xpZW50MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4QZJuqZS
+mSDbjkoFGKvtYmSVaJ3IjtmgWsgQio4F5phIXpM6IZZfcLkJToY0b9W2jGhODK55
+jA+zkRxHrICkwTAKBggqhkjOPQQDAgNIADBFAiEA0iGNqg4t16SxFdZJu7o9gK8R
+XVXphQ/9XAtw4XqfCUYCIGLoExE9XKdkzZ+sahFOpKD6YLZ1GgPRBPpBJFBGTYu7
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/client.csr.pem b/tests/certificate-authority/ec/client.csr.pem
index 4ec08d410f..571e164752 100644
--- a/tests/certificate-authority/ec/client.csr.pem
+++ b/tests/certificate-authority/ec/client.csr.pem
@@ -1,7 +1,7 @@
------BEGIN CERTIFICATE REQUEST-----
-MIHLMHMCAQAwETEPMA0GA1UEAwwGY2xpZW50MFkwEwYHKoZIzj0CAQYIKoZIzj0D
-AQcDQgAE4QZJuqZSmSDbjkoFGKvtYmSVaJ3IjtmgWsgQio4F5phIXpM6IZZfcLkJ
-ToY0b9W2jGhODK55jA+zkRxHrICkwaAAMAoGCCqGSM49BAMCA0gAMEUCIQDNZOBD
-Z/YAWKEeRSVqhPvIpFYob1gmQfDcBJdG8e0K8wIgcfO0PLquIZP9P8VrDkkLQdZ9
-krOKk+F/LF9aqQBHTbU=
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIHLMHMCAQAwETEPMA0GA1UEAwwGY2xpZW50MFkwEwYHKoZIzj0CAQYIKoZIzj0D
+AQcDQgAE4QZJuqZSmSDbjkoFGKvtYmSVaJ3IjtmgWsgQio4F5phIXpM6IZZfcLkJ
+ToY0b9W2jGhODK55jA+zkRxHrICkwaAAMAoGCCqGSM49BAMCA0gAMEUCIQDNZOBD
+Z/YAWKEeRSVqhPvIpFYob1gmQfDcBJdG8e0K8wIgcfO0PLquIZP9P8VrDkkLQdZ9
+krOKk+F/LF9aqQBHTbU=
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/ec/client.key-pk8.pem b/tests/certificate-authority/ec/client.key-pk8.pem
index 2b07827f21..8427abe6c1 100644
--- a/tests/certificate-authority/ec/client.key-pk8.pem
+++ b/tests/certificate-authority/ec/client.key-pk8.pem
@@ -1,5 +1,5 @@
------BEGIN PRIVATE KEY-----
-MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgrC3O+TuZ82b1bD1M
-SI9lMu6aaebqfoggcnaaAyUUstKhRANCAAThBkm6plKZINuOSgUYq+1iZJVonciO
-2aBayBCKjgXmmEhekzohll9wuQlOhjRv1baMaE4MrnmMD7ORHEesgKTB
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgrC3O+TuZ82b1bD1M
+SI9lMu6aaebqfoggcnaaAyUUstKhRANCAAThBkm6plKZINuOSgUYq+1iZJVonciO
+2aBayBCKjgXmmEhekzohll9wuQlOhjRv1baMaE4MrnmMD7ORHEesgKTB
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/client.key.pem b/tests/certificate-authority/ec/client.key.pem
index ac1207fa51..7b944dd9a2 100644
--- a/tests/certificate-authority/ec/client.key.pem
+++ b/tests/certificate-authority/ec/client.key.pem
@@ -1,8 +1,8 @@
------BEGIN EC PARAMETERS-----
-BggqhkjOPQMBBw==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MHcCAQEEIKwtzvk7mfNm9Ww9TEiPZTLummnm6n6IIHJ2mgMlFLLSoAoGCCqGSM49
-AwEHoUQDQgAE4QZJuqZSmSDbjkoFGKvtYmSVaJ3IjtmgWsgQio4F5phIXpM6IZZf
-cLkJToY0b9W2jGhODK55jA+zkRxHrICkwQ==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+BggqhkjOPQMBBw==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIKwtzvk7mfNm9Ww9TEiPZTLummnm6n6IIHJ2mgMlFLLSoAoGCCqGSM49
+AwEHoUQDQgAE4QZJuqZSmSDbjkoFGKvtYmSVaJ3IjtmgWsgQio4F5phIXpM6IZZf
+cLkJToY0b9W2jGhODK55jA+zkRxHrICkwQ==
+-----END EC PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/jks/broker_client.signed.cert.pem b/tests/certificate-authority/ec/jks/broker_client.signed.cert.pem
index b91c69400c..dd11bcdfb5 100644
--- a/tests/certificate-authority/ec/jks/broker_client.signed.cert.pem
+++ b/tests/certificate-authority/ec/jks/broker_client.signed.cert.pem
@@ -1,11 +1,11 @@
------BEGIN CERTIFICATE-----
-MIIBfTCCASQCFAJ6wB27laA1BCNConaAQPValPtaMAoGCCqGSM49BAMCMBExDzAN
-BgNVBAMMBkNBUm9vdDAeFw0yMzExMjUwNzAzNTNaFw0zMzExMjIwNzAzNTNaMHIx
-EDAOBgNVBAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vu
-a25vd24xEDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xFjAUBgNV
-BAMMDWJyb2tlcl9jbGllbnQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATRDn+O
-VCLOd1WvPO8UxUZGZZgpyVMGHrudKRJZdQD1MHJXSBzF2BKkaqEznAbUkceAqTvS
-zDxZsgktRPmn152yMAoGCCqGSM49BAMCA0cAMEQCIArXdTOx19Nn/a6bsfTYurQW
-4cepF5VKKijEjzyV69/BAiBpg60QwoZeSmz6bmil2zSb65jXrTzwhLpUZckVuHKn
-og==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBfTCCASQCFAJ6wB27laA1BCNConaAQPValPtaMAoGCCqGSM49BAMCMBExDzAN
+BgNVBAMMBkNBUm9vdDAeFw0yMzExMjUwNzAzNTNaFw0zMzExMjIwNzAzNTNaMHIx
+EDAOBgNVBAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vu
+a25vd24xEDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xFjAUBgNV
+BAMMDWJyb2tlcl9jbGllbnQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATRDn+O
+VCLOd1WvPO8UxUZGZZgpyVMGHrudKRJZdQD1MHJXSBzF2BKkaqEznAbUkceAqTvS
+zDxZsgktRPmn152yMAoGCCqGSM49BAMCA0cAMEQCIArXdTOx19Nn/a6bsfTYurQW
+4cepF5VKKijEjzyV69/BAiBpg60QwoZeSmz6bmil2zSb65jXrTzwhLpUZckVuHKn
+og==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/jks/ca.cert.pem b/tests/certificate-authority/ec/jks/ca.cert.pem
index a235464be7..9d90c7c0cd 100644
--- a/tests/certificate-authority/ec/jks/ca.cert.pem
+++ b/tests/certificate-authority/ec/jks/ca.cert.pem
@@ -1,10 +1,10 @@
------BEGIN CERTIFICATE-----
-MIIBdjCCAR2gAwIBAgIUfHm94cF84m6FrJVNywJI4qTGZAEwCgYIKoZIzj0EAwIw
-ETEPMA0GA1UEAwwGQ0FSb290MB4XDTIzMTEyNTAxMzQzM1oXDTMzMTEyMjAxMzQz
-M1owETEPMA0GA1UEAwwGQ0FSb290MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
-Sxvkij8HQ+g07SnOLz1in81iGKY7lOAbJ1r4ihMVnOVjS2A4ZVGXHM2wp5ZB9r3Y
-jPByBiaPApm/J17JwlXynqNTMFEwHQYDVR0OBBYEFKqDJwbgz0/Q3EKJ78OVJI5k
-8+RYMB8GA1UdIwQYMBaAFKqDJwbgz0/Q3EKJ78OVJI5k8+RYMA8GA1UdEwEB/wQF
-MAMBAf8wCgYIKoZIzj0EAwIDRwAwRAIgEF9RiwV0oBh9x1AvLFPoK5nnUlJ+0MNE
-zz8Zw284zkICIDUZOPN/E7ZmTKzfoZ0EkxRrinEZ5M538aNbYFAUYoK+
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBdjCCAR2gAwIBAgIUfHm94cF84m6FrJVNywJI4qTGZAEwCgYIKoZIzj0EAwIw
+ETEPMA0GA1UEAwwGQ0FSb290MB4XDTIzMTEyNTAxMzQzM1oXDTMzMTEyMjAxMzQz
+M1owETEPMA0GA1UEAwwGQ0FSb290MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
+Sxvkij8HQ+g07SnOLz1in81iGKY7lOAbJ1r4ihMVnOVjS2A4ZVGXHM2wp5ZB9r3Y
+jPByBiaPApm/J17JwlXynqNTMFEwHQYDVR0OBBYEFKqDJwbgz0/Q3EKJ78OVJI5k
+8+RYMB8GA1UdIwQYMBaAFKqDJwbgz0/Q3EKJ78OVJI5k8+RYMA8GA1UdEwEB/wQF
+MAMBAf8wCgYIKoZIzj0EAwIDRwAwRAIgEF9RiwV0oBh9x1AvLFPoK5nnUlJ+0MNE
+zz8Zw284zkICIDUZOPN/E7ZmTKzfoZ0EkxRrinEZ5M538aNbYFAUYoK+
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/jks/ca.cert.srl b/tests/certificate-authority/ec/jks/ca.cert.srl
index c7b003ddff..8a15493a5a 100644
--- a/tests/certificate-authority/ec/jks/ca.cert.srl
+++ b/tests/certificate-authority/ec/jks/ca.cert.srl
@@ -1 +1 @@
-027AC01DBB95A035042342A2768040F55A94FB5B
+027AC01DBB95A035042342A2768040F55A94FB5B
diff --git a/tests/certificate-authority/ec/jks/ca.key.pem b/tests/certificate-authority/ec/jks/ca.key.pem
index 57e595f139..19ba8de319 100644
--- a/tests/certificate-authority/ec/jks/ca.key.pem
+++ b/tests/certificate-authority/ec/jks/ca.key.pem
@@ -1,8 +1,8 @@
------BEGIN EC PARAMETERS-----
-BggqhkjOPQMBBw==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MHcCAQEEIJ/5AX63GN8cadJUCa5Aza5592JS7go9TXNfYemS4Ku4oAoGCCqGSM49
-AwEHoUQDQgAESxvkij8HQ+g07SnOLz1in81iGKY7lOAbJ1r4ihMVnOVjS2A4ZVGX
-HM2wp5ZB9r3YjPByBiaPApm/J17JwlXyng==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+BggqhkjOPQMBBw==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIJ/5AX63GN8cadJUCa5Aza5592JS7go9TXNfYemS4Ku4oAoGCCqGSM49
+AwEHoUQDQgAESxvkij8HQ+g07SnOLz1in81iGKY7lOAbJ1r4ihMVnOVjS2A4ZVGX
+HM2wp5ZB9r3YjPByBiaPApm/J17JwlXyng==
+-----END EC PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/jks/client.signed.cert.pem b/tests/certificate-authority/ec/jks/client.signed.cert.pem
index f0d8b87dbc..d7b475a1d8 100644
--- a/tests/certificate-authority/ec/jks/client.signed.cert.pem
+++ b/tests/certificate-authority/ec/jks/client.signed.cert.pem
@@ -1,10 +1,10 @@
------BEGIN CERTIFICATE-----
-MIIBdjCCAR0CFAJ6wB27laA1BCNConaAQPValPtbMAoGCCqGSM49BAMCMBExDzAN
-BgNVBAMMBkNBUm9vdDAeFw0yMzExMjUwNzAzNTdaFw0zMzExMjIwNzAzNTdaMGsx
-EDAOBgNVBAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vu
-a25vd24xEDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xDzANBgNV
-BAMTBmNsaWVudDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFWCAP7euI24gBmz
-07/uQDfPaMLVwoTIG9+0bCGLFZ/mLLAvamPDz+PZ/JnthrWeXaAUYfLW5pApiLNR
-Elf2RBwwCgYIKoZIzj0EAwIDRwAwRAIgEOvnGOeS9KdZ301pMOqovNDxxr1Sd4hy
-rp9a3+3LBvECIBxzHQ/IZN8nt9eG9Cm8vikOlmI1AmvMIKmo1n/9NwGr
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBdjCCAR0CFAJ6wB27laA1BCNConaAQPValPtbMAoGCCqGSM49BAMCMBExDzAN
+BgNVBAMMBkNBUm9vdDAeFw0yMzExMjUwNzAzNTdaFw0zMzExMjIwNzAzNTdaMGsx
+EDAOBgNVBAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vu
+a25vd24xEDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xDzANBgNV
+BAMTBmNsaWVudDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABFWCAP7euI24gBmz
+07/uQDfPaMLVwoTIG9+0bCGLFZ/mLLAvamPDz+PZ/JnthrWeXaAUYfLW5pApiLNR
+Elf2RBwwCgYIKoZIzj0EAwIDRwAwRAIgEOvnGOeS9KdZ301pMOqovNDxxr1Sd4hy
+rp9a3+3LBvECIBxzHQ/IZN8nt9eG9Cm8vikOlmI1AmvMIKmo1n/9NwGr
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/jks/key_store_generation.txt b/tests/certificate-authority/ec/jks/key_store_generation.txt
index 62c48e9a08..a0a9aae5f7 100644
--- a/tests/certificate-authority/ec/jks/key_store_generation.txt
+++ b/tests/certificate-authority/ec/jks/key_store_generation.txt
@@ -1,33 +1,33 @@
-# CA Private Key
-openssl ecparam -name secp256r1 -genkey -out ca.key.pem
-# Request certificate
-openssl req -x509 -new -nodes -key ca.key.pem -subj "/CN=CARoot" -days 3650 -out ca.cert.pem
-# Build Trust Cert
-keytool -keystore ca.truststore.jks -alias ca -importcert -file ca.cert.pem -storepass rootpw -keypass rootpw -noprompt
-
-
-# Create server keystore
-keytool -keystore server.keystore.jks -alias server -keyalg EC -validity 3600 -genkey -storepass serverpw -keypass serverpw -dname 'CN=server,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown' -noprompt
-# Export the certificate from the keystore:
-keytool -keystore server.keystore.jks -alias server -certreq -file server.cert.pem -storepass serverpw -keypass serverpw -noprompt
-# Sign it with the CA:
-openssl x509 -req -in server.cert.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out server.signed.cert.pem -days 3650 -sha256
-# Import signed cert into key store
-keytool -keystore server.keystore.jks -alias ca -importcert -file ca.cert.pem -storepass serverpw -keypass serverpw -noprompt
-keytool -keystore server.keystore.jks -alias server -importcert -file server.signed.cert.pem -storepass serverpw -keypass serverpw -noprompt
-
-
-# Create broker client keystore
-keytool -keystore broker_client.keystore.jks -alias broker_client -keyalg EC -validity 3600 -genkey -storepass brokerclientpw -keypass brokerclientpw -dname 'CN=broker_client,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown' -noprompt
-keytool -keystore broker_client.keystore.jks -alias broker_client -certreq -file broker_client.cert.pem -storepass brokerclientpw -keypass brokerclientpw -noprompt
-openssl x509 -req -in broker_client.cert.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out broker_client.signed.cert.pem -days 3650 -sha256
-keytool -keystore broker_client.keystore.jks -alias ca -importcert -file ca.cert.pem -storepass brokerclientpw -keypass brokerclientpw -noprompt
-keytool -keystore broker_client.keystore.jks -alias broker_client -importcert -file broker_client.signed.cert.pem -storepass brokerclientpw -keypass brokerclientpw -noprompt
-
-
-# Create client keystore
-keytool -keystore client.keystore.jks -alias client -keyalg EC -validity 3600 -genkey -storepass clientpw -keypass clientpw -dname 'CN=client,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown' -noprompt
-keytool -keystore client.keystore.jks -alias client -certreq -file client.cert.pem -storepass clientpw -keypass clientpw -noprompt
-openssl x509 -req -in client.cert.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out client.signed.cert.pem -days 3650 -sha256
-keytool -keystore client.keystore.jks -alias ca -importcert -file ca.cert.pem -storepass clientpw -keypass clientpw -noprompt
+# CA Private Key
+openssl ecparam -name secp256r1 -genkey -out ca.key.pem
+# Request certificate
+openssl req -x509 -new -nodes -key ca.key.pem -subj "/CN=CARoot" -days 3650 -out ca.cert.pem
+# Build Trust Cert
+keytool -keystore ca.truststore.jks -alias ca -importcert -file ca.cert.pem -storepass rootpw -keypass rootpw -noprompt
+
+
+# Create server keystore
+keytool -keystore server.keystore.jks -alias server -keyalg EC -validity 3600 -genkey -storepass serverpw -keypass serverpw -dname 'CN=server,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown' -noprompt
+# Export the certificate from the keystore:
+keytool -keystore server.keystore.jks -alias server -certreq -file server.cert.pem -storepass serverpw -keypass serverpw -noprompt
+# Sign it with the CA:
+openssl x509 -req -in server.cert.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out server.signed.cert.pem -days 3650 -sha256
+# Import signed cert into key store
+keytool -keystore server.keystore.jks -alias ca -importcert -file ca.cert.pem -storepass serverpw -keypass serverpw -noprompt
+keytool -keystore server.keystore.jks -alias server -importcert -file server.signed.cert.pem -storepass serverpw -keypass serverpw -noprompt
+
+
+# Create broker client keystore
+keytool -keystore broker_client.keystore.jks -alias broker_client -keyalg EC -validity 3600 -genkey -storepass brokerclientpw -keypass brokerclientpw -dname 'CN=broker_client,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown' -noprompt
+keytool -keystore broker_client.keystore.jks -alias broker_client -certreq -file broker_client.cert.pem -storepass brokerclientpw -keypass brokerclientpw -noprompt
+openssl x509 -req -in broker_client.cert.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out broker_client.signed.cert.pem -days 3650 -sha256
+keytool -keystore broker_client.keystore.jks -alias ca -importcert -file ca.cert.pem -storepass brokerclientpw -keypass brokerclientpw -noprompt
+keytool -keystore broker_client.keystore.jks -alias broker_client -importcert -file broker_client.signed.cert.pem -storepass brokerclientpw -keypass brokerclientpw -noprompt
+
+
+# Create client keystore
+keytool -keystore client.keystore.jks -alias client -keyalg EC -validity 3600 -genkey -storepass clientpw -keypass clientpw -dname 'CN=client,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown' -noprompt
+keytool -keystore client.keystore.jks -alias client -certreq -file client.cert.pem -storepass clientpw -keypass clientpw -noprompt
+openssl x509 -req -in client.cert.pem -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -out client.signed.cert.pem -days 3650 -sha256
+keytool -keystore client.keystore.jks -alias ca -importcert -file ca.cert.pem -storepass clientpw -keypass clientpw -noprompt
 keytool -keystore client.keystore.jks -alias client -importcert -file client.signed.cert.pem -storepass clientpw -keypass clientpw -noprompt
\ No newline at end of file
diff --git a/tests/certificate-authority/ec/jks/server.signed.cert.pem b/tests/certificate-authority/ec/jks/server.signed.cert.pem
index 79a0973173..aa6995aff5 100644
--- a/tests/certificate-authority/ec/jks/server.signed.cert.pem
+++ b/tests/certificate-authority/ec/jks/server.signed.cert.pem
@@ -1,10 +1,10 @@
------BEGIN CERTIFICATE-----
-MIIBdzCCAR0CFAJ6wB27laA1BCNConaAQPValPtQMAoGCCqGSM49BAMCMBExDzAN
-BgNVBAMMBkNBUm9vdDAeFw0yMzExMjUwMTQzMDRaFw0zMzExMjIwMTQzMDRaMGsx
-EDAOBgNVBAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vu
-a25vd24xEDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xDzANBgNV
-BAMTBnNlcnZlcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDQcG7N7b1I0Zrfe
-NMzM1n6LhmZC1xxkasZHxJ8k8lUQ1qEpKomeguB8ebON/JpfJiv+7A/gtgiqtbD2
-exhmZv4wCgYIKoZIzj0EAwIDSAAwRQIgG4IatfLHoaCGVPDxnYV3XkWzVJpAEdX6
-QIDYgmdogckCIQDpJJle7jw6PNA1o3nSZJ2o2GCOg9nmmNaKVBQfxL2E/g==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIBdzCCAR0CFAJ6wB27laA1BCNConaAQPValPtQMAoGCCqGSM49BAMCMBExDzAN
+BgNVBAMMBkNBUm9vdDAeFw0yMzExMjUwMTQzMDRaFw0zMzExMjIwMTQzMDRaMGsx
+EDAOBgNVBAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vu
+a25vd24xEDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xDzANBgNV
+BAMTBnNlcnZlcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDQcG7N7b1I0Zrfe
+NMzM1n6LhmZC1xxkasZHxJ8k8lUQ1qEpKomeguB8ebON/JpfJiv+7A/gtgiqtbD2
+exhmZv4wCgYIKoZIzj0EAwIDSAAwRQIgG4IatfLHoaCGVPDxnYV3XkWzVJpAEdX6
+QIDYgmdogckCIQDpJJle7jw6PNA1o3nSZJ2o2GCOg9nmmNaKVBQfxL2E/g==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/server.cert.pem b/tests/certificate-authority/ec/server.cert.pem
index 184aa882e2..85b03416d7 100644
--- a/tests/certificate-authority/ec/server.cert.pem
+++ b/tests/certificate-authority/ec/server.cert.pem
@@ -1,13 +1,13 @@
------BEGIN CERTIFICATE-----
-MIIB9DCCAZqgAwIBAgIUSAxJKNrIEmn3SVyw5rcYhwhKulswCgYIKoZIzj0EAwIw
-ETEPMA0GA1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTE0MloXDTMzMTEyMTExNTE0
-MlowETEPMA0GA1UEAwwGc2VydmVyMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
-8xsai5lXx2Y7TbmzB1sZr2RunBOtzHFelNBmryjgkatf0yIEy9/cCmH+DvJfjvG1
-hfZDvnVFBPaoDFwgmvb26KOBzzCBzDBMBgNVHSMERTBDgBQ5Kn765yezyYcSexUw
-O6PPm3/gkaEVpBMwETEPMA0GA1UEAwwGQ0FSb290ghQpEbNw+bdFW4ju1d08MBln
-tWGqzzAJBgNVHRMEAjAAMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEF
-BQcDATAtBgNVHREEJjAkggZwdWxzYXKCDnB1bHNhci5kZWZhdWx0hwR/AAABhwTA
-qAECMB0GA1UdDgQWBBQe+uKXtB+I7vfU+mRAMvuNYbWJSTAKBggqhkjOPQQDAgNI
-ADBFAiEAlCUpm4I5F6+OPS/lEJKIEQJILHivB3lPYW/OgXlpq5UCIFuUVgYwQ2ca
-yildeQibDy/gbxLCFVzDtYrVKf7SZSK+
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIB9DCCAZqgAwIBAgIUSAxJKNrIEmn3SVyw5rcYhwhKulswCgYIKoZIzj0EAwIw
+ETEPMA0GA1UEAwwGQ0FSb290MB4XDTIzMTEyNDExNTE0MloXDTMzMTEyMTExNTE0
+MlowETEPMA0GA1UEAwwGc2VydmVyMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
+8xsai5lXx2Y7TbmzB1sZr2RunBOtzHFelNBmryjgkatf0yIEy9/cCmH+DvJfjvG1
+hfZDvnVFBPaoDFwgmvb26KOBzzCBzDBMBgNVHSMERTBDgBQ5Kn765yezyYcSexUw
+O6PPm3/gkaEVpBMwETEPMA0GA1UEAwwGQ0FSb290ghQpEbNw+bdFW4ju1d08MBln
+tWGqzzAJBgNVHRMEAjAAMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEF
+BQcDATAtBgNVHREEJjAkggZwdWxzYXKCDnB1bHNhci5kZWZhdWx0hwR/AAABhwTA
+qAECMB0GA1UdDgQWBBQe+uKXtB+I7vfU+mRAMvuNYbWJSTAKBggqhkjOPQQDAgNI
+ADBFAiEAlCUpm4I5F6+OPS/lEJKIEQJILHivB3lPYW/OgXlpq5UCIFuUVgYwQ2ca
+yildeQibDy/gbxLCFVzDtYrVKf7SZSK+
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/ec/server.conf b/tests/certificate-authority/ec/server.conf
index 557c2c2720..13e3ef41a1 100644
--- a/tests/certificate-authority/ec/server.conf
+++ b/tests/certificate-authority/ec/server.conf
@@ -1,40 +1,40 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[ req ]
-default_bits = 2048
-prompt = no
-default_md = sha256
-distinguished_name = dn
-
-[ v3_ext ]
-authorityKeyIdentifier=keyid,issuer:always
-basicConstraints=CA:FALSE
-keyUsage=critical, digitalSignature, keyEncipherment
-extendedKeyUsage=serverAuth
-subjectAltName=@alt_names
-
-[ dn ]
-CN = server
-
-[ alt_names ]
-DNS.1 = pulsar
-DNS.2 = pulsar.default
-IP.1 = 127.0.0.1
-IP.2 = 192.168.1.2
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[ req ]
+default_bits = 2048
+prompt = no
+default_md = sha256
+distinguished_name = dn
+
+[ v3_ext ]
+authorityKeyIdentifier=keyid,issuer:always
+basicConstraints=CA:FALSE
+keyUsage=critical, digitalSignature, keyEncipherment
+extendedKeyUsage=serverAuth
+subjectAltName=@alt_names
+
+[ dn ]
+CN = server
+
+[ alt_names ]
+DNS.1 = pulsar
+DNS.2 = pulsar.default
+IP.1 = 127.0.0.1
+IP.2 = 192.168.1.2
diff --git a/tests/certificate-authority/ec/server.csr.pem b/tests/certificate-authority/ec/server.csr.pem
index ac75bb2d1f..a59f15fd1c 100644
--- a/tests/certificate-authority/ec/server.csr.pem
+++ b/tests/certificate-authority/ec/server.csr.pem
@@ -1,7 +1,7 @@
------BEGIN CERTIFICATE REQUEST-----
-MIHLMHMCAQAwETEPMA0GA1UEAwwGc2VydmVyMFkwEwYHKoZIzj0CAQYIKoZIzj0D
-AQcDQgAE8xsai5lXx2Y7TbmzB1sZr2RunBOtzHFelNBmryjgkatf0yIEy9/cCmH+
-DvJfjvG1hfZDvnVFBPaoDFwgmvb26KAAMAoGCCqGSM49BAMCA0gAMEUCIFUCpVkb
-5u0EEY/4zcXFTHahm4xq/GAziFZsGS3mjwncAiEA2RGraZwclbHwjBiIChd56Xim
-SHyZ2voxfe+xJG7uX8g=
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIHLMHMCAQAwETEPMA0GA1UEAwwGc2VydmVyMFkwEwYHKoZIzj0CAQYIKoZIzj0D
+AQcDQgAE8xsai5lXx2Y7TbmzB1sZr2RunBOtzHFelNBmryjgkatf0yIEy9/cCmH+
+DvJfjvG1hfZDvnVFBPaoDFwgmvb26KAAMAoGCCqGSM49BAMCA0gAMEUCIFUCpVkb
+5u0EEY/4zcXFTHahm4xq/GAziFZsGS3mjwncAiEA2RGraZwclbHwjBiIChd56Xim
+SHyZ2voxfe+xJG7uX8g=
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/ec/server.key-pk8.pem b/tests/certificate-authority/ec/server.key-pk8.pem
index f30bd1cc58..d11b1b2ed1 100644
--- a/tests/certificate-authority/ec/server.key-pk8.pem
+++ b/tests/certificate-authority/ec/server.key-pk8.pem
@@ -1,5 +1,5 @@
------BEGIN PRIVATE KEY-----
-MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgnYGgcNz49WhMgVPD
-LmI1fYtfI/YqWDrd2jtnXFGNawShRANCAATzGxqLmVfHZjtNubMHWxmvZG6cE63M
-cV6U0GavKOCRq1/TIgTL39wKYf4O8l+O8bWF9kO+dUUE9qgMXCCa9vbo
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgnYGgcNz49WhMgVPD
+LmI1fYtfI/YqWDrd2jtnXFGNawShRANCAATzGxqLmVfHZjtNubMHWxmvZG6cE63M
+cV6U0GavKOCRq1/TIgTL39wKYf4O8l+O8bWF9kO+dUUE9qgMXCCa9vbo
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/ec/server.key.pem b/tests/certificate-authority/ec/server.key.pem
index 1725f1be43..879182f1aa 100644
--- a/tests/certificate-authority/ec/server.key.pem
+++ b/tests/certificate-authority/ec/server.key.pem
@@ -1,8 +1,8 @@
------BEGIN EC PARAMETERS-----
-BggqhkjOPQMBBw==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MHcCAQEEIJ2BoHDc+PVoTIFTwy5iNX2LXyP2Klg63do7Z1xRjWsEoAoGCCqGSM49
-AwEHoUQDQgAE8xsai5lXx2Y7TbmzB1sZr2RunBOtzHFelNBmryjgkatf0yIEy9/c
-CmH+DvJfjvG1hfZDvnVFBPaoDFwgmvb26A==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+BggqhkjOPQMBBw==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEIJ2BoHDc+PVoTIFTwy5iNX2LXyP2Klg63do7Z1xRjWsEoAoGCCqGSM49
+AwEHoUQDQgAE8xsai5lXx2Y7TbmzB1sZr2RunBOtzHFelNBmryjgkatf0yIEy9/c
+CmH+DvJfjvG1hfZDvnVFBPaoDFwgmvb26A==
+-----END EC PRIVATE KEY-----
diff --git a/tests/certificate-authority/generate_keystore.sh b/tests/certificate-authority/generate_keystore.sh
index 4f928192d1..faf7a7a080 100755
--- a/tests/certificate-authority/generate_keystore.sh
+++ b/tests/certificate-authority/generate_keystore.sh
@@ -1,63 +1,63 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-rm -rf jks
-mkdir jks
-cd jks
-
-DAYS=36500
-
-COMMON_PARAMS="-storetype JKS -storepass 111111 -keypass 111111 -noprompt"
-
-# generate keystore
-keytool -genkeypair -keystore broker.keystore.jks $COMMON_PARAMS -keyalg RSA -keysize 2048 -alias broker -validity $DAYS \
-  -dname 'CN=localhost,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown'
-keytool -genkeypair -keystore client.keystore.jks $COMMON_PARAMS -keyalg RSA -keysize 2048 -alias client -validity $DAYS \
-  -dname 'CN=clientuser,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown'
-keytool -genkeypair -keystore proxy.keystore.jks $COMMON_PARAMS -keyalg RSA -keysize 2048 -alias proxy -validity $DAYS \
-  -dname 'CN=proxy,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown'
-
-# export certificate
-keytool -exportcert -keystore broker.keystore.jks $COMMON_PARAMS -file broker.cer -alias broker
-keytool -exportcert -keystore client.keystore.jks $COMMON_PARAMS -file client.cer -alias client
-keytool -exportcert -keystore proxy.keystore.jks $COMMON_PARAMS -file proxy.cer -alias proxy
-
-# generate truststore
-keytool -importcert -keystore client.truststore.jks $COMMON_PARAMS -file client.cer -alias truststore
-keytool -importcert -keystore broker.truststore.jks $COMMON_PARAMS -file broker.cer -alias truststore
-keytool -importcert -keystore proxy.truststore.jks $COMMON_PARAMS -file proxy.cer -file client.cer -alias truststore
-
-# generate trust store with proxy and client public certs
-keytool -importcert -keystore proxy-and-client.truststore.jks $COMMON_PARAMS -file proxy.cer -alias proxy
-keytool -importcert -keystore proxy-and-client.truststore.jks $COMMON_PARAMS -file client.cer -alias client
-
-# generate a truststore without password
-java ../RemoveJksPassword.java client.truststore.jks 111111 client.truststore.nopassword.jks
-java ../RemoveJksPassword.java broker.truststore.jks 111111 broker.truststore.nopassword.jks
-java ../RemoveJksPassword.java proxy.truststore.jks 111111 proxy.truststore.nopassword.jks
-java ../RemoveJksPassword.java proxy-and-client.truststore.jks 111111 proxy-and-client.truststore.nopassword.jks
-
-# write broker truststore to pem file for use in http client as a ca cert
-keytool -keystore broker.truststore.jks -exportcert -alias truststore | openssl x509 -inform der -text > broker.truststore.pem
-
-# cleanup
-rm broker.cer
-rm client.cer
-rm proxy.cer
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+rm -rf jks
+mkdir jks
+cd jks
+
+DAYS=36500
+
+COMMON_PARAMS="-storetype JKS -storepass 111111 -keypass 111111 -noprompt"
+
+# generate keystore
+keytool -genkeypair -keystore broker.keystore.jks $COMMON_PARAMS -keyalg RSA -keysize 2048 -alias broker -validity $DAYS \
+  -dname 'CN=localhost,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown'
+keytool -genkeypair -keystore client.keystore.jks $COMMON_PARAMS -keyalg RSA -keysize 2048 -alias client -validity $DAYS \
+  -dname 'CN=clientuser,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown'
+keytool -genkeypair -keystore proxy.keystore.jks $COMMON_PARAMS -keyalg RSA -keysize 2048 -alias proxy -validity $DAYS \
+  -dname 'CN=proxy,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown'
+
+# export certificate
+keytool -exportcert -keystore broker.keystore.jks $COMMON_PARAMS -file broker.cer -alias broker
+keytool -exportcert -keystore client.keystore.jks $COMMON_PARAMS -file client.cer -alias client
+keytool -exportcert -keystore proxy.keystore.jks $COMMON_PARAMS -file proxy.cer -alias proxy
+
+# generate truststore
+keytool -importcert -keystore client.truststore.jks $COMMON_PARAMS -file client.cer -alias truststore
+keytool -importcert -keystore broker.truststore.jks $COMMON_PARAMS -file broker.cer -alias truststore
+keytool -importcert -keystore proxy.truststore.jks $COMMON_PARAMS -file proxy.cer -file client.cer -alias truststore
+
+# generate trust store with proxy and client public certs
+keytool -importcert -keystore proxy-and-client.truststore.jks $COMMON_PARAMS -file proxy.cer -alias proxy
+keytool -importcert -keystore proxy-and-client.truststore.jks $COMMON_PARAMS -file client.cer -alias client
+
+# generate a truststore without password
+java ../RemoveJksPassword.java client.truststore.jks 111111 client.truststore.nopassword.jks
+java ../RemoveJksPassword.java broker.truststore.jks 111111 broker.truststore.nopassword.jks
+java ../RemoveJksPassword.java proxy.truststore.jks 111111 proxy.truststore.nopassword.jks
+java ../RemoveJksPassword.java proxy-and-client.truststore.jks 111111 proxy-and-client.truststore.nopassword.jks
+
+# write broker truststore to pem file for use in http client as a ca cert
+keytool -keystore broker.truststore.jks -exportcert -alias truststore | openssl x509 -inform der -text > broker.truststore.pem
+
+# cleanup
+rm broker.cer
+rm client.cer
+rm proxy.cer
diff --git a/tests/certificate-authority/index.txt b/tests/certificate-authority/index.txt
index acb5eed051..ad06bcfaa1 100644
--- a/tests/certificate-authority/index.txt
+++ b/tests/certificate-authority/index.txt
@@ -1,9 +1,9 @@
-V	22920406085532Z		1000	unknown	/CN=broker.pulsar.apache.org
-V	22920406085706Z		1001	unknown	/CN=admin
-V	210318101354Z		1002	unknown	/CN=ivan
-V	22920409135604Z		1003	unknown	/CN=proxy
-V	22920410132517Z		1004	unknown	/CN=superproxy
-V	22920411084025Z		1005	unknown	/CN=user1
-V	22960802101401Z		1006	unknown	/CN=proxy.pulsar.apache.org
-V	22970222155018Z		1007	unknown	/CN=broker-localhost-SAN
-V	22970222155019Z		1008	unknown	/CN=proxy-localhost-SAN
+V	22920406085532Z		1000	unknown	/CN=broker.pulsar.apache.org
+V	22920406085706Z		1001	unknown	/CN=admin
+V	210318101354Z		1002	unknown	/CN=ivan
+V	22920409135604Z		1003	unknown	/CN=proxy
+V	22920410132517Z		1004	unknown	/CN=superproxy
+V	22920411084025Z		1005	unknown	/CN=user1
+V	22960802101401Z		1006	unknown	/CN=proxy.pulsar.apache.org
+V	22970222155018Z		1007	unknown	/CN=broker-localhost-SAN
+V	22970222155019Z		1008	unknown	/CN=proxy-localhost-SAN
diff --git a/tests/certificate-authority/jks/broker.truststore.pem b/tests/certificate-authority/jks/broker.truststore.pem
index e0fcbf6c2d..f89e9845a6 100644
--- a/tests/certificate-authority/jks/broker.truststore.pem
+++ b/tests/certificate-authority/jks/broker.truststore.pem
@@ -1,73 +1,73 @@
-Certificate:
-    Data:
-        Version: 3 (0x2)
-        Serial Number: 17442377827579325010 (0xf20fc6387303ea52)
-    Signature Algorithm: sha256WithRSAEncryption
-        Issuer: C=Unknown, ST=Unknown, L=Unknown, O=Unknown, OU=Unknown, CN=localhost
-        Validity
-            Not Before: Feb 13 05:52:32 2023 GMT
-            Not After : Jan 20 05:52:32 2123 GMT
-        Subject: C=Unknown, ST=Unknown, L=Unknown, O=Unknown, OU=Unknown, CN=localhost
-        Subject Public Key Info:
-            Public Key Algorithm: rsaEncryption
-                Public-Key: (2048 bit)
-                Modulus:
-                    00:e8:b7:df:ee:32:88:98:0e:07:18:41:fd:d8:e2:
-                    34:c8:7e:54:86:9b:d8:a3:7b:47:6e:e9:a1:8c:74:
-                    f3:0f:bb:a6:83:43:11:77:c4:9a:ab:53:74:64:46:
-                    fe:81:8f:72:03:97:0b:37:78:6e:ff:6e:64:68:eb:
-                    9e:b0:6b:ae:79:6a:50:e1:1e:1d:39:df:51:0b:04:
-                    8e:89:4b:e4:02:6b:e4:12:d3:41:47:2c:8e:75:30:
-                    14:1a:ed:32:93:a6:fe:73:7d:dc:e0:d4:93:d9:8c:
-                    44:55:d2:53:4a:0c:2e:f9:95:5f:4f:cb:2f:e5:41:
-                    c5:bc:33:88:eb:d8:52:0e:19:55:36:02:31:0f:81:
-                    0b:c2:4f:35:63:a6:06:e3:3b:93:3c:04:5c:63:32:
-                    3d:c3:26:50:96:b7:8c:67:8e:9e:d1:a3:7e:7b:54:
-                    86:35:07:fe:15:32:fb:6d:4e:e7:4c:97:95:32:e2:
-                    d8:04:8b:e2:00:4b:85:64:91:70:ae:24:88:07:47:
-                    45:7d:19:c3:c1:25:02:50:f8:f4:0a:a3:7b:6a:11:
-                    c3:6f:b9:da:06:a0:2d:3d:65:47:8e:28:d2:18:8a:
-                    45:bb:79:7b:ba:d5:d8:29:4d:4e:da:fd:b2:1e:eb:
-                    b6:59:1b:f1:c9:8a:ea:ac:7d:72:dc:8d:e7:43:7d:
-                    d3:c7
-                Exponent: 65537 (0x10001)
-        X509v3 extensions:
-            X509v3 Subject Key Identifier: 
-                88:3A:59:9D:B2:72:AC:64:FB:F3:8D:79:ED:54:FE:20:C3:83:49:24
-    Signature Algorithm: sha256WithRSAEncryption
-         71:88:eb:c7:f2:f2:84:35:f7:ab:bc:3c:ce:be:11:f9:c9:36:
-         b5:1e:93:96:cf:66:06:4a:f1:b6:f5:cc:97:b9:cd:93:0f:8a:
-         66:62:85:cb:fd:c1:63:7e:38:d9:02:0c:6b:04:38:7b:ec:82:
-         e6:25:f3:8c:99:8d:d1:20:c6:eb:5e:75:9e:b6:f0:ec:ad:9a:
-         76:22:41:bd:88:e9:c3:7f:3d:8e:9a:f1:4a:b3:e2:30:ca:e0:
-         68:39:8d:7c:e6:db:dc:fd:44:75:66:55:d3:a7:8f:eb:fb:28:
-         86:bd:ae:3e:93:9d:f6:76:32:db:05:4d:6e:34:92:16:21:85:
-         d3:0e:2f:73:d3:89:f7:69:6e:0c:74:35:95:8c:e3:ff:c6:f7:
-         5c:b4:55:c0:49:7d:00:ae:6c:88:5b:46:31:b3:62:64:62:b0:
-         0d:9c:7c:d0:84:68:d9:e3:52:ed:35:f8:5a:6f:9e:57:62:4b:
-         36:8f:f7:3e:31:15:fc:bb:df:51:c4:fd:92:96:59:d5:55:3e:
-         7b:fb:2f:2e:5a:15:be:ec:46:38:e0:c9:b4:46:cb:5c:71:4a:
-         fe:c7:19:2c:84:1c:d9:15:12:fc:40:cc:7c:fc:f4:38:22:f6:
-         ba:db:f2:05:97:c1:26:f5:cb:c0:ed:ba:16:e6:33:0c:37:3a:
-         07:b3:a3:ca
------BEGIN CERTIFICATE-----
-MIIDgjCCAmqgAwIBAgIJAPIPxjhzA+pSMA0GCSqGSIb3DQEBCwUAMG4xEDAOBgNV
-BAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vua25vd24x
-EDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xEjAQBgNVBAMTCWxv
-Y2FsaG9zdDAgFw0yMzAyMTMwNTUyMzJaGA8yMTIzMDEyMDA1NTIzMlowbjEQMA4G
-A1UEBhMHVW5rbm93bjEQMA4GA1UECBMHVW5rbm93bjEQMA4GA1UEBxMHVW5rbm93
-bjEQMA4GA1UEChMHVW5rbm93bjEQMA4GA1UECxMHVW5rbm93bjESMBAGA1UEAxMJ
-bG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6Lff7jKI
-mA4HGEH92OI0yH5UhpvYo3tHbumhjHTzD7umg0MRd8Saq1N0ZEb+gY9yA5cLN3hu
-/25kaOuesGuueWpQ4R4dOd9RCwSOiUvkAmvkEtNBRyyOdTAUGu0yk6b+c33c4NST
-2YxEVdJTSgwu+ZVfT8sv5UHFvDOI69hSDhlVNgIxD4ELwk81Y6YG4zuTPARcYzI9
-wyZQlreMZ46e0aN+e1SGNQf+FTL7bU7nTJeVMuLYBIviAEuFZJFwriSIB0dFfRnD
-wSUCUPj0CqN7ahHDb7naBqAtPWVHjijSGIpFu3l7utXYKU1O2v2yHuu2WRvxyYrq
-rH1y3I3nQ33TxwIDAQABoyEwHzAdBgNVHQ4EFgQUiDpZnbJyrGT784157VT+IMOD
-SSQwDQYJKoZIhvcNAQELBQADggEBAHGI68fy8oQ196u8PM6+EfnJNrUek5bPZgZK
-8bb1zJe5zZMPimZihcv9wWN+ONkCDGsEOHvsguYl84yZjdEgxutedZ628OytmnYi
-Qb2I6cN/PY6a8Uqz4jDK4Gg5jXzm29z9RHVmVdOnj+v7KIa9rj6TnfZ2MtsFTW40
-khYhhdMOL3PTifdpbgx0NZWM4//G91y0VcBJfQCubIhbRjGzYmRisA2cfNCEaNnj
-Uu01+FpvnldiSzaP9z4xFfy731HE/ZKWWdVVPnv7Ly5aFb7sRjjgybRGy1xxSv7H
-GSyEHNkVEvxAzHz89Dgi9rrb8gWXwSb1y8DtuhbmMww3Ogezo8o=
------END CERTIFICATE-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 17442377827579325010 (0xf20fc6387303ea52)
+    Signature Algorithm: sha256WithRSAEncryption
+        Issuer: C=Unknown, ST=Unknown, L=Unknown, O=Unknown, OU=Unknown, CN=localhost
+        Validity
+            Not Before: Feb 13 05:52:32 2023 GMT
+            Not After : Jan 20 05:52:32 2123 GMT
+        Subject: C=Unknown, ST=Unknown, L=Unknown, O=Unknown, OU=Unknown, CN=localhost
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:e8:b7:df:ee:32:88:98:0e:07:18:41:fd:d8:e2:
+                    34:c8:7e:54:86:9b:d8:a3:7b:47:6e:e9:a1:8c:74:
+                    f3:0f:bb:a6:83:43:11:77:c4:9a:ab:53:74:64:46:
+                    fe:81:8f:72:03:97:0b:37:78:6e:ff:6e:64:68:eb:
+                    9e:b0:6b:ae:79:6a:50:e1:1e:1d:39:df:51:0b:04:
+                    8e:89:4b:e4:02:6b:e4:12:d3:41:47:2c:8e:75:30:
+                    14:1a:ed:32:93:a6:fe:73:7d:dc:e0:d4:93:d9:8c:
+                    44:55:d2:53:4a:0c:2e:f9:95:5f:4f:cb:2f:e5:41:
+                    c5:bc:33:88:eb:d8:52:0e:19:55:36:02:31:0f:81:
+                    0b:c2:4f:35:63:a6:06:e3:3b:93:3c:04:5c:63:32:
+                    3d:c3:26:50:96:b7:8c:67:8e:9e:d1:a3:7e:7b:54:
+                    86:35:07:fe:15:32:fb:6d:4e:e7:4c:97:95:32:e2:
+                    d8:04:8b:e2:00:4b:85:64:91:70:ae:24:88:07:47:
+                    45:7d:19:c3:c1:25:02:50:f8:f4:0a:a3:7b:6a:11:
+                    c3:6f:b9:da:06:a0:2d:3d:65:47:8e:28:d2:18:8a:
+                    45:bb:79:7b:ba:d5:d8:29:4d:4e:da:fd:b2:1e:eb:
+                    b6:59:1b:f1:c9:8a:ea:ac:7d:72:dc:8d:e7:43:7d:
+                    d3:c7
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Subject Key Identifier: 
+                88:3A:59:9D:B2:72:AC:64:FB:F3:8D:79:ED:54:FE:20:C3:83:49:24
+    Signature Algorithm: sha256WithRSAEncryption
+         71:88:eb:c7:f2:f2:84:35:f7:ab:bc:3c:ce:be:11:f9:c9:36:
+         b5:1e:93:96:cf:66:06:4a:f1:b6:f5:cc:97:b9:cd:93:0f:8a:
+         66:62:85:cb:fd:c1:63:7e:38:d9:02:0c:6b:04:38:7b:ec:82:
+         e6:25:f3:8c:99:8d:d1:20:c6:eb:5e:75:9e:b6:f0:ec:ad:9a:
+         76:22:41:bd:88:e9:c3:7f:3d:8e:9a:f1:4a:b3:e2:30:ca:e0:
+         68:39:8d:7c:e6:db:dc:fd:44:75:66:55:d3:a7:8f:eb:fb:28:
+         86:bd:ae:3e:93:9d:f6:76:32:db:05:4d:6e:34:92:16:21:85:
+         d3:0e:2f:73:d3:89:f7:69:6e:0c:74:35:95:8c:e3:ff:c6:f7:
+         5c:b4:55:c0:49:7d:00:ae:6c:88:5b:46:31:b3:62:64:62:b0:
+         0d:9c:7c:d0:84:68:d9:e3:52:ed:35:f8:5a:6f:9e:57:62:4b:
+         36:8f:f7:3e:31:15:fc:bb:df:51:c4:fd:92:96:59:d5:55:3e:
+         7b:fb:2f:2e:5a:15:be:ec:46:38:e0:c9:b4:46:cb:5c:71:4a:
+         fe:c7:19:2c:84:1c:d9:15:12:fc:40:cc:7c:fc:f4:38:22:f6:
+         ba:db:f2:05:97:c1:26:f5:cb:c0:ed:ba:16:e6:33:0c:37:3a:
+         07:b3:a3:ca
+-----BEGIN CERTIFICATE-----
+MIIDgjCCAmqgAwIBAgIJAPIPxjhzA+pSMA0GCSqGSIb3DQEBCwUAMG4xEDAOBgNV
+BAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vua25vd24x
+EDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xEjAQBgNVBAMTCWxv
+Y2FsaG9zdDAgFw0yMzAyMTMwNTUyMzJaGA8yMTIzMDEyMDA1NTIzMlowbjEQMA4G
+A1UEBhMHVW5rbm93bjEQMA4GA1UECBMHVW5rbm93bjEQMA4GA1UEBxMHVW5rbm93
+bjEQMA4GA1UEChMHVW5rbm93bjEQMA4GA1UECxMHVW5rbm93bjESMBAGA1UEAxMJ
+bG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6Lff7jKI
+mA4HGEH92OI0yH5UhpvYo3tHbumhjHTzD7umg0MRd8Saq1N0ZEb+gY9yA5cLN3hu
+/25kaOuesGuueWpQ4R4dOd9RCwSOiUvkAmvkEtNBRyyOdTAUGu0yk6b+c33c4NST
+2YxEVdJTSgwu+ZVfT8sv5UHFvDOI69hSDhlVNgIxD4ELwk81Y6YG4zuTPARcYzI9
+wyZQlreMZ46e0aN+e1SGNQf+FTL7bU7nTJeVMuLYBIviAEuFZJFwriSIB0dFfRnD
+wSUCUPj0CqN7ahHDb7naBqAtPWVHjijSGIpFu3l7utXYKU1O2v2yHuu2WRvxyYrq
+rH1y3I3nQ33TxwIDAQABoyEwHzAdBgNVHQ4EFgQUiDpZnbJyrGT784157VT+IMOD
+SSQwDQYJKoZIhvcNAQELBQADggEBAHGI68fy8oQ196u8PM6+EfnJNrUek5bPZgZK
+8bb1zJe5zZMPimZihcv9wWN+ONkCDGsEOHvsguYl84yZjdEgxutedZ628OytmnYi
+Qb2I6cN/PY6a8Uqz4jDK4Gg5jXzm29z9RHVmVdOnj+v7KIa9rj6TnfZ2MtsFTW40
+khYhhdMOL3PTifdpbgx0NZWM4//G91y0VcBJfQCubIhbRjGzYmRisA2cfNCEaNnj
+Uu01+FpvnldiSzaP9z4xFfy731HE/ZKWWdVVPnv7Ly5aFb7sRjjgybRGy1xxSv7H
+GSyEHNkVEvxAzHz89Dgi9rrb8gWXwSb1y8DtuhbmMww3Ogezo8o=
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1000.pem b/tests/certificate-authority/newcerts/1000.pem
index b5c7a5dc70..fc3f09bbbe 100644
--- a/tests/certificate-authority/newcerts/1000.pem
+++ b/tests/certificate-authority/newcerts/1000.pem
@@ -1,27 +1,27 @@
------BEGIN CERTIFICATE-----
-MIIEkDCCAnigAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyMjA4NTUzMloYDzIyOTIwNDA2MDg1NTMyWjAjMSEwHwYDVQQD
-DBhicm9rZXIucHVsc2FyLmFwYWNoZS5vcmcwggEiMA0GCSqGSIb3DQEBAQUAA4IB
-DwAwggEKAoIBAQDQouKhZah4hMCqmg4aS5RhQG/Y1gA+yP9DGF9mlw35tfhfWs63
-EvNjEK4L/ZWSEV45L/wc6YV14RmM6bJ0V/0vXo4xmISbqptND/2kRIspkLZQ5F0O
-OQXVicqZLOc6igZQhRg8ANDYdTJUTF65DqauX4OJt3YMhF2FSt7jQtlj06IQBa01
-+ARO9OotMJtBY+vIU5bV6JydfgkhQH9rIDI7AMeY5j02gGkJJrelfm+WoOsUez+X
-aqTN3/tF8+MBcFB3G04s1qc2CJPJM3YGxvxEtHqTGI14t9J8p5O7X9JHpcY8X00s
-bxa4FGbKgfDobbkJ+GgblWCkAcLN95sKTqtHAgMBAAGjgd0wgdowCQYDVR0TBAIw
-ADARBglghkgBhvhCAQEEBAMCBkAwMwYJYIZIAYb4QgENBCYWJE9wZW5TU0wgR2Vu
-ZXJhdGVkIFNlcnZlciBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUaxFvJrkEGqk8azTA
-DyVyTyTbJAIwQQYDVR0jBDowOIAUVwvpyyPov0c+UHo/RX6hGEOdFSehFaQTMBEx
-DzANBgNVBAMMBmZvb2JhcoIJANfih0+geeIMMA4GA1UdDwEB/wQEAwIFoDATBgNV
-HSUEDDAKBggrBgEFBQcDATANBgkqhkiG9w0BAQsFAAOCAgEA35QDGclHzQtHs3yQ
-ZzNOSKisg5srTiIoQgRzfHrXfkthNFCnBzhKjBxqk3EIasVtvyGuk0ThneC1ai3y
-ZK3BivnMZfm1SfyvieFoqWetsxohWfcpOSVkpvO37P6v/NmmaTIGkBN3gxKCx0QN
-zqApLQyNTM++X3wxetYH/afAGUrRmBGWZuJheQpB9yZ+FB6BRp8YuYIYBzANJyW9
-spvXW03TpqX2AIoRBoGMLzK72vbhAbLWiCIfEYREhbZVRkP+yvD338cWrILlOEur
-x/n8L/FTmbf7mXzHg4xaQ3zg/5+0OCPMDPUBE4xWDBAbZ82hgOcTqfVjwoPgo2V0
-fbbx6redq44J3Vn5d9Xhi59fkpqEjHpX4xebr5iMikZsNTJMeLh0h3uf7DstuO9d
-mfnF5j+yDXCKb9XzCsTSvGCN+spmUh6RfSrbkw8/LrRvBUpKVEM0GfKSnaFpOaSS
-efM4UEi72FRjszzHEkdvpiLhYvihINLJmDXszhc3fCi42be/DGmUhuhTZWynOPmp
-0N0V/8/sGT5gh4fGEtGzS/8xEvZwO9uDlccJiG8Pi+aO0/K9urB9nppd/xKWXv3C
-cib/QrW0Qow4TADWC1fnGYCpFzzaZ2esPL2MvzOYXnW4/AbEqmb6Weatluai64ZK
-3N2cGJWRyvpvvmbP2hKCa4eLgEc=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEkDCCAnigAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyMjA4NTUzMloYDzIyOTIwNDA2MDg1NTMyWjAjMSEwHwYDVQQD
+DBhicm9rZXIucHVsc2FyLmFwYWNoZS5vcmcwggEiMA0GCSqGSIb3DQEBAQUAA4IB
+DwAwggEKAoIBAQDQouKhZah4hMCqmg4aS5RhQG/Y1gA+yP9DGF9mlw35tfhfWs63
+EvNjEK4L/ZWSEV45L/wc6YV14RmM6bJ0V/0vXo4xmISbqptND/2kRIspkLZQ5F0O
+OQXVicqZLOc6igZQhRg8ANDYdTJUTF65DqauX4OJt3YMhF2FSt7jQtlj06IQBa01
++ARO9OotMJtBY+vIU5bV6JydfgkhQH9rIDI7AMeY5j02gGkJJrelfm+WoOsUez+X
+aqTN3/tF8+MBcFB3G04s1qc2CJPJM3YGxvxEtHqTGI14t9J8p5O7X9JHpcY8X00s
+bxa4FGbKgfDobbkJ+GgblWCkAcLN95sKTqtHAgMBAAGjgd0wgdowCQYDVR0TBAIw
+ADARBglghkgBhvhCAQEEBAMCBkAwMwYJYIZIAYb4QgENBCYWJE9wZW5TU0wgR2Vu
+ZXJhdGVkIFNlcnZlciBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUaxFvJrkEGqk8azTA
+DyVyTyTbJAIwQQYDVR0jBDowOIAUVwvpyyPov0c+UHo/RX6hGEOdFSehFaQTMBEx
+DzANBgNVBAMMBmZvb2JhcoIJANfih0+geeIMMA4GA1UdDwEB/wQEAwIFoDATBgNV
+HSUEDDAKBggrBgEFBQcDATANBgkqhkiG9w0BAQsFAAOCAgEA35QDGclHzQtHs3yQ
+ZzNOSKisg5srTiIoQgRzfHrXfkthNFCnBzhKjBxqk3EIasVtvyGuk0ThneC1ai3y
+ZK3BivnMZfm1SfyvieFoqWetsxohWfcpOSVkpvO37P6v/NmmaTIGkBN3gxKCx0QN
+zqApLQyNTM++X3wxetYH/afAGUrRmBGWZuJheQpB9yZ+FB6BRp8YuYIYBzANJyW9
+spvXW03TpqX2AIoRBoGMLzK72vbhAbLWiCIfEYREhbZVRkP+yvD338cWrILlOEur
+x/n8L/FTmbf7mXzHg4xaQ3zg/5+0OCPMDPUBE4xWDBAbZ82hgOcTqfVjwoPgo2V0
+fbbx6redq44J3Vn5d9Xhi59fkpqEjHpX4xebr5iMikZsNTJMeLh0h3uf7DstuO9d
+mfnF5j+yDXCKb9XzCsTSvGCN+spmUh6RfSrbkw8/LrRvBUpKVEM0GfKSnaFpOaSS
+efM4UEi72FRjszzHEkdvpiLhYvihINLJmDXszhc3fCi42be/DGmUhuhTZWynOPmp
+0N0V/8/sGT5gh4fGEtGzS/8xEvZwO9uDlccJiG8Pi+aO0/K9urB9nppd/xKWXv3C
+cib/QrW0Qow4TADWC1fnGYCpFzzaZ2esPL2MvzOYXnW4/AbEqmb6Weatluai64ZK
+3N2cGJWRyvpvvmbP2hKCa4eLgEc=
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1001.pem b/tests/certificate-authority/newcerts/1001.pem
index 0665edbdc1..ff2fd7a126 100644
--- a/tests/certificate-authority/newcerts/1001.pem
+++ b/tests/certificate-authority/newcerts/1001.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEZTCCAk2gAwIBAgICEAEwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyMjA4NTcwNloYDzIyOTIwNDA2MDg1NzA2WjAQMQ4wDAYDVQQD
-DAVhZG1pbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJw3Jfbn0xkW
-36kqQjES6Hn+YTZ2jXS5Co2MzsGBsIY0qJ2BbWHSSaMrja4IERUaCQp16SWxPmZ0
-srMm6ErDoap+O70CWXLT3ybYMV5aVwv3ca4uxsedzaw9MpFXfUDsJJ3yre1JpO+t
-A/QzJEGq1d6NN49InUP5kB1Rpay3vaxx8hduzqTO+E/Lptv92p6GjOpXi2icSjiA
-pgaan2ldGGKEKv2Sc2bfdIDkTq1yDyNmuPET0yD2dci106EW/mPyj81umPKG/o4K
-5W18yG/IhXw5W1zlgO1fWCuqva8NCBdu7s1c7hUX8DBx7km4/I7dllz/nYHIfCEQ
-Dmj38oQjYk8CAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
-oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
-ZmljYXRlMB0GA1UdDgQWBBQTMzAAOJ9gXvQSS7Be3+qmrb1kVDAfBgNVHSMEGDAW
-gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
-FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQAwy8f6hsG0
-85e3SOIztbUnaVxS7wzDeDzR3vCjpXpm4vTToYzN9zx3JHKSdJrB12emVxItwW/7
-bXqBk0n2EdQjRHCuebnY05eFMNGagMEEMVmSLOproQD7VsyALNxCss1JAyRikh70
-W7wgOVeAhqE53UqqrkzTE7Q+8Bag9t3FytHxApY17XglbWkiVcFpQwSURe9Emi3E
-aCJCryGJXrBNuCFXGzetSygDEy27+2FeH8S2XsMwUEGLqDDehzvMenVz1xjXtq+s
-KPkofAde52NHd4lLkSeBMSFnKe3V7Xxax2OEUsoQRF3bkbpcJSWsKS9ZAA2yrtuy
-Nz/aA1F42LuSFPAYQr1kcZ8eSS918RWz+BiJYU2JuUOPd1XUmJXVvZ4CJurWaC7+
-ZD51YdD8E245xd55fsA6/qLx3eE/Kp0dVq+Hxuz6b4yLET0zkGunOe4A3hnRgkOA
-XolXCL+VthhWtFGXn8CjpxDnzjahq69Io+dINehqd5aJEgvnHZIK2s7FTqqBBodU
-HhyAE94f64z7ziuRhEG54bmBF+MoGyPf6dVn1Mp3+o+YeQ5q6XlKgh+u8jMgmqRO
-ikdsVdMqopt/FXh9eFzvQrwOZFLK6JE/edUgb6xvS1jMF5zi2lIlIkq1RBQOr4HT
-XDwX4vRtfpDxpsetGVpeq9O07fbMvp+mkw==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEZTCCAk2gAwIBAgICEAEwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyMjA4NTcwNloYDzIyOTIwNDA2MDg1NzA2WjAQMQ4wDAYDVQQD
+DAVhZG1pbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJw3Jfbn0xkW
+36kqQjES6Hn+YTZ2jXS5Co2MzsGBsIY0qJ2BbWHSSaMrja4IERUaCQp16SWxPmZ0
+srMm6ErDoap+O70CWXLT3ybYMV5aVwv3ca4uxsedzaw9MpFXfUDsJJ3yre1JpO+t
+A/QzJEGq1d6NN49InUP5kB1Rpay3vaxx8hduzqTO+E/Lptv92p6GjOpXi2icSjiA
+pgaan2ldGGKEKv2Sc2bfdIDkTq1yDyNmuPET0yD2dci106EW/mPyj81umPKG/o4K
+5W18yG/IhXw5W1zlgO1fWCuqva8NCBdu7s1c7hUX8DBx7km4/I7dllz/nYHIfCEQ
+Dmj38oQjYk8CAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
+oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
+ZmljYXRlMB0GA1UdDgQWBBQTMzAAOJ9gXvQSS7Be3+qmrb1kVDAfBgNVHSMEGDAW
+gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
+FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQAwy8f6hsG0
+85e3SOIztbUnaVxS7wzDeDzR3vCjpXpm4vTToYzN9zx3JHKSdJrB12emVxItwW/7
+bXqBk0n2EdQjRHCuebnY05eFMNGagMEEMVmSLOproQD7VsyALNxCss1JAyRikh70
+W7wgOVeAhqE53UqqrkzTE7Q+8Bag9t3FytHxApY17XglbWkiVcFpQwSURe9Emi3E
+aCJCryGJXrBNuCFXGzetSygDEy27+2FeH8S2XsMwUEGLqDDehzvMenVz1xjXtq+s
+KPkofAde52NHd4lLkSeBMSFnKe3V7Xxax2OEUsoQRF3bkbpcJSWsKS9ZAA2yrtuy
+Nz/aA1F42LuSFPAYQr1kcZ8eSS918RWz+BiJYU2JuUOPd1XUmJXVvZ4CJurWaC7+
+ZD51YdD8E245xd55fsA6/qLx3eE/Kp0dVq+Hxuz6b4yLET0zkGunOe4A3hnRgkOA
+XolXCL+VthhWtFGXn8CjpxDnzjahq69Io+dINehqd5aJEgvnHZIK2s7FTqqBBodU
+HhyAE94f64z7ziuRhEG54bmBF+MoGyPf6dVn1Mp3+o+YeQ5q6XlKgh+u8jMgmqRO
+ikdsVdMqopt/FXh9eFzvQrwOZFLK6JE/edUgb6xvS1jMF5zi2lIlIkq1RBQOr4HT
+XDwX4vRtfpDxpsetGVpeq9O07fbMvp+mkw==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1002.pem b/tests/certificate-authority/newcerts/1002.pem
index 7602549796..e0c7cb4724 100644
--- a/tests/certificate-authority/newcerts/1002.pem
+++ b/tests/certificate-authority/newcerts/1002.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEYjCCAkqgAwIBAgICEAIwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMB4XDTE4MDYyMjEwMTM1NFoXDTIxMDMxODEwMTM1NFowDzENMAsGA1UEAwwE
-aXZhbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOYoffQM9SSMiSZt
-V167eR8ijudNmM44bAweDJk/RPAkJa7nnsunZm9otY/7sDWT5V2ZQAVHIFMa2qT/
-i2J7no62apzqazDX5g4k1YBtbXexBZvHo7l4NUdk5wGcvQYQ8cjprzS+hA7Iu4x9
-BN8KwKzbg0KS3vfhL0qRoPQZofP7Ao4H+g7Xb8785zU5RvsTLJKU5z3WpSishWG7
-ZSy58PaUrX51lg5D4RGJK6MfN1+p0uzA7pi/pwLzHQZDUl2wDvs1JBJKVQI6FBjK
-Zz78+vqEegA1oAXnhasiDNIcIyGlFApqGm+MuJtvMM2BgQd3VkCdK0glm0UMkUWr
-YSMkKMcCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIFoDAz
-BglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRpZmlj
-YXRlMB0GA1UdDgQWBBTDhMbwEtRTA67cYnyMQYMNivG5wDAfBgNVHSMEGDAWgBRX
-C+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYwFAYI
-KwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQA0cpz3f/pI9E3Q
-oCVc7ohx8tAkWGFgg62LDn1Xa0/4zJ1XoJoOHqQRffXas0xX3xJKZuWMBtZg/uuR
-0HlcLv6oKDH8DBbU0XHigTF25JBgtmrUuQBth0zR0RMe3jYwmAMFuAfvI4i4ysXE
-h+v0oeVMZMnv8V2fCFpuiBA2hXm1qp6GbuFN7dmxjt6+POGxPkVLYNGS/5rLXaRp
-qIQ6TZvA4A71uERM/bizO8pV0aIKzdrJ/94wGlDFRlGkSkcRMRz9gaCqb368sy4P
-WFLOELC8WkfQ38g2fgXX31rt+E1r2yYzku/rnID3pj2OyDfPWKxQxGsZNbHz3VLU
-XJ70DJNMU8Iv003XlTcy30VvDMKqyYFiN86qS2Hr+z24eMq+fgIHZtE9rzoTQTau
-stxUn/YS8tozeEb7ABaBFZhRC5rkWJKI+0LSDiAkIhqq4cXzsN+fBfl94lXboFzr
-ta54Wpv5TRggikylFLyKERGECHmFp9dHnk7n2+3pU7ZZaG4S9ZZrEufJvc+mdRAy
-XgvKrXW7HphaRO7lwSZDABsuJ2blH8dW8kqvXOiklf72iCZIlVRsBpjm9eDvBXJd
-pfaObag9eKsmQTsO7CYf5gNxfDBPtSBpzElWlC+GF1EaGHVzPD+h+kFF9FLth/p+
-NUK5J+p271foXpiKDXVHFxhSQSPeFA==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEYjCCAkqgAwIBAgICEAIwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMB4XDTE4MDYyMjEwMTM1NFoXDTIxMDMxODEwMTM1NFowDzENMAsGA1UEAwwE
+aXZhbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOYoffQM9SSMiSZt
+V167eR8ijudNmM44bAweDJk/RPAkJa7nnsunZm9otY/7sDWT5V2ZQAVHIFMa2qT/
+i2J7no62apzqazDX5g4k1YBtbXexBZvHo7l4NUdk5wGcvQYQ8cjprzS+hA7Iu4x9
+BN8KwKzbg0KS3vfhL0qRoPQZofP7Ao4H+g7Xb8785zU5RvsTLJKU5z3WpSishWG7
+ZSy58PaUrX51lg5D4RGJK6MfN1+p0uzA7pi/pwLzHQZDUl2wDvs1JBJKVQI6FBjK
+Zz78+vqEegA1oAXnhasiDNIcIyGlFApqGm+MuJtvMM2BgQd3VkCdK0glm0UMkUWr
+YSMkKMcCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIFoDAz
+BglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRpZmlj
+YXRlMB0GA1UdDgQWBBTDhMbwEtRTA67cYnyMQYMNivG5wDAfBgNVHSMEGDAWgBRX
+C+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYwFAYI
+KwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQA0cpz3f/pI9E3Q
+oCVc7ohx8tAkWGFgg62LDn1Xa0/4zJ1XoJoOHqQRffXas0xX3xJKZuWMBtZg/uuR
+0HlcLv6oKDH8DBbU0XHigTF25JBgtmrUuQBth0zR0RMe3jYwmAMFuAfvI4i4ysXE
+h+v0oeVMZMnv8V2fCFpuiBA2hXm1qp6GbuFN7dmxjt6+POGxPkVLYNGS/5rLXaRp
+qIQ6TZvA4A71uERM/bizO8pV0aIKzdrJ/94wGlDFRlGkSkcRMRz9gaCqb368sy4P
+WFLOELC8WkfQ38g2fgXX31rt+E1r2yYzku/rnID3pj2OyDfPWKxQxGsZNbHz3VLU
+XJ70DJNMU8Iv003XlTcy30VvDMKqyYFiN86qS2Hr+z24eMq+fgIHZtE9rzoTQTau
+stxUn/YS8tozeEb7ABaBFZhRC5rkWJKI+0LSDiAkIhqq4cXzsN+fBfl94lXboFzr
+ta54Wpv5TRggikylFLyKERGECHmFp9dHnk7n2+3pU7ZZaG4S9ZZrEufJvc+mdRAy
+XgvKrXW7HphaRO7lwSZDABsuJ2blH8dW8kqvXOiklf72iCZIlVRsBpjm9eDvBXJd
+pfaObag9eKsmQTsO7CYf5gNxfDBPtSBpzElWlC+GF1EaGHVzPD+h+kFF9FLth/p+
+NUK5J+p271foXpiKDXVHFxhSQSPeFA==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1003.pem b/tests/certificate-authority/newcerts/1003.pem
index 6c2f4295c9..caa2051ba5 100644
--- a/tests/certificate-authority/newcerts/1003.pem
+++ b/tests/certificate-authority/newcerts/1003.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEZTCCAk2gAwIBAgICEAMwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyNTEzNTYwNFoYDzIyOTIwNDA5MTM1NjA0WjAQMQ4wDAYDVQQD
-DAVwcm94eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMieX78Yj8OW
-eBHAneRaCCoO8Qrpj8zGo7h9lCdmi1lBDh1uR2sDbotiHGfJzQn836WcYmyeAvfn
-qvgr9HCXmXdLgmJ3GT/LVu5GEm6msSDiZQPr9so5lQVioisK4UwJROQsE/J52cyR
-9o3H6M4FKb6QpoobKa62fSfTumwwulaYaDJuRRGoGIkcRuUQ59EWAaDkD3IcDpAn
-9mTbnE4Iz+JxSrsZ5DJ3X/m/AqyLWtj6GAfyK9a1dhNdlf2x4JZT1QNtojiBXt95
-OIZyRBNbHMFniq5gel6wdBkmJWutfcTct7wKa2LCxLpKoDIc1HWoL3+RUzOKxYIP
-0qXEQ3bmONkCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
-oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
-ZmljYXRlMB0GA1UdDgQWBBSgsgfmDbXEkrrpHUC9GnDDjxaKizAfBgNVHSMEGDAW
-gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
-FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQB+uZ2OWR+G
-sRqYHEeVqUI8G2p8Np8eC/onGpBL8Gj9SGxIQcIPtqHPUlCe9fd/96JOptOGRYEB
-BmUCaCmQ4IgMW6e6fArka5IB4XXIgHFXyQ6ImTvjDavzlVw06zn9S4dLwVzsRBg+
-GS9svtq23W+f5rEN5N+7LhtcbclfiG4VCCqDG5VhkzEok+SRamDI8rDRZtodMw0O
-/+L+xaaQPUPjX8KUlKn4uVpCDbxUzHonlCPzbkHHm5su0D4ysjJIy3/y3yow6JE/
-02L7PZkmkmw3/V+84T3X8/GD15sVUv/3v1gXEBxYwAs+RNTJ0APvMEMSvCq0AMfF
-bPMZBuAGNBG7lv7TovzHgGFKXT7du5OFF/qjAsEffhbo224CB96fgwvvndwHHBFh
-J06BvHZG1i9dDVhUKoB1owkWrE4RZv2ZKEtZYgizzSmzZRHtARo0t1Byc5djx1tX
-TkJOHshNqJZOY1ER0DPaVQgKI+PRTbEdj/xPGRX3ebSqDmilAfPXshqgElfch6Yl
-f2V58TyCnjXOibvkG9D5OyCdWLEECumOZgYar0KZgNfrvTOi1OKXnX1fsbh29fWA
-ICZRcdmjkz79zQXY2SuzCWlskuXPKAmW1AMqs+l6ormmKfzIUx3Yriy4LqIIYY1v
-uQD5vghZmd9HUg2KaXfSGD9stGCD8KhntA==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEZTCCAk2gAwIBAgICEAMwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyNTEzNTYwNFoYDzIyOTIwNDA5MTM1NjA0WjAQMQ4wDAYDVQQD
+DAVwcm94eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMieX78Yj8OW
+eBHAneRaCCoO8Qrpj8zGo7h9lCdmi1lBDh1uR2sDbotiHGfJzQn836WcYmyeAvfn
+qvgr9HCXmXdLgmJ3GT/LVu5GEm6msSDiZQPr9so5lQVioisK4UwJROQsE/J52cyR
+9o3H6M4FKb6QpoobKa62fSfTumwwulaYaDJuRRGoGIkcRuUQ59EWAaDkD3IcDpAn
+9mTbnE4Iz+JxSrsZ5DJ3X/m/AqyLWtj6GAfyK9a1dhNdlf2x4JZT1QNtojiBXt95
+OIZyRBNbHMFniq5gel6wdBkmJWutfcTct7wKa2LCxLpKoDIc1HWoL3+RUzOKxYIP
+0qXEQ3bmONkCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
+oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
+ZmljYXRlMB0GA1UdDgQWBBSgsgfmDbXEkrrpHUC9GnDDjxaKizAfBgNVHSMEGDAW
+gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
+FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQB+uZ2OWR+G
+sRqYHEeVqUI8G2p8Np8eC/onGpBL8Gj9SGxIQcIPtqHPUlCe9fd/96JOptOGRYEB
+BmUCaCmQ4IgMW6e6fArka5IB4XXIgHFXyQ6ImTvjDavzlVw06zn9S4dLwVzsRBg+
+GS9svtq23W+f5rEN5N+7LhtcbclfiG4VCCqDG5VhkzEok+SRamDI8rDRZtodMw0O
+/+L+xaaQPUPjX8KUlKn4uVpCDbxUzHonlCPzbkHHm5su0D4ysjJIy3/y3yow6JE/
+02L7PZkmkmw3/V+84T3X8/GD15sVUv/3v1gXEBxYwAs+RNTJ0APvMEMSvCq0AMfF
+bPMZBuAGNBG7lv7TovzHgGFKXT7du5OFF/qjAsEffhbo224CB96fgwvvndwHHBFh
+J06BvHZG1i9dDVhUKoB1owkWrE4RZv2ZKEtZYgizzSmzZRHtARo0t1Byc5djx1tX
+TkJOHshNqJZOY1ER0DPaVQgKI+PRTbEdj/xPGRX3ebSqDmilAfPXshqgElfch6Yl
+f2V58TyCnjXOibvkG9D5OyCdWLEECumOZgYar0KZgNfrvTOi1OKXnX1fsbh29fWA
+ICZRcdmjkz79zQXY2SuzCWlskuXPKAmW1AMqs+l6ormmKfzIUx3Yriy4LqIIYY1v
+uQD5vghZmd9HUg2KaXfSGD9stGCD8KhntA==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1004.pem b/tests/certificate-authority/newcerts/1004.pem
index 9656e2c8ba..a9c8a7fb91 100644
--- a/tests/certificate-authority/newcerts/1004.pem
+++ b/tests/certificate-authority/newcerts/1004.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEajCCAlKgAwIBAgICEAQwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyNjEzMjUxN1oYDzIyOTIwNDEwMTMyNTE3WjAVMRMwEQYDVQQD
-DApzdXBlcnByb3h5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA43Sn
-ys/h3wxJ/IBEzbJdQAKCxU4of5KgTDzFoOaS8C63Nwbjgy0qcWYdRDceP4lJIKSA
-1+JZ+R1opyrfVIC2D9oDJFIJTFfXy9G9VYDccwAONPgAamvRzBnYcEu8fqM+Ohle
-kZltKktAHnX3WtG3RyxEL5nYzlMlGwUXJu3Rxc9SlkYSxERzjWHikGqGmXLX2qB0
-k6oyxTrK+4+EHk3khbEIqyQZSOFbD7NMfnRy0CWFv/9T1shgjAIBCake6jY7lwaT
-S7JvbLfG6ABf5xHMxoWLXa2qwb+Ar43Ff9g8kKZwFOxMeGcwkzyJPBbWytFxaWn+
-R2RHhTaVCGc22CjdfQIDAQABo4HFMIHCMAkGA1UdEwQCMAAwEQYJYIZIAYb4QgEB
-BAQDAgWgMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRlZCBDbGllbnQg
-Q2VydGlmaWNhdGUwHQYDVR0OBBYEFHEgLhfH0Z1QlLxeQbG7YZyBlz1MMB8GA1Ud
-IwQYMBaAFFcL6csj6L9HPlB6P0V+oRhDnRUnMA4GA1UdDwEB/wQEAwIF4DAdBgNV
-HSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwQwDQYJKoZIhvcNAQELBQADggIBAK9q
-3YnEa99Cq3Vo3g6PE/A/xOE97seVNuavqyBcVv9PrTydb5XG4jPkYU3xOYXIc8rA
-A4gzd+AsGO9rjGMPGGjQJI3JO/3BCeBJMkn50C/rM1yWVMHnVyFcJlg16xaWtj1e
-2Jk8egJW2gSYyF+N2TdzI7tOb002GNr36posnqO+IOoLapyHFBxxUjsPDRoo8fJn
-myWsV1Y9oRUZyJlfIAJsu85ew7gDBY2jaiEiopzour3uU3C0N7gYni2OmVwfr6J8
-R2/Jp43BSD5sYOW9RAJIEEXef+InYtz9HTJvKu2LsWwIBkaztk29tJcDE+1La6Sw
-0dF0YkUwnXoGQFjiV+8pXX3TF5glXKj1rU8WfNazF6lqslB6DmdgR3/FQ6Z2sE86
-d9hVtayZIGlzU0rWmBBtr++7Wo88nmzAtd/xbZMFG8U//+Q2AvJT2oVGtqM48+al
-rnsN/gYrLDr7RC14bHIuO1v6ZL/rAi7SPKrKYAyQVTAcRuW516SxxR6S1Xa1ITnh
-rwgKg13eQuwu3iigguIS9XL6nAXabBIxBxMl6o2YlyIPekKYIcQmpqhkavJ6VOgX
-iq9VdY6fIJVfmxNZuwM3/28k7UeUAfhI2SSVH4ZURbPiGGH2wukc1QkmtZ2cNa35
-C1y79aqJbIa3ErqLFPj/fM+34x8L7QHPq6RfaODa
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEajCCAlKgAwIBAgICEAQwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyNjEzMjUxN1oYDzIyOTIwNDEwMTMyNTE3WjAVMRMwEQYDVQQD
+DApzdXBlcnByb3h5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA43Sn
+ys/h3wxJ/IBEzbJdQAKCxU4of5KgTDzFoOaS8C63Nwbjgy0qcWYdRDceP4lJIKSA
+1+JZ+R1opyrfVIC2D9oDJFIJTFfXy9G9VYDccwAONPgAamvRzBnYcEu8fqM+Ohle
+kZltKktAHnX3WtG3RyxEL5nYzlMlGwUXJu3Rxc9SlkYSxERzjWHikGqGmXLX2qB0
+k6oyxTrK+4+EHk3khbEIqyQZSOFbD7NMfnRy0CWFv/9T1shgjAIBCake6jY7lwaT
+S7JvbLfG6ABf5xHMxoWLXa2qwb+Ar43Ff9g8kKZwFOxMeGcwkzyJPBbWytFxaWn+
+R2RHhTaVCGc22CjdfQIDAQABo4HFMIHCMAkGA1UdEwQCMAAwEQYJYIZIAYb4QgEB
+BAQDAgWgMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRlZCBDbGllbnQg
+Q2VydGlmaWNhdGUwHQYDVR0OBBYEFHEgLhfH0Z1QlLxeQbG7YZyBlz1MMB8GA1Ud
+IwQYMBaAFFcL6csj6L9HPlB6P0V+oRhDnRUnMA4GA1UdDwEB/wQEAwIF4DAdBgNV
+HSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwQwDQYJKoZIhvcNAQELBQADggIBAK9q
+3YnEa99Cq3Vo3g6PE/A/xOE97seVNuavqyBcVv9PrTydb5XG4jPkYU3xOYXIc8rA
+A4gzd+AsGO9rjGMPGGjQJI3JO/3BCeBJMkn50C/rM1yWVMHnVyFcJlg16xaWtj1e
+2Jk8egJW2gSYyF+N2TdzI7tOb002GNr36posnqO+IOoLapyHFBxxUjsPDRoo8fJn
+myWsV1Y9oRUZyJlfIAJsu85ew7gDBY2jaiEiopzour3uU3C0N7gYni2OmVwfr6J8
+R2/Jp43BSD5sYOW9RAJIEEXef+InYtz9HTJvKu2LsWwIBkaztk29tJcDE+1La6Sw
+0dF0YkUwnXoGQFjiV+8pXX3TF5glXKj1rU8WfNazF6lqslB6DmdgR3/FQ6Z2sE86
+d9hVtayZIGlzU0rWmBBtr++7Wo88nmzAtd/xbZMFG8U//+Q2AvJT2oVGtqM48+al
+rnsN/gYrLDr7RC14bHIuO1v6ZL/rAi7SPKrKYAyQVTAcRuW516SxxR6S1Xa1ITnh
+rwgKg13eQuwu3iigguIS9XL6nAXabBIxBxMl6o2YlyIPekKYIcQmpqhkavJ6VOgX
+iq9VdY6fIJVfmxNZuwM3/28k7UeUAfhI2SSVH4ZURbPiGGH2wukc1QkmtZ2cNa35
+C1y79aqJbIa3ErqLFPj/fM+34x8L7QHPq6RfaODa
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1005.pem b/tests/certificate-authority/newcerts/1005.pem
index 072f2867fe..3646d0feae 100644
--- a/tests/certificate-authority/newcerts/1005.pem
+++ b/tests/certificate-authority/newcerts/1005.pem
@@ -1,26 +1,26 @@
------BEGIN CERTIFICATE-----
-MIIEZTCCAk2gAwIBAgICEAUwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTE4MDYyNzA4NDAyNVoYDzIyOTIwNDExMDg0MDI1WjAQMQ4wDAYDVQQD
-DAV1c2VyMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM5iqgr4PUUZ
-AW9MDGP5cBaSJALSPV63m6M/IoovrMWJ9CGtcQfZTUHwDorIlXgQ6H/KufmsHW0Y
-OQbChLSTDB14D0jSMtyv6+ibSoE1ZEl2SbB1miLd0P5AS9YmzzEW2+bx0zJORLYD
-PzJ1Nh3/kQlRs04IECki291WZiVRzX2JRoL7kMtOAoKJqQfsT14Oi9EAw39VhLeB
-uc/Mx6Jsutq/YdXakoZtQbfZka2MMfLXgMDLIPDqbU+09q7au2dq8RjGzrWnxnOX
-o/XQssrIbwzJJYASBsgAAtnAw7bPzCX6+cL6PZVRyiEZov0HKXyRyvrbQ5hyEMuS
-3dHqoKt0fKMCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
-oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
-ZmljYXRlMB0GA1UdDgQWBBQ7NSD6lx6Vq38cEoD5l7FHs1Ej8DAfBgNVHSMEGDAW
-gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
-FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQC+cU7ctY7o
-eTW+oHTq9EGJUMwW1fOww4QDrHtgZT4OYkO88zxQV2Cr050p8eaV5dHXZBf9/bRV
-7hPNV5+HpQhb9TZ9xK2WRZ2QV7a/UDyUnksVKGSK9tNZMZPueOEB19e4bIBcgnQa
-5i9sgZr93na7pFOY7lBQy6gfaOcnejYHmvVqIGaZBVH8rkEsGhhkJxy7qkpFNKgf
-PGiIRo9L0WYqDCSiaICeCiteJwIfjsUFJKF0YnpXZq1kFfQscnleg60MWZAXvacp
-tAciE51Ow60cqQWER66iwqnBSPD4l91SxAaGQAmalgCioGsYSbojXcOvRidhYJ2T
-3YwCpqlC0qC9D2ZmNoukb1a0Pi03MuSJwD/8v9eqwEW9dFAzdnWDzTZMN9CfdjVh
-2qiO5o5Si/X1Dmjdk2F/EM62YJQBAlkZBetFJ0o2QPGTSD+zrpfITIW8Pu+/5zcC
-MZdzyUf0p1GO2Kn7wmqPQjz59zABagmxCNks8HeqPnzmWuADMaggb0nOmrBACE2x
-b9XR6/xaXpwTRf0h5N3evivzUHo6XVw8A3gVUNoBm9Of3PlAsjM4I4SWFb6nrwYv
-RnI04c+R95Su1fMc2wky0PmW+iWRTaEN/cUdX1SF6jo1nRLELGcbMSGUI6UI8kff
-crvCz7uLu7Lr5/CKnEm2bSCZ4eIQpOs4nQ==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEZTCCAk2gAwIBAgICEAUwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTE4MDYyNzA4NDAyNVoYDzIyOTIwNDExMDg0MDI1WjAQMQ4wDAYDVQQD
+DAV1c2VyMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM5iqgr4PUUZ
+AW9MDGP5cBaSJALSPV63m6M/IoovrMWJ9CGtcQfZTUHwDorIlXgQ6H/KufmsHW0Y
+OQbChLSTDB14D0jSMtyv6+ibSoE1ZEl2SbB1miLd0P5AS9YmzzEW2+bx0zJORLYD
+PzJ1Nh3/kQlRs04IECki291WZiVRzX2JRoL7kMtOAoKJqQfsT14Oi9EAw39VhLeB
+uc/Mx6Jsutq/YdXakoZtQbfZka2MMfLXgMDLIPDqbU+09q7au2dq8RjGzrWnxnOX
+o/XQssrIbwzJJYASBsgAAtnAw7bPzCX6+cL6PZVRyiEZov0HKXyRyvrbQ5hyEMuS
+3dHqoKt0fKMCAwEAAaOBxTCBwjAJBgNVHRMEAjAAMBEGCWCGSAGG+EIBAQQEAwIF
+oDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5lcmF0ZWQgQ2xpZW50IENlcnRp
+ZmljYXRlMB0GA1UdDgQWBBQ7NSD6lx6Vq38cEoD5l7FHs1Ej8DAfBgNVHSMEGDAW
+gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJzAOBgNVHQ8BAf8EBAMCBeAwHQYDVR0lBBYw
+FAYIKwYBBQUHAwIGCCsGAQUFBwMEMA0GCSqGSIb3DQEBCwUAA4ICAQC+cU7ctY7o
+eTW+oHTq9EGJUMwW1fOww4QDrHtgZT4OYkO88zxQV2Cr050p8eaV5dHXZBf9/bRV
+7hPNV5+HpQhb9TZ9xK2WRZ2QV7a/UDyUnksVKGSK9tNZMZPueOEB19e4bIBcgnQa
+5i9sgZr93na7pFOY7lBQy6gfaOcnejYHmvVqIGaZBVH8rkEsGhhkJxy7qkpFNKgf
+PGiIRo9L0WYqDCSiaICeCiteJwIfjsUFJKF0YnpXZq1kFfQscnleg60MWZAXvacp
+tAciE51Ow60cqQWER66iwqnBSPD4l91SxAaGQAmalgCioGsYSbojXcOvRidhYJ2T
+3YwCpqlC0qC9D2ZmNoukb1a0Pi03MuSJwD/8v9eqwEW9dFAzdnWDzTZMN9CfdjVh
+2qiO5o5Si/X1Dmjdk2F/EM62YJQBAlkZBetFJ0o2QPGTSD+zrpfITIW8Pu+/5zcC
+MZdzyUf0p1GO2Kn7wmqPQjz59zABagmxCNks8HeqPnzmWuADMaggb0nOmrBACE2x
+b9XR6/xaXpwTRf0h5N3evivzUHo6XVw8A3gVUNoBm9Of3PlAsjM4I4SWFb6nrwYv
+RnI04c+R95Su1fMc2wky0PmW+iWRTaEN/cUdX1SF6jo1nRLELGcbMSGUI6UI8kff
+crvCz7uLu7Lr5/CKnEm2bSCZ4eIQpOs4nQ==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1006.pem b/tests/certificate-authority/newcerts/1006.pem
index 02caee5826..a0d2d125a0 100644
--- a/tests/certificate-authority/newcerts/1006.pem
+++ b/tests/certificate-authority/newcerts/1006.pem
@@ -1,27 +1,27 @@
------BEGIN CERTIFICATE-----
-MIIEjzCCAnegAwIBAgICEAYwDQYJKoZIhvcNAQENBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTIyMTAxODEwMTQwMVoYDzIyOTYwODAyMTAxNDAxWjAiMSAwHgYDVQQD
-DBdwcm94eS5wdWxzYXIuYXBhY2hlLm9yZzCCASIwDQYJKoZIhvcNAQEBBQADggEP
-ADCCAQoCggEBAPPnBnkHqKvXuv7BKOoQ8nAa7gEVAjzRANhOx2Yk3/JpN1/Ash48
-UltPjHtop1kXLrnjM3DahQuolz1A/N5sN2RGoe+/Y/aI/FRDF25yGzEoM/kwZDjm
-ejQj2Hb6YsupI+YYtPr5ZDSeIBvvlVurXfXJkZf5CXYeEjqr1pEpLpNCZoWoOiiC
-73/0KBoOToR5+akw+Db2Qr5FSz7AuTQ9KUZ1HZNl4xZBuEha6avESdRykH2XQzDs
-qMBVruByHbzO1pg/op4iOhqQ6DFu67veKjWzMLxKR7x/A8UOd9f9D3+pabBoU72b
-NqgwbKCnERoo3Y0ge1B1x7GORR7GHrWSKlUCAwEAAaOB3TCB2jAJBgNVHRMEAjAA
-MBEGCWCGSAGG+EIBAQQEAwIGQDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5l
-cmF0ZWQgU2VydmVyIENlcnRpZmljYXRlMB0GA1UdDgQWBBQqVR7lwaEgKHsI8+D8
-nNxPmgWZ7TBBBgNVHSMEOjA4gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJ6EVpBMwETEP
-MA0GA1UEAwwGZm9vYmFyggkA1+KHT6B54gwwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud
-JQQMMAoGCCsGAQUFBwMBMA0GCSqGSIb3DQEBDQUAA4ICAQBtoQTZ5u6NpDIKHo6V
-yZqkRrMcg9J61zRm0tbf4D/iIsfWNiJrAWSudK4OgkUrXj4LFWKvzzcZtPltuUr5
-yODXZgz8lnyLbw6GyrKFU4Gpbr8Be30Y1yF7dfTV0yp5ZoIXNILfKhU3not1yL41
-0owaO7N0PyDAzQ7erPbbB9UG7xhYM5qFfAnevwX1rde12JHJULfeE9Ushuv+DcK5
-JmNvkRE+nB/dljsST9pW+zjBDuhwTiDZMPtUPyM0tPn6+x5zwF0pWFKhCkO8lVhr
-TxCG/bMF3j/0MxjQvDvcijJFHaZqLHsw/FqgEM5SNgAsTuuY7wBohSNRddfvahV1
-xPdXUrALuDH/NmIzaYZW6hh6mOhl+R7lP2XXZbFTpTGVdoosdBTGkjbPGKMrT/L8
-hwLvFezXaHZzqj4hLnmqFbhu+dDH55EE1HT5RP7kxGCq1AMuwlsjOVxURS0FZi87
-Oaq19NKsyWfdf8igONsk0GBt5HeG+93fJkW/SxssTJdz1xc91KgGDlP3nAW3xBAz
-TRvgiKIeMzOh+SWkTyz/cJugyxD+wXaAEL7VYsgOwilV+rbWKTDPvnNORqrLO/md
-MHZqYWkFlld2kw8i4LYc6zXOsOWlOv0ZM7VcEs7ufBADQEiZPkDNvWlzM97oDabE
-n/htdqxnoZ3NHJ1HJnz03jKSfg==
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIEjzCCAnegAwIBAgICEAYwDQYJKoZIhvcNAQENBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTIyMTAxODEwMTQwMVoYDzIyOTYwODAyMTAxNDAxWjAiMSAwHgYDVQQD
+DBdwcm94eS5wdWxzYXIuYXBhY2hlLm9yZzCCASIwDQYJKoZIhvcNAQEBBQADggEP
+ADCCAQoCggEBAPPnBnkHqKvXuv7BKOoQ8nAa7gEVAjzRANhOx2Yk3/JpN1/Ash48
+UltPjHtop1kXLrnjM3DahQuolz1A/N5sN2RGoe+/Y/aI/FRDF25yGzEoM/kwZDjm
+ejQj2Hb6YsupI+YYtPr5ZDSeIBvvlVurXfXJkZf5CXYeEjqr1pEpLpNCZoWoOiiC
+73/0KBoOToR5+akw+Db2Qr5FSz7AuTQ9KUZ1HZNl4xZBuEha6avESdRykH2XQzDs
+qMBVruByHbzO1pg/op4iOhqQ6DFu67veKjWzMLxKR7x/A8UOd9f9D3+pabBoU72b
+NqgwbKCnERoo3Y0ge1B1x7GORR7GHrWSKlUCAwEAAaOB3TCB2jAJBgNVHRMEAjAA
+MBEGCWCGSAGG+EIBAQQEAwIGQDAzBglghkgBhvhCAQ0EJhYkT3BlblNTTCBHZW5l
+cmF0ZWQgU2VydmVyIENlcnRpZmljYXRlMB0GA1UdDgQWBBQqVR7lwaEgKHsI8+D8
+nNxPmgWZ7TBBBgNVHSMEOjA4gBRXC+nLI+i/Rz5Qej9FfqEYQ50VJ6EVpBMwETEP
+MA0GA1UEAwwGZm9vYmFyggkA1+KHT6B54gwwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud
+JQQMMAoGCCsGAQUFBwMBMA0GCSqGSIb3DQEBDQUAA4ICAQBtoQTZ5u6NpDIKHo6V
+yZqkRrMcg9J61zRm0tbf4D/iIsfWNiJrAWSudK4OgkUrXj4LFWKvzzcZtPltuUr5
+yODXZgz8lnyLbw6GyrKFU4Gpbr8Be30Y1yF7dfTV0yp5ZoIXNILfKhU3not1yL41
+0owaO7N0PyDAzQ7erPbbB9UG7xhYM5qFfAnevwX1rde12JHJULfeE9Ushuv+DcK5
+JmNvkRE+nB/dljsST9pW+zjBDuhwTiDZMPtUPyM0tPn6+x5zwF0pWFKhCkO8lVhr
+TxCG/bMF3j/0MxjQvDvcijJFHaZqLHsw/FqgEM5SNgAsTuuY7wBohSNRddfvahV1
+xPdXUrALuDH/NmIzaYZW6hh6mOhl+R7lP2XXZbFTpTGVdoosdBTGkjbPGKMrT/L8
+hwLvFezXaHZzqj4hLnmqFbhu+dDH55EE1HT5RP7kxGCq1AMuwlsjOVxURS0FZi87
+Oaq19NKsyWfdf8igONsk0GBt5HeG+93fJkW/SxssTJdz1xc91KgGDlP3nAW3xBAz
+TRvgiKIeMzOh+SWkTyz/cJugyxD+wXaAEL7VYsgOwilV+rbWKTDPvnNORqrLO/md
+MHZqYWkFlld2kw8i4LYc6zXOsOWlOv0ZM7VcEs7ufBADQEiZPkDNvWlzM97oDabE
+n/htdqxnoZ3NHJ1HJnz03jKSfg==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1007.pem b/tests/certificate-authority/newcerts/1007.pem
index 4237719f20..3b4e93f962 100644
--- a/tests/certificate-authority/newcerts/1007.pem
+++ b/tests/certificate-authority/newcerts/1007.pem
@@ -1,111 +1,111 @@
-Certificate:
-    Data:
-        Version: 3 (0x2)
-        Serial Number: 4103 (0x1007)
-    Signature Algorithm: sha256WithRSAEncryption
-        Issuer: CN=foobar
-        Validity
-            Not Before: May 10 15:50:18 2023 GMT
-            Not After : Feb 22 15:50:18 2297 GMT
-        Subject: CN=broker-localhost-SAN
-        Subject Public Key Info:
-            Public Key Algorithm: rsaEncryption
-                Public-Key: (2048 bit)
-                Modulus:
-                    00:de:d1:da:bb:91:b3:16:c4:b2:e8:89:30:9e:c1:
-                    5e:0b:cf:db:c4:c3:d9:b1:af:40:a5:0b:38:36:1b:
-                    14:fe:0f:22:9c:e6:59:6a:15:5b:db:f6:f7:f3:a5:
-                    02:29:94:7a:d2:0c:67:ad:aa:63:62:7e:fc:58:11:
-                    29:48:b8:3c:91:b2:73:7e:12:6b:f2:ea:36:77:0f:
-                    15:9b:46:95:ce:73:15:8d:c8:d9:97:57:03:90:33:
-                    2d:7d:f3:ee:e5:01:6d:d8:c6:da:ab:07:b9:dd:1c:
-                    e0:4b:ce:6a:de:a8:d2:e3:c1:52:6d:83:3a:0a:f0:
-                    ed:cf:f7:56:6a:87:0e:73:e3:12:82:2b:65:ab:d8:
-                    a9:44:5b:4a:2f:a5:92:94:32:f1:a1:e4:af:18:0f:
-                    0f:18:60:cd:f7:d0:9d:03:9f:d7:e9:a8:60:54:bb:
-                    3b:9a:05:db:fd:38:04:3c:b4:23:41:16:6c:7c:3b:
-                    d9:b6:e0:2f:bd:cb:62:55:1b:e8:d0:8f:43:76:ef:
-                    55:86:cf:25:c3:bc:ae:e3:46:50:89:f7:71:ad:06:
-                    5e:28:e6:f6:f0:76:27:ea:7e:1b:67:53:39:26:20:
-                    19:18:82:b1:11:5f:ea:91:c2:e3:d3:f6:5a:c7:fd:
-                    61:a2:92:de:7d:7c:da:6d:e8:bf:39:52:10:31:60:
-                    4b:e1
-                Exponent: 65537 (0x10001)
-        X509v3 extensions:
-            X509v3 Basic Constraints: 
-                CA:FALSE
-            Netscape Cert Type: 
-                SSL Server
-            Netscape Comment: 
-                OpenSSL Generated Server Certificate
-            X509v3 Subject Key Identifier: 
-                17:07:3B:AA:85:83:B5:04:83:EC:B2:6C:1E:3A:F0:F5:59:AA:61:28
-            X509v3 Subject Alternative Name: 
-                DNS:localhost, DNS:unresolvable-broker-address, IP Address:127.0.0.1
-            X509v3 Authority Key Identifier: 
-                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
-                DirName:/CN=foobar
-                serial:D7:E2:87:4F:A0:79:E2:0C
-
-            X509v3 Key Usage: critical
-                Digital Signature, Key Encipherment
-            X509v3 Extended Key Usage: 
-                TLS Web Server Authentication
-    Signature Algorithm: sha256WithRSAEncryption
-         e4:27:61:e2:0f:b6:a0:ca:9f:ce:e3:53:0b:44:ab:86:a1:e2:
-         4d:88:e1:7d:2e:b0:aa:32:96:2b:3d:da:60:70:6a:c3:62:c5:
-         76:f2:8f:0d:16:31:f2:ad:e5:2f:43:f3:cb:e4:fa:95:6c:20:
-         81:33:1a:c7:5a:55:57:c9:ab:ca:66:45:30:58:00:db:e8:51:
-         c9:2c:a9:72:c1:18:f5:01:87:9f:73:20:85:6c:e5:6c:3f:c9:
-         67:b4:f0:20:e5:ed:e2:4a:08:0b:af:68:43:e5:a9:c7:e1:39:
-         e8:b5:49:cb:47:4a:6d:e5:16:ae:88:92:13:85:8e:42:1e:0a:
-         eb:59:ed:a7:c1:9b:bc:4b:7b:99:f8:1d:f0:d7:1d:90:c9:cf:
-         86:6a:d3:10:d0:36:e4:f5:b9:33:79:c7:a2:68:31:f7:bb:8d:
-         1e:d6:33:79:bd:e7:0e:4f:4d:e9:2e:15:04:4f:6b:4b:2e:93:
-         28:72:d1:0e:aa:ee:e6:ef:68:be:58:2b:cc:56:01:27:16:f9:
-         34:8e:66:86:27:0a:b0:fb:32:56:a9:8a:d9:6f:b1:86:bd:ba:
-         fd:50:6c:d5:b2:54:e7:4e:c6:2d:19:88:a9:89:2c:ef:be:08:
-         0d:2b:49:91:0b:09:42:64:06:a3:9d:d7:94:ed:e8:74:74:48:
-         43:57:41:6f:e5:06:98:46:1d:c5:60:9c:69:f8:fb:fe:a6:01:
-         4a:35:be:21:36:c2:a3:44:c8:c4:2c:21:09:f4:28:9a:ad:a0:
-         97:1e:00:29:cc:0f:26:fa:59:21:25:c0:9e:fa:22:53:67:6d:
-         ab:a6:56:08:fd:37:1d:69:fe:ef:6f:29:89:1a:66:7b:c7:ff:
-         b1:34:f1:d6:be:21:81:e3:bc:4f:13:02:a7:4b:9d:13:05:46:
-         40:88:4a:aa:db:fb:64:f8:6b:fb:5d:a0:b1:0c:1a:b8:4c:ab:
-         6f:69:fe:0b:55:4e:b3:38:1f:91:0b:71:77:1e:11:39:54:9a:
-         62:51:ea:6d:a8:5e:0d:4a:91:fb:d8:be:5d:93:e8:43:f3:4a:
-         11:fb:31:cf:14:1a:1c:8d:31:1b:99:31:e0:2b:81:01:91:6f:
-         da:ba:cb:1f:51:21:55:29:3f:4c:71:e3:d0:29:41:de:a0:00:
-         da:07:ed:5e:c9:af:32:61:6d:55:f8:f5:2d:46:03:34:33:fb:
-         2e:1e:aa:7c:fe:d2:30:4d:40:cc:ed:76:ec:f6:bd:ed:35:c8:
-         d8:b3:46:56:aa:2c:53:84:56:45:b0:a3:f6:35:66:93:da:8c:
-         17:39:c1:29:7c:99:c5:0b:73:c1:f9:16:d0:57:fc:57:59:06:
-         af:39:9f:a9:51:35:0b:c7
------BEGIN CERTIFICATE-----
-MIIExzCCAq+gAwIBAgICEAcwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTIzMDUxMDE1NTAxOFoYDzIyOTcwMjIyMTU1MDE4WjAfMR0wGwYDVQQD
-DBRicm9rZXItbG9jYWxob3N0LVNBTjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
-AQoCggEBAN7R2ruRsxbEsuiJMJ7BXgvP28TD2bGvQKULODYbFP4PIpzmWWoVW9v2
-9/OlAimUetIMZ62qY2J+/FgRKUi4PJGyc34Sa/LqNncPFZtGlc5zFY3I2ZdXA5Az
-LX3z7uUBbdjG2qsHud0c4EvOat6o0uPBUm2DOgrw7c/3VmqHDnPjEoIrZavYqURb
-Si+lkpQy8aHkrxgPDxhgzffQnQOf1+moYFS7O5oF2/04BDy0I0EWbHw72bbgL73L
-YlUb6NCPQ3bvVYbPJcO8ruNGUIn3ca0GXijm9vB2J+p+G2dTOSYgGRiCsRFf6pHC
-49P2Wsf9YaKS3n182m3ovzlSEDFgS+ECAwEAAaOCARcwggETMAkGA1UdEwQCMAAw
-EQYJYIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVy
-YXRlZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFBcHO6qFg7UEg+yybB46
-8PVZqmEoMDcGA1UdEQQwMC6CCWxvY2FsaG9zdIIbdW5yZXNvbHZhYmxlLWJyb2tl
-ci1hZGRyZXNzhwR/AAABMEEGA1UdIwQ6MDiAFFcL6csj6L9HPlB6P0V+oRhDnRUn
-oRWkEzARMQ8wDQYDVQQDDAZmb29iYXKCCQDX4odPoHniDDAOBgNVHQ8BAf8EBAMC
-BaAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQELBQADggIBAOQnYeIP
-tqDKn87jUwtEq4ah4k2I4X0usKoylis92mBwasNixXbyjw0WMfKt5S9D88vk+pVs
-IIEzGsdaVVfJq8pmRTBYANvoUcksqXLBGPUBh59zIIVs5Ww/yWe08CDl7eJKCAuv
-aEPlqcfhOei1SctHSm3lFq6IkhOFjkIeCutZ7afBm7xLe5n4HfDXHZDJz4Zq0xDQ
-NuT1uTN5x6JoMfe7jR7WM3m95w5PTekuFQRPa0sukyhy0Q6q7ubvaL5YK8xWAScW
-+TSOZoYnCrD7MlapitlvsYa9uv1QbNWyVOdOxi0ZiKmJLO++CA0rSZELCUJkBqOd
-15Tt6HR0SENXQW/lBphGHcVgnGn4+/6mAUo1viE2wqNEyMQsIQn0KJqtoJceACnM
-Dyb6WSElwJ76IlNnbaumVgj9Nx1p/u9vKYkaZnvH/7E08da+IYHjvE8TAqdLnRMF
-RkCISqrb+2T4a/tdoLEMGrhMq29p/gtVTrM4H5ELcXceETlUmmJR6m2oXg1KkfvY
-vl2T6EPzShH7Mc8UGhyNMRuZMeArgQGRb9q6yx9RIVUpP0xx49ApQd6gANoH7V7J
-rzJhbVX49S1GAzQz+y4eqnz+0jBNQMztduz2ve01yNizRlaqLFOEVkWwo/Y1ZpPa
-jBc5wSl8mcULc8H5FtBX/FdZBq85n6lRNQvH
------END CERTIFICATE-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 4103 (0x1007)
+    Signature Algorithm: sha256WithRSAEncryption
+        Issuer: CN=foobar
+        Validity
+            Not Before: May 10 15:50:18 2023 GMT
+            Not After : Feb 22 15:50:18 2297 GMT
+        Subject: CN=broker-localhost-SAN
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:de:d1:da:bb:91:b3:16:c4:b2:e8:89:30:9e:c1:
+                    5e:0b:cf:db:c4:c3:d9:b1:af:40:a5:0b:38:36:1b:
+                    14:fe:0f:22:9c:e6:59:6a:15:5b:db:f6:f7:f3:a5:
+                    02:29:94:7a:d2:0c:67:ad:aa:63:62:7e:fc:58:11:
+                    29:48:b8:3c:91:b2:73:7e:12:6b:f2:ea:36:77:0f:
+                    15:9b:46:95:ce:73:15:8d:c8:d9:97:57:03:90:33:
+                    2d:7d:f3:ee:e5:01:6d:d8:c6:da:ab:07:b9:dd:1c:
+                    e0:4b:ce:6a:de:a8:d2:e3:c1:52:6d:83:3a:0a:f0:
+                    ed:cf:f7:56:6a:87:0e:73:e3:12:82:2b:65:ab:d8:
+                    a9:44:5b:4a:2f:a5:92:94:32:f1:a1:e4:af:18:0f:
+                    0f:18:60:cd:f7:d0:9d:03:9f:d7:e9:a8:60:54:bb:
+                    3b:9a:05:db:fd:38:04:3c:b4:23:41:16:6c:7c:3b:
+                    d9:b6:e0:2f:bd:cb:62:55:1b:e8:d0:8f:43:76:ef:
+                    55:86:cf:25:c3:bc:ae:e3:46:50:89:f7:71:ad:06:
+                    5e:28:e6:f6:f0:76:27:ea:7e:1b:67:53:39:26:20:
+                    19:18:82:b1:11:5f:ea:91:c2:e3:d3:f6:5a:c7:fd:
+                    61:a2:92:de:7d:7c:da:6d:e8:bf:39:52:10:31:60:
+                    4b:e1
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            Netscape Cert Type: 
+                SSL Server
+            Netscape Comment: 
+                OpenSSL Generated Server Certificate
+            X509v3 Subject Key Identifier: 
+                17:07:3B:AA:85:83:B5:04:83:EC:B2:6C:1E:3A:F0:F5:59:AA:61:28
+            X509v3 Subject Alternative Name: 
+                DNS:localhost, DNS:unresolvable-broker-address, IP Address:127.0.0.1
+            X509v3 Authority Key Identifier: 
+                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
+                DirName:/CN=foobar
+                serial:D7:E2:87:4F:A0:79:E2:0C
+
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication
+    Signature Algorithm: sha256WithRSAEncryption
+         e4:27:61:e2:0f:b6:a0:ca:9f:ce:e3:53:0b:44:ab:86:a1:e2:
+         4d:88:e1:7d:2e:b0:aa:32:96:2b:3d:da:60:70:6a:c3:62:c5:
+         76:f2:8f:0d:16:31:f2:ad:e5:2f:43:f3:cb:e4:fa:95:6c:20:
+         81:33:1a:c7:5a:55:57:c9:ab:ca:66:45:30:58:00:db:e8:51:
+         c9:2c:a9:72:c1:18:f5:01:87:9f:73:20:85:6c:e5:6c:3f:c9:
+         67:b4:f0:20:e5:ed:e2:4a:08:0b:af:68:43:e5:a9:c7:e1:39:
+         e8:b5:49:cb:47:4a:6d:e5:16:ae:88:92:13:85:8e:42:1e:0a:
+         eb:59:ed:a7:c1:9b:bc:4b:7b:99:f8:1d:f0:d7:1d:90:c9:cf:
+         86:6a:d3:10:d0:36:e4:f5:b9:33:79:c7:a2:68:31:f7:bb:8d:
+         1e:d6:33:79:bd:e7:0e:4f:4d:e9:2e:15:04:4f:6b:4b:2e:93:
+         28:72:d1:0e:aa:ee:e6:ef:68:be:58:2b:cc:56:01:27:16:f9:
+         34:8e:66:86:27:0a:b0:fb:32:56:a9:8a:d9:6f:b1:86:bd:ba:
+         fd:50:6c:d5:b2:54:e7:4e:c6:2d:19:88:a9:89:2c:ef:be:08:
+         0d:2b:49:91:0b:09:42:64:06:a3:9d:d7:94:ed:e8:74:74:48:
+         43:57:41:6f:e5:06:98:46:1d:c5:60:9c:69:f8:fb:fe:a6:01:
+         4a:35:be:21:36:c2:a3:44:c8:c4:2c:21:09:f4:28:9a:ad:a0:
+         97:1e:00:29:cc:0f:26:fa:59:21:25:c0:9e:fa:22:53:67:6d:
+         ab:a6:56:08:fd:37:1d:69:fe:ef:6f:29:89:1a:66:7b:c7:ff:
+         b1:34:f1:d6:be:21:81:e3:bc:4f:13:02:a7:4b:9d:13:05:46:
+         40:88:4a:aa:db:fb:64:f8:6b:fb:5d:a0:b1:0c:1a:b8:4c:ab:
+         6f:69:fe:0b:55:4e:b3:38:1f:91:0b:71:77:1e:11:39:54:9a:
+         62:51:ea:6d:a8:5e:0d:4a:91:fb:d8:be:5d:93:e8:43:f3:4a:
+         11:fb:31:cf:14:1a:1c:8d:31:1b:99:31:e0:2b:81:01:91:6f:
+         da:ba:cb:1f:51:21:55:29:3f:4c:71:e3:d0:29:41:de:a0:00:
+         da:07:ed:5e:c9:af:32:61:6d:55:f8:f5:2d:46:03:34:33:fb:
+         2e:1e:aa:7c:fe:d2:30:4d:40:cc:ed:76:ec:f6:bd:ed:35:c8:
+         d8:b3:46:56:aa:2c:53:84:56:45:b0:a3:f6:35:66:93:da:8c:
+         17:39:c1:29:7c:99:c5:0b:73:c1:f9:16:d0:57:fc:57:59:06:
+         af:39:9f:a9:51:35:0b:c7
+-----BEGIN CERTIFICATE-----
+MIIExzCCAq+gAwIBAgICEAcwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTIzMDUxMDE1NTAxOFoYDzIyOTcwMjIyMTU1MDE4WjAfMR0wGwYDVQQD
+DBRicm9rZXItbG9jYWxob3N0LVNBTjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
+AQoCggEBAN7R2ruRsxbEsuiJMJ7BXgvP28TD2bGvQKULODYbFP4PIpzmWWoVW9v2
+9/OlAimUetIMZ62qY2J+/FgRKUi4PJGyc34Sa/LqNncPFZtGlc5zFY3I2ZdXA5Az
+LX3z7uUBbdjG2qsHud0c4EvOat6o0uPBUm2DOgrw7c/3VmqHDnPjEoIrZavYqURb
+Si+lkpQy8aHkrxgPDxhgzffQnQOf1+moYFS7O5oF2/04BDy0I0EWbHw72bbgL73L
+YlUb6NCPQ3bvVYbPJcO8ruNGUIn3ca0GXijm9vB2J+p+G2dTOSYgGRiCsRFf6pHC
+49P2Wsf9YaKS3n182m3ovzlSEDFgS+ECAwEAAaOCARcwggETMAkGA1UdEwQCMAAw
+EQYJYIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVy
+YXRlZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFBcHO6qFg7UEg+yybB46
+8PVZqmEoMDcGA1UdEQQwMC6CCWxvY2FsaG9zdIIbdW5yZXNvbHZhYmxlLWJyb2tl
+ci1hZGRyZXNzhwR/AAABMEEGA1UdIwQ6MDiAFFcL6csj6L9HPlB6P0V+oRhDnRUn
+oRWkEzARMQ8wDQYDVQQDDAZmb29iYXKCCQDX4odPoHniDDAOBgNVHQ8BAf8EBAMC
+BaAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQELBQADggIBAOQnYeIP
+tqDKn87jUwtEq4ah4k2I4X0usKoylis92mBwasNixXbyjw0WMfKt5S9D88vk+pVs
+IIEzGsdaVVfJq8pmRTBYANvoUcksqXLBGPUBh59zIIVs5Ww/yWe08CDl7eJKCAuv
+aEPlqcfhOei1SctHSm3lFq6IkhOFjkIeCutZ7afBm7xLe5n4HfDXHZDJz4Zq0xDQ
+NuT1uTN5x6JoMfe7jR7WM3m95w5PTekuFQRPa0sukyhy0Q6q7ubvaL5YK8xWAScW
++TSOZoYnCrD7MlapitlvsYa9uv1QbNWyVOdOxi0ZiKmJLO++CA0rSZELCUJkBqOd
+15Tt6HR0SENXQW/lBphGHcVgnGn4+/6mAUo1viE2wqNEyMQsIQn0KJqtoJceACnM
+Dyb6WSElwJ76IlNnbaumVgj9Nx1p/u9vKYkaZnvH/7E08da+IYHjvE8TAqdLnRMF
+RkCISqrb+2T4a/tdoLEMGrhMq29p/gtVTrM4H5ELcXceETlUmmJR6m2oXg1KkfvY
+vl2T6EPzShH7Mc8UGhyNMRuZMeArgQGRb9q6yx9RIVUpP0xx49ApQd6gANoH7V7J
+rzJhbVX49S1GAzQz+y4eqnz+0jBNQMztduz2ve01yNizRlaqLFOEVkWwo/Y1ZpPa
+jBc5wSl8mcULc8H5FtBX/FdZBq85n6lRNQvH
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/newcerts/1008.pem b/tests/certificate-authority/newcerts/1008.pem
index 85687bdfd3..a58e3f33a8 100644
--- a/tests/certificate-authority/newcerts/1008.pem
+++ b/tests/certificate-authority/newcerts/1008.pem
@@ -1,110 +1,110 @@
-Certificate:
-    Data:
-        Version: 3 (0x2)
-        Serial Number: 4104 (0x1008)
-    Signature Algorithm: sha256WithRSAEncryption
-        Issuer: CN=foobar
-        Validity
-            Not Before: May 10 15:50:19 2023 GMT
-            Not After : Feb 22 15:50:19 2297 GMT
-        Subject: CN=proxy-localhost-SAN
-        Subject Public Key Info:
-            Public Key Algorithm: rsaEncryption
-                Public-Key: (2048 bit)
-                Modulus:
-                    00:cc:15:c9:85:06:43:47:bd:46:9f:4f:03:1a:e0:
-                    6e:94:13:4e:b0:30:ea:88:ca:3a:e4:39:92:12:c1:
-                    77:51:8c:0d:3c:b9:26:5c:2f:dc:fc:b1:5a:bf:0e:
-                    47:ff:09:60:30:79:8e:55:26:fe:d0:a1:ed:9f:6d:
-                    8a:6a:06:85:f0:d0:dc:94:a6:54:a1:a6:c9:3e:57:
-                    d5:69:7d:e9:25:c1:ef:6b:77:e1:62:76:d8:e4:54:
-                    91:40:bc:0b:11:74:b8:30:bb:d4:02:77:d6:bd:d2:
-                    d0:e7:ad:df:7d:98:96:74:42:ad:53:b3:88:c8:dc:
-                    1d:db:51:63:84:ee:7e:85:73:14:5e:d4:c8:f0:01:
-                    5f:67:52:ed:94:87:f7:d6:aa:28:8b:2c:84:98:8c:
-                    b9:91:b5:38:99:80:5d:b3:d4:db:95:96:09:ef:1d:
-                    a1:6f:86:c8:17:86:f7:0a:1e:72:3b:50:8c:53:e5:
-                    ce:d4:8c:cf:cc:81:3d:46:55:ff:65:25:0b:36:31:
-                    31:a6:22:27:47:96:59:38:c1:cd:66:a6:9a:83:98:
-                    dc:b8:2e:10:8d:ba:45:ae:aa:20:6e:e3:0b:bd:ec:
-                    e6:63:b5:40:55:d4:fe:97:b1:f1:8d:9a:c0:a2:46:
-                    8e:a3:ed:a0:1b:ed:40:b0:00:a5:28:f9:da:03:bd:
-                    c1:a9
-                Exponent: 65537 (0x10001)
-        X509v3 extensions:
-            X509v3 Basic Constraints: 
-                CA:FALSE
-            Netscape Cert Type: 
-                SSL Server
-            Netscape Comment: 
-                OpenSSL Generated Server Certificate
-            X509v3 Subject Key Identifier: 
-                C5:33:73:67:03:B7:51:08:F4:BD:D3:CD:4F:DC:CF:83:11:53:AD:39
-            X509v3 Subject Alternative Name: 
-                DNS:localhost, IP Address:127.0.0.1
-            X509v3 Authority Key Identifier: 
-                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
-                DirName:/CN=foobar
-                serial:D7:E2:87:4F:A0:79:E2:0C
-
-            X509v3 Key Usage: critical
-                Digital Signature, Key Encipherment
-            X509v3 Extended Key Usage: 
-                TLS Web Server Authentication
-    Signature Algorithm: sha256WithRSAEncryption
-         43:ef:67:29:9a:0c:53:97:7c:fc:72:73:6c:8d:48:78:4e:ec:
-         e3:14:9d:d9:1e:83:4c:d6:f0:56:e9:c4:d8:de:f5:54:fb:a5:
-         3b:ff:59:23:75:26:74:f0:86:90:d0:4d:41:25:03:87:e0:60:
-         a4:9b:33:3d:bd:1c:79:b8:db:86:1c:38:09:26:0d:80:3e:f9:
-         1e:28:11:0d:3d:6b:1e:1a:7a:9a:fa:fc:18:22:7f:fd:46:55:
-         c2:2f:56:5c:5c:8a:45:f2:74:7a:e4:6c:d0:e0:ea:ec:74:b7:
-         0d:a8:f3:ca:18:cf:a4:be:a0:e0:4a:32:ca:15:7e:5d:06:56:
-         b7:71:7c:e0:dc:19:fa:be:3e:94:84:20:be:96:34:61:0b:f0:
-         d1:d6:31:49:0b:b0:20:b8:f9:5c:49:08:13:9b:45:c0:6f:58:
-         16:81:0b:0c:f8:66:38:58:83:d4:b0:bc:14:35:8d:e2:1d:d5:
-         2d:ea:02:ae:42:e1:88:22:5a:b0:cf:e5:31:b1:cb:d3:e9:d2:
-         5e:88:55:bd:62:ac:85:aa:4e:fc:18:6b:65:f9:9e:fc:93:27:
-         0c:c6:29:aa:f0:64:6e:72:dc:d9:95:ae:38:ae:64:9e:c6:44:
-         8a:0b:0f:0e:d4:69:7e:79:e0:46:d0:75:96:2a:1a:60:af:30:
-         23:dc:d2:67:0d:08:2a:9d:58:29:09:1e:c8:08:d5:3a:88:2d:
-         1a:dc:47:dc:5d:bd:0d:5c:54:f1:5d:5a:6d:0d:de:bc:18:67:
-         2d:dd:1b:fe:8b:0e:03:19:b0:0f:f2:59:69:d0:7a:4f:a1:33:
-         74:f7:22:ef:ff:90:e1:4b:8e:ac:13:00:6f:00:9b:55:83:d2:
-         96:db:a8:81:c9:a9:8d:c6:a6:21:3d:14:d3:43:71:28:c6:ea:
-         6d:2d:91:b9:58:bf:ec:18:75:c4:8c:10:43:88:60:08:c0:bb:
-         9d:fb:90:80:1e:d5:a3:ea:e7:8a:16:f7:f4:d7:cb:35:93:03:
-         55:e4:cc:58:31:1e:df:6e:e4:1b:6e:ad:3a:76:56:e5:8b:4e:
-         d9:71:af:11:92:a7:7a:e2:66:cc:d2:73:f3:ec:e8:3b:67:f0:
-         6a:31:10:82:e8:c4:1e:ae:c3:54:a7:e2:42:86:fe:43:75:ad:
-         ef:83:d7:1c:2f:91:94:1c:57:9d:1c:43:94:b1:47:b2:6c:96:
-         fd:83:69:0f:6c:e2:18:9b:65:8e:71:08:01:b3:73:46:aa:3c:
-         2e:07:14:cd:03:ae:dc:5a:51:da:c5:41:53:cc:f5:fc:c8:db:
-         4e:76:27:99:9a:ec:40:68:07:d6:10:e1:f9:68:6b:5d:52:95:
-         3d:01:f4:a7:40:11:61:0a
------BEGIN CERTIFICATE-----
-MIIEpzCCAo+gAwIBAgICEAgwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTIzMDUxMDE1NTAxOVoYDzIyOTcwMjIyMTU1MDE5WjAeMRwwGgYDVQQD
-DBNwcm94eS1sb2NhbGhvc3QtU0FOMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
-CgKCAQEAzBXJhQZDR71Gn08DGuBulBNOsDDqiMo65DmSEsF3UYwNPLkmXC/c/LFa
-vw5H/wlgMHmOVSb+0KHtn22KagaF8NDclKZUoabJPlfVaX3pJcHva3fhYnbY5FSR
-QLwLEXS4MLvUAnfWvdLQ563ffZiWdEKtU7OIyNwd21FjhO5+hXMUXtTI8AFfZ1Lt
-lIf31qooiyyEmIy5kbU4mYBds9TblZYJ7x2hb4bIF4b3Ch5yO1CMU+XO1IzPzIE9
-RlX/ZSULNjExpiInR5ZZOMHNZqaag5jcuC4QjbpFrqogbuMLvezmY7VAVdT+l7Hx
-jZrAokaOo+2gG+1AsAClKPnaA73BqQIDAQABo4H5MIH2MAkGA1UdEwQCMAAwEQYJ
-YIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRl
-ZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFMUzc2cDt1EI9L3TzU/cz4MR
-U605MBoGA1UdEQQTMBGCCWxvY2FsaG9zdIcEfwAAATBBBgNVHSMEOjA4gBRXC+nL
-I+i/Rz5Qej9FfqEYQ50VJ6EVpBMwETEPMA0GA1UEAwwGZm9vYmFyggkA1+KHT6B5
-4gwwDgYDVR0PAQH/BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA0GCSqGSIb3
-DQEBCwUAA4ICAQBD72cpmgxTl3z8cnNsjUh4TuzjFJ3ZHoNM1vBW6cTY3vVU+6U7
-/1kjdSZ08IaQ0E1BJQOH4GCkmzM9vRx5uNuGHDgJJg2APvkeKBENPWseGnqa+vwY
-In/9RlXCL1ZcXIpF8nR65GzQ4OrsdLcNqPPKGM+kvqDgSjLKFX5dBla3cXzg3Bn6
-vj6UhCC+ljRhC/DR1jFJC7AguPlcSQgTm0XAb1gWgQsM+GY4WIPUsLwUNY3iHdUt
-6gKuQuGIIlqwz+UxscvT6dJeiFW9YqyFqk78GGtl+Z78kycMximq8GRuctzZla44
-rmSexkSKCw8O1Gl+eeBG0HWWKhpgrzAj3NJnDQgqnVgpCR7ICNU6iC0a3EfcXb0N
-XFTxXVptDd68GGct3Rv+iw4DGbAP8llp0HpPoTN09yLv/5DhS46sEwBvAJtVg9KW
-26iByamNxqYhPRTTQ3EoxuptLZG5WL/sGHXEjBBDiGAIwLud+5CAHtWj6ueKFvf0
-18s1kwNV5MxYMR7fbuQbbq06dlbli07Zca8Rkqd64mbM0nPz7Og7Z/BqMRCC6MQe
-rsNUp+JChv5Dda3vg9ccL5GUHFedHEOUsUeybJb9g2kPbOIYm2WOcQgBs3NGqjwu
-BxTNA67cWlHaxUFTzPX8yNtOdieZmuxAaAfWEOH5aGtdUpU9AfSnQBFhCg==
------END CERTIFICATE-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 4104 (0x1008)
+    Signature Algorithm: sha256WithRSAEncryption
+        Issuer: CN=foobar
+        Validity
+            Not Before: May 10 15:50:19 2023 GMT
+            Not After : Feb 22 15:50:19 2297 GMT
+        Subject: CN=proxy-localhost-SAN
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:cc:15:c9:85:06:43:47:bd:46:9f:4f:03:1a:e0:
+                    6e:94:13:4e:b0:30:ea:88:ca:3a:e4:39:92:12:c1:
+                    77:51:8c:0d:3c:b9:26:5c:2f:dc:fc:b1:5a:bf:0e:
+                    47:ff:09:60:30:79:8e:55:26:fe:d0:a1:ed:9f:6d:
+                    8a:6a:06:85:f0:d0:dc:94:a6:54:a1:a6:c9:3e:57:
+                    d5:69:7d:e9:25:c1:ef:6b:77:e1:62:76:d8:e4:54:
+                    91:40:bc:0b:11:74:b8:30:bb:d4:02:77:d6:bd:d2:
+                    d0:e7:ad:df:7d:98:96:74:42:ad:53:b3:88:c8:dc:
+                    1d:db:51:63:84:ee:7e:85:73:14:5e:d4:c8:f0:01:
+                    5f:67:52:ed:94:87:f7:d6:aa:28:8b:2c:84:98:8c:
+                    b9:91:b5:38:99:80:5d:b3:d4:db:95:96:09:ef:1d:
+                    a1:6f:86:c8:17:86:f7:0a:1e:72:3b:50:8c:53:e5:
+                    ce:d4:8c:cf:cc:81:3d:46:55:ff:65:25:0b:36:31:
+                    31:a6:22:27:47:96:59:38:c1:cd:66:a6:9a:83:98:
+                    dc:b8:2e:10:8d:ba:45:ae:aa:20:6e:e3:0b:bd:ec:
+                    e6:63:b5:40:55:d4:fe:97:b1:f1:8d:9a:c0:a2:46:
+                    8e:a3:ed:a0:1b:ed:40:b0:00:a5:28:f9:da:03:bd:
+                    c1:a9
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            Netscape Cert Type: 
+                SSL Server
+            Netscape Comment: 
+                OpenSSL Generated Server Certificate
+            X509v3 Subject Key Identifier: 
+                C5:33:73:67:03:B7:51:08:F4:BD:D3:CD:4F:DC:CF:83:11:53:AD:39
+            X509v3 Subject Alternative Name: 
+                DNS:localhost, IP Address:127.0.0.1
+            X509v3 Authority Key Identifier: 
+                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
+                DirName:/CN=foobar
+                serial:D7:E2:87:4F:A0:79:E2:0C
+
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication
+    Signature Algorithm: sha256WithRSAEncryption
+         43:ef:67:29:9a:0c:53:97:7c:fc:72:73:6c:8d:48:78:4e:ec:
+         e3:14:9d:d9:1e:83:4c:d6:f0:56:e9:c4:d8:de:f5:54:fb:a5:
+         3b:ff:59:23:75:26:74:f0:86:90:d0:4d:41:25:03:87:e0:60:
+         a4:9b:33:3d:bd:1c:79:b8:db:86:1c:38:09:26:0d:80:3e:f9:
+         1e:28:11:0d:3d:6b:1e:1a:7a:9a:fa:fc:18:22:7f:fd:46:55:
+         c2:2f:56:5c:5c:8a:45:f2:74:7a:e4:6c:d0:e0:ea:ec:74:b7:
+         0d:a8:f3:ca:18:cf:a4:be:a0:e0:4a:32:ca:15:7e:5d:06:56:
+         b7:71:7c:e0:dc:19:fa:be:3e:94:84:20:be:96:34:61:0b:f0:
+         d1:d6:31:49:0b:b0:20:b8:f9:5c:49:08:13:9b:45:c0:6f:58:
+         16:81:0b:0c:f8:66:38:58:83:d4:b0:bc:14:35:8d:e2:1d:d5:
+         2d:ea:02:ae:42:e1:88:22:5a:b0:cf:e5:31:b1:cb:d3:e9:d2:
+         5e:88:55:bd:62:ac:85:aa:4e:fc:18:6b:65:f9:9e:fc:93:27:
+         0c:c6:29:aa:f0:64:6e:72:dc:d9:95:ae:38:ae:64:9e:c6:44:
+         8a:0b:0f:0e:d4:69:7e:79:e0:46:d0:75:96:2a:1a:60:af:30:
+         23:dc:d2:67:0d:08:2a:9d:58:29:09:1e:c8:08:d5:3a:88:2d:
+         1a:dc:47:dc:5d:bd:0d:5c:54:f1:5d:5a:6d:0d:de:bc:18:67:
+         2d:dd:1b:fe:8b:0e:03:19:b0:0f:f2:59:69:d0:7a:4f:a1:33:
+         74:f7:22:ef:ff:90:e1:4b:8e:ac:13:00:6f:00:9b:55:83:d2:
+         96:db:a8:81:c9:a9:8d:c6:a6:21:3d:14:d3:43:71:28:c6:ea:
+         6d:2d:91:b9:58:bf:ec:18:75:c4:8c:10:43:88:60:08:c0:bb:
+         9d:fb:90:80:1e:d5:a3:ea:e7:8a:16:f7:f4:d7:cb:35:93:03:
+         55:e4:cc:58:31:1e:df:6e:e4:1b:6e:ad:3a:76:56:e5:8b:4e:
+         d9:71:af:11:92:a7:7a:e2:66:cc:d2:73:f3:ec:e8:3b:67:f0:
+         6a:31:10:82:e8:c4:1e:ae:c3:54:a7:e2:42:86:fe:43:75:ad:
+         ef:83:d7:1c:2f:91:94:1c:57:9d:1c:43:94:b1:47:b2:6c:96:
+         fd:83:69:0f:6c:e2:18:9b:65:8e:71:08:01:b3:73:46:aa:3c:
+         2e:07:14:cd:03:ae:dc:5a:51:da:c5:41:53:cc:f5:fc:c8:db:
+         4e:76:27:99:9a:ec:40:68:07:d6:10:e1:f9:68:6b:5d:52:95:
+         3d:01:f4:a7:40:11:61:0a
+-----BEGIN CERTIFICATE-----
+MIIEpzCCAo+gAwIBAgICEAgwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTIzMDUxMDE1NTAxOVoYDzIyOTcwMjIyMTU1MDE5WjAeMRwwGgYDVQQD
+DBNwcm94eS1sb2NhbGhvc3QtU0FOMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
+CgKCAQEAzBXJhQZDR71Gn08DGuBulBNOsDDqiMo65DmSEsF3UYwNPLkmXC/c/LFa
+vw5H/wlgMHmOVSb+0KHtn22KagaF8NDclKZUoabJPlfVaX3pJcHva3fhYnbY5FSR
+QLwLEXS4MLvUAnfWvdLQ563ffZiWdEKtU7OIyNwd21FjhO5+hXMUXtTI8AFfZ1Lt
+lIf31qooiyyEmIy5kbU4mYBds9TblZYJ7x2hb4bIF4b3Ch5yO1CMU+XO1IzPzIE9
+RlX/ZSULNjExpiInR5ZZOMHNZqaag5jcuC4QjbpFrqogbuMLvezmY7VAVdT+l7Hx
+jZrAokaOo+2gG+1AsAClKPnaA73BqQIDAQABo4H5MIH2MAkGA1UdEwQCMAAwEQYJ
+YIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRl
+ZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFMUzc2cDt1EI9L3TzU/cz4MR
+U605MBoGA1UdEQQTMBGCCWxvY2FsaG9zdIcEfwAAATBBBgNVHSMEOjA4gBRXC+nL
+I+i/Rz5Qej9FfqEYQ50VJ6EVpBMwETEPMA0GA1UEAwwGZm9vYmFyggkA1+KHT6B5
+4gwwDgYDVR0PAQH/BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA0GCSqGSIb3
+DQEBCwUAA4ICAQBD72cpmgxTl3z8cnNsjUh4TuzjFJ3ZHoNM1vBW6cTY3vVU+6U7
+/1kjdSZ08IaQ0E1BJQOH4GCkmzM9vRx5uNuGHDgJJg2APvkeKBENPWseGnqa+vwY
+In/9RlXCL1ZcXIpF8nR65GzQ4OrsdLcNqPPKGM+kvqDgSjLKFX5dBla3cXzg3Bn6
+vj6UhCC+ljRhC/DR1jFJC7AguPlcSQgTm0XAb1gWgQsM+GY4WIPUsLwUNY3iHdUt
+6gKuQuGIIlqwz+UxscvT6dJeiFW9YqyFqk78GGtl+Z78kycMximq8GRuctzZla44
+rmSexkSKCw8O1Gl+eeBG0HWWKhpgrzAj3NJnDQgqnVgpCR7ICNU6iC0a3EfcXb0N
+XFTxXVptDd68GGct3Rv+iw4DGbAP8llp0HpPoTN09yLv/5DhS46sEwBvAJtVg9KW
+26iByamNxqYhPRTTQ3EoxuptLZG5WL/sGHXEjBBDiGAIwLud+5CAHtWj6ueKFvf0
+18s1kwNV5MxYMR7fbuQbbq06dlbli07Zca8Rkqd64mbM0nPz7Og7Z/BqMRCC6MQe
+rsNUp+JChv5Dda3vg9ccL5GUHFedHEOUsUeybJb9g2kPbOIYm2WOcQgBs3NGqjwu
+BxTNA67cWlHaxUFTzPX8yNtOdieZmuxAaAfWEOH5aGtdUpU9AfSnQBFhCg==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/openssl.cnf b/tests/certificate-authority/openssl.cnf
index f7a23b3b33..bbc16fd762 100644
--- a/tests/certificate-authority/openssl.cnf
+++ b/tests/certificate-authority/openssl.cnf
@@ -1,128 +1,128 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-# 
-# Configuration file for testing certificate authority.
-# The environment variable, CA_HOME, must be set to point to the directory
-# containing this file before running any openssl commands.
-#
-[ ca ]
-# `man ca`
-default_ca = CA_default
-
-[ CA_default ]
-# Directory and file locations.
-dir               = .
-certs             = $dir/certs
-crl_dir           = $dir/crl
-new_certs_dir     = $dir/newcerts
-database          = $dir/index.txt
-serial            = $dir/serial
-RANDFILE          = $dir/private/.rand
-
-# The root key and root certificate.
-private_key       = $dir/private/ca.key.pem
-certificate       = $dir/certs/ca.cert.pem
-
-# For certificate revocation lists.
-crlnumber         = $dir/crlnumber
-crl               = $dir/crl/ca.crl.pem
-crl_extensions    = crl_ext
-default_crl_days  = 30
-
-# SHA-1 is deprecated, so use SHA-2 instead.
-default_md        = sha256
-
-name_opt          = ca_default
-cert_opt          = ca_default
-default_days      = 375
-preserve          = no
-policy            = policy_strict
-
-[ policy_strict ]
-# The root CA should only sign intermediate certificates that match.
-# See the POLICY FORMAT section of `man ca`.
-commonName              = supplied
-
-[ req ]
-# Options for the `req` tool (`man req`).
-default_bits        = 2048
-distinguished_name  = req_distinguished_name
-string_mask         = utf8only
-
-# SHA-1 is deprecated, so use SHA-2 instead.
-default_md          = sha256
-
-# Extension to add when the -x509 option is used.
-x509_extensions     = v3_ca
-
-[ req_distinguished_name ]
-# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
-commonName                      = Common Name
-
-[ v3_ca ]
-# Extensions for a typical CA (`man x509v3_config`).
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid:always,issuer
-basicConstraints = critical, CA:true
-keyUsage = critical, digitalSignature, cRLSign, keyCertSign
-
-[ usr_cert ]
-# Extensions for client certificates (`man x509v3_config`).
-basicConstraints = CA:FALSE
-nsCertType = client, email
-nsComment = "OpenSSL Generated Client Certificate"
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid,issuer
-keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
-extendedKeyUsage = clientAuth, emailProtection
-
-[ broker_cert ]
-# Extensions for server certificates (`man x509v3_config`).
-basicConstraints = CA:FALSE
-nsCertType = server
-nsComment = "OpenSSL Generated Server Certificate"
-subjectKeyIdentifier = hash
-# The unresolvable address is used for SNI testing
-subjectAltName = DNS:localhost, DNS:unresolvable-broker-address, IP:127.0.0.1
-authorityKeyIdentifier = keyid,issuer:always
-keyUsage = critical, digitalSignature, keyEncipherment
-extendedKeyUsage = serverAuth
-
-[ proxy_cert ]
-# Extensions for server certificates (`man x509v3_config`).
-basicConstraints = CA:FALSE
-nsCertType = server
-nsComment = "OpenSSL Generated Server Certificate"
-subjectKeyIdentifier = hash
-subjectAltName = DNS:localhost, IP:127.0.0.1
-authorityKeyIdentifier = keyid,issuer:always
-keyUsage = critical, digitalSignature, keyEncipherment
-extendedKeyUsage = serverAuth
-
-[ crl_ext ]
-# Extension for CRLs (`man x509v3_config`).
-authorityKeyIdentifier=keyid:always
-
-[ ocsp ]
-# Extension for OCSP signing certificates (`man ocsp`).
-basicConstraints = CA:FALSE
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid,issuer
-keyUsage = critical, digitalSignature
-extendedKeyUsage = critical, OCSPSigning
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+# 
+# Configuration file for testing certificate authority.
+# The environment variable, CA_HOME, must be set to point to the directory
+# containing this file before running any openssl commands.
+#
+[ ca ]
+# `man ca`
+default_ca = CA_default
+
+[ CA_default ]
+# Directory and file locations.
+dir               = .
+certs             = $dir/certs
+crl_dir           = $dir/crl
+new_certs_dir     = $dir/newcerts
+database          = $dir/index.txt
+serial            = $dir/serial
+RANDFILE          = $dir/private/.rand
+
+# The root key and root certificate.
+private_key       = $dir/private/ca.key.pem
+certificate       = $dir/certs/ca.cert.pem
+
+# For certificate revocation lists.
+crlnumber         = $dir/crlnumber
+crl               = $dir/crl/ca.crl.pem
+crl_extensions    = crl_ext
+default_crl_days  = 30
+
+# SHA-1 is deprecated, so use SHA-2 instead.
+default_md        = sha256
+
+name_opt          = ca_default
+cert_opt          = ca_default
+default_days      = 375
+preserve          = no
+policy            = policy_strict
+
+[ policy_strict ]
+# The root CA should only sign intermediate certificates that match.
+# See the POLICY FORMAT section of `man ca`.
+commonName              = supplied
+
+[ req ]
+# Options for the `req` tool (`man req`).
+default_bits        = 2048
+distinguished_name  = req_distinguished_name
+string_mask         = utf8only
+
+# SHA-1 is deprecated, so use SHA-2 instead.
+default_md          = sha256
+
+# Extension to add when the -x509 option is used.
+x509_extensions     = v3_ca
+
+[ req_distinguished_name ]
+# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
+commonName                      = Common Name
+
+[ v3_ca ]
+# Extensions for a typical CA (`man x509v3_config`).
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid:always,issuer
+basicConstraints = critical, CA:true
+keyUsage = critical, digitalSignature, cRLSign, keyCertSign
+
+[ usr_cert ]
+# Extensions for client certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = client, email
+nsComment = "OpenSSL Generated Client Certificate"
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer
+keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
+extendedKeyUsage = clientAuth, emailProtection
+
+[ broker_cert ]
+# Extensions for server certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = server
+nsComment = "OpenSSL Generated Server Certificate"
+subjectKeyIdentifier = hash
+# The unresolvable address is used for SNI testing
+subjectAltName = DNS:localhost, DNS:unresolvable-broker-address, IP:127.0.0.1
+authorityKeyIdentifier = keyid,issuer:always
+keyUsage = critical, digitalSignature, keyEncipherment
+extendedKeyUsage = serverAuth
+
+[ proxy_cert ]
+# Extensions for server certificates (`man x509v3_config`).
+basicConstraints = CA:FALSE
+nsCertType = server
+nsComment = "OpenSSL Generated Server Certificate"
+subjectKeyIdentifier = hash
+subjectAltName = DNS:localhost, IP:127.0.0.1
+authorityKeyIdentifier = keyid,issuer:always
+keyUsage = critical, digitalSignature, keyEncipherment
+extendedKeyUsage = serverAuth
+
+[ crl_ext ]
+# Extension for CRLs (`man x509v3_config`).
+authorityKeyIdentifier=keyid:always
+
+[ ocsp ]
+# Extension for OCSP signing certificates (`man ocsp`).
+basicConstraints = CA:FALSE
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid,issuer
+keyUsage = critical, digitalSignature
+extendedKeyUsage = critical, OCSPSigning
diff --git a/tests/certificate-authority/private/ca.key.pem b/tests/certificate-authority/private/ca.key.pem
index 81bf0a975a..4d780fb605 100644
--- a/tests/certificate-authority/private/ca.key.pem
+++ b/tests/certificate-authority/private/ca.key.pem
@@ -1,54 +1,54 @@
------BEGIN RSA PRIVATE KEY-----
-Proc-Type: 4,ENCRYPTED
-DEK-Info: AES-256-CBC,F5EE66FC9E0BAC81B099AD0295201BA4
-
-7gxBEmHrsr6Q3Fij0vduvcSgKTgTy7BS2qGdnE2fiZHk63Z1rLh6V/nPpv9VAvbh
-oZU7WA1ysN/szUoHUFQnsKYH4wPxk2YHVMm435JPb+CLCwV3tly2iCzc5AXu3+v/
-8x+oD5Ad8mlNUPIur6LlWP60lGn18mKwDpqhMIjS/3gzOb5lGyw0MimQYCOTjzeS
-HzwsATWpRmblh5YHzdPewB/sG7xYVi6DKmdg5H2CKFuEXVGFiTk1sxuCSWSF0dlu
-o+PKOwJCn9xKl+JlczttR8qgoNKu/ajn9B+bog5xcznPyIi/j5eEvAoxg/GmwWEM
-c1VBxoEre7dokteGF3elOidTiUqPWT2Qseyo1oITT2JA5cW3eZEXYu+dD8nx3aNU
-dUYYdl84uzOhTjEA0wg8X4jWuwijHhdjzASxduVWfOrQGaYYN51ZfhEbIb3e07sJ
-oyl854Wf0yGajLfuYx/nPxi7wHeUWMKRysVXxP7A3T+9IyMG5Nq90D1kfiRMETEQ
-Ks3oqrUoLvD4e/oq/oypqQSo7FfZkj6KyEELZTdRjh7tvSvJ8a8a1VVmgA0G0wV5
-VCd/c0c12O1pCNy9cOfEkPSVc2q2ep/fX8RqvWxkpHV/n80uIn6uDwPdzNDyx4JD
-7S19sOwdhxd2u1WdibEu9k9JjpZbigKk0fvyu4/C2h4ElwSMxyNbcJi7aOwZjOnj
-prCDgza66m04hBKj442qDLRdxBTL21eQjxGIwbsEUf60GXRlGZg3K4VprMgjFLyK
-IB+6e5lx1sbU89NHwrFIGvkIdAF4N2h6Vn4T8EIpHrufRuFIiuMRB4v8K/Frgj/U
-/I+HWw0TCZIjRqgC8mMPJZiDf6u+UzE8L5uvYXGKUJqSSffSwSmZYxeaGBKplwkm
-4g68gcVYfL7I2Kpnr9WUhwJemgvYX+VYckNr+FxhIUvdvGSq8GBYwYOd8UcjkXpp
-wb4ZoNFOU+fr+WsZJhV4js0pEQqzzwWSxOOE5DK3IZQGbBVutdxgex/VSgGydZ7X
-4x1I/MmO/z5srS9mHOGDQFneZphwP3GjSCQt+/yeyZ5SOSIRKusZJxyjWlxiBl7M
-45PZ/L3ZhFHa3KZO4rW8KN8EygLm6dJ9laIdIWEN1NnLpaeimZ2UWVsewqPjRTgA
-ZGOU98YrDH5FiFWy4YX6eW/CXaRBlLURicwLezs6U3yoIfAON45adyVcPFCWMDun
-0XKndCnuz90kcRUiim80A1QhbiLxp5kPolrWDSnybthLXID6zLIY8bpHfYOLgIVm
-VC24NXMU+IwXJ/18ElL/062B4Pll8JpeAvcvgg1BwCwPJndorHloS5d2ohq2qDNu
-1k7eAR80yrPfgVcmVwUamLThahQA3h8WrlzzoVUCLVvkQmj2DHF0wRNA1I3BBdik
-NvktdVidgbLSh+t9X7ULegNUlRMRROuMrPgmZgc6/D1IFNEYxy/EM/iCDI3HPzaI
-e+1yAdQxM2FfSYsIa372BScc159U6CdOjESkbfqKoni/OcwghA6mRJ0VaO2sunRp
-FO8M/S7xAO8GzE/Tl2JHQupXnPrl68mcHnKZPhZW0/NmtUSZ9GdkZ8qlGKInkQAi
-PaddOZICyw9b8tt5qQTaSRkXDzleYIRirYe78x1QY7qotY8TmC/FvREhMNLWmdkb
-GQ9BYU2IyM5V6++ydlHtsBhk+zil5Zl7jVYopqnaw7L8puuShcq8KKw+pAaKwZhw
-ghKGXsclgWZxsuJMUws0VntfXCb5twCa4Pe73uWivA8/GzOLaphwPN7NuKCLmqoa
-7AbEgWMHUM2LElmqhwJbM5A9tAOwgbFPRiDo2ZGVvK5ILJHqDO77jSLzo54iaj7r
-8YnzRSK4wLay1cJJ6m7IYc8IZUyleofI8aP/JP/icsg5Kxjwx38407lof1jkGw+K
-Qq15Q5h54zMc1EJpGuuiJ5sXRd+TFyVX4dIWzc2KhzauSNogok/wCLIitmD70S48
-PfYoC5oXNtCFjGL0skJeDqCy0sXkUPXaLd9kfjo5NmIpTRDFiLtknjmRwKFJvreM
-K1pXNYCcSAWJ1vOvA71fJiuhtc77vOCVGywhlSwN5bdV16cVaoPdzl1qgXBZZPCY
-UoHjPa66vg9t7BoQ9eTae/7A7i7DSKBAyCn/8PR4YLmcDLGSN7Lx9Hb0JLHfYFLm
-dydQ3lWX5dFb1kmy8NgeNuFWaaSpS3/HzIIjOIUUaQfTQOQ6eGGzpXN45Axxyppi
-KGwUr9jsA6jsPpqvTJaJ3eH2CyTB+oId8vMNxaadFCIkM47wklBnVBw6h7CBxXQO
-pBztI3hcrY13LSBEqD8GuWqkmMEJWEaStuaeZN1zcPq8R+UmdZXKUd2gQpBmxsz6
-iooAWwZhsOtlWcA8O6xe61KWSrxEi8S40zZ5EAIN0CPLie9IYoyRJFvtALJl7PrG
-BaW3tbD7TL/g6VC/ocKQLVMkGNvyVY9l8A/gYWlbR7rqib/0NVX0+kufGdDNhX1M
-ZrrhphqG/vs4RHWSwyO7+u5kPF+XthzaWuxad/0SonCdN5J6iwseIrLuOfBxkbxD
-wd4qL5KN1MXT23ccTPYAug5LZ3HBcbxPtGH/ywLCTxYHWw0Z8x7yfXjgXkssGVwr
-wSkHysTaldyI45ForiZXJR6GwL/Xxi8nZzJf2/ygFwItFA5qOHw+B6yrItDsanow
-bDBDKdRgNlIKmf0rI9ZIIOX/L4L4gyoJLuXV5z09wLQkuTuCFytndp7eFnX/EeSE
-jIljQ1U53MeBAp/vIxqf97c4K5YAd5QMSvRG124F7nWLWBI3jS4wzJfF9+DHTsJ+
-qVOEjjAqAH9WpSZzgkiisQh3ba5tU2e4JHc5ABsdTFKN/dda7IbOH7Ht1SnWQZ5M
-HapgCcXNXc/JtXrliLcQmAfWyxSr2l9QClZ2pA5vqqzB1ds6kM7qxcI6TsUCiUnO
-pzqQsPXXL0mAoo3OoItW4qEQhPYRuNK3VZoxr+LIiAR5hvfd2KOs81l8olJSgM2R
-1ktO79H764pn4TrR2kDFyrFov7PxnrW0dTuhQ+/4SAJ1Jm6r8PDD+sn9kD9Eax6g
-EPVemVjJ9lvuiWlMH1lYtu8Wcpzn1ZzSjiY0irLrhdg0jhJPTQG/4fDoD90NtT2y
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-256-CBC,F5EE66FC9E0BAC81B099AD0295201BA4
+
+7gxBEmHrsr6Q3Fij0vduvcSgKTgTy7BS2qGdnE2fiZHk63Z1rLh6V/nPpv9VAvbh
+oZU7WA1ysN/szUoHUFQnsKYH4wPxk2YHVMm435JPb+CLCwV3tly2iCzc5AXu3+v/
+8x+oD5Ad8mlNUPIur6LlWP60lGn18mKwDpqhMIjS/3gzOb5lGyw0MimQYCOTjzeS
+HzwsATWpRmblh5YHzdPewB/sG7xYVi6DKmdg5H2CKFuEXVGFiTk1sxuCSWSF0dlu
+o+PKOwJCn9xKl+JlczttR8qgoNKu/ajn9B+bog5xcznPyIi/j5eEvAoxg/GmwWEM
+c1VBxoEre7dokteGF3elOidTiUqPWT2Qseyo1oITT2JA5cW3eZEXYu+dD8nx3aNU
+dUYYdl84uzOhTjEA0wg8X4jWuwijHhdjzASxduVWfOrQGaYYN51ZfhEbIb3e07sJ
+oyl854Wf0yGajLfuYx/nPxi7wHeUWMKRysVXxP7A3T+9IyMG5Nq90D1kfiRMETEQ
+Ks3oqrUoLvD4e/oq/oypqQSo7FfZkj6KyEELZTdRjh7tvSvJ8a8a1VVmgA0G0wV5
+VCd/c0c12O1pCNy9cOfEkPSVc2q2ep/fX8RqvWxkpHV/n80uIn6uDwPdzNDyx4JD
+7S19sOwdhxd2u1WdibEu9k9JjpZbigKk0fvyu4/C2h4ElwSMxyNbcJi7aOwZjOnj
+prCDgza66m04hBKj442qDLRdxBTL21eQjxGIwbsEUf60GXRlGZg3K4VprMgjFLyK
+IB+6e5lx1sbU89NHwrFIGvkIdAF4N2h6Vn4T8EIpHrufRuFIiuMRB4v8K/Frgj/U
+/I+HWw0TCZIjRqgC8mMPJZiDf6u+UzE8L5uvYXGKUJqSSffSwSmZYxeaGBKplwkm
+4g68gcVYfL7I2Kpnr9WUhwJemgvYX+VYckNr+FxhIUvdvGSq8GBYwYOd8UcjkXpp
+wb4ZoNFOU+fr+WsZJhV4js0pEQqzzwWSxOOE5DK3IZQGbBVutdxgex/VSgGydZ7X
+4x1I/MmO/z5srS9mHOGDQFneZphwP3GjSCQt+/yeyZ5SOSIRKusZJxyjWlxiBl7M
+45PZ/L3ZhFHa3KZO4rW8KN8EygLm6dJ9laIdIWEN1NnLpaeimZ2UWVsewqPjRTgA
+ZGOU98YrDH5FiFWy4YX6eW/CXaRBlLURicwLezs6U3yoIfAON45adyVcPFCWMDun
+0XKndCnuz90kcRUiim80A1QhbiLxp5kPolrWDSnybthLXID6zLIY8bpHfYOLgIVm
+VC24NXMU+IwXJ/18ElL/062B4Pll8JpeAvcvgg1BwCwPJndorHloS5d2ohq2qDNu
+1k7eAR80yrPfgVcmVwUamLThahQA3h8WrlzzoVUCLVvkQmj2DHF0wRNA1I3BBdik
+NvktdVidgbLSh+t9X7ULegNUlRMRROuMrPgmZgc6/D1IFNEYxy/EM/iCDI3HPzaI
+e+1yAdQxM2FfSYsIa372BScc159U6CdOjESkbfqKoni/OcwghA6mRJ0VaO2sunRp
+FO8M/S7xAO8GzE/Tl2JHQupXnPrl68mcHnKZPhZW0/NmtUSZ9GdkZ8qlGKInkQAi
+PaddOZICyw9b8tt5qQTaSRkXDzleYIRirYe78x1QY7qotY8TmC/FvREhMNLWmdkb
+GQ9BYU2IyM5V6++ydlHtsBhk+zil5Zl7jVYopqnaw7L8puuShcq8KKw+pAaKwZhw
+ghKGXsclgWZxsuJMUws0VntfXCb5twCa4Pe73uWivA8/GzOLaphwPN7NuKCLmqoa
+7AbEgWMHUM2LElmqhwJbM5A9tAOwgbFPRiDo2ZGVvK5ILJHqDO77jSLzo54iaj7r
+8YnzRSK4wLay1cJJ6m7IYc8IZUyleofI8aP/JP/icsg5Kxjwx38407lof1jkGw+K
+Qq15Q5h54zMc1EJpGuuiJ5sXRd+TFyVX4dIWzc2KhzauSNogok/wCLIitmD70S48
+PfYoC5oXNtCFjGL0skJeDqCy0sXkUPXaLd9kfjo5NmIpTRDFiLtknjmRwKFJvreM
+K1pXNYCcSAWJ1vOvA71fJiuhtc77vOCVGywhlSwN5bdV16cVaoPdzl1qgXBZZPCY
+UoHjPa66vg9t7BoQ9eTae/7A7i7DSKBAyCn/8PR4YLmcDLGSN7Lx9Hb0JLHfYFLm
+dydQ3lWX5dFb1kmy8NgeNuFWaaSpS3/HzIIjOIUUaQfTQOQ6eGGzpXN45Axxyppi
+KGwUr9jsA6jsPpqvTJaJ3eH2CyTB+oId8vMNxaadFCIkM47wklBnVBw6h7CBxXQO
+pBztI3hcrY13LSBEqD8GuWqkmMEJWEaStuaeZN1zcPq8R+UmdZXKUd2gQpBmxsz6
+iooAWwZhsOtlWcA8O6xe61KWSrxEi8S40zZ5EAIN0CPLie9IYoyRJFvtALJl7PrG
+BaW3tbD7TL/g6VC/ocKQLVMkGNvyVY9l8A/gYWlbR7rqib/0NVX0+kufGdDNhX1M
+ZrrhphqG/vs4RHWSwyO7+u5kPF+XthzaWuxad/0SonCdN5J6iwseIrLuOfBxkbxD
+wd4qL5KN1MXT23ccTPYAug5LZ3HBcbxPtGH/ywLCTxYHWw0Z8x7yfXjgXkssGVwr
+wSkHysTaldyI45ForiZXJR6GwL/Xxi8nZzJf2/ygFwItFA5qOHw+B6yrItDsanow
+bDBDKdRgNlIKmf0rI9ZIIOX/L4L4gyoJLuXV5z09wLQkuTuCFytndp7eFnX/EeSE
+jIljQ1U53MeBAp/vIxqf97c4K5YAd5QMSvRG124F7nWLWBI3jS4wzJfF9+DHTsJ+
+qVOEjjAqAH9WpSZzgkiisQh3ba5tU2e4JHc5ABsdTFKN/dda7IbOH7Ht1SnWQZ5M
+HapgCcXNXc/JtXrliLcQmAfWyxSr2l9QClZ2pA5vqqzB1ds6kM7qxcI6TsUCiUnO
+pzqQsPXXL0mAoo3OoItW4qEQhPYRuNK3VZoxr+LIiAR5hvfd2KOs81l8olJSgM2R
+1ktO79H764pn4TrR2kDFyrFov7PxnrW0dTuhQ+/4SAJ1Jm6r8PDD+sn9kD9Eax6g
+EPVemVjJ9lvuiWlMH1lYtu8Wcpzn1ZzSjiY0irLrhdg0jhJPTQG/4fDoD90NtT2y
+-----END RSA PRIVATE KEY-----
diff --git a/tests/certificate-authority/serial b/tests/certificate-authority/serial
index 6cb3869343..b8e58f1085 100644
--- a/tests/certificate-authority/serial
+++ b/tests/certificate-authority/serial
@@ -1 +1 @@
-1009
+1009
diff --git a/tests/certificate-authority/server-keys/broker.cert.pem b/tests/certificate-authority/server-keys/broker.cert.pem
index 4237719f20..3b4e93f962 100644
--- a/tests/certificate-authority/server-keys/broker.cert.pem
+++ b/tests/certificate-authority/server-keys/broker.cert.pem
@@ -1,111 +1,111 @@
-Certificate:
-    Data:
-        Version: 3 (0x2)
-        Serial Number: 4103 (0x1007)
-    Signature Algorithm: sha256WithRSAEncryption
-        Issuer: CN=foobar
-        Validity
-            Not Before: May 10 15:50:18 2023 GMT
-            Not After : Feb 22 15:50:18 2297 GMT
-        Subject: CN=broker-localhost-SAN
-        Subject Public Key Info:
-            Public Key Algorithm: rsaEncryption
-                Public-Key: (2048 bit)
-                Modulus:
-                    00:de:d1:da:bb:91:b3:16:c4:b2:e8:89:30:9e:c1:
-                    5e:0b:cf:db:c4:c3:d9:b1:af:40:a5:0b:38:36:1b:
-                    14:fe:0f:22:9c:e6:59:6a:15:5b:db:f6:f7:f3:a5:
-                    02:29:94:7a:d2:0c:67:ad:aa:63:62:7e:fc:58:11:
-                    29:48:b8:3c:91:b2:73:7e:12:6b:f2:ea:36:77:0f:
-                    15:9b:46:95:ce:73:15:8d:c8:d9:97:57:03:90:33:
-                    2d:7d:f3:ee:e5:01:6d:d8:c6:da:ab:07:b9:dd:1c:
-                    e0:4b:ce:6a:de:a8:d2:e3:c1:52:6d:83:3a:0a:f0:
-                    ed:cf:f7:56:6a:87:0e:73:e3:12:82:2b:65:ab:d8:
-                    a9:44:5b:4a:2f:a5:92:94:32:f1:a1:e4:af:18:0f:
-                    0f:18:60:cd:f7:d0:9d:03:9f:d7:e9:a8:60:54:bb:
-                    3b:9a:05:db:fd:38:04:3c:b4:23:41:16:6c:7c:3b:
-                    d9:b6:e0:2f:bd:cb:62:55:1b:e8:d0:8f:43:76:ef:
-                    55:86:cf:25:c3:bc:ae:e3:46:50:89:f7:71:ad:06:
-                    5e:28:e6:f6:f0:76:27:ea:7e:1b:67:53:39:26:20:
-                    19:18:82:b1:11:5f:ea:91:c2:e3:d3:f6:5a:c7:fd:
-                    61:a2:92:de:7d:7c:da:6d:e8:bf:39:52:10:31:60:
-                    4b:e1
-                Exponent: 65537 (0x10001)
-        X509v3 extensions:
-            X509v3 Basic Constraints: 
-                CA:FALSE
-            Netscape Cert Type: 
-                SSL Server
-            Netscape Comment: 
-                OpenSSL Generated Server Certificate
-            X509v3 Subject Key Identifier: 
-                17:07:3B:AA:85:83:B5:04:83:EC:B2:6C:1E:3A:F0:F5:59:AA:61:28
-            X509v3 Subject Alternative Name: 
-                DNS:localhost, DNS:unresolvable-broker-address, IP Address:127.0.0.1
-            X509v3 Authority Key Identifier: 
-                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
-                DirName:/CN=foobar
-                serial:D7:E2:87:4F:A0:79:E2:0C
-
-            X509v3 Key Usage: critical
-                Digital Signature, Key Encipherment
-            X509v3 Extended Key Usage: 
-                TLS Web Server Authentication
-    Signature Algorithm: sha256WithRSAEncryption
-         e4:27:61:e2:0f:b6:a0:ca:9f:ce:e3:53:0b:44:ab:86:a1:e2:
-         4d:88:e1:7d:2e:b0:aa:32:96:2b:3d:da:60:70:6a:c3:62:c5:
-         76:f2:8f:0d:16:31:f2:ad:e5:2f:43:f3:cb:e4:fa:95:6c:20:
-         81:33:1a:c7:5a:55:57:c9:ab:ca:66:45:30:58:00:db:e8:51:
-         c9:2c:a9:72:c1:18:f5:01:87:9f:73:20:85:6c:e5:6c:3f:c9:
-         67:b4:f0:20:e5:ed:e2:4a:08:0b:af:68:43:e5:a9:c7:e1:39:
-         e8:b5:49:cb:47:4a:6d:e5:16:ae:88:92:13:85:8e:42:1e:0a:
-         eb:59:ed:a7:c1:9b:bc:4b:7b:99:f8:1d:f0:d7:1d:90:c9:cf:
-         86:6a:d3:10:d0:36:e4:f5:b9:33:79:c7:a2:68:31:f7:bb:8d:
-         1e:d6:33:79:bd:e7:0e:4f:4d:e9:2e:15:04:4f:6b:4b:2e:93:
-         28:72:d1:0e:aa:ee:e6:ef:68:be:58:2b:cc:56:01:27:16:f9:
-         34:8e:66:86:27:0a:b0:fb:32:56:a9:8a:d9:6f:b1:86:bd:ba:
-         fd:50:6c:d5:b2:54:e7:4e:c6:2d:19:88:a9:89:2c:ef:be:08:
-         0d:2b:49:91:0b:09:42:64:06:a3:9d:d7:94:ed:e8:74:74:48:
-         43:57:41:6f:e5:06:98:46:1d:c5:60:9c:69:f8:fb:fe:a6:01:
-         4a:35:be:21:36:c2:a3:44:c8:c4:2c:21:09:f4:28:9a:ad:a0:
-         97:1e:00:29:cc:0f:26:fa:59:21:25:c0:9e:fa:22:53:67:6d:
-         ab:a6:56:08:fd:37:1d:69:fe:ef:6f:29:89:1a:66:7b:c7:ff:
-         b1:34:f1:d6:be:21:81:e3:bc:4f:13:02:a7:4b:9d:13:05:46:
-         40:88:4a:aa:db:fb:64:f8:6b:fb:5d:a0:b1:0c:1a:b8:4c:ab:
-         6f:69:fe:0b:55:4e:b3:38:1f:91:0b:71:77:1e:11:39:54:9a:
-         62:51:ea:6d:a8:5e:0d:4a:91:fb:d8:be:5d:93:e8:43:f3:4a:
-         11:fb:31:cf:14:1a:1c:8d:31:1b:99:31:e0:2b:81:01:91:6f:
-         da:ba:cb:1f:51:21:55:29:3f:4c:71:e3:d0:29:41:de:a0:00:
-         da:07:ed:5e:c9:af:32:61:6d:55:f8:f5:2d:46:03:34:33:fb:
-         2e:1e:aa:7c:fe:d2:30:4d:40:cc:ed:76:ec:f6:bd:ed:35:c8:
-         d8:b3:46:56:aa:2c:53:84:56:45:b0:a3:f6:35:66:93:da:8c:
-         17:39:c1:29:7c:99:c5:0b:73:c1:f9:16:d0:57:fc:57:59:06:
-         af:39:9f:a9:51:35:0b:c7
------BEGIN CERTIFICATE-----
-MIIExzCCAq+gAwIBAgICEAcwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTIzMDUxMDE1NTAxOFoYDzIyOTcwMjIyMTU1MDE4WjAfMR0wGwYDVQQD
-DBRicm9rZXItbG9jYWxob3N0LVNBTjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
-AQoCggEBAN7R2ruRsxbEsuiJMJ7BXgvP28TD2bGvQKULODYbFP4PIpzmWWoVW9v2
-9/OlAimUetIMZ62qY2J+/FgRKUi4PJGyc34Sa/LqNncPFZtGlc5zFY3I2ZdXA5Az
-LX3z7uUBbdjG2qsHud0c4EvOat6o0uPBUm2DOgrw7c/3VmqHDnPjEoIrZavYqURb
-Si+lkpQy8aHkrxgPDxhgzffQnQOf1+moYFS7O5oF2/04BDy0I0EWbHw72bbgL73L
-YlUb6NCPQ3bvVYbPJcO8ruNGUIn3ca0GXijm9vB2J+p+G2dTOSYgGRiCsRFf6pHC
-49P2Wsf9YaKS3n182m3ovzlSEDFgS+ECAwEAAaOCARcwggETMAkGA1UdEwQCMAAw
-EQYJYIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVy
-YXRlZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFBcHO6qFg7UEg+yybB46
-8PVZqmEoMDcGA1UdEQQwMC6CCWxvY2FsaG9zdIIbdW5yZXNvbHZhYmxlLWJyb2tl
-ci1hZGRyZXNzhwR/AAABMEEGA1UdIwQ6MDiAFFcL6csj6L9HPlB6P0V+oRhDnRUn
-oRWkEzARMQ8wDQYDVQQDDAZmb29iYXKCCQDX4odPoHniDDAOBgNVHQ8BAf8EBAMC
-BaAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQELBQADggIBAOQnYeIP
-tqDKn87jUwtEq4ah4k2I4X0usKoylis92mBwasNixXbyjw0WMfKt5S9D88vk+pVs
-IIEzGsdaVVfJq8pmRTBYANvoUcksqXLBGPUBh59zIIVs5Ww/yWe08CDl7eJKCAuv
-aEPlqcfhOei1SctHSm3lFq6IkhOFjkIeCutZ7afBm7xLe5n4HfDXHZDJz4Zq0xDQ
-NuT1uTN5x6JoMfe7jR7WM3m95w5PTekuFQRPa0sukyhy0Q6q7ubvaL5YK8xWAScW
-+TSOZoYnCrD7MlapitlvsYa9uv1QbNWyVOdOxi0ZiKmJLO++CA0rSZELCUJkBqOd
-15Tt6HR0SENXQW/lBphGHcVgnGn4+/6mAUo1viE2wqNEyMQsIQn0KJqtoJceACnM
-Dyb6WSElwJ76IlNnbaumVgj9Nx1p/u9vKYkaZnvH/7E08da+IYHjvE8TAqdLnRMF
-RkCISqrb+2T4a/tdoLEMGrhMq29p/gtVTrM4H5ELcXceETlUmmJR6m2oXg1KkfvY
-vl2T6EPzShH7Mc8UGhyNMRuZMeArgQGRb9q6yx9RIVUpP0xx49ApQd6gANoH7V7J
-rzJhbVX49S1GAzQz+y4eqnz+0jBNQMztduz2ve01yNizRlaqLFOEVkWwo/Y1ZpPa
-jBc5wSl8mcULc8H5FtBX/FdZBq85n6lRNQvH
------END CERTIFICATE-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 4103 (0x1007)
+    Signature Algorithm: sha256WithRSAEncryption
+        Issuer: CN=foobar
+        Validity
+            Not Before: May 10 15:50:18 2023 GMT
+            Not After : Feb 22 15:50:18 2297 GMT
+        Subject: CN=broker-localhost-SAN
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:de:d1:da:bb:91:b3:16:c4:b2:e8:89:30:9e:c1:
+                    5e:0b:cf:db:c4:c3:d9:b1:af:40:a5:0b:38:36:1b:
+                    14:fe:0f:22:9c:e6:59:6a:15:5b:db:f6:f7:f3:a5:
+                    02:29:94:7a:d2:0c:67:ad:aa:63:62:7e:fc:58:11:
+                    29:48:b8:3c:91:b2:73:7e:12:6b:f2:ea:36:77:0f:
+                    15:9b:46:95:ce:73:15:8d:c8:d9:97:57:03:90:33:
+                    2d:7d:f3:ee:e5:01:6d:d8:c6:da:ab:07:b9:dd:1c:
+                    e0:4b:ce:6a:de:a8:d2:e3:c1:52:6d:83:3a:0a:f0:
+                    ed:cf:f7:56:6a:87:0e:73:e3:12:82:2b:65:ab:d8:
+                    a9:44:5b:4a:2f:a5:92:94:32:f1:a1:e4:af:18:0f:
+                    0f:18:60:cd:f7:d0:9d:03:9f:d7:e9:a8:60:54:bb:
+                    3b:9a:05:db:fd:38:04:3c:b4:23:41:16:6c:7c:3b:
+                    d9:b6:e0:2f:bd:cb:62:55:1b:e8:d0:8f:43:76:ef:
+                    55:86:cf:25:c3:bc:ae:e3:46:50:89:f7:71:ad:06:
+                    5e:28:e6:f6:f0:76:27:ea:7e:1b:67:53:39:26:20:
+                    19:18:82:b1:11:5f:ea:91:c2:e3:d3:f6:5a:c7:fd:
+                    61:a2:92:de:7d:7c:da:6d:e8:bf:39:52:10:31:60:
+                    4b:e1
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            Netscape Cert Type: 
+                SSL Server
+            Netscape Comment: 
+                OpenSSL Generated Server Certificate
+            X509v3 Subject Key Identifier: 
+                17:07:3B:AA:85:83:B5:04:83:EC:B2:6C:1E:3A:F0:F5:59:AA:61:28
+            X509v3 Subject Alternative Name: 
+                DNS:localhost, DNS:unresolvable-broker-address, IP Address:127.0.0.1
+            X509v3 Authority Key Identifier: 
+                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
+                DirName:/CN=foobar
+                serial:D7:E2:87:4F:A0:79:E2:0C
+
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication
+    Signature Algorithm: sha256WithRSAEncryption
+         e4:27:61:e2:0f:b6:a0:ca:9f:ce:e3:53:0b:44:ab:86:a1:e2:
+         4d:88:e1:7d:2e:b0:aa:32:96:2b:3d:da:60:70:6a:c3:62:c5:
+         76:f2:8f:0d:16:31:f2:ad:e5:2f:43:f3:cb:e4:fa:95:6c:20:
+         81:33:1a:c7:5a:55:57:c9:ab:ca:66:45:30:58:00:db:e8:51:
+         c9:2c:a9:72:c1:18:f5:01:87:9f:73:20:85:6c:e5:6c:3f:c9:
+         67:b4:f0:20:e5:ed:e2:4a:08:0b:af:68:43:e5:a9:c7:e1:39:
+         e8:b5:49:cb:47:4a:6d:e5:16:ae:88:92:13:85:8e:42:1e:0a:
+         eb:59:ed:a7:c1:9b:bc:4b:7b:99:f8:1d:f0:d7:1d:90:c9:cf:
+         86:6a:d3:10:d0:36:e4:f5:b9:33:79:c7:a2:68:31:f7:bb:8d:
+         1e:d6:33:79:bd:e7:0e:4f:4d:e9:2e:15:04:4f:6b:4b:2e:93:
+         28:72:d1:0e:aa:ee:e6:ef:68:be:58:2b:cc:56:01:27:16:f9:
+         34:8e:66:86:27:0a:b0:fb:32:56:a9:8a:d9:6f:b1:86:bd:ba:
+         fd:50:6c:d5:b2:54:e7:4e:c6:2d:19:88:a9:89:2c:ef:be:08:
+         0d:2b:49:91:0b:09:42:64:06:a3:9d:d7:94:ed:e8:74:74:48:
+         43:57:41:6f:e5:06:98:46:1d:c5:60:9c:69:f8:fb:fe:a6:01:
+         4a:35:be:21:36:c2:a3:44:c8:c4:2c:21:09:f4:28:9a:ad:a0:
+         97:1e:00:29:cc:0f:26:fa:59:21:25:c0:9e:fa:22:53:67:6d:
+         ab:a6:56:08:fd:37:1d:69:fe:ef:6f:29:89:1a:66:7b:c7:ff:
+         b1:34:f1:d6:be:21:81:e3:bc:4f:13:02:a7:4b:9d:13:05:46:
+         40:88:4a:aa:db:fb:64:f8:6b:fb:5d:a0:b1:0c:1a:b8:4c:ab:
+         6f:69:fe:0b:55:4e:b3:38:1f:91:0b:71:77:1e:11:39:54:9a:
+         62:51:ea:6d:a8:5e:0d:4a:91:fb:d8:be:5d:93:e8:43:f3:4a:
+         11:fb:31:cf:14:1a:1c:8d:31:1b:99:31:e0:2b:81:01:91:6f:
+         da:ba:cb:1f:51:21:55:29:3f:4c:71:e3:d0:29:41:de:a0:00:
+         da:07:ed:5e:c9:af:32:61:6d:55:f8:f5:2d:46:03:34:33:fb:
+         2e:1e:aa:7c:fe:d2:30:4d:40:cc:ed:76:ec:f6:bd:ed:35:c8:
+         d8:b3:46:56:aa:2c:53:84:56:45:b0:a3:f6:35:66:93:da:8c:
+         17:39:c1:29:7c:99:c5:0b:73:c1:f9:16:d0:57:fc:57:59:06:
+         af:39:9f:a9:51:35:0b:c7
+-----BEGIN CERTIFICATE-----
+MIIExzCCAq+gAwIBAgICEAcwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTIzMDUxMDE1NTAxOFoYDzIyOTcwMjIyMTU1MDE4WjAfMR0wGwYDVQQD
+DBRicm9rZXItbG9jYWxob3N0LVNBTjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
+AQoCggEBAN7R2ruRsxbEsuiJMJ7BXgvP28TD2bGvQKULODYbFP4PIpzmWWoVW9v2
+9/OlAimUetIMZ62qY2J+/FgRKUi4PJGyc34Sa/LqNncPFZtGlc5zFY3I2ZdXA5Az
+LX3z7uUBbdjG2qsHud0c4EvOat6o0uPBUm2DOgrw7c/3VmqHDnPjEoIrZavYqURb
+Si+lkpQy8aHkrxgPDxhgzffQnQOf1+moYFS7O5oF2/04BDy0I0EWbHw72bbgL73L
+YlUb6NCPQ3bvVYbPJcO8ruNGUIn3ca0GXijm9vB2J+p+G2dTOSYgGRiCsRFf6pHC
+49P2Wsf9YaKS3n182m3ovzlSEDFgS+ECAwEAAaOCARcwggETMAkGA1UdEwQCMAAw
+EQYJYIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVy
+YXRlZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFBcHO6qFg7UEg+yybB46
+8PVZqmEoMDcGA1UdEQQwMC6CCWxvY2FsaG9zdIIbdW5yZXNvbHZhYmxlLWJyb2tl
+ci1hZGRyZXNzhwR/AAABMEEGA1UdIwQ6MDiAFFcL6csj6L9HPlB6P0V+oRhDnRUn
+oRWkEzARMQ8wDQYDVQQDDAZmb29iYXKCCQDX4odPoHniDDAOBgNVHQ8BAf8EBAMC
+BaAwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQELBQADggIBAOQnYeIP
+tqDKn87jUwtEq4ah4k2I4X0usKoylis92mBwasNixXbyjw0WMfKt5S9D88vk+pVs
+IIEzGsdaVVfJq8pmRTBYANvoUcksqXLBGPUBh59zIIVs5Ww/yWe08CDl7eJKCAuv
+aEPlqcfhOei1SctHSm3lFq6IkhOFjkIeCutZ7afBm7xLe5n4HfDXHZDJz4Zq0xDQ
+NuT1uTN5x6JoMfe7jR7WM3m95w5PTekuFQRPa0sukyhy0Q6q7ubvaL5YK8xWAScW
++TSOZoYnCrD7MlapitlvsYa9uv1QbNWyVOdOxi0ZiKmJLO++CA0rSZELCUJkBqOd
+15Tt6HR0SENXQW/lBphGHcVgnGn4+/6mAUo1viE2wqNEyMQsIQn0KJqtoJceACnM
+Dyb6WSElwJ76IlNnbaumVgj9Nx1p/u9vKYkaZnvH/7E08da+IYHjvE8TAqdLnRMF
+RkCISqrb+2T4a/tdoLEMGrhMq29p/gtVTrM4H5ELcXceETlUmmJR6m2oXg1KkfvY
+vl2T6EPzShH7Mc8UGhyNMRuZMeArgQGRb9q6yx9RIVUpP0xx49ApQd6gANoH7V7J
+rzJhbVX49S1GAzQz+y4eqnz+0jBNQMztduz2ve01yNizRlaqLFOEVkWwo/Y1ZpPa
+jBc5wSl8mcULc8H5FtBX/FdZBq85n6lRNQvH
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/server-keys/broker.csr.pem b/tests/certificate-authority/server-keys/broker.csr.pem
index 9d28c52be7..63c0f476f2 100644
--- a/tests/certificate-authority/server-keys/broker.csr.pem
+++ b/tests/certificate-authority/server-keys/broker.csr.pem
@@ -1,15 +1,15 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICZDCCAUwCAQAwHzEdMBsGA1UEAwwUYnJva2VyLWxvY2FsaG9zdC1TQU4wggEi
-MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDe0dq7kbMWxLLoiTCewV4Lz9vE
-w9mxr0ClCzg2GxT+DyKc5llqFVvb9vfzpQIplHrSDGetqmNifvxYESlIuDyRsnN+
-Emvy6jZ3DxWbRpXOcxWNyNmXVwOQMy198+7lAW3YxtqrB7ndHOBLzmreqNLjwVJt
-gzoK8O3P91Zqhw5z4xKCK2Wr2KlEW0ovpZKUMvGh5K8YDw8YYM330J0Dn9fpqGBU
-uzuaBdv9OAQ8tCNBFmx8O9m24C+9y2JVG+jQj0N271WGzyXDvK7jRlCJ93GtBl4o
-5vbwdifqfhtnUzkmIBkYgrERX+qRwuPT9lrH/WGikt59fNpt6L85UhAxYEvhAgMB
-AAGgADANBgkqhkiG9w0BAQsFAAOCAQEAcLkzWe6zgkVpk4OUlCv1HUqmntiBHdmh
-24v3OKhQjyMs+m/srBe6r+lBdZLnbSH5fq7eToEwRMt/vNirsXCaxGGVOUnThStt
-Z/rR45bpJl1TomXwEG9xHq7yOaHVfxkNZgaHCu6BZ1ZjYgfqWffFf9hcqAJ3xZm0
-XMPfJs9i/TRHCsdUge1BHZrxD/fzriWM7k89XktY+0zSqGfdhOXE0FO30bnC4mJG
-vZXY5reyIuRlFBpnDUtuYBaSfbUYguaSUYIoHOUsQrmMSqPLJUyY1zNm1t5f1jIx
-ZaK8NEIq2AHHqEx7I/7+lVRRWa9IjdqWIT9KD5TraOML9oS74sto2w==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICZDCCAUwCAQAwHzEdMBsGA1UEAwwUYnJva2VyLWxvY2FsaG9zdC1TQU4wggEi
+MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDe0dq7kbMWxLLoiTCewV4Lz9vE
+w9mxr0ClCzg2GxT+DyKc5llqFVvb9vfzpQIplHrSDGetqmNifvxYESlIuDyRsnN+
+Emvy6jZ3DxWbRpXOcxWNyNmXVwOQMy198+7lAW3YxtqrB7ndHOBLzmreqNLjwVJt
+gzoK8O3P91Zqhw5z4xKCK2Wr2KlEW0ovpZKUMvGh5K8YDw8YYM330J0Dn9fpqGBU
+uzuaBdv9OAQ8tCNBFmx8O9m24C+9y2JVG+jQj0N271WGzyXDvK7jRlCJ93GtBl4o
+5vbwdifqfhtnUzkmIBkYgrERX+qRwuPT9lrH/WGikt59fNpt6L85UhAxYEvhAgMB
+AAGgADANBgkqhkiG9w0BAQsFAAOCAQEAcLkzWe6zgkVpk4OUlCv1HUqmntiBHdmh
+24v3OKhQjyMs+m/srBe6r+lBdZLnbSH5fq7eToEwRMt/vNirsXCaxGGVOUnThStt
+Z/rR45bpJl1TomXwEG9xHq7yOaHVfxkNZgaHCu6BZ1ZjYgfqWffFf9hcqAJ3xZm0
+XMPfJs9i/TRHCsdUge1BHZrxD/fzriWM7k89XktY+0zSqGfdhOXE0FO30bnC4mJG
+vZXY5reyIuRlFBpnDUtuYBaSfbUYguaSUYIoHOUsQrmMSqPLJUyY1zNm1t5f1jIx
+ZaK8NEIq2AHHqEx7I/7+lVRRWa9IjdqWIT9KD5TraOML9oS74sto2w==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/server-keys/broker.key-pk8.pem b/tests/certificate-authority/server-keys/broker.key-pk8.pem
index dd9fa523e8..4fcee83158 100644
--- a/tests/certificate-authority/server-keys/broker.key-pk8.pem
+++ b/tests/certificate-authority/server-keys/broker.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDe0dq7kbMWxLLo
-iTCewV4Lz9vEw9mxr0ClCzg2GxT+DyKc5llqFVvb9vfzpQIplHrSDGetqmNifvxY
-ESlIuDyRsnN+Emvy6jZ3DxWbRpXOcxWNyNmXVwOQMy198+7lAW3YxtqrB7ndHOBL
-zmreqNLjwVJtgzoK8O3P91Zqhw5z4xKCK2Wr2KlEW0ovpZKUMvGh5K8YDw8YYM33
-0J0Dn9fpqGBUuzuaBdv9OAQ8tCNBFmx8O9m24C+9y2JVG+jQj0N271WGzyXDvK7j
-RlCJ93GtBl4o5vbwdifqfhtnUzkmIBkYgrERX+qRwuPT9lrH/WGikt59fNpt6L85
-UhAxYEvhAgMBAAECggEAbQ4xDFTHXoFvPzjGPy1NJmLZoXhp9/lanmzbWj/vClnG
-Cx0C7lT93K8HtIwyfr9ZTa0coXcfpXmZcFEV762cl4LL3AyQIRhZB/SuEo19jMnu
-5rJDLTs9Vzp1LYxShGsqpErPg54IbhxP+0pQLCJc9XQNL+RmaCx7eKoJ9aGchULY
-BdbCRctYhHaq/AC2qNYZF41Ys9zdNN0/2NnRqfgaaAj9hUzu3LlaJX1TWHbgikLo
-QdmRNmTMMxfLl2kyoweDEC6MdSKCbcdDyM46Va3yY3KTuAdjP6x1ALzAarBDj6zb
-a0Vp7g80OcKjmLYt8rFImjwb7D9EanOy2GkK2CwhAQKBgQD8v4gOTeNYC4Xo6Rti
-psv+QCuH8hiLdee4KFdzqthlELDfhncDKXfwcZI3PME/aBWvvAn+rokl/UfCm5nQ
-fwXW3MYyNpmk0HJjWAQcexsdHCM9I0CgEp8uInn+8EFqlYVh2ltoQLhGuIwOqqPk
-3cQV8ImW+CmqmWYzbSZw97OqqQKBgQDhr7+oOf+sly0MVf5WixHTURJAU6p2VyTt
-aNsNiuLN/W3Vax9Ql9HEm3RPx2SxFEIxllPcwb1Vms/ONmvT1t3xWGp7TIOX/0/m
-uhNIG2/Bcr47NgWjhiV4zE/TfawkcP7/MujUxl2/zm7RHLrU2bmi8rV+PGqlVE0w
-v7iKj4bSeQKBgHkI34a6Fdzb58yZlNuxNI8U+8OmU8q1M7ok13w0nFwJminwop2J
-Bj7GpFZ/aauLlJcLXV3xBwyCNhMjoI0PxyQVpXP2Ya1jhOO+Cnn5GgrepqFoeFIv
-mLrnF7TWKP15jN5HSu6pz5VOWwPLA6Fd8cDv53O8c3eW7jJCWt5OQGPBAoGALwbI
-EO3E8NmvcVqZ3L6twDKscur8IhyWfUHUI0ZFbFbahBYGOGzqMOWTnuwVdzCZemuw
-nddg9G2Fz5pXbZTgOmIKDhcrdIimxZUQX34YE18tdHkVQ7W4KSuplpAhRpalC9g3
-295ZupXxUXGDHMchf2rDlsJQFpMyYm4Qrg6qMUECgYBhBG/iLvE6/Z1oh6eky6WU
-Dx7nL+FDDu3JbNAWs6RMDs9fE+7iDEj8MxZL0PUnVMsQvf43Ew1boyIGwlNtdRZ5
-dLaKFAgJ8YbqIptnFfGQ/8vKhK+x4FWzEd3kuRzQZPVRVV5Op6bRp1Kb8NMPCQXb
-72qifYUaI7uirULNSit9wg==
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDe0dq7kbMWxLLo
+iTCewV4Lz9vEw9mxr0ClCzg2GxT+DyKc5llqFVvb9vfzpQIplHrSDGetqmNifvxY
+ESlIuDyRsnN+Emvy6jZ3DxWbRpXOcxWNyNmXVwOQMy198+7lAW3YxtqrB7ndHOBL
+zmreqNLjwVJtgzoK8O3P91Zqhw5z4xKCK2Wr2KlEW0ovpZKUMvGh5K8YDw8YYM33
+0J0Dn9fpqGBUuzuaBdv9OAQ8tCNBFmx8O9m24C+9y2JVG+jQj0N271WGzyXDvK7j
+RlCJ93GtBl4o5vbwdifqfhtnUzkmIBkYgrERX+qRwuPT9lrH/WGikt59fNpt6L85
+UhAxYEvhAgMBAAECggEAbQ4xDFTHXoFvPzjGPy1NJmLZoXhp9/lanmzbWj/vClnG
+Cx0C7lT93K8HtIwyfr9ZTa0coXcfpXmZcFEV762cl4LL3AyQIRhZB/SuEo19jMnu
+5rJDLTs9Vzp1LYxShGsqpErPg54IbhxP+0pQLCJc9XQNL+RmaCx7eKoJ9aGchULY
+BdbCRctYhHaq/AC2qNYZF41Ys9zdNN0/2NnRqfgaaAj9hUzu3LlaJX1TWHbgikLo
+QdmRNmTMMxfLl2kyoweDEC6MdSKCbcdDyM46Va3yY3KTuAdjP6x1ALzAarBDj6zb
+a0Vp7g80OcKjmLYt8rFImjwb7D9EanOy2GkK2CwhAQKBgQD8v4gOTeNYC4Xo6Rti
+psv+QCuH8hiLdee4KFdzqthlELDfhncDKXfwcZI3PME/aBWvvAn+rokl/UfCm5nQ
+fwXW3MYyNpmk0HJjWAQcexsdHCM9I0CgEp8uInn+8EFqlYVh2ltoQLhGuIwOqqPk
+3cQV8ImW+CmqmWYzbSZw97OqqQKBgQDhr7+oOf+sly0MVf5WixHTURJAU6p2VyTt
+aNsNiuLN/W3Vax9Ql9HEm3RPx2SxFEIxllPcwb1Vms/ONmvT1t3xWGp7TIOX/0/m
+uhNIG2/Bcr47NgWjhiV4zE/TfawkcP7/MujUxl2/zm7RHLrU2bmi8rV+PGqlVE0w
+v7iKj4bSeQKBgHkI34a6Fdzb58yZlNuxNI8U+8OmU8q1M7ok13w0nFwJminwop2J
+Bj7GpFZ/aauLlJcLXV3xBwyCNhMjoI0PxyQVpXP2Ya1jhOO+Cnn5GgrepqFoeFIv
+mLrnF7TWKP15jN5HSu6pz5VOWwPLA6Fd8cDv53O8c3eW7jJCWt5OQGPBAoGALwbI
+EO3E8NmvcVqZ3L6twDKscur8IhyWfUHUI0ZFbFbahBYGOGzqMOWTnuwVdzCZemuw
+nddg9G2Fz5pXbZTgOmIKDhcrdIimxZUQX34YE18tdHkVQ7W4KSuplpAhRpalC9g3
+295ZupXxUXGDHMchf2rDlsJQFpMyYm4Qrg6qMUECgYBhBG/iLvE6/Z1oh6eky6WU
+Dx7nL+FDDu3JbNAWs6RMDs9fE+7iDEj8MxZL0PUnVMsQvf43Ew1boyIGwlNtdRZ5
+dLaKFAgJ8YbqIptnFfGQ/8vKhK+x4FWzEd3kuRzQZPVRVV5Op6bRp1Kb8NMPCQXb
+72qifYUaI7uirULNSit9wg==
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/server-keys/broker.key.pem b/tests/certificate-authority/server-keys/broker.key.pem
index 5c20238c7b..b46c951b54 100644
--- a/tests/certificate-authority/server-keys/broker.key.pem
+++ b/tests/certificate-authority/server-keys/broker.key.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEogIBAAKCAQEA3tHau5GzFsSy6IkwnsFeC8/bxMPZsa9ApQs4NhsU/g8inOZZ
-ahVb2/b386UCKZR60gxnrapjYn78WBEpSLg8kbJzfhJr8uo2dw8Vm0aVznMVjcjZ
-l1cDkDMtffPu5QFt2Mbaqwe53RzgS85q3qjS48FSbYM6CvDtz/dWaocOc+MSgitl
-q9ipRFtKL6WSlDLxoeSvGA8PGGDN99CdA5/X6ahgVLs7mgXb/TgEPLQjQRZsfDvZ
-tuAvvctiVRvo0I9Ddu9Vhs8lw7yu40ZQifdxrQZeKOb28HYn6n4bZ1M5JiAZGIKx
-EV/qkcLj0/Zax/1hopLefXzabei/OVIQMWBL4QIDAQABAoIBAG0OMQxUx16Bbz84
-xj8tTSZi2aF4aff5Wp5s21o/7wpZxgsdAu5U/dyvB7SMMn6/WU2tHKF3H6V5mXBR
-Fe+tnJeCy9wMkCEYWQf0rhKNfYzJ7uayQy07PVc6dS2MUoRrKqRKz4OeCG4cT/tK
-UCwiXPV0DS/kZmgse3iqCfWhnIVC2AXWwkXLWIR2qvwAtqjWGReNWLPc3TTdP9jZ
-0an4GmgI/YVM7ty5WiV9U1h24IpC6EHZkTZkzDMXy5dpMqMHgxAujHUigm3HQ8jO
-OlWt8mNyk7gHYz+sdQC8wGqwQ4+s22tFae4PNDnCo5i2LfKxSJo8G+w/RGpzsthp
-CtgsIQECgYEA/L+IDk3jWAuF6OkbYqbL/kArh/IYi3XnuChXc6rYZRCw34Z3Ayl3
-8HGSNzzBP2gVr7wJ/q6JJf1HwpuZ0H8F1tzGMjaZpNByY1gEHHsbHRwjPSNAoBKf
-LiJ5/vBBapWFYdpbaEC4RriMDqqj5N3EFfCJlvgpqplmM20mcPezqqkCgYEA4a+/
-qDn/rJctDFX+VosR01ESQFOqdlck7WjbDYrizf1t1WsfUJfRxJt0T8dksRRCMZZT
-3MG9VZrPzjZr09bd8Vhqe0yDl/9P5roTSBtvwXK+OzYFo4YleMxP032sJHD+/zLo
-1MZdv85u0Ry61Nm5ovK1fjxqpVRNML+4io+G0nkCgYB5CN+GuhXc2+fMmZTbsTSP
-FPvDplPKtTO6JNd8NJxcCZop8KKdiQY+xqRWf2mri5SXC11d8QcMgjYTI6CND8ck
-FaVz9mGtY4Tjvgp5+RoK3qahaHhSL5i65xe01ij9eYzeR0ruqc+VTlsDywOhXfHA
-7+dzvHN3lu4yQlreTkBjwQKBgC8GyBDtxPDZr3Famdy+rcAyrHLq/CIcln1B1CNG
-RWxW2oQWBjhs6jDlk57sFXcwmXprsJ3XYPRthc+aV22U4DpiCg4XK3SIpsWVEF9+
-GBNfLXR5FUO1uCkrqZaQIUaWpQvYN9veWbqV8VFxgxzHIX9qw5bCUBaTMmJuEK4O
-qjFBAoGAYQRv4i7xOv2daIenpMullA8e5y/hQw7tyWzQFrOkTA7PXxPu4gxI/DMW
-S9D1J1TLEL3+NxMNW6MiBsJTbXUWeXS2ihQICfGG6iKbZxXxkP/LyoSvseBVsxHd
-5Lkc0GT1UVVeTqem0adSm/DTDwkF2+9qon2FGiO7oq1CzUorfcI=
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEogIBAAKCAQEA3tHau5GzFsSy6IkwnsFeC8/bxMPZsa9ApQs4NhsU/g8inOZZ
+ahVb2/b386UCKZR60gxnrapjYn78WBEpSLg8kbJzfhJr8uo2dw8Vm0aVznMVjcjZ
+l1cDkDMtffPu5QFt2Mbaqwe53RzgS85q3qjS48FSbYM6CvDtz/dWaocOc+MSgitl
+q9ipRFtKL6WSlDLxoeSvGA8PGGDN99CdA5/X6ahgVLs7mgXb/TgEPLQjQRZsfDvZ
+tuAvvctiVRvo0I9Ddu9Vhs8lw7yu40ZQifdxrQZeKOb28HYn6n4bZ1M5JiAZGIKx
+EV/qkcLj0/Zax/1hopLefXzabei/OVIQMWBL4QIDAQABAoIBAG0OMQxUx16Bbz84
+xj8tTSZi2aF4aff5Wp5s21o/7wpZxgsdAu5U/dyvB7SMMn6/WU2tHKF3H6V5mXBR
+Fe+tnJeCy9wMkCEYWQf0rhKNfYzJ7uayQy07PVc6dS2MUoRrKqRKz4OeCG4cT/tK
+UCwiXPV0DS/kZmgse3iqCfWhnIVC2AXWwkXLWIR2qvwAtqjWGReNWLPc3TTdP9jZ
+0an4GmgI/YVM7ty5WiV9U1h24IpC6EHZkTZkzDMXy5dpMqMHgxAujHUigm3HQ8jO
+OlWt8mNyk7gHYz+sdQC8wGqwQ4+s22tFae4PNDnCo5i2LfKxSJo8G+w/RGpzsthp
+CtgsIQECgYEA/L+IDk3jWAuF6OkbYqbL/kArh/IYi3XnuChXc6rYZRCw34Z3Ayl3
+8HGSNzzBP2gVr7wJ/q6JJf1HwpuZ0H8F1tzGMjaZpNByY1gEHHsbHRwjPSNAoBKf
+LiJ5/vBBapWFYdpbaEC4RriMDqqj5N3EFfCJlvgpqplmM20mcPezqqkCgYEA4a+/
+qDn/rJctDFX+VosR01ESQFOqdlck7WjbDYrizf1t1WsfUJfRxJt0T8dksRRCMZZT
+3MG9VZrPzjZr09bd8Vhqe0yDl/9P5roTSBtvwXK+OzYFo4YleMxP032sJHD+/zLo
+1MZdv85u0Ry61Nm5ovK1fjxqpVRNML+4io+G0nkCgYB5CN+GuhXc2+fMmZTbsTSP
+FPvDplPKtTO6JNd8NJxcCZop8KKdiQY+xqRWf2mri5SXC11d8QcMgjYTI6CND8ck
+FaVz9mGtY4Tjvgp5+RoK3qahaHhSL5i65xe01ij9eYzeR0ruqc+VTlsDywOhXfHA
+7+dzvHN3lu4yQlreTkBjwQKBgC8GyBDtxPDZr3Famdy+rcAyrHLq/CIcln1B1CNG
+RWxW2oQWBjhs6jDlk57sFXcwmXprsJ3XYPRthc+aV22U4DpiCg4XK3SIpsWVEF9+
+GBNfLXR5FUO1uCkrqZaQIUaWpQvYN9veWbqV8VFxgxzHIX9qw5bCUBaTMmJuEK4O
+qjFBAoGAYQRv4i7xOv2daIenpMullA8e5y/hQw7tyWzQFrOkTA7PXxPu4gxI/DMW
+S9D1J1TLEL3+NxMNW6MiBsJTbXUWeXS2ihQICfGG6iKbZxXxkP/LyoSvseBVsxHd
+5Lkc0GT1UVVeTqem0adSm/DTDwkF2+9qon2FGiO7oq1CzUorfcI=
+-----END RSA PRIVATE KEY-----
diff --git a/tests/certificate-authority/server-keys/proxy.cert.pem b/tests/certificate-authority/server-keys/proxy.cert.pem
index 85687bdfd3..a58e3f33a8 100644
--- a/tests/certificate-authority/server-keys/proxy.cert.pem
+++ b/tests/certificate-authority/server-keys/proxy.cert.pem
@@ -1,110 +1,110 @@
-Certificate:
-    Data:
-        Version: 3 (0x2)
-        Serial Number: 4104 (0x1008)
-    Signature Algorithm: sha256WithRSAEncryption
-        Issuer: CN=foobar
-        Validity
-            Not Before: May 10 15:50:19 2023 GMT
-            Not After : Feb 22 15:50:19 2297 GMT
-        Subject: CN=proxy-localhost-SAN
-        Subject Public Key Info:
-            Public Key Algorithm: rsaEncryption
-                Public-Key: (2048 bit)
-                Modulus:
-                    00:cc:15:c9:85:06:43:47:bd:46:9f:4f:03:1a:e0:
-                    6e:94:13:4e:b0:30:ea:88:ca:3a:e4:39:92:12:c1:
-                    77:51:8c:0d:3c:b9:26:5c:2f:dc:fc:b1:5a:bf:0e:
-                    47:ff:09:60:30:79:8e:55:26:fe:d0:a1:ed:9f:6d:
-                    8a:6a:06:85:f0:d0:dc:94:a6:54:a1:a6:c9:3e:57:
-                    d5:69:7d:e9:25:c1:ef:6b:77:e1:62:76:d8:e4:54:
-                    91:40:bc:0b:11:74:b8:30:bb:d4:02:77:d6:bd:d2:
-                    d0:e7:ad:df:7d:98:96:74:42:ad:53:b3:88:c8:dc:
-                    1d:db:51:63:84:ee:7e:85:73:14:5e:d4:c8:f0:01:
-                    5f:67:52:ed:94:87:f7:d6:aa:28:8b:2c:84:98:8c:
-                    b9:91:b5:38:99:80:5d:b3:d4:db:95:96:09:ef:1d:
-                    a1:6f:86:c8:17:86:f7:0a:1e:72:3b:50:8c:53:e5:
-                    ce:d4:8c:cf:cc:81:3d:46:55:ff:65:25:0b:36:31:
-                    31:a6:22:27:47:96:59:38:c1:cd:66:a6:9a:83:98:
-                    dc:b8:2e:10:8d:ba:45:ae:aa:20:6e:e3:0b:bd:ec:
-                    e6:63:b5:40:55:d4:fe:97:b1:f1:8d:9a:c0:a2:46:
-                    8e:a3:ed:a0:1b:ed:40:b0:00:a5:28:f9:da:03:bd:
-                    c1:a9
-                Exponent: 65537 (0x10001)
-        X509v3 extensions:
-            X509v3 Basic Constraints: 
-                CA:FALSE
-            Netscape Cert Type: 
-                SSL Server
-            Netscape Comment: 
-                OpenSSL Generated Server Certificate
-            X509v3 Subject Key Identifier: 
-                C5:33:73:67:03:B7:51:08:F4:BD:D3:CD:4F:DC:CF:83:11:53:AD:39
-            X509v3 Subject Alternative Name: 
-                DNS:localhost, IP Address:127.0.0.1
-            X509v3 Authority Key Identifier: 
-                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
-                DirName:/CN=foobar
-                serial:D7:E2:87:4F:A0:79:E2:0C
-
-            X509v3 Key Usage: critical
-                Digital Signature, Key Encipherment
-            X509v3 Extended Key Usage: 
-                TLS Web Server Authentication
-    Signature Algorithm: sha256WithRSAEncryption
-         43:ef:67:29:9a:0c:53:97:7c:fc:72:73:6c:8d:48:78:4e:ec:
-         e3:14:9d:d9:1e:83:4c:d6:f0:56:e9:c4:d8:de:f5:54:fb:a5:
-         3b:ff:59:23:75:26:74:f0:86:90:d0:4d:41:25:03:87:e0:60:
-         a4:9b:33:3d:bd:1c:79:b8:db:86:1c:38:09:26:0d:80:3e:f9:
-         1e:28:11:0d:3d:6b:1e:1a:7a:9a:fa:fc:18:22:7f:fd:46:55:
-         c2:2f:56:5c:5c:8a:45:f2:74:7a:e4:6c:d0:e0:ea:ec:74:b7:
-         0d:a8:f3:ca:18:cf:a4:be:a0:e0:4a:32:ca:15:7e:5d:06:56:
-         b7:71:7c:e0:dc:19:fa:be:3e:94:84:20:be:96:34:61:0b:f0:
-         d1:d6:31:49:0b:b0:20:b8:f9:5c:49:08:13:9b:45:c0:6f:58:
-         16:81:0b:0c:f8:66:38:58:83:d4:b0:bc:14:35:8d:e2:1d:d5:
-         2d:ea:02:ae:42:e1:88:22:5a:b0:cf:e5:31:b1:cb:d3:e9:d2:
-         5e:88:55:bd:62:ac:85:aa:4e:fc:18:6b:65:f9:9e:fc:93:27:
-         0c:c6:29:aa:f0:64:6e:72:dc:d9:95:ae:38:ae:64:9e:c6:44:
-         8a:0b:0f:0e:d4:69:7e:79:e0:46:d0:75:96:2a:1a:60:af:30:
-         23:dc:d2:67:0d:08:2a:9d:58:29:09:1e:c8:08:d5:3a:88:2d:
-         1a:dc:47:dc:5d:bd:0d:5c:54:f1:5d:5a:6d:0d:de:bc:18:67:
-         2d:dd:1b:fe:8b:0e:03:19:b0:0f:f2:59:69:d0:7a:4f:a1:33:
-         74:f7:22:ef:ff:90:e1:4b:8e:ac:13:00:6f:00:9b:55:83:d2:
-         96:db:a8:81:c9:a9:8d:c6:a6:21:3d:14:d3:43:71:28:c6:ea:
-         6d:2d:91:b9:58:bf:ec:18:75:c4:8c:10:43:88:60:08:c0:bb:
-         9d:fb:90:80:1e:d5:a3:ea:e7:8a:16:f7:f4:d7:cb:35:93:03:
-         55:e4:cc:58:31:1e:df:6e:e4:1b:6e:ad:3a:76:56:e5:8b:4e:
-         d9:71:af:11:92:a7:7a:e2:66:cc:d2:73:f3:ec:e8:3b:67:f0:
-         6a:31:10:82:e8:c4:1e:ae:c3:54:a7:e2:42:86:fe:43:75:ad:
-         ef:83:d7:1c:2f:91:94:1c:57:9d:1c:43:94:b1:47:b2:6c:96:
-         fd:83:69:0f:6c:e2:18:9b:65:8e:71:08:01:b3:73:46:aa:3c:
-         2e:07:14:cd:03:ae:dc:5a:51:da:c5:41:53:cc:f5:fc:c8:db:
-         4e:76:27:99:9a:ec:40:68:07:d6:10:e1:f9:68:6b:5d:52:95:
-         3d:01:f4:a7:40:11:61:0a
------BEGIN CERTIFICATE-----
-MIIEpzCCAo+gAwIBAgICEAgwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
-YmFyMCAXDTIzMDUxMDE1NTAxOVoYDzIyOTcwMjIyMTU1MDE5WjAeMRwwGgYDVQQD
-DBNwcm94eS1sb2NhbGhvc3QtU0FOMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
-CgKCAQEAzBXJhQZDR71Gn08DGuBulBNOsDDqiMo65DmSEsF3UYwNPLkmXC/c/LFa
-vw5H/wlgMHmOVSb+0KHtn22KagaF8NDclKZUoabJPlfVaX3pJcHva3fhYnbY5FSR
-QLwLEXS4MLvUAnfWvdLQ563ffZiWdEKtU7OIyNwd21FjhO5+hXMUXtTI8AFfZ1Lt
-lIf31qooiyyEmIy5kbU4mYBds9TblZYJ7x2hb4bIF4b3Ch5yO1CMU+XO1IzPzIE9
-RlX/ZSULNjExpiInR5ZZOMHNZqaag5jcuC4QjbpFrqogbuMLvezmY7VAVdT+l7Hx
-jZrAokaOo+2gG+1AsAClKPnaA73BqQIDAQABo4H5MIH2MAkGA1UdEwQCMAAwEQYJ
-YIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRl
-ZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFMUzc2cDt1EI9L3TzU/cz4MR
-U605MBoGA1UdEQQTMBGCCWxvY2FsaG9zdIcEfwAAATBBBgNVHSMEOjA4gBRXC+nL
-I+i/Rz5Qej9FfqEYQ50VJ6EVpBMwETEPMA0GA1UEAwwGZm9vYmFyggkA1+KHT6B5
-4gwwDgYDVR0PAQH/BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA0GCSqGSIb3
-DQEBCwUAA4ICAQBD72cpmgxTl3z8cnNsjUh4TuzjFJ3ZHoNM1vBW6cTY3vVU+6U7
-/1kjdSZ08IaQ0E1BJQOH4GCkmzM9vRx5uNuGHDgJJg2APvkeKBENPWseGnqa+vwY
-In/9RlXCL1ZcXIpF8nR65GzQ4OrsdLcNqPPKGM+kvqDgSjLKFX5dBla3cXzg3Bn6
-vj6UhCC+ljRhC/DR1jFJC7AguPlcSQgTm0XAb1gWgQsM+GY4WIPUsLwUNY3iHdUt
-6gKuQuGIIlqwz+UxscvT6dJeiFW9YqyFqk78GGtl+Z78kycMximq8GRuctzZla44
-rmSexkSKCw8O1Gl+eeBG0HWWKhpgrzAj3NJnDQgqnVgpCR7ICNU6iC0a3EfcXb0N
-XFTxXVptDd68GGct3Rv+iw4DGbAP8llp0HpPoTN09yLv/5DhS46sEwBvAJtVg9KW
-26iByamNxqYhPRTTQ3EoxuptLZG5WL/sGHXEjBBDiGAIwLud+5CAHtWj6ueKFvf0
-18s1kwNV5MxYMR7fbuQbbq06dlbli07Zca8Rkqd64mbM0nPz7Og7Z/BqMRCC6MQe
-rsNUp+JChv5Dda3vg9ccL5GUHFedHEOUsUeybJb9g2kPbOIYm2WOcQgBs3NGqjwu
-BxTNA67cWlHaxUFTzPX8yNtOdieZmuxAaAfWEOH5aGtdUpU9AfSnQBFhCg==
------END CERTIFICATE-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 4104 (0x1008)
+    Signature Algorithm: sha256WithRSAEncryption
+        Issuer: CN=foobar
+        Validity
+            Not Before: May 10 15:50:19 2023 GMT
+            Not After : Feb 22 15:50:19 2297 GMT
+        Subject: CN=proxy-localhost-SAN
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (2048 bit)
+                Modulus:
+                    00:cc:15:c9:85:06:43:47:bd:46:9f:4f:03:1a:e0:
+                    6e:94:13:4e:b0:30:ea:88:ca:3a:e4:39:92:12:c1:
+                    77:51:8c:0d:3c:b9:26:5c:2f:dc:fc:b1:5a:bf:0e:
+                    47:ff:09:60:30:79:8e:55:26:fe:d0:a1:ed:9f:6d:
+                    8a:6a:06:85:f0:d0:dc:94:a6:54:a1:a6:c9:3e:57:
+                    d5:69:7d:e9:25:c1:ef:6b:77:e1:62:76:d8:e4:54:
+                    91:40:bc:0b:11:74:b8:30:bb:d4:02:77:d6:bd:d2:
+                    d0:e7:ad:df:7d:98:96:74:42:ad:53:b3:88:c8:dc:
+                    1d:db:51:63:84:ee:7e:85:73:14:5e:d4:c8:f0:01:
+                    5f:67:52:ed:94:87:f7:d6:aa:28:8b:2c:84:98:8c:
+                    b9:91:b5:38:99:80:5d:b3:d4:db:95:96:09:ef:1d:
+                    a1:6f:86:c8:17:86:f7:0a:1e:72:3b:50:8c:53:e5:
+                    ce:d4:8c:cf:cc:81:3d:46:55:ff:65:25:0b:36:31:
+                    31:a6:22:27:47:96:59:38:c1:cd:66:a6:9a:83:98:
+                    dc:b8:2e:10:8d:ba:45:ae:aa:20:6e:e3:0b:bd:ec:
+                    e6:63:b5:40:55:d4:fe:97:b1:f1:8d:9a:c0:a2:46:
+                    8e:a3:ed:a0:1b:ed:40:b0:00:a5:28:f9:da:03:bd:
+                    c1:a9
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            Netscape Cert Type: 
+                SSL Server
+            Netscape Comment: 
+                OpenSSL Generated Server Certificate
+            X509v3 Subject Key Identifier: 
+                C5:33:73:67:03:B7:51:08:F4:BD:D3:CD:4F:DC:CF:83:11:53:AD:39
+            X509v3 Subject Alternative Name: 
+                DNS:localhost, IP Address:127.0.0.1
+            X509v3 Authority Key Identifier: 
+                keyid:57:0B:E9:CB:23:E8:BF:47:3E:50:7A:3F:45:7E:A1:18:43:9D:15:27
+                DirName:/CN=foobar
+                serial:D7:E2:87:4F:A0:79:E2:0C
+
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication
+    Signature Algorithm: sha256WithRSAEncryption
+         43:ef:67:29:9a:0c:53:97:7c:fc:72:73:6c:8d:48:78:4e:ec:
+         e3:14:9d:d9:1e:83:4c:d6:f0:56:e9:c4:d8:de:f5:54:fb:a5:
+         3b:ff:59:23:75:26:74:f0:86:90:d0:4d:41:25:03:87:e0:60:
+         a4:9b:33:3d:bd:1c:79:b8:db:86:1c:38:09:26:0d:80:3e:f9:
+         1e:28:11:0d:3d:6b:1e:1a:7a:9a:fa:fc:18:22:7f:fd:46:55:
+         c2:2f:56:5c:5c:8a:45:f2:74:7a:e4:6c:d0:e0:ea:ec:74:b7:
+         0d:a8:f3:ca:18:cf:a4:be:a0:e0:4a:32:ca:15:7e:5d:06:56:
+         b7:71:7c:e0:dc:19:fa:be:3e:94:84:20:be:96:34:61:0b:f0:
+         d1:d6:31:49:0b:b0:20:b8:f9:5c:49:08:13:9b:45:c0:6f:58:
+         16:81:0b:0c:f8:66:38:58:83:d4:b0:bc:14:35:8d:e2:1d:d5:
+         2d:ea:02:ae:42:e1:88:22:5a:b0:cf:e5:31:b1:cb:d3:e9:d2:
+         5e:88:55:bd:62:ac:85:aa:4e:fc:18:6b:65:f9:9e:fc:93:27:
+         0c:c6:29:aa:f0:64:6e:72:dc:d9:95:ae:38:ae:64:9e:c6:44:
+         8a:0b:0f:0e:d4:69:7e:79:e0:46:d0:75:96:2a:1a:60:af:30:
+         23:dc:d2:67:0d:08:2a:9d:58:29:09:1e:c8:08:d5:3a:88:2d:
+         1a:dc:47:dc:5d:bd:0d:5c:54:f1:5d:5a:6d:0d:de:bc:18:67:
+         2d:dd:1b:fe:8b:0e:03:19:b0:0f:f2:59:69:d0:7a:4f:a1:33:
+         74:f7:22:ef:ff:90:e1:4b:8e:ac:13:00:6f:00:9b:55:83:d2:
+         96:db:a8:81:c9:a9:8d:c6:a6:21:3d:14:d3:43:71:28:c6:ea:
+         6d:2d:91:b9:58:bf:ec:18:75:c4:8c:10:43:88:60:08:c0:bb:
+         9d:fb:90:80:1e:d5:a3:ea:e7:8a:16:f7:f4:d7:cb:35:93:03:
+         55:e4:cc:58:31:1e:df:6e:e4:1b:6e:ad:3a:76:56:e5:8b:4e:
+         d9:71:af:11:92:a7:7a:e2:66:cc:d2:73:f3:ec:e8:3b:67:f0:
+         6a:31:10:82:e8:c4:1e:ae:c3:54:a7:e2:42:86:fe:43:75:ad:
+         ef:83:d7:1c:2f:91:94:1c:57:9d:1c:43:94:b1:47:b2:6c:96:
+         fd:83:69:0f:6c:e2:18:9b:65:8e:71:08:01:b3:73:46:aa:3c:
+         2e:07:14:cd:03:ae:dc:5a:51:da:c5:41:53:cc:f5:fc:c8:db:
+         4e:76:27:99:9a:ec:40:68:07:d6:10:e1:f9:68:6b:5d:52:95:
+         3d:01:f4:a7:40:11:61:0a
+-----BEGIN CERTIFICATE-----
+MIIEpzCCAo+gAwIBAgICEAgwDQYJKoZIhvcNAQELBQAwETEPMA0GA1UEAwwGZm9v
+YmFyMCAXDTIzMDUxMDE1NTAxOVoYDzIyOTcwMjIyMTU1MDE5WjAeMRwwGgYDVQQD
+DBNwcm94eS1sb2NhbGhvc3QtU0FOMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
+CgKCAQEAzBXJhQZDR71Gn08DGuBulBNOsDDqiMo65DmSEsF3UYwNPLkmXC/c/LFa
+vw5H/wlgMHmOVSb+0KHtn22KagaF8NDclKZUoabJPlfVaX3pJcHva3fhYnbY5FSR
+QLwLEXS4MLvUAnfWvdLQ563ffZiWdEKtU7OIyNwd21FjhO5+hXMUXtTI8AFfZ1Lt
+lIf31qooiyyEmIy5kbU4mYBds9TblZYJ7x2hb4bIF4b3Ch5yO1CMU+XO1IzPzIE9
+RlX/ZSULNjExpiInR5ZZOMHNZqaag5jcuC4QjbpFrqogbuMLvezmY7VAVdT+l7Hx
+jZrAokaOo+2gG+1AsAClKPnaA73BqQIDAQABo4H5MIH2MAkGA1UdEwQCMAAwEQYJ
+YIZIAYb4QgEBBAQDAgZAMDMGCWCGSAGG+EIBDQQmFiRPcGVuU1NMIEdlbmVyYXRl
+ZCBTZXJ2ZXIgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFMUzc2cDt1EI9L3TzU/cz4MR
+U605MBoGA1UdEQQTMBGCCWxvY2FsaG9zdIcEfwAAATBBBgNVHSMEOjA4gBRXC+nL
+I+i/Rz5Qej9FfqEYQ50VJ6EVpBMwETEPMA0GA1UEAwwGZm9vYmFyggkA1+KHT6B5
+4gwwDgYDVR0PAQH/BAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA0GCSqGSIb3
+DQEBCwUAA4ICAQBD72cpmgxTl3z8cnNsjUh4TuzjFJ3ZHoNM1vBW6cTY3vVU+6U7
+/1kjdSZ08IaQ0E1BJQOH4GCkmzM9vRx5uNuGHDgJJg2APvkeKBENPWseGnqa+vwY
+In/9RlXCL1ZcXIpF8nR65GzQ4OrsdLcNqPPKGM+kvqDgSjLKFX5dBla3cXzg3Bn6
+vj6UhCC+ljRhC/DR1jFJC7AguPlcSQgTm0XAb1gWgQsM+GY4WIPUsLwUNY3iHdUt
+6gKuQuGIIlqwz+UxscvT6dJeiFW9YqyFqk78GGtl+Z78kycMximq8GRuctzZla44
+rmSexkSKCw8O1Gl+eeBG0HWWKhpgrzAj3NJnDQgqnVgpCR7ICNU6iC0a3EfcXb0N
+XFTxXVptDd68GGct3Rv+iw4DGbAP8llp0HpPoTN09yLv/5DhS46sEwBvAJtVg9KW
+26iByamNxqYhPRTTQ3EoxuptLZG5WL/sGHXEjBBDiGAIwLud+5CAHtWj6ueKFvf0
+18s1kwNV5MxYMR7fbuQbbq06dlbli07Zca8Rkqd64mbM0nPz7Og7Z/BqMRCC6MQe
+rsNUp+JChv5Dda3vg9ccL5GUHFedHEOUsUeybJb9g2kPbOIYm2WOcQgBs3NGqjwu
+BxTNA67cWlHaxUFTzPX8yNtOdieZmuxAaAfWEOH5aGtdUpU9AfSnQBFhCg==
+-----END CERTIFICATE-----
diff --git a/tests/certificate-authority/server-keys/proxy.csr.pem b/tests/certificate-authority/server-keys/proxy.csr.pem
index 6cebd3548a..10f23ba858 100644
--- a/tests/certificate-authority/server-keys/proxy.csr.pem
+++ b/tests/certificate-authority/server-keys/proxy.csr.pem
@@ -1,15 +1,15 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICYzCCAUsCAQAwHjEcMBoGA1UEAwwTcHJveHktbG9jYWxob3N0LVNBTjCCASIw
-DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMwVyYUGQ0e9Rp9PAxrgbpQTTrAw
-6ojKOuQ5khLBd1GMDTy5Jlwv3PyxWr8OR/8JYDB5jlUm/tCh7Z9timoGhfDQ3JSm
-VKGmyT5X1Wl96SXB72t34WJ22ORUkUC8CxF0uDC71AJ31r3S0Oet332YlnRCrVOz
-iMjcHdtRY4TufoVzFF7UyPABX2dS7ZSH99aqKIsshJiMuZG1OJmAXbPU25WWCe8d
-oW+GyBeG9woecjtQjFPlztSMz8yBPUZV/2UlCzYxMaYiJ0eWWTjBzWammoOY3Lgu
-EI26Ra6qIG7jC73s5mO1QFXU/pex8Y2awKJGjqPtoBvtQLAApSj52gO9wakCAwEA
-AaAAMA0GCSqGSIb3DQEBCwUAA4IBAQCqq+WUWY5w8RHsMi/zeR0JjXhbgdYSlsfP
-J0fUTB88Jr/litM2u96/HFPC4K8MDlei7cKccyrRsLd+iEbG3ydNRB66WBCjq93o
-/5LSMYGCejMDAdeE8qWBDf53Xlg+hGhMlFbbmL4JGTKX0OjAKnF5xT5i7n9rh/dM
-FwoIU6ac+5btszD62IRGhyOmOHXSqL+KYArKhXKzGICFKvrOwfGrSC7Rt9zwV+lL
-UB6NRWR5viSgIkwYw/W4R9M1iQPQLjGm/ibjW/FXWzr98LNgs8kjqMoAIDs7z8YU
-FCT6YDb8zJlqiOBKnU7ReetKsHwPM2mAyWMS6z8R3LOSNdgrP70Y
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICYzCCAUsCAQAwHjEcMBoGA1UEAwwTcHJveHktbG9jYWxob3N0LVNBTjCCASIw
+DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMwVyYUGQ0e9Rp9PAxrgbpQTTrAw
+6ojKOuQ5khLBd1GMDTy5Jlwv3PyxWr8OR/8JYDB5jlUm/tCh7Z9timoGhfDQ3JSm
+VKGmyT5X1Wl96SXB72t34WJ22ORUkUC8CxF0uDC71AJ31r3S0Oet332YlnRCrVOz
+iMjcHdtRY4TufoVzFF7UyPABX2dS7ZSH99aqKIsshJiMuZG1OJmAXbPU25WWCe8d
+oW+GyBeG9woecjtQjFPlztSMz8yBPUZV/2UlCzYxMaYiJ0eWWTjBzWammoOY3Lgu
+EI26Ra6qIG7jC73s5mO1QFXU/pex8Y2awKJGjqPtoBvtQLAApSj52gO9wakCAwEA
+AaAAMA0GCSqGSIb3DQEBCwUAA4IBAQCqq+WUWY5w8RHsMi/zeR0JjXhbgdYSlsfP
+J0fUTB88Jr/litM2u96/HFPC4K8MDlei7cKccyrRsLd+iEbG3ydNRB66WBCjq93o
+/5LSMYGCejMDAdeE8qWBDf53Xlg+hGhMlFbbmL4JGTKX0OjAKnF5xT5i7n9rh/dM
+FwoIU6ac+5btszD62IRGhyOmOHXSqL+KYArKhXKzGICFKvrOwfGrSC7Rt9zwV+lL
+UB6NRWR5viSgIkwYw/W4R9M1iQPQLjGm/ibjW/FXWzr98LNgs8kjqMoAIDs7z8YU
+FCT6YDb8zJlqiOBKnU7ReetKsHwPM2mAyWMS6z8R3LOSNdgrP70Y
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/certificate-authority/server-keys/proxy.key-pk8.pem b/tests/certificate-authority/server-keys/proxy.key-pk8.pem
index 0dc72cde40..51a53e29cd 100644
--- a/tests/certificate-authority/server-keys/proxy.key-pk8.pem
+++ b/tests/certificate-authority/server-keys/proxy.key-pk8.pem
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDMFcmFBkNHvUaf
-TwMa4G6UE06wMOqIyjrkOZISwXdRjA08uSZcL9z8sVq/Dkf/CWAweY5VJv7Qoe2f
-bYpqBoXw0NyUplShpsk+V9Vpfeklwe9rd+FidtjkVJFAvAsRdLgwu9QCd9a90tDn
-rd99mJZ0Qq1Ts4jI3B3bUWOE7n6FcxRe1MjwAV9nUu2Uh/fWqiiLLISYjLmRtTiZ
-gF2z1NuVlgnvHaFvhsgXhvcKHnI7UIxT5c7UjM/MgT1GVf9lJQs2MTGmIidHllk4
-wc1mppqDmNy4LhCNukWuqiBu4wu97OZjtUBV1P6XsfGNmsCiRo6j7aAb7UCwAKUo
-+doDvcGpAgMBAAECggEAPTAXEFQVXe/ouaDV3HwHi0vSns67srF3QK/mFMt+e6uS
-2G7mimMrTXPbMkcU3OkxtrbrLqqXYXP7K36LLkiwZcgpKkRIQYMg+RkaehtvCIwB
-vWXe5Eefta2JMzBt3RjylGHsKaVGc/k9+whNZnmWOls3Xk4Ip7gfF39qaBOdSWLy
-gVJJ9qbM6nHejl3vdSew5nRGlqGu0qonB+OhbM2GGSLEjH4BBbDlvI1Gl/mdKMLK
-XMJf6WvO/d43+y+/EWmln2NF5lXHRwD+Gk84316mf+ANFy8V3yvp7BC9kDWqLeDH
-A6wK9fmwPzwEWZKgzurN/Euz8gv1hEVcxH54HUBgVQKBgQD/iprN8phLUeA1VwJg
-zm/AX6jM4GIEig0rXkYOOz1KI7wx6DunfnFINxSpDXf93cK7k6wtmLkxu0ONO9LE
-1q4bmaBPkObfGOzBFixSOEE9ecyH9+EiFQi4O1zBqZLPObIY7tJ5xVsAmvQmwrf9
-Agy6fKNGM1SFBWyHgmTUvtLrlwKBgQDMc4slLWyTZYZn7bpbuXslRBWSp3KROP8M
-R5wCGe0xmOz2A/UEfGMruAS3/2+GJQlMpW25ACi3GX+Wq0OAlVxHZfArw9vaJSXm
-Nj1rC0bkICKYHojS0kFckTHBGUEKOAaSdP1Ehm+eUaH0kVapfw9bSQ0+Yd5Z0XHS
-65QqcY9kvwKBgFD8emc+tSlZv3boJmbLxfrv1i1oB2hs4BOYgxdLivcOMDyY3x8M
-IZbDbhbNn/Oi7m5INM8WkcrDEHuYNAoSB4fTvky5HZIi8hWXk2BTV8nF6h5FXuJQ
-TD0nAxSVS2PFYz4noijZdSfR9AK8v1a96Y7IpW5AIk8uEuE3YAFUoL/tAoGAMGXh
-uIlKPJI6APw7s17zEd1OJgtRiaMubR++hJjSl30WCx7gr5EqgLztEQl8wwqdavF2
-SecJvF5i363nKtcwow40joes0bUdhaOtYlunCnW4+r2vsghnxJvyZT2vMdYVaDId
-ik0wuw+kARsuoq0bW4athejxE94Kzd1Kk8mSIk0CgYEAiBYxMU8c821HwRzHGUi4
-MEqrOV7D0WrQIeeunT9yBZvP1/OpH9VcHXM53JOQLX/1bF3gGzLevOxvzhSid9Kg
-7avc497uam9LfmIueIsc90yH6Qf83O2pwLc6x/Jx9cyVX4elMC9b+CpXPzC4RDla
-NGH4KgEBAySS0x7x6a31/yg=
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDMFcmFBkNHvUaf
+TwMa4G6UE06wMOqIyjrkOZISwXdRjA08uSZcL9z8sVq/Dkf/CWAweY5VJv7Qoe2f
+bYpqBoXw0NyUplShpsk+V9Vpfeklwe9rd+FidtjkVJFAvAsRdLgwu9QCd9a90tDn
+rd99mJZ0Qq1Ts4jI3B3bUWOE7n6FcxRe1MjwAV9nUu2Uh/fWqiiLLISYjLmRtTiZ
+gF2z1NuVlgnvHaFvhsgXhvcKHnI7UIxT5c7UjM/MgT1GVf9lJQs2MTGmIidHllk4
+wc1mppqDmNy4LhCNukWuqiBu4wu97OZjtUBV1P6XsfGNmsCiRo6j7aAb7UCwAKUo
++doDvcGpAgMBAAECggEAPTAXEFQVXe/ouaDV3HwHi0vSns67srF3QK/mFMt+e6uS
+2G7mimMrTXPbMkcU3OkxtrbrLqqXYXP7K36LLkiwZcgpKkRIQYMg+RkaehtvCIwB
+vWXe5Eefta2JMzBt3RjylGHsKaVGc/k9+whNZnmWOls3Xk4Ip7gfF39qaBOdSWLy
+gVJJ9qbM6nHejl3vdSew5nRGlqGu0qonB+OhbM2GGSLEjH4BBbDlvI1Gl/mdKMLK
+XMJf6WvO/d43+y+/EWmln2NF5lXHRwD+Gk84316mf+ANFy8V3yvp7BC9kDWqLeDH
+A6wK9fmwPzwEWZKgzurN/Euz8gv1hEVcxH54HUBgVQKBgQD/iprN8phLUeA1VwJg
+zm/AX6jM4GIEig0rXkYOOz1KI7wx6DunfnFINxSpDXf93cK7k6wtmLkxu0ONO9LE
+1q4bmaBPkObfGOzBFixSOEE9ecyH9+EiFQi4O1zBqZLPObIY7tJ5xVsAmvQmwrf9
+Agy6fKNGM1SFBWyHgmTUvtLrlwKBgQDMc4slLWyTZYZn7bpbuXslRBWSp3KROP8M
+R5wCGe0xmOz2A/UEfGMruAS3/2+GJQlMpW25ACi3GX+Wq0OAlVxHZfArw9vaJSXm
+Nj1rC0bkICKYHojS0kFckTHBGUEKOAaSdP1Ehm+eUaH0kVapfw9bSQ0+Yd5Z0XHS
+65QqcY9kvwKBgFD8emc+tSlZv3boJmbLxfrv1i1oB2hs4BOYgxdLivcOMDyY3x8M
+IZbDbhbNn/Oi7m5INM8WkcrDEHuYNAoSB4fTvky5HZIi8hWXk2BTV8nF6h5FXuJQ
+TD0nAxSVS2PFYz4noijZdSfR9AK8v1a96Y7IpW5AIk8uEuE3YAFUoL/tAoGAMGXh
+uIlKPJI6APw7s17zEd1OJgtRiaMubR++hJjSl30WCx7gr5EqgLztEQl8wwqdavF2
+SecJvF5i363nKtcwow40joes0bUdhaOtYlunCnW4+r2vsghnxJvyZT2vMdYVaDId
+ik0wuw+kARsuoq0bW4athejxE94Kzd1Kk8mSIk0CgYEAiBYxMU8c821HwRzHGUi4
+MEqrOV7D0WrQIeeunT9yBZvP1/OpH9VcHXM53JOQLX/1bF3gGzLevOxvzhSid9Kg
+7avc497uam9LfmIueIsc90yH6Qf83O2pwLc6x/Jx9cyVX4elMC9b+CpXPzC4RDla
+NGH4KgEBAySS0x7x6a31/yg=
+-----END PRIVATE KEY-----
diff --git a/tests/certificate-authority/server-keys/proxy.key.pem b/tests/certificate-authority/server-keys/proxy.key.pem
index 17c431ba9f..34aef36510 100644
--- a/tests/certificate-authority/server-keys/proxy.key.pem
+++ b/tests/certificate-authority/server-keys/proxy.key.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEAzBXJhQZDR71Gn08DGuBulBNOsDDqiMo65DmSEsF3UYwNPLkm
-XC/c/LFavw5H/wlgMHmOVSb+0KHtn22KagaF8NDclKZUoabJPlfVaX3pJcHva3fh
-YnbY5FSRQLwLEXS4MLvUAnfWvdLQ563ffZiWdEKtU7OIyNwd21FjhO5+hXMUXtTI
-8AFfZ1LtlIf31qooiyyEmIy5kbU4mYBds9TblZYJ7x2hb4bIF4b3Ch5yO1CMU+XO
-1IzPzIE9RlX/ZSULNjExpiInR5ZZOMHNZqaag5jcuC4QjbpFrqogbuMLvezmY7VA
-VdT+l7HxjZrAokaOo+2gG+1AsAClKPnaA73BqQIDAQABAoIBAD0wFxBUFV3v6Lmg
-1dx8B4tL0p7Ou7Kxd0Cv5hTLfnurkthu5opjK01z2zJHFNzpMba26y6ql2Fz+yt+
-iy5IsGXIKSpESEGDIPkZGnobbwiMAb1l3uRHn7WtiTMwbd0Y8pRh7CmlRnP5PfsI
-TWZ5ljpbN15OCKe4Hxd/amgTnUli8oFSSfamzOpx3o5d73UnsOZ0RpahrtKqJwfj
-oWzNhhkixIx+AQWw5byNRpf5nSjCylzCX+lrzv3eN/svvxFppZ9jReZVx0cA/hpP
-ON9epn/gDRcvFd8r6ewQvZA1qi3gxwOsCvX5sD88BFmSoM7qzfxLs/IL9YRFXMR+
-eB1AYFUCgYEA/4qazfKYS1HgNVcCYM5vwF+ozOBiBIoNK15GDjs9SiO8Meg7p35x
-SDcUqQ13/d3Cu5OsLZi5MbtDjTvSxNauG5mgT5Dm3xjswRYsUjhBPXnMh/fhIhUI
-uDtcwamSzzmyGO7SecVbAJr0JsK3/QIMunyjRjNUhQVsh4Jk1L7S65cCgYEAzHOL
-JS1sk2WGZ+26W7l7JUQVkqdykTj/DEecAhntMZjs9gP1BHxjK7gEt/9vhiUJTKVt
-uQAotxl/lqtDgJVcR2XwK8Pb2iUl5jY9awtG5CAimB6I0tJBXJExwRlBCjgGknT9
-RIZvnlGh9JFWqX8PW0kNPmHeWdFx0uuUKnGPZL8CgYBQ/HpnPrUpWb926CZmy8X6
-79YtaAdobOATmIMXS4r3DjA8mN8fDCGWw24WzZ/zou5uSDTPFpHKwxB7mDQKEgeH
-075MuR2SIvIVl5NgU1fJxeoeRV7iUEw9JwMUlUtjxWM+J6Io2XUn0fQCvL9WvemO
-yKVuQCJPLhLhN2ABVKC/7QKBgDBl4biJSjySOgD8O7Ne8xHdTiYLUYmjLm0fvoSY
-0pd9Fgse4K+RKoC87REJfMMKnWrxdknnCbxeYt+t5yrXMKMONI6HrNG1HYWjrWJb
-pwp1uPq9r7IIZ8Sb8mU9rzHWFWgyHYpNMLsPpAEbLqKtG1uGrYXo8RPeCs3dSpPJ
-kiJNAoGBAIgWMTFPHPNtR8EcxxlIuDBKqzlew9Fq0CHnrp0/cgWbz9fzqR/VXB1z
-OdyTkC1/9Wxd4Bsy3rzsb84UonfSoO2r3OPe7mpvS35iLniLHPdMh+kH/NztqcC3
-OsfycfXMlV+HpTAvW/gqVz8wuEQ5WjRh+CoBAQMkktMe8emt9f8o
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEAzBXJhQZDR71Gn08DGuBulBNOsDDqiMo65DmSEsF3UYwNPLkm
+XC/c/LFavw5H/wlgMHmOVSb+0KHtn22KagaF8NDclKZUoabJPlfVaX3pJcHva3fh
+YnbY5FSRQLwLEXS4MLvUAnfWvdLQ563ffZiWdEKtU7OIyNwd21FjhO5+hXMUXtTI
+8AFfZ1LtlIf31qooiyyEmIy5kbU4mYBds9TblZYJ7x2hb4bIF4b3Ch5yO1CMU+XO
+1IzPzIE9RlX/ZSULNjExpiInR5ZZOMHNZqaag5jcuC4QjbpFrqogbuMLvezmY7VA
+VdT+l7HxjZrAokaOo+2gG+1AsAClKPnaA73BqQIDAQABAoIBAD0wFxBUFV3v6Lmg
+1dx8B4tL0p7Ou7Kxd0Cv5hTLfnurkthu5opjK01z2zJHFNzpMba26y6ql2Fz+yt+
+iy5IsGXIKSpESEGDIPkZGnobbwiMAb1l3uRHn7WtiTMwbd0Y8pRh7CmlRnP5PfsI
+TWZ5ljpbN15OCKe4Hxd/amgTnUli8oFSSfamzOpx3o5d73UnsOZ0RpahrtKqJwfj
+oWzNhhkixIx+AQWw5byNRpf5nSjCylzCX+lrzv3eN/svvxFppZ9jReZVx0cA/hpP
+ON9epn/gDRcvFd8r6ewQvZA1qi3gxwOsCvX5sD88BFmSoM7qzfxLs/IL9YRFXMR+
+eB1AYFUCgYEA/4qazfKYS1HgNVcCYM5vwF+ozOBiBIoNK15GDjs9SiO8Meg7p35x
+SDcUqQ13/d3Cu5OsLZi5MbtDjTvSxNauG5mgT5Dm3xjswRYsUjhBPXnMh/fhIhUI
+uDtcwamSzzmyGO7SecVbAJr0JsK3/QIMunyjRjNUhQVsh4Jk1L7S65cCgYEAzHOL
+JS1sk2WGZ+26W7l7JUQVkqdykTj/DEecAhntMZjs9gP1BHxjK7gEt/9vhiUJTKVt
+uQAotxl/lqtDgJVcR2XwK8Pb2iUl5jY9awtG5CAimB6I0tJBXJExwRlBCjgGknT9
+RIZvnlGh9JFWqX8PW0kNPmHeWdFx0uuUKnGPZL8CgYBQ/HpnPrUpWb926CZmy8X6
+79YtaAdobOATmIMXS4r3DjA8mN8fDCGWw24WzZ/zou5uSDTPFpHKwxB7mDQKEgeH
+075MuR2SIvIVl5NgU1fJxeoeRV7iUEw9JwMUlUtjxWM+J6Io2XUn0fQCvL9WvemO
+yKVuQCJPLhLhN2ABVKC/7QKBgDBl4biJSjySOgD8O7Ne8xHdTiYLUYmjLm0fvoSY
+0pd9Fgse4K+RKoC87REJfMMKnWrxdknnCbxeYt+t5yrXMKMONI6HrNG1HYWjrWJb
+pwp1uPq9r7IIZ8Sb8mU9rzHWFWgyHYpNMLsPpAEbLqKtG1uGrYXo8RPeCs3dSpPJ
+kiJNAoGBAIgWMTFPHPNtR8EcxxlIuDBKqzlew9Fq0CHnrp0/cgWbz9fzqR/VXB1z
+OdyTkC1/9Wxd4Bsy3rzsb84UonfSoO2r3OPe7mpvS35iLniLHPdMh+kH/NztqcC3
+OsfycfXMlV+HpTAvW/gqVz8wuEQ5WjRh+CoBAQMkktMe8emt9f8o
+-----END RSA PRIVATE KEY-----
diff --git a/tests/compose/multi/docker-compose.yml b/tests/compose/multi/docker-compose.yml
index 3a5258f188..0436772b9c 100644
--- a/tests/compose/multi/docker-compose.yml
+++ b/tests/compose/multi/docker-compose.yml
@@ -1,167 +1,167 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-version: '2.1'
-networks:
-  pulsar:
-    driver: bridge
-
-services:
-  conf-eu:
-    hostname: conf-eu
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-global-zk.sh
-    environment:
-      ZOOKEEPER_SERVERS: conf-eu,conf-us
-    networks:
-      pulsar:
-
-  zk-eu:
-    hostname: zk-eu
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-local-zk.sh
-    environment:
-      ZOOKEEPER_SERVERS: zk-eu
-    networks:
-      pulsar:
-
-  init-eu:
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/init-cluster.sh
-    environment:
-      clusterName: eu
-      zkServers: zk-eu
-      configurationStore: conf-eu:2184,conf-us:2184
-      pulsarNode: pulsar1-eu
-    networks:
-      pulsar:
-
-  bk1-eu:
-    hostname: bk1-eu
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: eu
-      zkServers: zk-eu
-    networks:
-      pulsar:
-
-  bk2-eu:
-    hostname: bk2-eu
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: eu
-      zkServers: zk-eu
-    networks:
-      pulsar:
-
-  pulsar1-eu:
-    hostname: pulsar1-eu
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-broker.sh
-    environment:
-      clusterName: eu
-      zookeeperServers: zk-eu
-      configurationStoreServers: conf-eu:2184
-    networks:
-      pulsar:
-
-  proxy-eu:
-    hostname: proxy-eu
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-proxy.sh
-    environment:
-      clusterName: eu
-      zookeeperServers: zk-eu
-      configurationStoreServers: conf-eu:2184
-    networks:
-      pulsar:
-
-  conf-us:
-    hostname: conf-us
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-global-zk.sh
-    environment:
-      ZOOKEEPER_SERVERS: conf-eu,conf-us
-    networks:
-      pulsar:
-
-  zk-us:
-    hostname: zk-us
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-local-zk.sh
-    environment:
-      ZOOKEEPER_SERVERS: zk-us
-    networks:
-      pulsar:
-
-  init-us:
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/init-cluster.sh
-    environment:
-      clusterName: us
-      zkServers: zk-us
-      configurationStore: conf-eu:2184,conf-us:2184
-      pulsarNode: pulsar1-us
-    networks:
-      pulsar:
-
-  bk1-us:
-    hostname: bk1-us
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: us
-      zkServers: zk-us
-    networks:
-      pulsar:
-
-  bk2-us:
-    hostname: bk2-us
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: us
-      zkServers: zk-us
-    networks:
-      pulsar:
-
-  pulsar1-us:
-    hostname: pulsar1-us
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-broker.sh
-    environment:
-      clusterName: us
-      zookeeperServers: zk-us
-      configurationStoreServers: conf-us:2184
-    networks:
-      pulsar:
-
-  proxy-us:
-    hostname: proxy-us
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-proxy.sh
-    environment:
-      clusterName: us
-      zookeeperServers: zk-us
-      configurationStoreServers: conf-us:2184
-    networks:
-      pulsar:
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+version: '2.1'
+networks:
+  pulsar:
+    driver: bridge
+
+services:
+  conf-eu:
+    hostname: conf-eu
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-global-zk.sh
+    environment:
+      ZOOKEEPER_SERVERS: conf-eu,conf-us
+    networks:
+      pulsar:
+
+  zk-eu:
+    hostname: zk-eu
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-local-zk.sh
+    environment:
+      ZOOKEEPER_SERVERS: zk-eu
+    networks:
+      pulsar:
+
+  init-eu:
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/init-cluster.sh
+    environment:
+      clusterName: eu
+      zkServers: zk-eu
+      configurationStore: conf-eu:2184,conf-us:2184
+      pulsarNode: pulsar1-eu
+    networks:
+      pulsar:
+
+  bk1-eu:
+    hostname: bk1-eu
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: eu
+      zkServers: zk-eu
+    networks:
+      pulsar:
+
+  bk2-eu:
+    hostname: bk2-eu
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: eu
+      zkServers: zk-eu
+    networks:
+      pulsar:
+
+  pulsar1-eu:
+    hostname: pulsar1-eu
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-broker.sh
+    environment:
+      clusterName: eu
+      zookeeperServers: zk-eu
+      configurationStoreServers: conf-eu:2184
+    networks:
+      pulsar:
+
+  proxy-eu:
+    hostname: proxy-eu
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-proxy.sh
+    environment:
+      clusterName: eu
+      zookeeperServers: zk-eu
+      configurationStoreServers: conf-eu:2184
+    networks:
+      pulsar:
+
+  conf-us:
+    hostname: conf-us
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-global-zk.sh
+    environment:
+      ZOOKEEPER_SERVERS: conf-eu,conf-us
+    networks:
+      pulsar:
+
+  zk-us:
+    hostname: zk-us
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-local-zk.sh
+    environment:
+      ZOOKEEPER_SERVERS: zk-us
+    networks:
+      pulsar:
+
+  init-us:
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/init-cluster.sh
+    environment:
+      clusterName: us
+      zkServers: zk-us
+      configurationStore: conf-eu:2184,conf-us:2184
+      pulsarNode: pulsar1-us
+    networks:
+      pulsar:
+
+  bk1-us:
+    hostname: bk1-us
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: us
+      zkServers: zk-us
+    networks:
+      pulsar:
+
+  bk2-us:
+    hostname: bk2-us
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: us
+      zkServers: zk-us
+    networks:
+      pulsar:
+
+  pulsar1-us:
+    hostname: pulsar1-us
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-broker.sh
+    environment:
+      clusterName: us
+      zookeeperServers: zk-us
+      configurationStoreServers: conf-us:2184
+    networks:
+      pulsar:
+
+  proxy-us:
+    hostname: proxy-us
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-proxy.sh
+    environment:
+      clusterName: us
+      zookeeperServers: zk-us
+      configurationStoreServers: conf-us:2184
+    networks:
+      pulsar:
+
diff --git a/tests/compose/simple/docker-compose.yml b/tests/compose/simple/docker-compose.yml
index 99647e5a1e..4e257d2ddc 100644
--- a/tests/compose/simple/docker-compose.yml
+++ b/tests/compose/simple/docker-compose.yml
@@ -1,86 +1,86 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-version: '2.1'
-networks:
-  pulsar:
-    driver: bridge
-    
-services:
-  zk:
-    hostname: zk
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-local-zk.sh
-    environment:
-      ZOOKEEPER_SERVERS: zk
-    networks:
-      pulsar:
-
-  init:
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/init-cluster.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-      configurationStore: zk:2181
-      pulsarNode: pulsar1
-    networks:
-      pulsar:
-
-  bk1:
-    hostname: bk1
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-    networks:
-      pulsar:
-
-  bk2:
-    hostname: bk2
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-    networks:
-      pulsar:
-
-  bk3:
-    hostname: bk3
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-    networks:
-      pulsar:
-
-  pulsar1:
-    hostname: pulsar1
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-broker.sh
-    environment:
-      clusterName: test
-      zookeeperServers: zk
-      configurationStoreServers: zk:2181
-    networks:
-      pulsar:
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+version: '2.1'
+networks:
+  pulsar:
+    driver: bridge
+    
+services:
+  zk:
+    hostname: zk
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-local-zk.sh
+    environment:
+      ZOOKEEPER_SERVERS: zk
+    networks:
+      pulsar:
+
+  init:
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/init-cluster.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+      configurationStore: zk:2181
+      pulsarNode: pulsar1
+    networks:
+      pulsar:
+
+  bk1:
+    hostname: bk1
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+    networks:
+      pulsar:
+
+  bk2:
+    hostname: bk2
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+    networks:
+      pulsar:
+
+  bk3:
+    hostname: bk3
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+    networks:
+      pulsar:
+
+  pulsar1:
+    hostname: pulsar1
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-broker.sh
+    environment:
+      clusterName: test
+      zookeeperServers: zk
+      configurationStoreServers: zk:2181
+    networks:
+      pulsar:
+
diff --git a/tests/compose/tls/docker-compose.yml b/tests/compose/tls/docker-compose.yml
index ca7d3455ff..203a39f0ef 100644
--- a/tests/compose/tls/docker-compose.yml
+++ b/tests/compose/tls/docker-compose.yml
@@ -1,120 +1,120 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-version: '2.1'
-networks:
-  pulsar:
-    driver: bridge
-
-services:
-  zk:
-    hostname: zk
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-local-zk.sh
-    environment:
-      ZOOKEEPER_SERVERS: zk
-    networks:
-      pulsar:
-
-  init:
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/init-cluster.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-      configurationStore: zk:2181
-      pulsarNode: pulsar1
-    networks:
-      pulsar:
-
-  bk1:
-    hostname: bk1
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-    networks:
-      pulsar:
-
-  bk2:
-    hostname: bk2
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-    networks:
-      pulsar:
-
-  bk3:
-    hostname: bk3
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-bookie.sh
-    environment:
-      clusterName: test
-      zkServers: zk
-    networks:
-      pulsar:
-
-  pulsar1:
-    hostname: pulsar1
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-broker.sh
-    environment:
-      clusterName: test
-      zookeeperServers: zk
-      configurationStoreServers: zk:2181
-      brokerServicePortTls: 6651
-      webServicePortTls: 8443
-      tlsCertificateFilePath: /pulsar/certificate-authority/server-keys/broker.cert.pem
-      tlsKeyFilePath: /pulsar/certificate-authority/server-keys/broker.key-pk8.pem
-      tlsTrustCertsFilePath: /pulsar/certificate-authority/certs/ca.cert.pem
-      authenticationEnabled: "true"
-      authenticationProviders: org.apache.pulsar.broker.authentication.AuthenticationProviderTls
-      authorizationEnabled: "true"
-      authorizationProvider: org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider
-      superUserRoles: admin,superproxy
-      proxyRoles: superproxy
-    networks:
-      pulsar:
-
-  proxy1:
-    hostname: proxy1
-    image: apachepulsar/pulsar-test-latest-version:latest
-    command: bin/run-proxy.sh
-    environment:
-      clusterName: test
-      zookeeperServers: zk
-      configurationStoreServers: zk:2181
-      servicePortTls: 6651
-      webServicePortTls: 8443
-      tlsCertificateFilePath: /pulsar/certificate-authority/server-keys/broker.cert.pem
-      tlsKeyFilePath: /pulsar/certificate-authority/server-keys/broker.key-pk8.pem
-      tlsTrustCertsFilePath: /pulsar/certificate-authority/certs/ca.cert.pem
-      brokerClientTrustCertsFilePath: /pulsar/certificate-authority/certs/ca.cert.pem
-      authenticationEnabled: "true"
-      authenticationProviders: org.apache.pulsar.broker.authentication.AuthenticationProviderTls
-      tlsEnabledWithBroker: "true"
-      brokerClientAuthenticationPlugin: org.apache.pulsar.client.impl.auth.AuthenticationTls
-      brokerClientAuthenticationParameters: tlsCertFile:/pulsar/certificate-authority/client-keys/superproxy.cert.pem,tlsKeyFile:/pulsar/certificate-authority/client-keys/superproxy.key-pk8.pem
-    networks:
-      pulsar:
-
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+version: '2.1'
+networks:
+  pulsar:
+    driver: bridge
+
+services:
+  zk:
+    hostname: zk
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-local-zk.sh
+    environment:
+      ZOOKEEPER_SERVERS: zk
+    networks:
+      pulsar:
+
+  init:
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/init-cluster.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+      configurationStore: zk:2181
+      pulsarNode: pulsar1
+    networks:
+      pulsar:
+
+  bk1:
+    hostname: bk1
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+    networks:
+      pulsar:
+
+  bk2:
+    hostname: bk2
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+    networks:
+      pulsar:
+
+  bk3:
+    hostname: bk3
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-bookie.sh
+    environment:
+      clusterName: test
+      zkServers: zk
+    networks:
+      pulsar:
+
+  pulsar1:
+    hostname: pulsar1
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-broker.sh
+    environment:
+      clusterName: test
+      zookeeperServers: zk
+      configurationStoreServers: zk:2181
+      brokerServicePortTls: 6651
+      webServicePortTls: 8443
+      tlsCertificateFilePath: /pulsar/certificate-authority/server-keys/broker.cert.pem
+      tlsKeyFilePath: /pulsar/certificate-authority/server-keys/broker.key-pk8.pem
+      tlsTrustCertsFilePath: /pulsar/certificate-authority/certs/ca.cert.pem
+      authenticationEnabled: "true"
+      authenticationProviders: org.apache.pulsar.broker.authentication.AuthenticationProviderTls
+      authorizationEnabled: "true"
+      authorizationProvider: org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider
+      superUserRoles: admin,superproxy
+      proxyRoles: superproxy
+    networks:
+      pulsar:
+
+  proxy1:
+    hostname: proxy1
+    image: apachepulsar/pulsar-test-latest-version:latest
+    command: bin/run-proxy.sh
+    environment:
+      clusterName: test
+      zookeeperServers: zk
+      configurationStoreServers: zk:2181
+      servicePortTls: 6651
+      webServicePortTls: 8443
+      tlsCertificateFilePath: /pulsar/certificate-authority/server-keys/broker.cert.pem
+      tlsKeyFilePath: /pulsar/certificate-authority/server-keys/broker.key-pk8.pem
+      tlsTrustCertsFilePath: /pulsar/certificate-authority/certs/ca.cert.pem
+      brokerClientTrustCertsFilePath: /pulsar/certificate-authority/certs/ca.cert.pem
+      authenticationEnabled: "true"
+      authenticationProviders: org.apache.pulsar.broker.authentication.AuthenticationProviderTls
+      tlsEnabledWithBroker: "true"
+      brokerClientAuthenticationPlugin: org.apache.pulsar.client.impl.auth.AuthenticationTls
+      brokerClientAuthenticationParameters: tlsCertFile:/pulsar/certificate-authority/client-keys/superproxy.cert.pem,tlsKeyFile:/pulsar/certificate-authority/client-keys/superproxy.key-pk8.pem
+    networks:
+      pulsar:
+
+
diff --git a/tests/docker-images/java-test-functions/pom.xml b/tests/docker-images/java-test-functions/pom.xml
index aaf4b0d4be..1a60ea4d69 100644
--- a/tests/docker-images/java-test-functions/pom.xml
+++ b/tests/docker-images/java-test-functions/pom.xml
@@ -1,106 +1,106 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.apache.pulsar.tests</groupId>
-    <artifactId>docker-images</artifactId>
-    <version>4.1.2</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>java-test-functions</artifactId>
-  <name>Apache Pulsar :: Tests :: Docker Images :: Java Test Functions</name>
-  <dependencies>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-io-core</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-functions-api</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <!-- allow sinks to use native Avro and Json -->
-    <dependency>
-      <groupId>org.apache.avro</groupId>
-      <artifactId>avro</artifactId>
-      <version>${avro.version}</version>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.fasterxml.jackson.core</groupId>
-      <artifactId>jackson-databind</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.protobuf</groupId>
-      <artifactId>protobuf-java</artifactId>
-      <version>${protobuf3.version}</version>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-  <packaging>jar</packaging>
-
-  <profiles>
-    <profile>
-      <id>docker</id>
-      <activation>
-        <property>
-          <name>integrationTests</name>
-        </property>
-      </activation>
-
-      <dependencies>
-        <dependency>
-          <groupId>org.apache.pulsar</groupId>
-          <artifactId>pulsar-functions-api-examples</artifactId>
-          <version>${project.version}</version>
-        </dependency>
-      </dependencies>
-
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-shade-plugin</artifactId>
-            <executions>
-              <execution>
-                <phase>${shadePluginPhase}</phase>
-                <goals>
-                  <goal>shade</goal>
-                </goals>
-                <configuration>
-                  <artifactSet>
-                    <includes>
-                      <include>org.apache.pulsar:pulsar-functions-api-examples</include>
-                    </includes>
-                  </artifactSet>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-
-</project>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <parent>
+    <groupId>org.apache.pulsar.tests</groupId>
+    <artifactId>docker-images</artifactId>
+    <version>4.1.2</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>java-test-functions</artifactId>
+  <name>Apache Pulsar :: Tests :: Docker Images :: Java Test Functions</name>
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-io-core</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-functions-api</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <!-- allow sinks to use native Avro and Json -->
+    <dependency>
+      <groupId>org.apache.avro</groupId>
+      <artifactId>avro</artifactId>
+      <version>${avro.version}</version>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.fasterxml.jackson.core</groupId>
+      <artifactId>jackson-databind</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.protobuf</groupId>
+      <artifactId>protobuf-java</artifactId>
+      <version>${protobuf3.version}</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <packaging>jar</packaging>
+
+  <profiles>
+    <profile>
+      <id>docker</id>
+      <activation>
+        <property>
+          <name>integrationTests</name>
+        </property>
+      </activation>
+
+      <dependencies>
+        <dependency>
+          <groupId>org.apache.pulsar</groupId>
+          <artifactId>pulsar-functions-api-examples</artifactId>
+          <version>${project.version}</version>
+        </dependency>
+      </dependencies>
+
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-shade-plugin</artifactId>
+            <executions>
+              <execution>
+                <phase>${shadePluginPhase}</phase>
+                <goals>
+                  <goal>shade</goal>
+                </goals>
+                <configuration>
+                  <artifactSet>
+                    <includes>
+                      <include>org.apache.pulsar:pulsar-functions-api-examples</include>
+                    </includes>
+                  </artifactSet>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+
+</project>
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/ExceptionFunction.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/ExceptionFunction.java
index 66545771d7..0f71c08319 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/ExceptionFunction.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/ExceptionFunction.java
@@ -1,35 +1,35 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import java.util.function.Function;
-
-public class ExceptionFunction implements Function<String, String> {
-
-    int i = 0;
-    @Override
-    public String apply(String s) {
-        i++;
-        if (i % 10 == 0) {
-            throw new RuntimeException("test");
-        }
-
-        return s + "!";
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import java.util.function.Function;
+
+public class ExceptionFunction implements Function<String, String> {
+
+    int i = 0;
+    @Override
+    public String apply(String s) {
+        i++;
+        if (i % 10 == 0) {
+            throw new RuntimeException("test");
+        }
+
+        return s + "!";
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/GenericObjectFunction.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/GenericObjectFunction.java
index ad7ffa970e..101105ffd4 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/GenericObjectFunction.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/GenericObjectFunction.java
@@ -1,64 +1,64 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.GenericObject;
-import org.apache.pulsar.functions.api.Context;
-import org.apache.pulsar.functions.api.Function;
-import org.apache.pulsar.functions.api.Record;
-
-/**
- * This function processes any message with any schema,
- * and outputs the message with the same schema to another topic.
- */
-@Slf4j
-public class GenericObjectFunction implements Function<GenericObject, Void> {
-
-    @Override
-    public Void process(GenericObject genericObject, Context context) throws Exception {
-        Record<?> currentRecord = context.getCurrentRecord();
-        log.info("apply to {} {}", genericObject, genericObject.getNativeObject());
-        log.info("record with schema {} {}", currentRecord.getSchema(), currentRecord);
-        // do some processing...
-        final boolean isStruct;
-        switch (currentRecord.getSchema().getSchemaInfo().getType()) {
-            case AVRO:
-            case JSON:
-            case PROTOBUF_NATIVE:
-                isStruct = true;
-                break;
-            default:
-                isStruct = false;
-                break;
-        }
-        if (isStruct) {
-            // GenericRecord must stay wrapped
-            context.newOutputMessage(context.getOutputTopic(), (Schema) currentRecord.getSchema())
-                    .value(genericObject).send();
-        } else {
-            // primitives and KeyValue must be unwrapped
-            context.newOutputMessage(context.getOutputTopic(), (Schema) currentRecord.getSchema())
-                    .value(genericObject.getNativeObject()).send();
-        }
-        return null;
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.GenericObject;
+import org.apache.pulsar.functions.api.Context;
+import org.apache.pulsar.functions.api.Function;
+import org.apache.pulsar.functions.api.Record;
+
+/**
+ * This function processes any message with any schema,
+ * and outputs the message with the same schema to another topic.
+ */
+@Slf4j
+public class GenericObjectFunction implements Function<GenericObject, Void> {
+
+    @Override
+    public Void process(GenericObject genericObject, Context context) throws Exception {
+        Record<?> currentRecord = context.getCurrentRecord();
+        log.info("apply to {} {}", genericObject, genericObject.getNativeObject());
+        log.info("record with schema {} {}", currentRecord.getSchema(), currentRecord);
+        // do some processing...
+        final boolean isStruct;
+        switch (currentRecord.getSchema().getSchemaInfo().getType()) {
+            case AVRO:
+            case JSON:
+            case PROTOBUF_NATIVE:
+                isStruct = true;
+                break;
+            default:
+                isStruct = false;
+                break;
+        }
+        if (isStruct) {
+            // GenericRecord must stay wrapped
+            context.newOutputMessage(context.getOutputTopic(), (Schema) currentRecord.getSchema())
+                    .value(genericObject).send();
+        } else {
+            // primitives and KeyValue must be unwrapped
+            context.newOutputMessage(context.getOutputTopic(), (Schema) currentRecord.getSchema())
+                    .value(genericObject.getNativeObject()).send();
+        }
+        return null;
+    }
+}
+
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldFunction.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldFunction.java
index efa7c9f281..029aec68ff 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldFunction.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldFunction.java
@@ -1,166 +1,166 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import java.io.ByteArrayOutputStream;
-import java.util.stream.Collectors;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.avro.generic.GenericData;
-import org.apache.avro.generic.GenericDatumWriter;
-import org.apache.avro.io.BinaryEncoder;
-import org.apache.avro.io.EncoderFactory;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.GenericObject;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.client.api.schema.KeyValueSchema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.SchemaType;
-import org.apache.pulsar.functions.api.Context;
-import org.apache.pulsar.functions.api.Function;
-import org.apache.pulsar.functions.api.Record;
-
-/**
- * This function removes a "field" from a AVRO message.
- */
-@Slf4j
-public class RemoveAvroFieldFunction implements Function<GenericObject, Void> {
-
-    private static final String FIELD_TO_REMOVE = "age";
-
-    @Override
-    public Void process(GenericObject genericObject, Context context) throws Exception {
-        Record<?> currentRecord = context.getCurrentRecord();
-        log.info("apply to {} {}", genericObject, genericObject.getNativeObject());
-        log.info("record with schema {} version {} {}", currentRecord.getSchema(),
-                currentRecord.getMessage().get().getSchemaVersion(),
-                currentRecord);
-        Object nativeObject = genericObject.getNativeObject();
-        Schema<?> schema = currentRecord.getSchema();
-
-        Schema outputSchema = schema;
-        Object outputObject = genericObject.getNativeObject();
-        boolean someThingDone = false;
-        if (schema instanceof KeyValueSchema && nativeObject instanceof KeyValue)  {
-            KeyValueSchema kvSchema = (KeyValueSchema) schema;
-
-            Schema keySchema = kvSchema.getKeySchema();
-            Schema valueSchema = kvSchema.getValueSchema();
-            // remove a column "age" from the "valueSchema"
-            if (valueSchema.getSchemaInfo().getType() == SchemaType.AVRO) {
-
-                org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) valueSchema.getNativeSchema().get();
-                if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
-                    org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
-                    org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
-                    org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
-                            originalAvroSchema.getName(),
-                            originalAvroSchema.getDoc(),
-                            originalAvroSchema.getNamespace(),
-                            originalAvroSchema.isError(),
-                            originalAvroSchema.getFields().
-                                    stream()
-                                    .filter(f->!f.name().equals(FIELD_TO_REMOVE))
-                                    .map(f-> new org.apache.avro.Schema.Field(
-                                            f.name(), f.schema(), f.doc(), f.defaultVal(), f.order()))
-                                    .collect(Collectors.toList()));
-
-                    KeyValue originalObject = (KeyValue) nativeObject;
-
-                    GenericRecord value = (GenericRecord) originalObject.getValue();
-                    org.apache.avro.generic.GenericRecord genericRecord =
-                            (org.apache.avro.generic.GenericRecord) value.getNativeObject();
-
-                    org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
-                    for (org.apache.avro.Schema.Field field : modified.getFields()) {
-                        newRecord.put(field.name(), genericRecord.get(field.name()));
-                    }
-                    GenericDatumWriter writer = new GenericDatumWriter(modified);
-                    ByteArrayOutputStream oo = new ByteArrayOutputStream();
-                    BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
-                    writer.write(newRecord, encoder);
-                    Object newValue = oo.toByteArray();
-
-                    Schema newValueSchema = Schema.NATIVE_AVRO(modified);
-                    outputSchema = Schema.KeyValue(keySchema, newValueSchema, kvSchema.getKeyValueEncodingType());
-                    outputObject = new KeyValue(originalObject.getKey(), newValue);
-                    someThingDone = true;
-                }
-            }
-        } else if (schema.getSchemaInfo().getType() == SchemaType.AVRO) {
-            org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) schema.getNativeSchema().get();
-            if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
-                org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
-                org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
-                org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
-                        originalAvroSchema.getName(),
-                        originalAvroSchema.getDoc(),
-                        originalAvroSchema.getNamespace(),
-                        originalAvroSchema.isError(),
-                        originalAvroSchema.getFields().
-                                stream()
-                                .filter(f -> !f.name().equals(FIELD_TO_REMOVE))
-                                .map(f -> new org.apache.avro.Schema.Field(
-                                        f.name(), f.schema(), f.doc(), f.defaultVal(), f.order()))
-                                .collect(Collectors.toList()));
-
-                org.apache.avro.generic.GenericRecord genericRecord =
-                        (org.apache.avro.generic.GenericRecord) nativeObject;
-                org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
-                for (org.apache.avro.Schema.Field field : modified.getFields()) {
-                    newRecord.put(field.name(), genericRecord.get(field.name()));
-                }
-                GenericDatumWriter writer = new GenericDatumWriter(modified);
-                ByteArrayOutputStream oo = new ByteArrayOutputStream();
-                BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
-                writer.write(newRecord, encoder);
-
-                Schema newValueSchema = Schema.NATIVE_AVRO(modified);
-                outputSchema = newValueSchema;
-                outputObject = oo.toByteArray();
-                someThingDone = true;
-            }
-        }
-
-        if (!someThingDone) {
-            // do some processing...
-            final boolean isStruct;
-            switch (currentRecord.getSchema().getSchemaInfo().getType()) {
-                case AVRO:
-                case JSON:
-                case PROTOBUF_NATIVE:
-                    isStruct = true;
-                    break;
-                default:
-                    isStruct = false;
-                    break;
-            }
-            if (isStruct) {
-                // GenericRecord must stay wrapped
-                outputObject = currentRecord.getValue();
-            } else {
-                // primitives and KeyValue must be unwrapped
-                outputObject = nativeObject;
-            }
-        }
-        log.info("output {} schema {}", outputObject, outputSchema);
-        context.newOutputMessage(context.getOutputTopic(), outputSchema)
-                .value(outputObject).send();
-        return null;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import java.io.ByteArrayOutputStream;
+import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.avro.generic.GenericData;
+import org.apache.avro.generic.GenericDatumWriter;
+import org.apache.avro.io.BinaryEncoder;
+import org.apache.avro.io.EncoderFactory;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.GenericObject;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.client.api.schema.KeyValueSchema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.SchemaType;
+import org.apache.pulsar.functions.api.Context;
+import org.apache.pulsar.functions.api.Function;
+import org.apache.pulsar.functions.api.Record;
+
+/**
+ * This function removes a "field" from a AVRO message.
+ */
+@Slf4j
+public class RemoveAvroFieldFunction implements Function<GenericObject, Void> {
+
+    private static final String FIELD_TO_REMOVE = "age";
+
+    @Override
+    public Void process(GenericObject genericObject, Context context) throws Exception {
+        Record<?> currentRecord = context.getCurrentRecord();
+        log.info("apply to {} {}", genericObject, genericObject.getNativeObject());
+        log.info("record with schema {} version {} {}", currentRecord.getSchema(),
+                currentRecord.getMessage().get().getSchemaVersion(),
+                currentRecord);
+        Object nativeObject = genericObject.getNativeObject();
+        Schema<?> schema = currentRecord.getSchema();
+
+        Schema outputSchema = schema;
+        Object outputObject = genericObject.getNativeObject();
+        boolean someThingDone = false;
+        if (schema instanceof KeyValueSchema && nativeObject instanceof KeyValue)  {
+            KeyValueSchema kvSchema = (KeyValueSchema) schema;
+
+            Schema keySchema = kvSchema.getKeySchema();
+            Schema valueSchema = kvSchema.getValueSchema();
+            // remove a column "age" from the "valueSchema"
+            if (valueSchema.getSchemaInfo().getType() == SchemaType.AVRO) {
+
+                org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) valueSchema.getNativeSchema().get();
+                if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
+                    org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
+                    org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
+                    org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
+                            originalAvroSchema.getName(),
+                            originalAvroSchema.getDoc(),
+                            originalAvroSchema.getNamespace(),
+                            originalAvroSchema.isError(),
+                            originalAvroSchema.getFields().
+                                    stream()
+                                    .filter(f->!f.name().equals(FIELD_TO_REMOVE))
+                                    .map(f-> new org.apache.avro.Schema.Field(
+                                            f.name(), f.schema(), f.doc(), f.defaultVal(), f.order()))
+                                    .collect(Collectors.toList()));
+
+                    KeyValue originalObject = (KeyValue) nativeObject;
+
+                    GenericRecord value = (GenericRecord) originalObject.getValue();
+                    org.apache.avro.generic.GenericRecord genericRecord =
+                            (org.apache.avro.generic.GenericRecord) value.getNativeObject();
+
+                    org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
+                    for (org.apache.avro.Schema.Field field : modified.getFields()) {
+                        newRecord.put(field.name(), genericRecord.get(field.name()));
+                    }
+                    GenericDatumWriter writer = new GenericDatumWriter(modified);
+                    ByteArrayOutputStream oo = new ByteArrayOutputStream();
+                    BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
+                    writer.write(newRecord, encoder);
+                    Object newValue = oo.toByteArray();
+
+                    Schema newValueSchema = Schema.NATIVE_AVRO(modified);
+                    outputSchema = Schema.KeyValue(keySchema, newValueSchema, kvSchema.getKeyValueEncodingType());
+                    outputObject = new KeyValue(originalObject.getKey(), newValue);
+                    someThingDone = true;
+                }
+            }
+        } else if (schema.getSchemaInfo().getType() == SchemaType.AVRO) {
+            org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) schema.getNativeSchema().get();
+            if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
+                org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
+                org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
+                org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
+                        originalAvroSchema.getName(),
+                        originalAvroSchema.getDoc(),
+                        originalAvroSchema.getNamespace(),
+                        originalAvroSchema.isError(),
+                        originalAvroSchema.getFields().
+                                stream()
+                                .filter(f -> !f.name().equals(FIELD_TO_REMOVE))
+                                .map(f -> new org.apache.avro.Schema.Field(
+                                        f.name(), f.schema(), f.doc(), f.defaultVal(), f.order()))
+                                .collect(Collectors.toList()));
+
+                org.apache.avro.generic.GenericRecord genericRecord =
+                        (org.apache.avro.generic.GenericRecord) nativeObject;
+                org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
+                for (org.apache.avro.Schema.Field field : modified.getFields()) {
+                    newRecord.put(field.name(), genericRecord.get(field.name()));
+                }
+                GenericDatumWriter writer = new GenericDatumWriter(modified);
+                ByteArrayOutputStream oo = new ByteArrayOutputStream();
+                BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
+                writer.write(newRecord, encoder);
+
+                Schema newValueSchema = Schema.NATIVE_AVRO(modified);
+                outputSchema = newValueSchema;
+                outputObject = oo.toByteArray();
+                someThingDone = true;
+            }
+        }
+
+        if (!someThingDone) {
+            // do some processing...
+            final boolean isStruct;
+            switch (currentRecord.getSchema().getSchemaInfo().getType()) {
+                case AVRO:
+                case JSON:
+                case PROTOBUF_NATIVE:
+                    isStruct = true;
+                    break;
+                default:
+                    isStruct = false;
+                    break;
+            }
+            if (isStruct) {
+                // GenericRecord must stay wrapped
+                outputObject = currentRecord.getValue();
+            } else {
+                // primitives and KeyValue must be unwrapped
+                outputObject = nativeObject;
+            }
+        }
+        log.info("output {} schema {}", outputObject, outputSchema);
+        context.newOutputMessage(context.getOutputTopic(), outputSchema)
+                .value(outputObject).send();
+        return null;
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldRecordFunction.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldRecordFunction.java
index bf8afe2846..e577856f45 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldRecordFunction.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/RemoveAvroFieldRecordFunction.java
@@ -1,163 +1,163 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import java.io.ByteArrayOutputStream;
-import java.util.stream.Collectors;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.avro.generic.GenericData;
-import org.apache.avro.generic.GenericDatumWriter;
-import org.apache.avro.io.BinaryEncoder;
-import org.apache.avro.io.EncoderFactory;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.GenericObject;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.client.api.schema.KeyValueSchema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.SchemaType;
-import org.apache.pulsar.functions.api.Context;
-import org.apache.pulsar.functions.api.Function;
-import org.apache.pulsar.functions.api.Record;
-
-/**
- * This function removes a "field" from a AVRO message.
- */
-@Slf4j
-public class RemoveAvroFieldRecordFunction implements Function<GenericObject, Record<GenericObject>> {
-
-    private static final String FIELD_TO_REMOVE = "age";
-
-    @Override
-    public Record<GenericObject> process(GenericObject genericObject, Context context) throws Exception {
-        Record<?> currentRecord = context.getCurrentRecord();
-        log.info("apply to {} {}", genericObject, genericObject.getNativeObject());
-        log.info("record with schema {} version {} {}", currentRecord.getSchema(),
-            currentRecord.getMessage().get().getSchemaVersion(),
-            currentRecord);
-        Object nativeObject = genericObject.getNativeObject();
-        Schema<?> schema = currentRecord.getSchema();
-
-        Schema outputSchema = schema;
-        Object outputObject = genericObject.getNativeObject();
-        boolean someThingDone = false;
-        if (schema instanceof KeyValueSchema && nativeObject instanceof KeyValue) {
-            KeyValueSchema kvSchema = (KeyValueSchema) schema;
-
-            Schema keySchema = kvSchema.getKeySchema();
-            Schema valueSchema = kvSchema.getValueSchema();
-            // remove a column "age" from the "valueSchema"
-            if (valueSchema.getSchemaInfo().getType() == SchemaType.AVRO) {
-
-                org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) valueSchema.getNativeSchema().get();
-                if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
-                    org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
-                    org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
-                    org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
-                        originalAvroSchema.getName(), originalAvroSchema.getDoc(), originalAvroSchema.getNamespace(),
-                        originalAvroSchema.isError(),
-                        originalAvroSchema.getFields().
-                            stream()
-                            .filter(f -> !f.name().equals(FIELD_TO_REMOVE))
-                            .map(f -> new org.apache.avro.Schema.Field(f.name(), f.schema(), f.doc(), f.defaultVal(),
-                                f.order()))
-                            .collect(Collectors.toList()));
-
-                    KeyValue originalObject = (KeyValue) nativeObject;
-
-                    GenericRecord value = (GenericRecord) originalObject.getValue();
-                    org.apache.avro.generic.GenericRecord genericRecord =
-                        (org.apache.avro.generic.GenericRecord) value.getNativeObject();
-
-                    org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
-                    for (org.apache.avro.Schema.Field field : modified.getFields()) {
-                        newRecord.put(field.name(), genericRecord.get(field.name()));
-                    }
-                    GenericDatumWriter writer = new GenericDatumWriter(modified);
-                    ByteArrayOutputStream oo = new ByteArrayOutputStream();
-                    BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
-                    writer.write(newRecord, encoder);
-                    Object newValue = oo.toByteArray();
-
-                    Schema newValueSchema = Schema.NATIVE_AVRO(modified);
-                    outputSchema = Schema.KeyValue(keySchema, newValueSchema, kvSchema.getKeyValueEncodingType());
-                    outputObject = new KeyValue(originalObject.getKey(), newValue);
-                    someThingDone = true;
-                }
-            }
-        } else if (schema.getSchemaInfo().getType() == SchemaType.AVRO) {
-            org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) schema.getNativeSchema().get();
-            if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
-                org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
-                org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
-                org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
-                    originalAvroSchema.getName(), originalAvroSchema.getDoc(), originalAvroSchema.getNamespace(),
-                    originalAvroSchema.isError(),
-                    originalAvroSchema.getFields().
-                        stream()
-                        .filter(f -> !f.name().equals(FIELD_TO_REMOVE))
-                        .map(f -> new org.apache.avro.Schema.Field(f.name(), f.schema(), f.doc(), f.defaultVal(),
-                            f.order()))
-                        .collect(Collectors.toList()));
-
-                org.apache.avro.generic.GenericRecord genericRecord =
-                    (org.apache.avro.generic.GenericRecord) nativeObject;
-                org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
-                for (org.apache.avro.Schema.Field field : modified.getFields()) {
-                    newRecord.put(field.name(), genericRecord.get(field.name()));
-                }
-                GenericDatumWriter writer = new GenericDatumWriter(modified);
-                ByteArrayOutputStream oo = new ByteArrayOutputStream();
-                BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
-                writer.write(newRecord, encoder);
-
-                Schema newValueSchema = Schema.NATIVE_AVRO(modified);
-                outputSchema = newValueSchema;
-                outputObject = oo.toByteArray();
-                someThingDone = true;
-            }
-        }
-
-        if (!someThingDone) {
-            // do some processing...
-            final boolean isStruct;
-            switch (currentRecord.getSchema().getSchemaInfo().getType()) {
-                case AVRO:
-                case JSON:
-                case PROTOBUF_NATIVE:
-                    isStruct = true;
-                    break;
-                default:
-                    isStruct = false;
-                    break;
-            }
-            if (isStruct) {
-                // GenericRecord must stay wrapped
-                outputObject = currentRecord.getValue();
-            } else {
-                // primitives and KeyValue must be unwrapped
-                outputObject = nativeObject;
-            }
-        }
-        log.info("output {} schema {}", outputObject, outputSchema);
-
-        return context.newOutputRecordBuilder(outputSchema)
-            .value(outputObject)
-            .build();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import java.io.ByteArrayOutputStream;
+import java.util.stream.Collectors;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.avro.generic.GenericData;
+import org.apache.avro.generic.GenericDatumWriter;
+import org.apache.avro.io.BinaryEncoder;
+import org.apache.avro.io.EncoderFactory;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.GenericObject;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.client.api.schema.KeyValueSchema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.SchemaType;
+import org.apache.pulsar.functions.api.Context;
+import org.apache.pulsar.functions.api.Function;
+import org.apache.pulsar.functions.api.Record;
+
+/**
+ * This function removes a "field" from a AVRO message.
+ */
+@Slf4j
+public class RemoveAvroFieldRecordFunction implements Function<GenericObject, Record<GenericObject>> {
+
+    private static final String FIELD_TO_REMOVE = "age";
+
+    @Override
+    public Record<GenericObject> process(GenericObject genericObject, Context context) throws Exception {
+        Record<?> currentRecord = context.getCurrentRecord();
+        log.info("apply to {} {}", genericObject, genericObject.getNativeObject());
+        log.info("record with schema {} version {} {}", currentRecord.getSchema(),
+            currentRecord.getMessage().get().getSchemaVersion(),
+            currentRecord);
+        Object nativeObject = genericObject.getNativeObject();
+        Schema<?> schema = currentRecord.getSchema();
+
+        Schema outputSchema = schema;
+        Object outputObject = genericObject.getNativeObject();
+        boolean someThingDone = false;
+        if (schema instanceof KeyValueSchema && nativeObject instanceof KeyValue) {
+            KeyValueSchema kvSchema = (KeyValueSchema) schema;
+
+            Schema keySchema = kvSchema.getKeySchema();
+            Schema valueSchema = kvSchema.getValueSchema();
+            // remove a column "age" from the "valueSchema"
+            if (valueSchema.getSchemaInfo().getType() == SchemaType.AVRO) {
+
+                org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) valueSchema.getNativeSchema().get();
+                if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
+                    org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
+                    org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
+                    org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
+                        originalAvroSchema.getName(), originalAvroSchema.getDoc(), originalAvroSchema.getNamespace(),
+                        originalAvroSchema.isError(),
+                        originalAvroSchema.getFields().
+                            stream()
+                            .filter(f -> !f.name().equals(FIELD_TO_REMOVE))
+                            .map(f -> new org.apache.avro.Schema.Field(f.name(), f.schema(), f.doc(), f.defaultVal(),
+                                f.order()))
+                            .collect(Collectors.toList()));
+
+                    KeyValue originalObject = (KeyValue) nativeObject;
+
+                    GenericRecord value = (GenericRecord) originalObject.getValue();
+                    org.apache.avro.generic.GenericRecord genericRecord =
+                        (org.apache.avro.generic.GenericRecord) value.getNativeObject();
+
+                    org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
+                    for (org.apache.avro.Schema.Field field : modified.getFields()) {
+                        newRecord.put(field.name(), genericRecord.get(field.name()));
+                    }
+                    GenericDatumWriter writer = new GenericDatumWriter(modified);
+                    ByteArrayOutputStream oo = new ByteArrayOutputStream();
+                    BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
+                    writer.write(newRecord, encoder);
+                    Object newValue = oo.toByteArray();
+
+                    Schema newValueSchema = Schema.NATIVE_AVRO(modified);
+                    outputSchema = Schema.KeyValue(keySchema, newValueSchema, kvSchema.getKeyValueEncodingType());
+                    outputObject = new KeyValue(originalObject.getKey(), newValue);
+                    someThingDone = true;
+                }
+            }
+        } else if (schema.getSchemaInfo().getType() == SchemaType.AVRO) {
+            org.apache.avro.Schema avroSchema = (org.apache.avro.Schema) schema.getNativeSchema().get();
+            if (avroSchema.getField(FIELD_TO_REMOVE) != null) {
+                org.apache.avro.Schema.Parser parser = new org.apache.avro.Schema.Parser();
+                org.apache.avro.Schema originalAvroSchema = parser.parse(avroSchema.toString(false));
+                org.apache.avro.Schema modified = org.apache.avro.Schema.createRecord(
+                    originalAvroSchema.getName(), originalAvroSchema.getDoc(), originalAvroSchema.getNamespace(),
+                    originalAvroSchema.isError(),
+                    originalAvroSchema.getFields().
+                        stream()
+                        .filter(f -> !f.name().equals(FIELD_TO_REMOVE))
+                        .map(f -> new org.apache.avro.Schema.Field(f.name(), f.schema(), f.doc(), f.defaultVal(),
+                            f.order()))
+                        .collect(Collectors.toList()));
+
+                org.apache.avro.generic.GenericRecord genericRecord =
+                    (org.apache.avro.generic.GenericRecord) nativeObject;
+                org.apache.avro.generic.GenericRecord newRecord = new GenericData.Record(modified);
+                for (org.apache.avro.Schema.Field field : modified.getFields()) {
+                    newRecord.put(field.name(), genericRecord.get(field.name()));
+                }
+                GenericDatumWriter writer = new GenericDatumWriter(modified);
+                ByteArrayOutputStream oo = new ByteArrayOutputStream();
+                BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(oo, null);
+                writer.write(newRecord, encoder);
+
+                Schema newValueSchema = Schema.NATIVE_AVRO(modified);
+                outputSchema = newValueSchema;
+                outputObject = oo.toByteArray();
+                someThingDone = true;
+            }
+        }
+
+        if (!someThingDone) {
+            // do some processing...
+            final boolean isStruct;
+            switch (currentRecord.getSchema().getSchemaInfo().getType()) {
+                case AVRO:
+                case JSON:
+                case PROTOBUF_NATIVE:
+                    isStruct = true;
+                    break;
+                default:
+                    isStruct = false;
+                    break;
+            }
+            if (isStruct) {
+                // GenericRecord must stay wrapped
+                outputObject = currentRecord.getValue();
+            } else {
+                // primitives and KeyValue must be unwrapped
+                outputObject = nativeObject;
+            }
+        }
+        log.info("output {} schema {}", outputObject, outputSchema);
+
+        return context.newOutputRecordBuilder(outputSchema)
+            .value(outputObject)
+            .build();
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/package-info.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/package-info.java
index 49427d1ddd..efe94d7602 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/package-info.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/functions/package-info.java
@@ -1,19 +1,19 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/GenericRecordSource.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/GenericRecordSource.java
index de17a17a8c..bd9b79fe63 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/GenericRecordSource.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/GenericRecordSource.java
@@ -1,88 +1,88 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.Field;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.client.api.schema.GenericSchema;
-import org.apache.pulsar.client.api.schema.RecordSchemaBuilder;
-import org.apache.pulsar.client.api.schema.SchemaBuilder;
-import org.apache.pulsar.common.schema.SchemaType;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Source;
-import org.apache.pulsar.io.core.SourceContext;
-
-/**
- * A source that generates {@link GenericRecord}s.
- */
-@Slf4j
-public class GenericRecordSource implements Source<GenericRecord> {
-
-    private RecordSchemaBuilder recordSchemaBuilder;
-    private GenericSchema<GenericRecord> schema;
-    private List<Field> fields;
-    private AtomicInteger count = new AtomicInteger();
-
-    @Override
-    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
-        this.recordSchemaBuilder = SchemaBuilder.record("MyBean");
-        this.recordSchemaBuilder.field("number").type(SchemaType.INT32);
-        this.recordSchemaBuilder.field("text").type(SchemaType.STRING);
-        schema = Schema.generic(this.recordSchemaBuilder.build(SchemaType.AVRO));
-        fields = Arrays.asList(new Field("number", 0),
-            new Field("text", 1));
-        log.info("created source, schema {}", new String(schema.getSchemaInfo().getSchema(), StandardCharsets.UTF_8));
-    }
-
-    @Override
-    public Record<GenericRecord> read() throws Exception {
-        // slow down the production of values
-        Thread.sleep(20);
-
-        int value = count.incrementAndGet();
-        GenericRecord record = schema.newRecordBuilder()
-            .set("number", value)
-            .set("text", "value-" + value)
-            .build();
-        log.info("produced {}", record);
-        return new Record<GenericRecord>() {
-            @Override
-            public GenericRecord getValue() {
-                return record;
-            }
-
-            @Override
-            public Schema<GenericRecord> getSchema() {
-                return schema;
-            }
-        };
-    }
-
-    @Override
-    public void close() {
-        // no-op
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.Field;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.client.api.schema.GenericSchema;
+import org.apache.pulsar.client.api.schema.RecordSchemaBuilder;
+import org.apache.pulsar.client.api.schema.SchemaBuilder;
+import org.apache.pulsar.common.schema.SchemaType;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Source;
+import org.apache.pulsar.io.core.SourceContext;
+
+/**
+ * A source that generates {@link GenericRecord}s.
+ */
+@Slf4j
+public class GenericRecordSource implements Source<GenericRecord> {
+
+    private RecordSchemaBuilder recordSchemaBuilder;
+    private GenericSchema<GenericRecord> schema;
+    private List<Field> fields;
+    private AtomicInteger count = new AtomicInteger();
+
+    @Override
+    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
+        this.recordSchemaBuilder = SchemaBuilder.record("MyBean");
+        this.recordSchemaBuilder.field("number").type(SchemaType.INT32);
+        this.recordSchemaBuilder.field("text").type(SchemaType.STRING);
+        schema = Schema.generic(this.recordSchemaBuilder.build(SchemaType.AVRO));
+        fields = Arrays.asList(new Field("number", 0),
+            new Field("text", 1));
+        log.info("created source, schema {}", new String(schema.getSchemaInfo().getSchema(), StandardCharsets.UTF_8));
+    }
+
+    @Override
+    public Record<GenericRecord> read() throws Exception {
+        // slow down the production of values
+        Thread.sleep(20);
+
+        int value = count.incrementAndGet();
+        GenericRecord record = schema.newRecordBuilder()
+            .set("number", value)
+            .set("text", "value-" + value)
+            .build();
+        log.info("produced {}", record);
+        return new Record<GenericRecord>() {
+            @Override
+            public GenericRecord getValue() {
+                return record;
+            }
+
+            @Override
+            public Schema<GenericRecord> getSchema() {
+                return schema;
+            }
+        };
+    }
+
+    @Override
+    public void close() {
+        // no-op
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestByteStateSource.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestByteStateSource.java
index dc8de9256a..5cbfab0f9e 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestByteStateSource.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestByteStateSource.java
@@ -1,55 +1,55 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import java.nio.ByteBuffer;
-import java.util.Base64;
-import java.util.Map;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Source;
-import org.apache.pulsar.io.core.SourceContext;
-
-public class TestByteStateSource implements Source<byte[]> {
-
-    private SourceContext sourceContext;
-
-    public static final String VALUE_BASE64 = "0a8001127e0a172e6576656e74732e437573746f6d65724372656174656412630a243"
-                                              + "2336366666263652d623038342d346631352d616565342d326330643135356131666"
-                                              + "36312026e311a3700000000000000000000000000000000000000000000000000000"
-                                              + "000000000000000000000000000000000000000000000000000000000";
-
-    @Override
-    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
-        sourceContext.putState("initial", ByteBuffer.wrap(Base64.getDecoder().decode(VALUE_BASE64)));
-        this.sourceContext = sourceContext;
-    }
-
-    @Override
-    public Record<byte[]> read() throws Exception {
-        Thread.sleep(50);
-        ByteBuffer initial = sourceContext.getState("initial");
-        sourceContext.putState("now", initial);
-        return initial::array;
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import java.nio.ByteBuffer;
+import java.util.Base64;
+import java.util.Map;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Source;
+import org.apache.pulsar.io.core.SourceContext;
+
+public class TestByteStateSource implements Source<byte[]> {
+
+    private SourceContext sourceContext;
+
+    public static final String VALUE_BASE64 = "0a8001127e0a172e6576656e74732e437573746f6d65724372656174656412630a243"
+                                              + "2336366666263652d623038342d346631352d616565342d326330643135356131666"
+                                              + "36312026e311a3700000000000000000000000000000000000000000000000000000"
+                                              + "000000000000000000000000000000000000000000000000000000000";
+
+    @Override
+    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
+        sourceContext.putState("initial", ByteBuffer.wrap(Base64.getDecoder().decode(VALUE_BASE64)));
+        this.sourceContext = sourceContext;
+    }
+
+    @Override
+    public Record<byte[]> read() throws Exception {
+        Thread.sleep(50);
+        ByteBuffer initial = sourceContext.getState("initial");
+        sourceContext.putState("now", initial);
+        return initial::array;
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
 }
\ No newline at end of file
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestGenericObjectSink.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestGenericObjectSink.java
index fa25846d72..5359c3ecce 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestGenericObjectSink.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestGenericObjectSink.java
@@ -1,118 +1,118 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import com.fasterxml.jackson.databind.JsonNode;
-import com.google.protobuf.DynamicMessage;
-import java.util.Map;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.avro.generic.GenericRecord;
-import org.apache.pulsar.client.api.schema.GenericObject;
-import org.apache.pulsar.client.api.schema.KeyValueSchema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.SchemaType;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Sink;
-import org.apache.pulsar.io.core.SinkContext;
-
-@Slf4j
-public class TestGenericObjectSink implements Sink<GenericObject> {
-
-    @Override
-    public void open(Map<String, Object> config, SinkContext sourceContext) throws Exception {
-    }
-
-    public void write(Record<GenericObject> record) {
-        log.info("topic {}", record.getTopicName().orElse(null));
-        log.info("properties {}", record.getProperties());
-        log.info("received record {} {}", record, record.getClass());
-        log.info("schema {}", record.getSchema());
-        log.info("native schema {}", record.getSchema().getNativeSchema().orElse(null));
-        log.info("schemaInfo {}", record.getSchema().getSchemaInfo());
-        log.info("schemaInfo.type {}", record.getSchema().getSchemaInfo().getType());
-
-        String expectedRecordType = record.getProperties().getOrDefault("expectedType", "MISSING");
-        log.info("expectedRecordType {}", expectedRecordType);
-        if (!expectedRecordType.equals(record.getSchema().getSchemaInfo().getType().name())) {
-            final String message = String.format(
-                    "Unexpected record type %s is not %s",
-                    record.getSchema().getSchemaInfo().getType().name(),
-                    expectedRecordType);
-            throw new RuntimeException(message);
-        }
-
-        log.info("value {}", record.getValue());
-        log.info("value schema type {}", record.getValue().getSchemaType());
-        log.info("value native object {}", record.getValue().getNativeObject());
-
-        if (record.getSchema().getSchemaInfo().getType() == SchemaType.KEY_VALUE) {
-            // assert that we are able to access the schema (leads to ClassCastException if there is a problem)
-            KeyValueSchema kvSchema = (KeyValueSchema) record.getSchema();
-            log.info("key schema type {}", kvSchema.getKeySchema());
-            log.info("value schema type {}", kvSchema.getValueSchema());
-            log.info("key encoding {}", kvSchema.getKeyValueEncodingType());
-
-            KeyValue keyValue = (KeyValue) record.getValue().getNativeObject();
-            log.info("kvkey {}", keyValue.getKey());
-            log.info("kvvalue {}", keyValue.getValue());
-        }
-
-        final GenericObject value = record.getValue();
-        log.info("value {}", value);
-        log.info("value schema type {}", value.getSchemaType());
-        log.info("value native object {} class {}", value.getNativeObject(), value.getNativeObject().getClass());
-
-        String expectedSchemaDefinition = record.getProperties().getOrDefault("expectedSchemaDefinition", "");
-        log.info("schemaDefinition {}", record.getSchema().getSchemaInfo().getSchemaDefinition());
-        log.info("expectedSchemaDefinition {}", expectedSchemaDefinition);
-        if (!expectedSchemaDefinition.isEmpty()) {
-            String schemaDefinition = record.getSchema().getSchemaInfo().getSchemaDefinition();
-            if (!expectedSchemaDefinition.equals(schemaDefinition)) {
-                final String message = String.format(
-                        "Unexpected schema definition %s is not %s", schemaDefinition, expectedSchemaDefinition);
-                throw new RuntimeException(message);
-            }
-        }
-
-        // testing that actually the Sink is able to use Native AVRO
-        if (record.getSchema().getSchemaInfo().getType() == SchemaType.AVRO) {
-            GenericRecord nativeGenericRecord = (GenericRecord) record.getValue().getNativeObject();
-            log.info("Schema from AVRO generic object {}", nativeGenericRecord.getSchema());
-        }
-
-        // testing that actually the Sink is able to use Native JSON
-        if (record.getSchema().getSchemaInfo().getType() == SchemaType.JSON) {
-            JsonNode nativeGenericRecord = (JsonNode) record.getValue().getNativeObject();
-            log.info("NodeType from JsonNode generic object {}", nativeGenericRecord.getNodeType());
-        }
-
-        // testing that actually the Sink is able to use Native JSON
-        if (record.getSchema().getSchemaInfo().getType() == SchemaType.PROTOBUF_NATIVE) {
-            DynamicMessage dynamicMessage = (DynamicMessage) record.getValue().getNativeObject();
-            log.info("Schema from PROTOBUF_NATIVE generic object {}", dynamicMessage.getAllFields());
-        }
-
-        record.ack();
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.google.protobuf.DynamicMessage;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.avro.generic.GenericRecord;
+import org.apache.pulsar.client.api.schema.GenericObject;
+import org.apache.pulsar.client.api.schema.KeyValueSchema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.SchemaType;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Sink;
+import org.apache.pulsar.io.core.SinkContext;
+
+@Slf4j
+public class TestGenericObjectSink implements Sink<GenericObject> {
+
+    @Override
+    public void open(Map<String, Object> config, SinkContext sourceContext) throws Exception {
+    }
+
+    public void write(Record<GenericObject> record) {
+        log.info("topic {}", record.getTopicName().orElse(null));
+        log.info("properties {}", record.getProperties());
+        log.info("received record {} {}", record, record.getClass());
+        log.info("schema {}", record.getSchema());
+        log.info("native schema {}", record.getSchema().getNativeSchema().orElse(null));
+        log.info("schemaInfo {}", record.getSchema().getSchemaInfo());
+        log.info("schemaInfo.type {}", record.getSchema().getSchemaInfo().getType());
+
+        String expectedRecordType = record.getProperties().getOrDefault("expectedType", "MISSING");
+        log.info("expectedRecordType {}", expectedRecordType);
+        if (!expectedRecordType.equals(record.getSchema().getSchemaInfo().getType().name())) {
+            final String message = String.format(
+                    "Unexpected record type %s is not %s",
+                    record.getSchema().getSchemaInfo().getType().name(),
+                    expectedRecordType);
+            throw new RuntimeException(message);
+        }
+
+        log.info("value {}", record.getValue());
+        log.info("value schema type {}", record.getValue().getSchemaType());
+        log.info("value native object {}", record.getValue().getNativeObject());
+
+        if (record.getSchema().getSchemaInfo().getType() == SchemaType.KEY_VALUE) {
+            // assert that we are able to access the schema (leads to ClassCastException if there is a problem)
+            KeyValueSchema kvSchema = (KeyValueSchema) record.getSchema();
+            log.info("key schema type {}", kvSchema.getKeySchema());
+            log.info("value schema type {}", kvSchema.getValueSchema());
+            log.info("key encoding {}", kvSchema.getKeyValueEncodingType());
+
+            KeyValue keyValue = (KeyValue) record.getValue().getNativeObject();
+            log.info("kvkey {}", keyValue.getKey());
+            log.info("kvvalue {}", keyValue.getValue());
+        }
+
+        final GenericObject value = record.getValue();
+        log.info("value {}", value);
+        log.info("value schema type {}", value.getSchemaType());
+        log.info("value native object {} class {}", value.getNativeObject(), value.getNativeObject().getClass());
+
+        String expectedSchemaDefinition = record.getProperties().getOrDefault("expectedSchemaDefinition", "");
+        log.info("schemaDefinition {}", record.getSchema().getSchemaInfo().getSchemaDefinition());
+        log.info("expectedSchemaDefinition {}", expectedSchemaDefinition);
+        if (!expectedSchemaDefinition.isEmpty()) {
+            String schemaDefinition = record.getSchema().getSchemaInfo().getSchemaDefinition();
+            if (!expectedSchemaDefinition.equals(schemaDefinition)) {
+                final String message = String.format(
+                        "Unexpected schema definition %s is not %s", schemaDefinition, expectedSchemaDefinition);
+                throw new RuntimeException(message);
+            }
+        }
+
+        // testing that actually the Sink is able to use Native AVRO
+        if (record.getSchema().getSchemaInfo().getType() == SchemaType.AVRO) {
+            GenericRecord nativeGenericRecord = (GenericRecord) record.getValue().getNativeObject();
+            log.info("Schema from AVRO generic object {}", nativeGenericRecord.getSchema());
+        }
+
+        // testing that actually the Sink is able to use Native JSON
+        if (record.getSchema().getSchemaInfo().getType() == SchemaType.JSON) {
+            JsonNode nativeGenericRecord = (JsonNode) record.getValue().getNativeObject();
+            log.info("NodeType from JsonNode generic object {}", nativeGenericRecord.getNodeType());
+        }
+
+        // testing that actually the Sink is able to use Native JSON
+        if (record.getSchema().getSchemaInfo().getType() == SchemaType.PROTOBUF_NATIVE) {
+            DynamicMessage dynamicMessage = (DynamicMessage) record.getValue().getNativeObject();
+            log.info("Schema from PROTOBUF_NATIVE generic object {}", dynamicMessage.getAllFields());
+        }
+
+        record.ack();
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestLoggingSink.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestLoggingSink.java
index f5cbd109bf..1e03a583f5 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestLoggingSink.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestLoggingSink.java
@@ -1,74 +1,74 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import java.util.Map;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.GenericObject;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Sink;
-import org.apache.pulsar.io.core.SinkContext;
-import org.slf4j.Logger;
-
-public class TestLoggingSink implements Sink<GenericObject> {
-
-    private Logger logger;
-    private Producer<String> producer;
-
-    @Override
-    public void open(Map<String, Object> config, SinkContext sinkContext) throws Exception {
-        logger = sinkContext.getLogger();
-        String topic = (String) config.getOrDefault("log-topic", "log-topic");
-        producer = sinkContext.getPulsarClient().newProducer(Schema.STRING)
-                .topic(topic)
-                .create();
-    }
-
-    @Override
-    public void write(Record<GenericObject> record) throws Exception {
-        Object nativeObject = record.getValue().getNativeObject();
-        logger.info("Got message: " + nativeObject + " with schema" + record.getSchema());
-        String payload = nativeObject.toString();
-        if (nativeObject instanceof KeyValue) {
-            KeyValue kv = (KeyValue) nativeObject;
-            String key = kv.getKey().toString();
-            String value = kv.getValue().toString();
-
-            if (kv.getKey() instanceof GenericObject) {
-                key = ((GenericObject) kv.getKey()).getNativeObject().toString();
-            }
-            if (kv.getValue() instanceof GenericObject) {
-                value = ((GenericObject) kv.getValue()).getNativeObject().toString();
-            }
-            payload = "(key = " + key + ", value = " + value + ")";
-        }
-        producer.newMessage()
-            .properties(record.getProperties())
-            .value(record.getSchema().getSchemaInfo().getType().name() + " - " + payload)
-            .send();
-        record.ack();
-    }
-
-    @Override
-    public void close() {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import java.util.Map;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.GenericObject;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Sink;
+import org.apache.pulsar.io.core.SinkContext;
+import org.slf4j.Logger;
+
+public class TestLoggingSink implements Sink<GenericObject> {
+
+    private Logger logger;
+    private Producer<String> producer;
+
+    @Override
+    public void open(Map<String, Object> config, SinkContext sinkContext) throws Exception {
+        logger = sinkContext.getLogger();
+        String topic = (String) config.getOrDefault("log-topic", "log-topic");
+        producer = sinkContext.getPulsarClient().newProducer(Schema.STRING)
+                .topic(topic)
+                .create();
+    }
+
+    @Override
+    public void write(Record<GenericObject> record) throws Exception {
+        Object nativeObject = record.getValue().getNativeObject();
+        logger.info("Got message: " + nativeObject + " with schema" + record.getSchema());
+        String payload = nativeObject.toString();
+        if (nativeObject instanceof KeyValue) {
+            KeyValue kv = (KeyValue) nativeObject;
+            String key = kv.getKey().toString();
+            String value = kv.getValue().toString();
+
+            if (kv.getKey() instanceof GenericObject) {
+                key = ((GenericObject) kv.getKey()).getNativeObject().toString();
+            }
+            if (kv.getValue() instanceof GenericObject) {
+                value = ((GenericObject) kv.getValue()).getNativeObject().toString();
+            }
+            payload = "(key = " + key + ", value = " + value + ")";
+        }
+        producer.newMessage()
+            .properties(record.getProperties())
+            .value(record.getSchema().getSchemaInfo().getType().name() + " - " + payload)
+            .send();
+        record.ack();
+    }
+
+    @Override
+    public void close() {
+
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestPropertySource.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestPropertySource.java
index 0b4577c44f..fd346d6fe2 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestPropertySource.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestPropertySource.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import java.util.HashMap;
-import java.util.Map;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Source;
-import org.apache.pulsar.io.core.SourceContext;
-
-public class TestPropertySource implements Source<String> {
-
-    @Override
-    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
-    }
-
-    @Override
-    public Record<String> read() throws Exception {
-        Thread.sleep(50);
-        return new Record<String>() {
-
-            @Override
-            public String getValue() {
-                return "property";
-            }
-            @Override
-            public Map<String, String> getProperties() {
-                HashMap<String, String> props = new HashMap<String, String>();
-                props.put("hello", "world");
-                props.put("foo", "bar");
-                return props;
-            }
-        };
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Source;
+import org.apache.pulsar.io.core.SourceContext;
+
+public class TestPropertySource implements Source<String> {
+
+    @Override
+    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
+    }
+
+    @Override
+    public Record<String> read() throws Exception {
+        Thread.sleep(50);
+        return new Record<String>() {
+
+            @Override
+            public String getValue() {
+                return "property";
+            }
+            @Override
+            public Map<String, String> getProperties() {
+                HashMap<String, String> props = new HashMap<String, String>();
+                props.put("hello", "world");
+                props.put("foo", "bar");
+                return props;
+            }
+        };
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSink.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSink.java
index ce5e86c7cd..f58661d7b4 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSink.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSink.java
@@ -1,50 +1,50 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import java.nio.ByteBuffer;
-import java.util.Map;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Sink;
-import org.apache.pulsar.io.core.SinkContext;
-
-public class TestStateSink implements Sink<String> {
-
-    private SinkContext sinkContext;
-    private int count;
-
-    @Override
-    public void open(Map<String, Object> config, SinkContext sinkContext) throws Exception {
-        sinkContext.putState("initial", ByteBuffer.wrap("val1".getBytes()));
-        this.sinkContext = sinkContext;
-    }
-
-    @Override
-    public void write(Record<String> record) throws Exception {
-        String initial = new String(sinkContext.getState("initial").array());
-        String val = String.format("%s-%d", initial, count);
-        sinkContext.putState("now", ByteBuffer.wrap(val.getBytes()));
-        count++;
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Sink;
+import org.apache.pulsar.io.core.SinkContext;
+
+public class TestStateSink implements Sink<String> {
+
+    private SinkContext sinkContext;
+    private int count;
+
+    @Override
+    public void open(Map<String, Object> config, SinkContext sinkContext) throws Exception {
+        sinkContext.putState("initial", ByteBuffer.wrap("val1".getBytes()));
+        this.sinkContext = sinkContext;
+    }
+
+    @Override
+    public void write(Record<String> record) throws Exception {
+        String initial = new String(sinkContext.getState("initial").array());
+        String val = String.format("%s-%d", initial, count);
+        sinkContext.putState("now", ByteBuffer.wrap(val.getBytes()));
+        count++;
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
+}
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSource.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSource.java
index 0a718b80af..0b629c3962 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSource.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/TestStateSource.java
@@ -1,52 +1,52 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import java.nio.ByteBuffer;
-import java.util.Map;
-import org.apache.pulsar.functions.api.Record;
-import org.apache.pulsar.io.core.Source;
-import org.apache.pulsar.io.core.SourceContext;
-
-public class TestStateSource implements Source<String> {
-
-    private SourceContext sourceContext;
-    private int count;
-
-    @Override
-    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
-        sourceContext.putState("initial", ByteBuffer.wrap("val1".getBytes()));
-        this.sourceContext = sourceContext;
-    }
-
-    @Override
-    public Record<String> read() throws Exception {
-        Thread.sleep(50);
-        String initial = new String(sourceContext.getState("initial").array());
-        String val = String.format("%s-%d", initial, count);
-        sourceContext.putState("now", ByteBuffer.wrap(val.getBytes()));
-        count++;
-        return () -> val;
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import java.nio.ByteBuffer;
+import java.util.Map;
+import org.apache.pulsar.functions.api.Record;
+import org.apache.pulsar.io.core.Source;
+import org.apache.pulsar.io.core.SourceContext;
+
+public class TestStateSource implements Source<String> {
+
+    private SourceContext sourceContext;
+    private int count;
+
+    @Override
+    public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {
+        sourceContext.putState("initial", ByteBuffer.wrap("val1".getBytes()));
+        this.sourceContext = sourceContext;
+    }
+
+    @Override
+    public Record<String> read() throws Exception {
+        Thread.sleep(50);
+        String initial = new String(sourceContext.getState("initial").array());
+        String val = String.format("%s-%d", initial, count);
+        sourceContext.putState("now", ByteBuffer.wrap(val.getBytes()));
+        count++;
+        return () -> val;
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
 }
\ No newline at end of file
diff --git a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/package-info.java b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/package-info.java
index 1f9797a803..7935f56763 100644
--- a/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/package-info.java
+++ b/tests/docker-images/java-test-functions/src/main/java/org/apache/pulsar/tests/integration/io/package-info.java
@@ -1,19 +1,19 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
diff --git a/tests/docker-images/java-test-image/Dockerfile b/tests/docker-images/java-test-image/Dockerfile
index 9cf45130d0..1cc4d0aea4 100644
--- a/tests/docker-images/java-test-image/Dockerfile
+++ b/tests/docker-images/java-test-image/Dockerfile
@@ -1,44 +1,44 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-ARG PULSAR_IMAGE
-FROM $PULSAR_IMAGE
-
-# Base pulsar image is designed not be modified, though we need to add more scripts
-USER root
-
-COPY target/scripts /pulsar/bin
-RUN chmod a+rx /pulsar/bin/*
-
-RUN apk add --no-cache supervisor
-
-RUN mkdir -p /var/log/pulsar \
-    && mkdir -p /var/run/supervisor/ \
-    && mkdir -p /pulsar/certificate-authority
-
-COPY target/conf /etc/supervisord/conf.d/
-RUN mv /etc/supervisord/conf.d/supervisord.conf /etc/supervisord.conf
-
-# TLS certificates
-COPY target/certificate-authority /pulsar/certificate-authority/
-
-COPY target/java-test-functions.jar /pulsar/examples/
-
-# copy buildtools.jar to /pulsar/lib so that org.apache.pulsar.tests.ExtendedNettyLeakDetector can be used
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+ARG PULSAR_IMAGE
+FROM $PULSAR_IMAGE
+
+# Base pulsar image is designed not be modified, though we need to add more scripts
+USER root
+
+COPY target/scripts /pulsar/bin
+RUN chmod a+rx /pulsar/bin/*
+
+RUN apk add --no-cache supervisor
+
+RUN mkdir -p /var/log/pulsar \
+    && mkdir -p /var/run/supervisor/ \
+    && mkdir -p /pulsar/certificate-authority
+
+COPY target/conf /etc/supervisord/conf.d/
+RUN mv /etc/supervisord/conf.d/supervisord.conf /etc/supervisord.conf
+
+# TLS certificates
+COPY target/certificate-authority /pulsar/certificate-authority/
+
+COPY target/java-test-functions.jar /pulsar/examples/
+
+# copy buildtools.jar to /pulsar/lib so that org.apache.pulsar.tests.ExtendedNettyLeakDetector can be used
 COPY target/buildtools.jar /pulsar/lib/
\ No newline at end of file
diff --git a/tests/docker-images/java-test-image/pom.xml b/tests/docker-images/java-test-image/pom.xml
index 30dc0f7e20..2f1e5bb66f 100644
--- a/tests/docker-images/java-test-image/pom.xml
+++ b/tests/docker-images/java-test-image/pom.xml
@@ -1,178 +1,178 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.apache.pulsar.tests</groupId>
-    <artifactId>docker-images</artifactId>
-    <version>4.1.2</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>java-test-image</artifactId>
-  <name>Apache Pulsar :: Tests :: Docker Images :: Java Test Image</name>
-  <packaging>pom</packaging>
-
-  <profiles>
-    <profile>
-      <id>docker</id>
-      <activation>
-        <property>
-          <name>integrationTests</name>
-        </property>
-      </activation>
-      <dependencies>
-        <dependency>
-          <groupId>org.apache.pulsar.tests</groupId>
-          <artifactId>java-test-functions</artifactId>
-          <version>${project.parent.version}</version>
-        </dependency>
-        <dependency>
-          <groupId>org.apache.pulsar</groupId>
-          <artifactId>pulsar-server-distribution</artifactId>
-          <version>${project.parent.version}</version>
-          <classifier>bin</classifier>
-          <type>tar.gz</type>
-          <scope>provided</scope>
-          <exclusions>
-            <exclusion>
-              <groupId>*</groupId>
-              <artifactId>*</artifactId>
-            </exclusion>
-          </exclusions>
-        </dependency>
-      </dependencies>
-      <build>
-        <plugins>
-          <plugin>
-            <artifactId>maven-dependency-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>copy-installed</id>
-                <phase>package</phase>
-                <goals>
-                  <goal>copy</goal>
-                </goals>
-                <configuration>
-                  <artifactItems>
-                    <artifactItem>
-                      <groupId>org.apache.pulsar.tests</groupId>
-                      <artifactId>java-test-functions</artifactId>
-                      <version>${project.parent.version}</version>
-                      <type>jar</type>
-                      <overWrite>true</overWrite>
-                      <outputDirectory>${project.build.directory}</outputDirectory>
-                      <destFileName>java-test-functions.jar</destFileName>
-                    </artifactItem>
-                    <artifactItem>
-                      <groupId>org.apache.pulsar</groupId>
-                      <artifactId>pulsar-server-distribution</artifactId>
-                      <version>${project.parent.version}</version>
-                      <classifier>bin</classifier>
-                      <type>tar.gz</type>
-                      <overWrite>true</overWrite>
-                      <outputDirectory>${project.build.directory}</outputDirectory>
-                      <destFileName>pulsar-server-distribution-bin.tar.gz</destFileName>
-                    </artifactItem>
-                    <artifactItem>
-                      <groupId>org.apache.pulsar</groupId>
-                      <artifactId>buildtools</artifactId>
-                      <version>${project.parent.version}</version>
-                      <type>jar</type>
-                      <overWrite>true</overWrite>
-                      <outputDirectory>${project.build.directory}</outputDirectory>
-                      <destFileName>buildtools.jar</destFileName>
-                    </artifactItem>
-                  </artifactItems>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-          <plugin>
-            <artifactId>maven-resources-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>copy-files</id>
-                <phase>generate-resources</phase>
-                <goals>
-                  <goal>copy-resources</goal>
-                </goals>
-                <configuration>
-                  <outputDirectory>${project.build.directory}</outputDirectory>
-                  <overwrite>true</overwrite>
-                  <resources>
-                    <resource>
-                      <directory>${pulsar.basedir}/docker/pulsar/scripts</directory>
-                      <targetPath>scripts</targetPath>
-                      <filtering>false</filtering>
-                    </resource>
-                    <resource>
-                      <directory>${project.basedir}/../latest-version-image/scripts</directory>
-                      <targetPath>scripts</targetPath>
-                      <filtering>false</filtering>
-                    </resource>
-                    <resource>
-                      <directory>${project.basedir}/../../certificate-authority</directory>
-                      <targetPath>certificate-authority</targetPath>
-                      <filtering>false</filtering>
-                    </resource>
-                    <resource>
-                      <directory>${project.basedir}/../latest-version-image/conf</directory>
-                      <targetPath>conf</targetPath>
-                      <filtering>false</filtering>
-                    </resource>
-                  </resources>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-          <plugin>
-            <groupId>io.fabric8</groupId>
-            <artifactId>docker-maven-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>default</id>
-                <phase>package</phase>
-                <goals>
-                  <goal>build</goal>
-                  <goal>tag</goal>
-                </goals>
-                <configuration>
-                  <images>
-                    <image>
-                      <name>${docker.organization}/java-test-image:${docker.tag}</name>
-                      <build>
-                        <args>
-                          <PULSAR_IMAGE>${docker.organization}/${docker.image}:${project.version}-${git.commit.id.abbrev}</PULSAR_IMAGE>
-                        </args>
-                        <contextDir>${project.basedir}</contextDir>
-                        <noCache>true</noCache>
-                      </build>
-                    </image>
-                  </images>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <parent>
+    <groupId>org.apache.pulsar.tests</groupId>
+    <artifactId>docker-images</artifactId>
+    <version>4.1.2</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>java-test-image</artifactId>
+  <name>Apache Pulsar :: Tests :: Docker Images :: Java Test Image</name>
+  <packaging>pom</packaging>
+
+  <profiles>
+    <profile>
+      <id>docker</id>
+      <activation>
+        <property>
+          <name>integrationTests</name>
+        </property>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.apache.pulsar.tests</groupId>
+          <artifactId>java-test-functions</artifactId>
+          <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.pulsar</groupId>
+          <artifactId>pulsar-server-distribution</artifactId>
+          <version>${project.parent.version}</version>
+          <classifier>bin</classifier>
+          <type>tar.gz</type>
+          <scope>provided</scope>
+          <exclusions>
+            <exclusion>
+              <groupId>*</groupId>
+              <artifactId>*</artifactId>
+            </exclusion>
+          </exclusions>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-dependency-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>copy-installed</id>
+                <phase>package</phase>
+                <goals>
+                  <goal>copy</goal>
+                </goals>
+                <configuration>
+                  <artifactItems>
+                    <artifactItem>
+                      <groupId>org.apache.pulsar.tests</groupId>
+                      <artifactId>java-test-functions</artifactId>
+                      <version>${project.parent.version}</version>
+                      <type>jar</type>
+                      <overWrite>true</overWrite>
+                      <outputDirectory>${project.build.directory}</outputDirectory>
+                      <destFileName>java-test-functions.jar</destFileName>
+                    </artifactItem>
+                    <artifactItem>
+                      <groupId>org.apache.pulsar</groupId>
+                      <artifactId>pulsar-server-distribution</artifactId>
+                      <version>${project.parent.version}</version>
+                      <classifier>bin</classifier>
+                      <type>tar.gz</type>
+                      <overWrite>true</overWrite>
+                      <outputDirectory>${project.build.directory}</outputDirectory>
+                      <destFileName>pulsar-server-distribution-bin.tar.gz</destFileName>
+                    </artifactItem>
+                    <artifactItem>
+                      <groupId>org.apache.pulsar</groupId>
+                      <artifactId>buildtools</artifactId>
+                      <version>${project.parent.version}</version>
+                      <type>jar</type>
+                      <overWrite>true</overWrite>
+                      <outputDirectory>${project.build.directory}</outputDirectory>
+                      <destFileName>buildtools.jar</destFileName>
+                    </artifactItem>
+                  </artifactItems>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <artifactId>maven-resources-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>copy-files</id>
+                <phase>generate-resources</phase>
+                <goals>
+                  <goal>copy-resources</goal>
+                </goals>
+                <configuration>
+                  <outputDirectory>${project.build.directory}</outputDirectory>
+                  <overwrite>true</overwrite>
+                  <resources>
+                    <resource>
+                      <directory>${pulsar.basedir}/docker/pulsar/scripts</directory>
+                      <targetPath>scripts</targetPath>
+                      <filtering>false</filtering>
+                    </resource>
+                    <resource>
+                      <directory>${project.basedir}/../latest-version-image/scripts</directory>
+                      <targetPath>scripts</targetPath>
+                      <filtering>false</filtering>
+                    </resource>
+                    <resource>
+                      <directory>${project.basedir}/../../certificate-authority</directory>
+                      <targetPath>certificate-authority</targetPath>
+                      <filtering>false</filtering>
+                    </resource>
+                    <resource>
+                      <directory>${project.basedir}/../latest-version-image/conf</directory>
+                      <targetPath>conf</targetPath>
+                      <filtering>false</filtering>
+                    </resource>
+                  </resources>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <groupId>io.fabric8</groupId>
+            <artifactId>docker-maven-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>default</id>
+                <phase>package</phase>
+                <goals>
+                  <goal>build</goal>
+                  <goal>tag</goal>
+                </goals>
+                <configuration>
+                  <images>
+                    <image>
+                      <name>${docker.organization}/java-test-image:${docker.tag}</name>
+                      <build>
+                        <args>
+                          <PULSAR_IMAGE>${docker.organization}/${docker.image}:${project.version}-${git.commit.id.abbrev}</PULSAR_IMAGE>
+                        </args>
+                        <contextDir>${project.basedir}</contextDir>
+                        <noCache>true</noCache>
+                      </build>
+                    </image>
+                  </images>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/tests/docker-images/java-test-plugins/pom.xml b/tests/docker-images/java-test-plugins/pom.xml
index b5ef030c02..810b06f048 100644
--- a/tests/docker-images/java-test-plugins/pom.xml
+++ b/tests/docker-images/java-test-plugins/pom.xml
@@ -1,49 +1,49 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.apache.pulsar.tests</groupId>
-    <artifactId>docker-images</artifactId>
-    <version>4.1.2</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>java-test-plugins</artifactId>
-  <name>Apache Pulsar :: Tests :: Docker Images :: Java Test Plugins</name>
-  <packaging>jar</packaging>
-  <dependencies>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-broker</artifactId>
-      <version>${project.version}</version>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.nifi</groupId>
-        <artifactId>nifi-nar-maven-plugin</artifactId>
-      </plugin>
-    </plugins>
-  </build>
-
-</project>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <parent>
+    <groupId>org.apache.pulsar.tests</groupId>
+    <artifactId>docker-images</artifactId>
+    <version>4.1.2</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>java-test-plugins</artifactId>
+  <name>Apache Pulsar :: Tests :: Docker Images :: Java Test Plugins</name>
+  <packaging>jar</packaging>
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-broker</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.nifi</groupId>
+        <artifactId>nifi-nar-maven-plugin</artifactId>
+      </plugin>
+    </plugins>
+  </build>
+
+</project>
diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoChannelHandler.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoChannelHandler.java
index 05bf0c715a..48151dcc94 100644
--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoChannelHandler.java
+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoChannelHandler.java
@@ -1,37 +1,37 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-
-public class EchoChannelHandler extends ChannelInboundHandlerAdapter {
-
-    @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) {
-        ctx.write(msg).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
-    }
-
-    @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) {
-        ctx.flush();
-        ctx.close();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+
+public class EchoChannelHandler extends ChannelInboundHandlerAdapter {
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+        ctx.write(msg).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
+    }
+
+    @Override
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
+        ctx.close();
+    }
+}
diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoProtocolHandler.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoProtocolHandler.java
index dfb072a207..d18b611a8d 100644
--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoProtocolHandler.java
+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/EchoProtocolHandler.java
@@ -1,97 +1,97 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.socket.SocketChannel;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Objects;
-import org.apache.pulsar.broker.ServiceConfiguration;
-import org.apache.pulsar.broker.protocol.ProtocolHandler;
-import org.apache.pulsar.broker.service.BrokerService;
-
-
-public class EchoProtocolHandler implements ProtocolHandler {
-
-    private ServiceConfiguration conf;
-
-    private BrokerService brokerService;
-
-    @Override
-    public String protocolName() {
-        return "echo";
-    }
-
-    @Override
-    public boolean accept(String protocol) {
-        return protocolName().equals(protocol.toLowerCase());
-    }
-
-    @Override
-    public void initialize(ServiceConfiguration conf) {
-        this.conf = conf;
-    }
-
-    @Override
-    public String getProtocolDataToAdvertise() {
-        try {
-            return InetAddress.getLocalHost().getCanonicalHostName()
-                    + ":" + conf.getProperties().getProperty("echoServerPort");
-        } catch (UnknownHostException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    @Override
-    public void start(BrokerService service) {
-        Objects.requireNonNull(conf, "initialize(ServiceConfiguration) has not been called before start");
-        this.brokerService = service;
-    }
-
-    @Override
-    public Map<InetSocketAddress, ChannelInitializer<SocketChannel>> newChannelInitializers() {
-        // Although this protocol handler does not need the BrokerService instance,
-        // we should verify that `start` was called in the right order
-        Objects.requireNonNull(brokerService,
-                "start(BrokerService) has not been called before newChannelInitializers");
-        InetSocketAddress address = getEchoAddress();
-        ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<>() {
-            @Override
-            protected void initChannel(SocketChannel socketChannel) {
-                socketChannel.pipeline().addLast(new EchoChannelHandler());
-            }
-        };
-        return Collections.singletonMap(address, initializer);
-    }
-
-    private InetSocketAddress getEchoAddress() {
-        String hostAndPort = getProtocolDataToAdvertise();
-        String[] parsed = hostAndPort.split(":");
-        return new InetSocketAddress(parsed[0], Integer.parseInt(parsed[1]));
-    }
-
-    @Override
-    public void close() {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.socket.SocketChannel;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+import org.apache.pulsar.broker.ServiceConfiguration;
+import org.apache.pulsar.broker.protocol.ProtocolHandler;
+import org.apache.pulsar.broker.service.BrokerService;
+
+
+public class EchoProtocolHandler implements ProtocolHandler {
+
+    private ServiceConfiguration conf;
+
+    private BrokerService brokerService;
+
+    @Override
+    public String protocolName() {
+        return "echo";
+    }
+
+    @Override
+    public boolean accept(String protocol) {
+        return protocolName().equals(protocol.toLowerCase());
+    }
+
+    @Override
+    public void initialize(ServiceConfiguration conf) {
+        this.conf = conf;
+    }
+
+    @Override
+    public String getProtocolDataToAdvertise() {
+        try {
+            return InetAddress.getLocalHost().getCanonicalHostName()
+                    + ":" + conf.getProperties().getProperty("echoServerPort");
+        } catch (UnknownHostException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void start(BrokerService service) {
+        Objects.requireNonNull(conf, "initialize(ServiceConfiguration) has not been called before start");
+        this.brokerService = service;
+    }
+
+    @Override
+    public Map<InetSocketAddress, ChannelInitializer<SocketChannel>> newChannelInitializers() {
+        // Although this protocol handler does not need the BrokerService instance,
+        // we should verify that `start` was called in the right order
+        Objects.requireNonNull(brokerService,
+                "start(BrokerService) has not been called before newChannelInitializers");
+        InetSocketAddress address = getEchoAddress();
+        ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<>() {
+            @Override
+            protected void initChannel(SocketChannel socketChannel) {
+                socketChannel.pipeline().addLast(new EchoChannelHandler());
+            }
+        };
+        return Collections.singletonMap(address, initializer);
+    }
+
+    private InetSocketAddress getEchoAddress() {
+        String hostAndPort = getProtocolDataToAdvertise();
+        String[] parsed = hostAndPort.split(":");
+        return new InetSocketAddress(parsed[0], Integer.parseInt(parsed[1]));
+    }
+
+    @Override
+    public void close() {
+
+    }
+}
diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java
index 7e46ba1849..4944222a26 100644
--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java
+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/LoggingBrokerInterceptor.java
@@ -1,132 +1,132 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import io.netty.buffer.ByteBuf;
-import java.io.IOException;
-import java.util.Map;
-import javax.servlet.FilterChain;
-import javax.servlet.ServletException;
-import javax.servlet.ServletRequest;
-import javax.servlet.ServletResponse;
-import org.apache.bookkeeper.mledger.Entry;
-import org.apache.pulsar.broker.PulsarService;
-import org.apache.pulsar.broker.intercept.BrokerInterceptor;
-import org.apache.pulsar.broker.service.Consumer;
-import org.apache.pulsar.broker.service.Producer;
-import org.apache.pulsar.broker.service.ServerCnx;
-import org.apache.pulsar.broker.service.Subscription;
-import org.apache.pulsar.broker.service.Topic;
-import org.apache.pulsar.common.api.proto.BaseCommand;
-import org.apache.pulsar.common.api.proto.CommandAck;
-import org.apache.pulsar.common.api.proto.MessageMetadata;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class LoggingBrokerInterceptor implements BrokerInterceptor {
-
-    private final Logger log = LoggerFactory.getLogger(LoggingBrokerInterceptor.class);
-
-
-    @Override
-    public void onPulsarCommand(BaseCommand command, ServerCnx cnx) {
-        log.info("onPulsarCommand");
-    }
-
-    @Override
-    public void onConnectionClosed(ServerCnx cnx) {
-        log.info("onConnectionClosed");
-    }
-
-    @Override
-    public void onWebserviceRequest(ServletRequest request) {
-        log.info("onWebserviceRequest");
-    }
-
-    @Override
-    public void onWebserviceResponse(ServletRequest request, ServletResponse response) {
-        log.info("onWebserviceResponse");
-    }
-
-    @Override
-    public void initialize(PulsarService pulsarService) {
-        log.info("initialize: " + (pulsarService != null ? "OK" : "NULL"));
-    }
-
-    @Override
-    public void close() {
-        log.info("close");
-    }
-
-
-    @Override
-    public void beforeSendMessage(Subscription subscription, Entry entry, long[] ackSet, MessageMetadata msgMetadata) {
-        log.info("beforeSendMessage: "
-                + ("producer".equals(msgMetadata.getProducerName()) ? "OK" : "WRONG"));
-    }
-
-    @Override
-    public void onConnectionCreated(ServerCnx cnx) {
-        log.info("onConnectionCreated");
-    }
-
-    @Override
-    public void producerCreated(ServerCnx cnx, Producer producer, Map<String, String> metadata) {
-        log.info("producerCreated");
-    }
-
-    @Override
-    public void consumerCreated(ServerCnx cnx, Consumer consumer, Map<String, String> metadata) {
-        log.info("consumerCreated");
-    }
-
-    @Override
-    public void messageProduced(ServerCnx cnx, Producer producer, long startTimeNs, long ledgerId, long entryId,
-                                Topic.PublishContext publishContext) {
-        log.info("messageProduced");
-    }
-
-    @Override
-    public void messageDispatched(ServerCnx cnx, Consumer consumer, long ledgerId, long entryId,
-                                  ByteBuf headersAndPayload) {
-        log.info("messageDispatched");
-    }
-
-    @Override
-    public void messageAcked(ServerCnx cnx, Consumer consumer, CommandAck ackCmd) {
-        log.info("messageAcked");
-    }
-
-    @Override
-    public void txnOpened(long tcId, String txnID) {
-        log.info("txnOpened");
-    }
-
-    @Override
-    public void txnEnded(String txnID, long txnAction) {
-        log.info("txnEnded");
-    }
-
-    @Override
-    public void onFilter(ServletRequest request, ServletResponse response, FilterChain chain)
-            throws ServletException, IOException {
-        log.info("onFilter");
-        chain.doFilter(request, response);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import io.netty.buffer.ByteBuf;
+import java.io.IOException;
+import java.util.Map;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import org.apache.bookkeeper.mledger.Entry;
+import org.apache.pulsar.broker.PulsarService;
+import org.apache.pulsar.broker.intercept.BrokerInterceptor;
+import org.apache.pulsar.broker.service.Consumer;
+import org.apache.pulsar.broker.service.Producer;
+import org.apache.pulsar.broker.service.ServerCnx;
+import org.apache.pulsar.broker.service.Subscription;
+import org.apache.pulsar.broker.service.Topic;
+import org.apache.pulsar.common.api.proto.BaseCommand;
+import org.apache.pulsar.common.api.proto.CommandAck;
+import org.apache.pulsar.common.api.proto.MessageMetadata;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class LoggingBrokerInterceptor implements BrokerInterceptor {
+
+    private final Logger log = LoggerFactory.getLogger(LoggingBrokerInterceptor.class);
+
+
+    @Override
+    public void onPulsarCommand(BaseCommand command, ServerCnx cnx) {
+        log.info("onPulsarCommand");
+    }
+
+    @Override
+    public void onConnectionClosed(ServerCnx cnx) {
+        log.info("onConnectionClosed");
+    }
+
+    @Override
+    public void onWebserviceRequest(ServletRequest request) {
+        log.info("onWebserviceRequest");
+    }
+
+    @Override
+    public void onWebserviceResponse(ServletRequest request, ServletResponse response) {
+        log.info("onWebserviceResponse");
+    }
+
+    @Override
+    public void initialize(PulsarService pulsarService) {
+        log.info("initialize: " + (pulsarService != null ? "OK" : "NULL"));
+    }
+
+    @Override
+    public void close() {
+        log.info("close");
+    }
+
+
+    @Override
+    public void beforeSendMessage(Subscription subscription, Entry entry, long[] ackSet, MessageMetadata msgMetadata) {
+        log.info("beforeSendMessage: "
+                + ("producer".equals(msgMetadata.getProducerName()) ? "OK" : "WRONG"));
+    }
+
+    @Override
+    public void onConnectionCreated(ServerCnx cnx) {
+        log.info("onConnectionCreated");
+    }
+
+    @Override
+    public void producerCreated(ServerCnx cnx, Producer producer, Map<String, String> metadata) {
+        log.info("producerCreated");
+    }
+
+    @Override
+    public void consumerCreated(ServerCnx cnx, Consumer consumer, Map<String, String> metadata) {
+        log.info("consumerCreated");
+    }
+
+    @Override
+    public void messageProduced(ServerCnx cnx, Producer producer, long startTimeNs, long ledgerId, long entryId,
+                                Topic.PublishContext publishContext) {
+        log.info("messageProduced");
+    }
+
+    @Override
+    public void messageDispatched(ServerCnx cnx, Consumer consumer, long ledgerId, long entryId,
+                                  ByteBuf headersAndPayload) {
+        log.info("messageDispatched");
+    }
+
+    @Override
+    public void messageAcked(ServerCnx cnx, Consumer consumer, CommandAck ackCmd) {
+        log.info("messageAcked");
+    }
+
+    @Override
+    public void txnOpened(long tcId, String txnID) {
+        log.info("txnOpened");
+    }
+
+    @Override
+    public void txnEnded(String txnID, long txnAction) {
+        log.info("txnEnded");
+    }
+
+    @Override
+    public void onFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+            throws ServletException, IOException {
+        log.info("onFilter");
+        chain.doFilter(request, response);
+    }
+}
diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/PatternEntryFilter.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/PatternEntryFilter.java
index 253556ef35..0d0ff5e4cb 100644
--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/PatternEntryFilter.java
+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/PatternEntryFilter.java
@@ -1,61 +1,61 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import java.util.regex.Pattern;
-import org.apache.bookkeeper.mledger.Entry;
-import org.apache.pulsar.broker.service.plugin.EntryFilter;
-import org.apache.pulsar.broker.service.plugin.FilterContext;
-import org.apache.pulsar.common.api.proto.KeyValue;
-
-public class PatternEntryFilter implements EntryFilter {
-
-    public static final String FILTER_PATTERN = "entry_filter_pattern";
-    public static final String FILTER_PROPERTY = "filter_property";
-
-    @Override
-    public FilterResult filterEntry(Entry entry, FilterContext context) {
-        Pattern p = getPattern(context);
-        String value = getMessagePropertyValue(context);
-        if (p == null || value == null || p.matcher(value).matches()) {
-            return FilterResult.ACCEPT;
-        }
-        return FilterResult.REJECT;
-    }
-
-    private Pattern getPattern(FilterContext context) {
-        String subscriptionRegex = context.getSubscription().getSubscriptionProperties().get(FILTER_PATTERN);
-        if (subscriptionRegex == null) {
-            return null;
-        }
-        return Pattern.compile(subscriptionRegex);
-    }
-
-    private String getMessagePropertyValue(FilterContext context) {
-        return context.getMsgMetadata().getPropertiesList().stream()
-                .filter(kv -> FILTER_PROPERTY.equals(kv.getKey()))
-                .map(KeyValue::getValue)
-                .findFirst().orElse(null);
-    }
-
-    @Override
-    public void close() {
-        // Nothing to do here
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import java.util.regex.Pattern;
+import org.apache.bookkeeper.mledger.Entry;
+import org.apache.pulsar.broker.service.plugin.EntryFilter;
+import org.apache.pulsar.broker.service.plugin.FilterContext;
+import org.apache.pulsar.common.api.proto.KeyValue;
+
+public class PatternEntryFilter implements EntryFilter {
+
+    public static final String FILTER_PATTERN = "entry_filter_pattern";
+    public static final String FILTER_PROPERTY = "filter_property";
+
+    @Override
+    public FilterResult filterEntry(Entry entry, FilterContext context) {
+        Pattern p = getPattern(context);
+        String value = getMessagePropertyValue(context);
+        if (p == null || value == null || p.matcher(value).matches()) {
+            return FilterResult.ACCEPT;
+        }
+        return FilterResult.REJECT;
+    }
+
+    private Pattern getPattern(FilterContext context) {
+        String subscriptionRegex = context.getSubscription().getSubscriptionProperties().get(FILTER_PATTERN);
+        if (subscriptionRegex == null) {
+            return null;
+        }
+        return Pattern.compile(subscriptionRegex);
+    }
+
+    private String getMessagePropertyValue(FilterContext context) {
+        return context.getMsgMetadata().getPropertiesList().stream()
+                .filter(kv -> FILTER_PROPERTY.equals(kv.getKey()))
+                .map(KeyValue::getValue)
+                .findFirst().orElse(null);
+    }
+
+    @Override
+    public void close() {
+        // Nothing to do here
+    }
+}
diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/RandomAdditionalServlet.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/RandomAdditionalServlet.java
index 9d4f7e18a6..cfc30f5695 100644
--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/RandomAdditionalServlet.java
+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/RandomAdditionalServlet.java
@@ -1,72 +1,72 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import org.apache.pulsar.broker.web.plugin.servlet.AdditionalServlet;
-import org.apache.pulsar.common.configuration.PulsarConfiguration;
-import org.eclipse.jetty.servlet.ServletHolder;
-
-public class RandomAdditionalServlet extends HttpServlet implements AdditionalServlet {
-
-    private int sequenceLength;
-
-    @Override
-    public void loadConfig(PulsarConfiguration pulsarConfiguration) {
-        sequenceLength = Integer.parseInt(
-                pulsarConfiguration.getProperties().getProperty("randomServletSequenceLength"));
-
-    }
-
-    @Override
-    public String getBasePath() {
-        return "/random";
-    }
-
-    @Override
-    public ServletHolder getServletHolder() {
-        return new ServletHolder(this);
-    }
-
-    @Override
-    public void close() {
-
-    }
-
-    @Override
-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
-        resp.setContentType("text/plain");
-        List<Integer> numbers = IntStream.range(0, sequenceLength).boxed()
-                .collect(Collectors.toCollection(ArrayList::new));
-        Collections.shuffle(numbers);
-        String responseBody = numbers.stream().map(Object::toString).collect(Collectors.joining(","));
-        ServletOutputStream output = resp.getOutputStream();
-        output.write(responseBody.getBytes());
-        output.close();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import org.apache.pulsar.broker.web.plugin.servlet.AdditionalServlet;
+import org.apache.pulsar.common.configuration.PulsarConfiguration;
+import org.eclipse.jetty.servlet.ServletHolder;
+
+public class RandomAdditionalServlet extends HttpServlet implements AdditionalServlet {
+
+    private int sequenceLength;
+
+    @Override
+    public void loadConfig(PulsarConfiguration pulsarConfiguration) {
+        sequenceLength = Integer.parseInt(
+                pulsarConfiguration.getProperties().getProperty("randomServletSequenceLength"));
+
+    }
+
+    @Override
+    public String getBasePath() {
+        return "/random";
+    }
+
+    @Override
+    public ServletHolder getServletHolder() {
+        return new ServletHolder(this);
+    }
+
+    @Override
+    public void close() {
+
+    }
+
+    @Override
+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
+        resp.setContentType("text/plain");
+        List<Integer> numbers = IntStream.range(0, sequenceLength).boxed()
+                .collect(Collectors.toCollection(ArrayList::new));
+        Collections.shuffle(numbers);
+        String responseBody = numbers.stream().map(Object::toString).collect(Collectors.joining(","));
+        ServletOutputStream output = resp.getOutputStream();
+        output.write(responseBody.getBytes());
+        output.close();
+    }
+}
diff --git a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/package-info.java b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/package-info.java
index dff75c6d00..5b5bed86dd 100644
--- a/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/package-info.java
+++ b/tests/docker-images/java-test-plugins/src/main/java/org/apache/pulsar/tests/integration/plugins/package-info.java
@@ -1,19 +1,19 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
 package org.apache.pulsar.tests.integration.plugins;
\ No newline at end of file
diff --git a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/additional_servlet.yml b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/additional_servlet.yml
index 10d25a2b68..0a68159a54 100644
--- a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/additional_servlet.yml
+++ b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/additional_servlet.yml
@@ -1,22 +1,22 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-name: random
-description: Additional servlet that generates a random sequence
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+name: random
+description: Additional servlet that generates a random sequence
 additionalServletClass: org.apache.pulsar.tests.integration.plugins.RandomAdditionalServlet
\ No newline at end of file
diff --git a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/broker_interceptor.yml b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/broker_interceptor.yml
index c90ce3593e..fa44c2c56e 100644
--- a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/broker_interceptor.yml
+++ b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/broker_interceptor.yml
@@ -1,22 +1,22 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-name: loggingInterceptor
-description: Broker Interceptor that logs each of its method invocations
-interceptorClass: org.apache.pulsar.tests.integration.plugins.LoggingBrokerInterceptor
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+name: loggingInterceptor
+description: Broker Interceptor that logs each of its method invocations
+interceptorClass: org.apache.pulsar.tests.integration.plugins.LoggingBrokerInterceptor
diff --git a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/entry_filter.yml b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/entry_filter.yml
index 6f37bc4310..4289fadf40 100644
--- a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/entry_filter.yml
+++ b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/entry_filter.yml
@@ -1,22 +1,22 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-name: pattern_filter
-description: Regex pattern based entry filter
-entryFilterClass: org.apache.pulsar.tests.integration.plugins.PatternEntryFilter
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+name: pattern_filter
+description: Regex pattern based entry filter
+entryFilterClass: org.apache.pulsar.tests.integration.plugins.PatternEntryFilter
diff --git a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/pulsar-protocol-handler.yml b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/pulsar-protocol-handler.yml
index 37968222b0..9a8ab1893d 100644
--- a/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/pulsar-protocol-handler.yml
+++ b/tests/docker-images/java-test-plugins/src/main/resources/META-INF/services/pulsar-protocol-handler.yml
@@ -1,22 +1,22 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-name: echo
-description: Echo Protocol Handler
-handlerClass: org.apache.pulsar.tests.integration.plugins.EchoProtocolHandler
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+name: echo
+description: Echo Protocol Handler
+handlerClass: org.apache.pulsar.tests.integration.plugins.EchoProtocolHandler
diff --git a/tests/docker-images/latest-version-image/Dockerfile b/tests/docker-images/latest-version-image/Dockerfile
index 316f499083..8358cd17b7 100644
--- a/tests/docker-images/latest-version-image/Dockerfile
+++ b/tests/docker-images/latest-version-image/Dockerfile
@@ -1,110 +1,110 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-ARG PULSAR_ALL_IMAGE
-
-# build go lang examples first in a separate layer
-FROM golang:1.23-alpine as pulsar-function-go
-
-COPY target/pulsar-function-go/ /go/src/github.com/apache/pulsar/pulsar-function-go
-RUN cd /go/src/github.com/apache/pulsar/pulsar-function-go && go install ./...
-RUN cd /go/src/github.com/apache/pulsar/pulsar-function-go/pf && go install
-RUN cd /go/src/github.com/apache/pulsar/pulsar-function-go/examples && go install ./...
-
-
-# patch Oracle Debezium Connector nar file to include Oracle JDBC dependencies
-FROM $PULSAR_ALL_IMAGE as oracle-jdbc-builder
-
-USER root
-WORKDIR /
-
-RUN OJDBC_VERSION="19.3.0.0" && \
-    OJDBC_BASE_URL="https://repo1.maven.org/maven2/com/oracle/ojdbc" && \
-    DEPS_DIR="META-INF/bundled-dependencies" && \
-    OJDBC_ARTIFACTS="ojdbc8 ucp oraclepki osdt_cert osdt_core simplefan orai18n xdb xmlparserv2" && \
-    cd / && rm -rf "$DEPS_DIR" && mkdir -p "$DEPS_DIR" && \
-    cd "$DEPS_DIR" && \
-    for ojdbc_artifact in $OJDBC_ARTIFACTS; do \
-        ojdbc_jar_file="${ojdbc_artifact}-${OJDBC_VERSION}.jar" && \
-        ojdbc_download_url="${OJDBC_BASE_URL}/${ojdbc_artifact}/${OJDBC_VERSION}/${ojdbc_jar_file}" && \
-        echo "Downloading $ojdbc_jar_file from $ojdbc_download_url" && \
-        curl -sSL --retry 5 --retry-delay 1 --retry-max-time 30 "${ojdbc_download_url}" -o "${ojdbc_jar_file}" && \
-        [ -f "${ojdbc_jar_file}" ] || (echo "Failed to download ${ojdbc_jar_file}" && exit 1); \
-    done && \
-    cd / && \
-    jar uvf /pulsar/connectors/pulsar-io-debezium-oracle-*.nar $DEPS_DIR/*.jar >&2
-
-########################################
-###### Main image build
-########################################
-FROM $PULSAR_ALL_IMAGE
-
-# Switch to run as the root user to simplify building container and then running
-# supervisord. Each of the pulsar components are spawned by supervisord and their
-# process configuration files specify that the process will be run with UID 10000.
-# However, any processes exec'ing into the containers will run as root, by default.
-USER root
-
-RUN apk add --no-cache supervisor procps curl
-
-RUN mkdir -p /var/log/pulsar && mkdir -p /var/run/supervisor/
-
-COPY conf/supervisord.conf /etc/supervisord.conf
-COPY conf/global-zk.conf conf/local-zk.conf conf/bookie.conf conf/broker.conf conf/functions_worker.conf \
-     conf/proxy.conf conf/websocket.conf /etc/supervisord/conf.d/
-
-COPY scripts/run-global-zk.sh scripts/run-local-zk.sh \
-     scripts/run-bookie.sh scripts/run-broker.sh scripts/run-functions-worker.sh scripts/run-proxy.sh \
-     scripts/run-standalone.sh scripts/run-websocket.sh \
-     /pulsar/bin/
-
-# copy python test examples
-RUN mkdir -p /pulsar/instances/deps
-COPY python-examples/exclamation_lib.py /pulsar/instances/deps/
-COPY python-examples/exclamation_with_extra_deps.py /pulsar/examples/python-examples/
-COPY python-examples/exclamation.zip /pulsar/examples/python-examples/
-COPY python-examples/producer_schema.py /pulsar/examples/python-examples/
-COPY python-examples/consumer_schema.py /pulsar/examples/python-examples/
-COPY python-examples/exception_function.py /pulsar/examples/python-examples/
-RUN chmod g+rx /pulsar/examples/python-examples/
-
-# copy java test examples
-COPY target/java-test-functions.jar /pulsar/examples/
-
-# copy buildtools.jar to /pulsar/lib so that org.apache.pulsar.tests.ExtendedNettyLeakDetector can be used
-COPY target/buildtools.jar /pulsar/lib/
-
-# copy go test examples
-COPY --from=pulsar-function-go /go/bin /pulsar/examples/go-examples
-
-# TLS certificates
-RUN mkdir -p /pulsar/certificate-authority
-COPY target/certificate-authority /pulsar/certificate-authority/
-
-# copy broker plugins
-COPY target/plugins/ /pulsar/examples/
-
-# Copy patched Oracle Debezium Connector nar file which includes Oracle JDBC dependencies
-COPY --from=oracle-jdbc-builder /pulsar/connectors/pulsar-io-debezium-oracle-*.nar /pulsar/connectors/
-
-# Fix permissions for filesystem offloader
-RUN mkdir -p pulsar
-RUN chmod g+rwx pulsar
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+ARG PULSAR_ALL_IMAGE
+
+# build go lang examples first in a separate layer
+FROM golang:1.23-alpine as pulsar-function-go
+
+COPY target/pulsar-function-go/ /go/src/github.com/apache/pulsar/pulsar-function-go
+RUN cd /go/src/github.com/apache/pulsar/pulsar-function-go && go install ./...
+RUN cd /go/src/github.com/apache/pulsar/pulsar-function-go/pf && go install
+RUN cd /go/src/github.com/apache/pulsar/pulsar-function-go/examples && go install ./...
+
+
+# patch Oracle Debezium Connector nar file to include Oracle JDBC dependencies
+FROM $PULSAR_ALL_IMAGE as oracle-jdbc-builder
+
+USER root
+WORKDIR /
+
+RUN OJDBC_VERSION="19.3.0.0" && \
+    OJDBC_BASE_URL="https://repo1.maven.org/maven2/com/oracle/ojdbc" && \
+    DEPS_DIR="META-INF/bundled-dependencies" && \
+    OJDBC_ARTIFACTS="ojdbc8 ucp oraclepki osdt_cert osdt_core simplefan orai18n xdb xmlparserv2" && \
+    cd / && rm -rf "$DEPS_DIR" && mkdir -p "$DEPS_DIR" && \
+    cd "$DEPS_DIR" && \
+    for ojdbc_artifact in $OJDBC_ARTIFACTS; do \
+        ojdbc_jar_file="${ojdbc_artifact}-${OJDBC_VERSION}.jar" && \
+        ojdbc_download_url="${OJDBC_BASE_URL}/${ojdbc_artifact}/${OJDBC_VERSION}/${ojdbc_jar_file}" && \
+        echo "Downloading $ojdbc_jar_file from $ojdbc_download_url" && \
+        curl -sSL --retry 5 --retry-delay 1 --retry-max-time 30 "${ojdbc_download_url}" -o "${ojdbc_jar_file}" && \
+        [ -f "${ojdbc_jar_file}" ] || (echo "Failed to download ${ojdbc_jar_file}" && exit 1); \
+    done && \
+    cd / && \
+    jar uvf /pulsar/connectors/pulsar-io-debezium-oracle-*.nar $DEPS_DIR/*.jar >&2
+
+########################################
+###### Main image build
+########################################
+FROM $PULSAR_ALL_IMAGE
+
+# Switch to run as the root user to simplify building container and then running
+# supervisord. Each of the pulsar components are spawned by supervisord and their
+# process configuration files specify that the process will be run with UID 10000.
+# However, any processes exec'ing into the containers will run as root, by default.
+USER root
+
+RUN apk add --no-cache supervisor procps curl
+
+RUN mkdir -p /var/log/pulsar && mkdir -p /var/run/supervisor/
+
+COPY conf/supervisord.conf /etc/supervisord.conf
+COPY conf/global-zk.conf conf/local-zk.conf conf/bookie.conf conf/broker.conf conf/functions_worker.conf \
+     conf/proxy.conf conf/websocket.conf /etc/supervisord/conf.d/
+
+COPY scripts/run-global-zk.sh scripts/run-local-zk.sh \
+     scripts/run-bookie.sh scripts/run-broker.sh scripts/run-functions-worker.sh scripts/run-proxy.sh \
+     scripts/run-standalone.sh scripts/run-websocket.sh \
+     /pulsar/bin/
+
+# copy python test examples
+RUN mkdir -p /pulsar/instances/deps
+COPY python-examples/exclamation_lib.py /pulsar/instances/deps/
+COPY python-examples/exclamation_with_extra_deps.py /pulsar/examples/python-examples/
+COPY python-examples/exclamation.zip /pulsar/examples/python-examples/
+COPY python-examples/producer_schema.py /pulsar/examples/python-examples/
+COPY python-examples/consumer_schema.py /pulsar/examples/python-examples/
+COPY python-examples/exception_function.py /pulsar/examples/python-examples/
+RUN chmod g+rx /pulsar/examples/python-examples/
+
+# copy java test examples
+COPY target/java-test-functions.jar /pulsar/examples/
+
+# copy buildtools.jar to /pulsar/lib so that org.apache.pulsar.tests.ExtendedNettyLeakDetector can be used
+COPY target/buildtools.jar /pulsar/lib/
+
+# copy go test examples
+COPY --from=pulsar-function-go /go/bin /pulsar/examples/go-examples
+
+# TLS certificates
+RUN mkdir -p /pulsar/certificate-authority
+COPY target/certificate-authority /pulsar/certificate-authority/
+
+# copy broker plugins
+COPY target/plugins/ /pulsar/examples/
+
+# Copy patched Oracle Debezium Connector nar file which includes Oracle JDBC dependencies
+COPY --from=oracle-jdbc-builder /pulsar/connectors/pulsar-io-debezium-oracle-*.nar /pulsar/connectors/
+
+# Fix permissions for filesystem offloader
+RUN mkdir -p pulsar
+RUN chmod g+rwx pulsar
+
 CMD bash
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/conf/bookie.conf b/tests/docker-images/latest-version-image/conf/bookie.conf
index df7501057a..1b682dd191 100644
--- a/tests/docker-images/latest-version-image/conf/bookie.conf
+++ b/tests/docker-images/latest-version-image/conf/bookie.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:bookie]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/bookie.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx128M -XX:MaxDirectMemorySize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar bookie
-user=pulsar
-stopwaitsecs=15
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:bookie]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/bookie.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx128M -XX:MaxDirectMemorySize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar bookie
+user=pulsar
+stopwaitsecs=15
diff --git a/tests/docker-images/latest-version-image/conf/broker.conf b/tests/docker-images/latest-version-image/conf/broker.conf
index 790dace8d6..3d0530a1f8 100644
--- a/tests/docker-images/latest-version-image/conf/broker.conf
+++ b/tests/docker-images/latest-version-image/conf/broker.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:broker]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/broker.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar broker
-user=pulsar
-stopwaitsecs=15
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:broker]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/broker.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar broker
+user=pulsar
+stopwaitsecs=15
diff --git a/tests/docker-images/latest-version-image/conf/functions_worker.conf b/tests/docker-images/latest-version-image/conf/functions_worker.conf
index b5d151ce3f..40675fc5e1 100644
--- a/tests/docker-images/latest-version-image/conf/functions_worker.conf
+++ b/tests/docker-images/latest-version-image/conf/functions_worker.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:functions-worker]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/functions_worker.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar functions-worker
-user=pulsar
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:functions-worker]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/functions_worker.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar functions-worker
+user=pulsar
 stopwaitsecs=15
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/conf/global-zk.conf b/tests/docker-images/latest-version-image/conf/global-zk.conf
index ef52150684..33e32c227a 100644
--- a/tests/docker-images/latest-version-image/conf/global-zk.conf
+++ b/tests/docker-images/latest-version-image/conf/global-zk.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:global-zk]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/global-zk.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx128M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar configuration-store
-user=pulsar
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:global-zk]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/global-zk.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx128M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar configuration-store
+user=pulsar
 stopwaitsecs=15
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/conf/local-zk.conf b/tests/docker-images/latest-version-image/conf/local-zk.conf
index d6bfdcb621..295b537fff 100644
--- a/tests/docker-images/latest-version-image/conf/local-zk.conf
+++ b/tests/docker-images/latest-version-image/conf/local-zk.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:local-zk]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/local-zk.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx128M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar zookeeper
-user=pulsar
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:local-zk]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/local-zk.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx128M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar zookeeper
+user=pulsar
 stopwaitsecs=15
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/conf/proxy.conf b/tests/docker-images/latest-version-image/conf/proxy.conf
index 17a0a658b4..ff7dcb0ed8 100644
--- a/tests/docker-images/latest-version-image/conf/proxy.conf
+++ b/tests/docker-images/latest-version-image/conf/proxy.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:proxy]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/proxy.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar proxy
-user=pulsar
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:proxy]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/proxy.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar proxy
+user=pulsar
 stopwaitsecs=15
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/conf/supervisord.conf b/tests/docker-images/latest-version-image/conf/supervisord.conf
index ee48be3265..92ed1bb511 100644
--- a/tests/docker-images/latest-version-image/conf/supervisord.conf
+++ b/tests/docker-images/latest-version-image/conf/supervisord.conf
@@ -1,40 +1,40 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[supervisord]
-nodaemon=true
-logfile=/var/log/supervisord.log
-logfile_maxbytes=50MB
-logfile_backups=10
-loglevel=info
-pidfile=/var/run/supervisord.pid
-minfds=1024
-minprocs=200
-
-[unix_http_server]
-file=/var/run/supervisor/supervisor.sock
-
-[supervisorctl]
-serverurl=unix:///var/run/supervisor/supervisor.sock
-
-[rpcinterface:supervisor]
-supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface
-
-[include]
-files = /etc/supervisord/conf.d/*.conf
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[supervisord]
+nodaemon=true
+logfile=/var/log/supervisord.log
+logfile_maxbytes=50MB
+logfile_backups=10
+loglevel=info
+pidfile=/var/run/supervisord.pid
+minfds=1024
+minprocs=200
+
+[unix_http_server]
+file=/var/run/supervisor/supervisor.sock
+
+[supervisorctl]
+serverurl=unix:///var/run/supervisor/supervisor.sock
+
+[rpcinterface:supervisor]
+supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface
+
+[include]
+files = /etc/supervisord/conf.d/*.conf
diff --git a/tests/docker-images/latest-version-image/conf/websocket.conf b/tests/docker-images/latest-version-image/conf/websocket.conf
index 7625dba3e0..4747972e2e 100644
--- a/tests/docker-images/latest-version-image/conf/websocket.conf
+++ b/tests/docker-images/latest-version-image/conf/websocket.conf
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[program:websocket]
-autostart=false
-redirect_stderr=true
-stdout_logfile=/var/log/pulsar/pulsar-websocket.log
-directory=/pulsar
-environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
-command=/pulsar/bin/pulsar websocket
-user=pulsar
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[program:websocket]
+autostart=false
+redirect_stderr=true
+stdout_logfile=/var/log/pulsar/pulsar-websocket.log
+directory=/pulsar
+environment=PULSAR_MEM="-Xmx150M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError",PULSAR_GC="-XX:+UseZGC"
+command=/pulsar/bin/pulsar websocket
+user=pulsar
 stopwaitsecs=15
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/pom.xml b/tests/docker-images/latest-version-image/pom.xml
index 82af143d98..cffa9698e3 100644
--- a/tests/docker-images/latest-version-image/pom.xml
+++ b/tests/docker-images/latest-version-image/pom.xml
@@ -1,187 +1,187 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <groupId>org.apache.pulsar.tests</groupId>
-    <artifactId>docker-images</artifactId>
-    <version>4.1.2</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-  <artifactId>latest-version-image</artifactId>
-  <name>Apache Pulsar :: Tests :: Docker Images :: Latest Version Testing</name>
-  <packaging>pom</packaging>
-
-  <profiles>
-    <profile>
-      <id>docker</id>
-      <activation>
-        <property>
-          <name>integrationTests</name>
-        </property>
-      </activation>
-      <dependencies>
-        <dependency>
-          <groupId>org.apache.pulsar.tests</groupId>
-          <artifactId>java-test-functions</artifactId>
-          <version>${project.parent.version}</version>
-        </dependency>
-        <dependency>
-          <groupId>org.apache.pulsar.tests</groupId>
-          <artifactId>java-test-plugins</artifactId>
-          <version>${project.parent.version}</version>
-        </dependency>
-        <dependency>
-          <groupId>org.apache.pulsar</groupId>
-          <artifactId>pulsar-all-docker-image</artifactId>
-          <version>${project.parent.version}</version>
-          <type>pom</type>
-          <scope>provided</scope>
-          <exclusions>
-            <exclusion>
-              <groupId>*</groupId>
-              <artifactId>*</artifactId>
-            </exclusion>
-          </exclusions>
-        </dependency>
-      </dependencies>
-      <build>
-        <plugins>
-          <plugin>
-            <artifactId>maven-dependency-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>copy-installed</id>
-                <phase>package</phase>
-                <goals>
-                  <goal>copy</goal>
-                </goals>
-                <configuration>
-                  <artifactItems>
-                    <artifactItem>
-                      <groupId>org.apache.pulsar.tests</groupId>
-                      <artifactId>java-test-functions</artifactId>
-                      <version>${project.parent.version}</version>
-                      <type>jar</type>
-                      <overWrite>true</overWrite>
-                      <outputDirectory>${project.build.directory}</outputDirectory>
-                      <destFileName>java-test-functions.jar</destFileName>
-                    </artifactItem>
-                    <artifactItem>
-                      <groupId>org.apache.pulsar.tests</groupId>
-                      <artifactId>java-test-plugins</artifactId>
-                      <version>${project.parent.version}</version>
-                      <type>jar</type>
-                      <overWrite>true</overWrite>
-                      <outputDirectory>${project.build.directory}/plugins</outputDirectory>
-                      <destFileName>java-test-plugins.nar</destFileName>
-                    </artifactItem>
-                    <artifactItem>
-                      <groupId>org.apache.pulsar</groupId>
-                      <artifactId>buildtools</artifactId>
-                      <version>${project.parent.version}</version>
-                      <type>jar</type>
-                      <overWrite>true</overWrite>
-                      <outputDirectory>${project.build.directory}</outputDirectory>
-                      <destFileName>buildtools.jar</destFileName>
-                    </artifactItem>
-                  </artifactItems>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-          <plugin>
-            <artifactId>maven-resources-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>copy-pulsar-function-go</id>
-                <phase>generate-resources</phase>
-                <goals>
-                  <goal>copy-resources</goal>
-                </goals>
-                <configuration>
-                  <outputDirectory>${project.build.directory}/pulsar-function-go/</outputDirectory>
-                  <overwrite>true</overwrite>
-                  <resources>
-                    <resource>
-                      <directory>../../../pulsar-function-go/</directory>
-                      <filtering>false</filtering>
-                    </resource>
-                  </resources>
-                </configuration>
-              </execution>
-              <execution>
-                <id>copy-pulsar-certificate-authority</id>
-                <phase>generate-resources</phase>
-                <goals>
-                  <goal>copy-resources</goal>
-                </goals>
-                <configuration>
-                  <outputDirectory>${project.build.directory}/certificate-authority</outputDirectory>
-                  <overwrite>true</overwrite>
-                  <resources>
-                    <resource>
-                      <directory>${project.basedir}/../../certificate-authority</directory>
-                      <filtering>false</filtering>
-                    </resource>
-                  </resources>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-          <plugin>
-            <groupId>io.fabric8</groupId>
-            <artifactId>docker-maven-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>default</id>
-                <phase>package</phase>
-                <goals>
-                  <goal>build</goal>
-                  <goal>tag</goal>
-                </goals>
-                <configuration>
-                  <images>
-                    <image>
-                      <name>${docker.organization}/${docker.image}-test-latest-version:${docker.tag}</name>
-                      <build>
-                        <contextDir>${project.basedir}</contextDir>
-                        <args>
-                          <PULSAR_ALL_IMAGE>${docker.organization}/${docker.image}-all:${project.version}-${git.commit.id.abbrev}</PULSAR_ALL_IMAGE>
-                        </args>
-                        <noCache>true</noCache>
-                        <buildx>
-                          <platforms>
-                            <platform>${docker.platforms}</platform>
-                          </platforms>
-                        </buildx>
-                      </build>
-                    </image>
-                  </images>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+  <parent>
+    <groupId>org.apache.pulsar.tests</groupId>
+    <artifactId>docker-images</artifactId>
+    <version>4.1.2</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+  <artifactId>latest-version-image</artifactId>
+  <name>Apache Pulsar :: Tests :: Docker Images :: Latest Version Testing</name>
+  <packaging>pom</packaging>
+
+  <profiles>
+    <profile>
+      <id>docker</id>
+      <activation>
+        <property>
+          <name>integrationTests</name>
+        </property>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.apache.pulsar.tests</groupId>
+          <artifactId>java-test-functions</artifactId>
+          <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.pulsar.tests</groupId>
+          <artifactId>java-test-plugins</artifactId>
+          <version>${project.parent.version}</version>
+        </dependency>
+        <dependency>
+          <groupId>org.apache.pulsar</groupId>
+          <artifactId>pulsar-all-docker-image</artifactId>
+          <version>${project.parent.version}</version>
+          <type>pom</type>
+          <scope>provided</scope>
+          <exclusions>
+            <exclusion>
+              <groupId>*</groupId>
+              <artifactId>*</artifactId>
+            </exclusion>
+          </exclusions>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-dependency-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>copy-installed</id>
+                <phase>package</phase>
+                <goals>
+                  <goal>copy</goal>
+                </goals>
+                <configuration>
+                  <artifactItems>
+                    <artifactItem>
+                      <groupId>org.apache.pulsar.tests</groupId>
+                      <artifactId>java-test-functions</artifactId>
+                      <version>${project.parent.version}</version>
+                      <type>jar</type>
+                      <overWrite>true</overWrite>
+                      <outputDirectory>${project.build.directory}</outputDirectory>
+                      <destFileName>java-test-functions.jar</destFileName>
+                    </artifactItem>
+                    <artifactItem>
+                      <groupId>org.apache.pulsar.tests</groupId>
+                      <artifactId>java-test-plugins</artifactId>
+                      <version>${project.parent.version}</version>
+                      <type>jar</type>
+                      <overWrite>true</overWrite>
+                      <outputDirectory>${project.build.directory}/plugins</outputDirectory>
+                      <destFileName>java-test-plugins.nar</destFileName>
+                    </artifactItem>
+                    <artifactItem>
+                      <groupId>org.apache.pulsar</groupId>
+                      <artifactId>buildtools</artifactId>
+                      <version>${project.parent.version}</version>
+                      <type>jar</type>
+                      <overWrite>true</overWrite>
+                      <outputDirectory>${project.build.directory}</outputDirectory>
+                      <destFileName>buildtools.jar</destFileName>
+                    </artifactItem>
+                  </artifactItems>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <artifactId>maven-resources-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>copy-pulsar-function-go</id>
+                <phase>generate-resources</phase>
+                <goals>
+                  <goal>copy-resources</goal>
+                </goals>
+                <configuration>
+                  <outputDirectory>${project.build.directory}/pulsar-function-go/</outputDirectory>
+                  <overwrite>true</overwrite>
+                  <resources>
+                    <resource>
+                      <directory>../../../pulsar-function-go/</directory>
+                      <filtering>false</filtering>
+                    </resource>
+                  </resources>
+                </configuration>
+              </execution>
+              <execution>
+                <id>copy-pulsar-certificate-authority</id>
+                <phase>generate-resources</phase>
+                <goals>
+                  <goal>copy-resources</goal>
+                </goals>
+                <configuration>
+                  <outputDirectory>${project.build.directory}/certificate-authority</outputDirectory>
+                  <overwrite>true</overwrite>
+                  <resources>
+                    <resource>
+                      <directory>${project.basedir}/../../certificate-authority</directory>
+                      <filtering>false</filtering>
+                    </resource>
+                  </resources>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <groupId>io.fabric8</groupId>
+            <artifactId>docker-maven-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>default</id>
+                <phase>package</phase>
+                <goals>
+                  <goal>build</goal>
+                  <goal>tag</goal>
+                </goals>
+                <configuration>
+                  <images>
+                    <image>
+                      <name>${docker.organization}/${docker.image}-test-latest-version:${docker.tag}</name>
+                      <build>
+                        <contextDir>${project.basedir}</contextDir>
+                        <args>
+                          <PULSAR_ALL_IMAGE>${docker.organization}/${docker.image}-all:${project.version}-${git.commit.id.abbrev}</PULSAR_ALL_IMAGE>
+                        </args>
+                        <noCache>true</noCache>
+                        <buildx>
+                          <platforms>
+                            <platform>${docker.platforms}</platform>
+                          </platforms>
+                        </buildx>
+                      </build>
+                    </image>
+                  </images>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/tests/docker-images/latest-version-image/python-examples/consumer_schema.py b/tests/docker-images/latest-version-image/python-examples/consumer_schema.py
index 0cd59ddacd..7e634745c3 100755
--- a/tests/docker-images/latest-version-image/python-examples/consumer_schema.py
+++ b/tests/docker-images/latest-version-image/python-examples/consumer_schema.py
@@ -1,49 +1,49 @@
-#!/usr/bin/env python3
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-import pulsar
-from pulsar.schema import *
-import sys
-
-
-class ReceiveExample(Record):
-    x = Integer()
-    y = Long()
-
-
-service_url = sys.argv[1]
-topic = sys.argv[2]
-
-client = pulsar.Client(service_url)
-
-consumer = client.subscribe(
-                    topic=topic,
-                    subscription_name="my-subscription",
-                    schema=JsonSchema(ReceiveExample)
-                )
-
-msg = consumer.receive()
-
-obj = msg.value()
-
-assert obj.x == 1
-assert obj.y == 2
-
-client.close()
+#!/usr/bin/env python3
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+import pulsar
+from pulsar.schema import *
+import sys
+
+
+class ReceiveExample(Record):
+    x = Integer()
+    y = Long()
+
+
+service_url = sys.argv[1]
+topic = sys.argv[2]
+
+client = pulsar.Client(service_url)
+
+consumer = client.subscribe(
+                    topic=topic,
+                    subscription_name="my-subscription",
+                    schema=JsonSchema(ReceiveExample)
+                )
+
+msg = consumer.receive()
+
+obj = msg.value()
+
+assert obj.x == 1
+assert obj.y == 2
+
+client.close()
diff --git a/tests/docker-images/latest-version-image/python-examples/exception_function.py b/tests/docker-images/latest-version-image/python-examples/exception_function.py
index b2e09083bf..e75389a9b0 100755
--- a/tests/docker-images/latest-version-image/python-examples/exception_function.py
+++ b/tests/docker-images/latest-version-image/python-examples/exception_function.py
@@ -1,28 +1,28 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-
-i = 0
-def process(input):
-  global i
-  i += 1
-  if i % 10 == 0:
-    raise Exception("test");
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+
+i = 0
+def process(input):
+  global i
+  i += 1
+  if i % 10 == 0:
+    raise Exception("test");
+
   return input + "!"
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/python-examples/exclamation_lib.py b/tests/docker-images/latest-version-image/python-examples/exclamation_lib.py
index 4e129f460a..8d78efd157 100755
--- a/tests/docker-images/latest-version-image/python-examples/exclamation_lib.py
+++ b/tests/docker-images/latest-version-image/python-examples/exclamation_lib.py
@@ -1,21 +1,21 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-def exclamation(input):
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+def exclamation(input):
     return input + '!'
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/python-examples/exclamation_with_extra_deps.py b/tests/docker-images/latest-version-image/python-examples/exclamation_with_extra_deps.py
index b32f0a1764..b56a28bc46 100755
--- a/tests/docker-images/latest-version-image/python-examples/exclamation_with_extra_deps.py
+++ b/tests/docker-images/latest-version-image/python-examples/exclamation_with_extra_deps.py
@@ -1,30 +1,30 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-from pulsar import Function
-from exclamation_lib import exclamation
-
-# The classic ExclamationFunction that appends an exclamation at the end
-# of the input
-class ExclamationFunction(Function):
-  def __init__(self):
-    pass
-
-  def process(self, input, context):
-    return exclamation(input)
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+from pulsar import Function
+from exclamation_lib import exclamation
+
+# The classic ExclamationFunction that appends an exclamation at the end
+# of the input
+class ExclamationFunction(Function):
+  def __init__(self):
+    pass
+
+  def process(self, input, context):
+    return exclamation(input)
diff --git a/tests/docker-images/latest-version-image/python-examples/producer_schema.py b/tests/docker-images/latest-version-image/python-examples/producer_schema.py
index d93078c3d3..f12e3229e2 100755
--- a/tests/docker-images/latest-version-image/python-examples/producer_schema.py
+++ b/tests/docker-images/latest-version-image/python-examples/producer_schema.py
@@ -1,45 +1,45 @@
-#!/usr/bin/env python3
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-import pulsar
-from pulsar.schema import *
-import sys
-
-
-class MyExample(Record):
-    a = String()
-    b = Integer(required=True)
-
-
-service_url = sys.argv[1]
-topic = sys.argv[2]
-
-client = pulsar.Client(service_url)
-
-producer = client.create_producer(
-                    topic=topic,
-                    schema=AvroSchema(MyExample)
-                )
-
-producer.send(MyExample(a="Hello", b=1))
-
-client.close()
-
-sys.exit(0)
+#!/usr/bin/env python3
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+import pulsar
+from pulsar.schema import *
+import sys
+
+
+class MyExample(Record):
+    a = String()
+    b = Integer(required=True)
+
+
+service_url = sys.argv[1]
+topic = sys.argv[2]
+
+client = pulsar.Client(service_url)
+
+producer = client.create_producer(
+                    topic=topic,
+                    schema=AvroSchema(MyExample)
+                )
+
+producer.send(MyExample(a="Hello", b=1))
+
+client.close()
+
+sys.exit(0)
diff --git a/tests/docker-images/latest-version-image/scripts/func-lib.sh b/tests/docker-images/latest-version-image/scripts/func-lib.sh
new file mode 100644
index 0000000000..3eeabbf03c
--- /dev/null
+++ b/tests/docker-images/latest-version-image/scripts/func-lib.sh
@@ -0,0 +1,62 @@
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+set -e
+set -o pipefail
+
+function set_pulsar_mem() {
+  local maxMem=$1
+  local additionalMemParam=$2
+  local pulsar_test_mem
+  # set into pulsar_test_mem while trimming whitespace
+  read -r pulsar_test_mem <<< "-Xmx${maxMem} ${additionalMemParam}"
+  # prefer PULSAR_MEM, but always append params to perform a heap dump on OOME
+  export PULSAR_MEM="${PULSAR_MEM:-"${pulsar_test_mem}"} -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/pulsar -XX:+ExitOnOutOfMemoryError"
+}
+
+function run_pulsar_component() {
+  local component=$1
+  local supervisord_component=$2
+  local maxMem=$3
+  local additionalMemParam=$4
+
+  set_pulsar_mem "$maxMem" "$additionalMemParam"
+
+  if [[ -f "conf/${component}.conf" ]]; then
+    bin/apply-config-from-env.py conf/${component}.conf
+  fi
+  bin/apply-config-from-env.py conf/client.conf
+
+  if [[ "$component" == "functions_worker" ]]; then
+    bin/gen-yml-from-env.py conf/functions_worker.yml
+  fi
+
+  if [[ "${supervisord_component}" == "global-zk" ]]; then
+    bin/generate-zookeeper-config.sh conf/global_zookeeper.conf
+  elif [[ "${supervisord_component}" == "local-zk" ]]; then
+    bin/generate-zookeeper-config.sh conf/zookeeper.conf
+  fi
+
+  if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/${supervisord_component}.conf
+  fi
+
+  exec /usr/bin/supervisord -c /etc/supervisord.conf
+}
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/scripts/run-bookie.sh b/tests/docker-images/latest-version-image/scripts/run-bookie.sh
index e454e66764..e12e316e30 100755
--- a/tests/docker-images/latest-version-image/scripts/run-bookie.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-bookie.sh
@@ -1,33 +1,33 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-# sets dbStorage_writeCacheMaxSizeMb and dbStorage_readAheadCacheMaxSizeMb if not already defined
-export dbStorage_writeCacheMaxSizeMb="${dbStorage_writeCacheMaxSizeMb:-16}"
-export dbStorage_readAheadCacheMaxSizeMb="${dbStorage_readAheadCacheMaxSizeMb:-16}"
-
-bin/apply-config-from-env.py conf/bookkeeper.conf && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/bookie.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
-
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+# sets dbStorage_writeCacheMaxSizeMb and dbStorage_readAheadCacheMaxSizeMb if not already defined
+export dbStorage_writeCacheMaxSizeMb="${dbStorage_writeCacheMaxSizeMb:-16}"
+export dbStorage_readAheadCacheMaxSizeMb="${dbStorage_readAheadCacheMaxSizeMb:-16}"
+
+bin/apply-config-from-env.py conf/bookkeeper.conf && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/bookie.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
+
diff --git a/tests/docker-images/latest-version-image/scripts/run-broker.sh b/tests/docker-images/latest-version-image/scripts/run-broker.sh
index 4f89f145f2..e4473a9487 100755
--- a/tests/docker-images/latest-version-image/scripts/run-broker.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-broker.sh
@@ -1,29 +1,29 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-bin/apply-config-from-env.py conf/broker.conf && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/broker.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
-
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+bin/apply-config-from-env.py conf/broker.conf && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/broker.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
+
diff --git a/tests/docker-images/latest-version-image/scripts/run-functions-worker.sh b/tests/docker-images/latest-version-image/scripts/run-functions-worker.sh
index cd9d7593db..2c0ceb7a3f 100755
--- a/tests/docker-images/latest-version-image/scripts/run-functions-worker.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-functions-worker.sh
@@ -1,30 +1,30 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-bin/apply-config-from-env.py conf/client.conf && \
-    bin/gen-yml-from-env.py conf/functions_worker.yml && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/functions_worker.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
-
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+bin/apply-config-from-env.py conf/client.conf && \
+    bin/gen-yml-from-env.py conf/functions_worker.yml && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/functions_worker.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
+
diff --git a/tests/docker-images/latest-version-image/scripts/run-global-zk.sh b/tests/docker-images/latest-version-image/scripts/run-global-zk.sh
index 783ef2d468..abebac3a8b 100755
--- a/tests/docker-images/latest-version-image/scripts/run-global-zk.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-global-zk.sh
@@ -1,29 +1,29 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-bin/apply-config-from-env.py conf/zookeeper.conf && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh && \
-    bin/generate-zookeeper-config.sh conf/global_zookeeper.conf
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/global-zk.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+bin/apply-config-from-env.py conf/zookeeper.conf && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh && \
+    bin/generate-zookeeper-config.sh conf/global_zookeeper.conf
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/global-zk.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
diff --git a/tests/docker-images/latest-version-image/scripts/run-local-zk.sh b/tests/docker-images/latest-version-image/scripts/run-local-zk.sh
index b27212b6ba..28ddbd1d4b 100755
--- a/tests/docker-images/latest-version-image/scripts/run-local-zk.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-local-zk.sh
@@ -1,29 +1,29 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-bin/apply-config-from-env.py conf/zookeeper.conf && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh && \
-    bin/generate-zookeeper-config.sh conf/zookeeper.conf
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/local-zk.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+bin/apply-config-from-env.py conf/zookeeper.conf && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh && \
+    bin/generate-zookeeper-config.sh conf/zookeeper.conf
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/local-zk.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
diff --git a/tests/docker-images/latest-version-image/scripts/run-proxy.sh b/tests/docker-images/latest-version-image/scripts/run-proxy.sh
index f44ed0bb65..d8c6f21436 100755
--- a/tests/docker-images/latest-version-image/scripts/run-proxy.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-proxy.sh
@@ -1,28 +1,28 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-bin/apply-config-from-env.py conf/proxy.conf && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/proxy.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+bin/apply-config-from-env.py conf/proxy.conf && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/proxy.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
diff --git a/tests/docker-images/latest-version-image/scripts/run-standalone.sh b/tests/docker-images/latest-version-image/scripts/run-standalone.sh
index c29f2ea91e..89f56bc6ca 100755
--- a/tests/docker-images/latest-version-image/scripts/run-standalone.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-standalone.sh
@@ -1,21 +1,21 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
 bin/pulsar standalone
\ No newline at end of file
diff --git a/tests/docker-images/latest-version-image/scripts/run-websocket.sh b/tests/docker-images/latest-version-image/scripts/run-websocket.sh
index 34e4b9016a..0563722465 100755
--- a/tests/docker-images/latest-version-image/scripts/run-websocket.sh
+++ b/tests/docker-images/latest-version-image/scripts/run-websocket.sh
@@ -1,28 +1,28 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-bin/apply-config-from-env.py conf/websocket.conf && \
-    bin/apply-config-from-env.py conf/pulsar_env.sh
-
-if [ -z "$NO_AUTOSTART" ]; then
-    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/websocket.conf
-fi
-
-exec /usr/bin/supervisord -c /etc/supervisord.conf
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+bin/apply-config-from-env.py conf/websocket.conf && \
+    bin/apply-config-from-env.py conf/pulsar_env.sh
+
+if [ -z "$NO_AUTOSTART" ]; then
+    sed -i 's/autostart=.*/autostart=true/' /etc/supervisord/conf.d/websocket.conf
+fi
+
+exec /usr/bin/supervisord -c /etc/supervisord.conf
diff --git a/tests/docker-images/pom.xml b/tests/docker-images/pom.xml
index 1d42d2b9bb..036a25ab1b 100644
--- a/tests/docker-images/pom.xml
+++ b/tests/docker-images/pom.xml
@@ -1,71 +1,71 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
-         xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-  <packaging>pom</packaging>
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.apache.pulsar.tests</groupId>
-    <artifactId>tests-parent</artifactId>
-    <version>4.1.2</version>
-  </parent>
-  <artifactId>docker-images</artifactId>
-  <name>Apache Pulsar :: Tests :: Docker Images</name>
-  <profiles>
-    <profile>
-      <id>skipDocker</id>
-      <activation>
-        <property>
-          <name>skipDocker</name>
-        </property>
-      </activation>
-      <modules/>
-    </profile>
-    <profile>
-      <id>docker</id>
-      <activation>
-        <activeByDefault>true</activeByDefault>
-      </activation>
-      <modules>
-        <module>java-test-functions</module>
-        <module>java-test-plugins</module>
-        <module>latest-version-image</module>
-        <module>java-test-image</module>
-      </modules>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>pl.project13.maven</groupId>
-            <artifactId>git-commit-id-plugin</artifactId>
-            <configuration>
-              <skip>false</skip>
-              <injectAllReactorProjects>true</injectAllReactorProjects>
-              <runOnlyOnce>true</runOnlyOnce>
-              <skipPoms>false</skipPoms>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
+         xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+  <packaging>pom</packaging>
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.pulsar.tests</groupId>
+    <artifactId>tests-parent</artifactId>
+    <version>4.1.2</version>
+  </parent>
+  <artifactId>docker-images</artifactId>
+  <name>Apache Pulsar :: Tests :: Docker Images</name>
+  <profiles>
+    <profile>
+      <id>skipDocker</id>
+      <activation>
+        <property>
+          <name>skipDocker</name>
+        </property>
+      </activation>
+      <modules/>
+    </profile>
+    <profile>
+      <id>docker</id>
+      <activation>
+        <activeByDefault>true</activeByDefault>
+      </activation>
+      <modules>
+        <module>java-test-functions</module>
+        <module>java-test-plugins</module>
+        <module>latest-version-image</module>
+        <module>java-test-image</module>
+      </modules>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>pl.project13.maven</groupId>
+            <artifactId>git-commit-id-plugin</artifactId>
+            <configuration>
+              <skip>false</skip>
+              <injectAllReactorProjects>true</injectAllReactorProjects>
+              <runOnlyOnce>true</runOnlyOnce>
+              <skipPoms>false</skipPoms>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/tests/integration/pom.xml b/tests/integration/pom.xml
index 850e9796a8..ba8752e2fb 100644
--- a/tests/integration/pom.xml
+++ b/tests/integration/pom.xml
@@ -1,362 +1,362 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.apache.pulsar.tests</groupId>
-    <artifactId>tests-parent</artifactId>
-    <version>4.1.2</version>
-  </parent>
-
-  <artifactId>integration</artifactId>
-  <packaging>jar</packaging>
-  <name>Apache Pulsar :: Tests :: Integration</name>
-
-  <properties>
-    <integrationTestSuiteFile>pulsar.xml</integrationTestSuiteFile>
-    <mongo-reactivestreams.version>5.2.0</mongo-reactivestreams.version>
-  </properties>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-functions-api-examples</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-broker</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-broker-common</artifactId>
-      <version>${project.version}</version>
-      <type>test-jar</type>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-common</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-client-original</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-client-admin-original</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-proxy</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>managed-ledger</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.datastax.cassandra</groupId>
-      <artifactId>cassandra-driver-core</artifactId>
-      <exclusions>
-        <exclusion>
-          <groupId>io.netty</groupId>
-          <artifactId>netty-handler</artifactId>
-        </exclusion>
-      </exclusions>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.testcontainers</groupId>
-      <artifactId>kafka</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-io-kafka</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>dev.failsafe</groupId>
-      <artifactId>failsafe</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.testcontainers</groupId>
-      <artifactId>mysql</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.postgresql</groupId>
-      <artifactId>postgresql</artifactId>
-      <version>${postgresql-jdbc.version}</version>
-      <scope>runtime</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.testcontainers</groupId>
-      <artifactId>postgresql</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.github.docker-java</groupId>
-      <artifactId>docker-java-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcpkix-jdk18on</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.apache.pulsar</groupId>
-      <artifactId>pulsar-io-jdbc-postgres</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.fasterxml.jackson.core</groupId>
-      <artifactId>jackson-databind</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.fasterxml.jackson.dataformat</groupId>
-      <artifactId>jackson-dataformat-yaml</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.opensearch.client</groupId>
-      <artifactId>opensearch-rest-high-level-client</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>co.elastic.clients</groupId>
-      <artifactId>elasticsearch-java</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.testcontainers</groupId>
-      <artifactId>elasticsearch</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>com.rabbitmq</groupId>
-      <artifactId>amqp-client</artifactId>
-      <version>${rabbitmq-client.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>joda-time</groupId>
-      <artifactId>joda-time</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>org.awaitility</groupId>
-      <artifactId>awaitility</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>io.rest-assured</groupId>
-      <artifactId>rest-assured</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-<!--    kinesis-->
-    <dependency>
-      <groupId>org.testcontainers</groupId>
-      <artifactId>localstack</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>software.amazon.kinesis</groupId>
-      <artifactId>amazon-kinesis-client</artifactId>
-      <version>3.1.2</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.amazonaws</groupId>
-      <artifactId>aws-java-sdk-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-
-    <!-- mongodb -->
-    <dependency>
-      <groupId>org.testcontainers</groupId>
-      <artifactId>mongodb</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mongodb</groupId>
-      <artifactId>mongodb-driver-reactivestreams</artifactId>
-      <version>${mongo-reactivestreams.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <executions>
-          <execution>
-            <goals>
-              <goal>test-jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <executions>
-          <execution>
-            <id>checkstyle</id>
-            <phase>verify</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-surefire-plugin</artifactId>
-        <configuration>
-          <!-- only run tests when -DintegrationTests is specified //-->
-          <skipTests>true</skipTests>
-          <systemPropertyVariables>
-            <currentVersion>${project.version}</currentVersion>
-            <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-          </systemPropertyVariables>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-
-  <profiles>
-    <profile>
-      <id>integrationTests</id>
-      <activation>
-        <property>
-          <name>integrationTests</name>
-        </property>
-      </activation>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-surefire-plugin</artifactId>
-            <configuration>
-              <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx1G -XX:MaxDirectMemorySize=1G
-              -Dconfluent.version=${confluent.version} -Djacoco.version=${jacoco-maven-plugin.version}
-              -Dintegrationtest.coverage.enabled=${integrationtest.coverage.enabled} -Dintegrationtest.coverage.dir=${integrationtest.coverage.dir}
-              ${test.additional.args}
-              </argLine>
-              <skipTests>false</skipTests>
-              <suiteXmlFiles>
-                <file>src/test/resources/${integrationTestSuiteFile}</file>
-              </suiteXmlFiles>
-              <forkCount>1</forkCount>
-            </configuration>
-          </plugin>
-          <plugin>
-            <artifactId>maven-resources-plugin</artifactId>
-            <executions>
-              <execution>
-                <id>copy-pulsar-certificate-authority-resources</id>
-                <phase>generate-test-resources</phase>
-                <goals>
-                  <goal>copy-resources</goal>
-                </goals>
-                <configuration>
-                  <outputDirectory>${project.build.testOutputDirectory}/certificate-authority</outputDirectory>
-                  <resources>
-                    <resource>
-                      <directory>${project.parent.basedir}/certificate-authority</directory>
-                      <filtering>false</filtering>
-                    </resource>
-                  </resources>
-                </configuration>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>apache-release</id>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-surefire-plugin</artifactId>
-            <configuration>
-              <skipTests>true</skipTests>
-            </configuration>
-          </plugin>
-          <plugin>
-            <groupId>org.apache.maven.plugins</groupId>
-            <artifactId>maven-deploy-plugin</artifactId>
-            <configuration>
-              <skip>${maven.deploy.skip}</skip>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.pulsar.tests</groupId>
+    <artifactId>tests-parent</artifactId>
+    <version>4.1.2</version>
+  </parent>
+
+  <artifactId>integration</artifactId>
+  <packaging>jar</packaging>
+  <name>Apache Pulsar :: Tests :: Integration</name>
+
+  <properties>
+    <integrationTestSuiteFile>pulsar.xml</integrationTestSuiteFile>
+    <mongo-reactivestreams.version>5.2.0</mongo-reactivestreams.version>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-functions-api-examples</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-broker</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-broker-common</artifactId>
+      <version>${project.version}</version>
+      <type>test-jar</type>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-common</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-client-original</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-client-admin-original</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-proxy</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>managed-ledger</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.datastax.cassandra</groupId>
+      <artifactId>cassandra-driver-core</artifactId>
+      <exclusions>
+        <exclusion>
+          <groupId>io.netty</groupId>
+          <artifactId>netty-handler</artifactId>
+        </exclusion>
+      </exclusions>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.testcontainers</groupId>
+      <artifactId>kafka</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-io-kafka</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>dev.failsafe</groupId>
+      <artifactId>failsafe</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.testcontainers</groupId>
+      <artifactId>mysql</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.postgresql</groupId>
+      <artifactId>postgresql</artifactId>
+      <version>${postgresql-jdbc.version}</version>
+      <scope>runtime</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.testcontainers</groupId>
+      <artifactId>postgresql</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.github.docker-java</groupId>
+      <artifactId>docker-java-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcpkix-jdk18on</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.pulsar</groupId>
+      <artifactId>pulsar-io-jdbc-postgres</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.fasterxml.jackson.core</groupId>
+      <artifactId>jackson-databind</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.fasterxml.jackson.dataformat</groupId>
+      <artifactId>jackson-dataformat-yaml</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.opensearch.client</groupId>
+      <artifactId>opensearch-rest-high-level-client</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>co.elastic.clients</groupId>
+      <artifactId>elasticsearch-java</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.testcontainers</groupId>
+      <artifactId>elasticsearch</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>com.rabbitmq</groupId>
+      <artifactId>amqp-client</artifactId>
+      <version>${rabbitmq-client.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>joda-time</groupId>
+      <artifactId>joda-time</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.awaitility</groupId>
+      <artifactId>awaitility</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>io.rest-assured</groupId>
+      <artifactId>rest-assured</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+<!--    kinesis-->
+    <dependency>
+      <groupId>org.testcontainers</groupId>
+      <artifactId>localstack</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>software.amazon.kinesis</groupId>
+      <artifactId>amazon-kinesis-client</artifactId>
+      <version>3.1.2</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.amazonaws</groupId>
+      <artifactId>aws-java-sdk-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- mongodb -->
+    <dependency>
+      <groupId>org.testcontainers</groupId>
+      <artifactId>mongodb</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mongodb</groupId>
+      <artifactId>mongodb-driver-reactivestreams</artifactId>
+      <version>${mongo-reactivestreams.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>test-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>checkstyle</id>
+            <phase>verify</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <configuration>
+          <!-- only run tests when -DintegrationTests is specified //-->
+          <skipTests>true</skipTests>
+          <systemPropertyVariables>
+            <currentVersion>${project.version}</currentVersion>
+            <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+          </systemPropertyVariables>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+
+  <profiles>
+    <profile>
+      <id>integrationTests</id>
+      <activation>
+        <property>
+          <name>integrationTests</name>
+        </property>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx1G -XX:MaxDirectMemorySize=1G
+              -Dconfluent.version=${confluent.version} -Djacoco.version=${jacoco-maven-plugin.version}
+              -Dintegrationtest.coverage.enabled=${integrationtest.coverage.enabled} -Dintegrationtest.coverage.dir=${integrationtest.coverage.dir}
+              ${test.additional.args}
+              </argLine>
+              <skipTests>false</skipTests>
+              <suiteXmlFiles>
+                <file>src/test/resources/${integrationTestSuiteFile}</file>
+              </suiteXmlFiles>
+              <forkCount>1</forkCount>
+            </configuration>
+          </plugin>
+          <plugin>
+            <artifactId>maven-resources-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>copy-pulsar-certificate-authority-resources</id>
+                <phase>generate-test-resources</phase>
+                <goals>
+                  <goal>copy-resources</goal>
+                </goals>
+                <configuration>
+                  <outputDirectory>${project.build.testOutputDirectory}/certificate-authority</outputDirectory>
+                  <resources>
+                    <resource>
+                      <directory>${project.parent.basedir}/certificate-authority</directory>
+                      <filtering>false</filtering>
+                    </resource>
+                  </resources>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+    <profile>
+      <id>apache-release</id>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <skipTests>true</skipTests>
+            </configuration>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-deploy-plugin</artifactId>
+            <configuration>
+              <skip>${maven.deploy.skip}</skip>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/admin/AdminTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/admin/AdminTest.java
index 83222b2cdf..f40426dce5 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/admin/AdminTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/admin/AdminTest.java
@@ -1,74 +1,74 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.admin;
-
-import static org.testng.Assert.assertNotNull;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.policies.data.PersistentTopicInternalStats;
-import org.apache.pulsar.tests.integration.messaging.MessagingBase;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * Integration tests for Pulsar Admin.
- */
-@Slf4j
-public class AdminTest extends MessagingBase {
-
-    @Test(dataProvider = "ServiceAndAdminUrls")
-    public void testUnderReplicatedState(Supplier<String> serviceUrl, Supplier<String> adminUrl) throws Exception {
-
-        String topicName = getNonPartitionedTopic("replicated-state", true);
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(adminUrl.get())
-                .build();
-
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl.get())
-                .build();
-
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .create();
-
-        for (int i = 0; i < 10; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-
-        log.info("Successfully to publish 10 messages to {}", topicName);
-        PersistentTopicInternalStats stats = admin.topics().getInternalStats(topicName);
-        Assert.assertTrue(stats.ledgers.size() > 0);
-        for (PersistentTopicInternalStats.LedgerInfo ledger : stats.ledgers) {
-            Assert.assertFalse(ledger.underReplicated);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.admin;
+
+import static org.testng.Assert.assertNotNull;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.policies.data.PersistentTopicInternalStats;
+import org.apache.pulsar.tests.integration.messaging.MessagingBase;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * Integration tests for Pulsar Admin.
+ */
+@Slf4j
+public class AdminTest extends MessagingBase {
+
+    @Test(dataProvider = "ServiceAndAdminUrls")
+    public void testUnderReplicatedState(Supplier<String> serviceUrl, Supplier<String> adminUrl) throws Exception {
+
+        String topicName = getNonPartitionedTopic("replicated-state", true);
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(adminUrl.get())
+                .build();
+
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl.get())
+                .build();
+
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .create();
+
+        for (int i = 0; i < 10; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+
+        log.info("Successfully to publish 10 messages to {}", topicName);
+        PersistentTopicInternalStats stats = admin.topics().getInternalStats(topicName);
+        Assert.assertTrue(stats.ledgers.size() > 0);
+        for (PersistentTopicInternalStats.LedgerInfo ledger : stats.ledgers) {
+            Assert.assertFalse(ledger.underReplicated);
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/PulsarTokenAuthenticationBaseSuite.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/PulsarTokenAuthenticationBaseSuite.java
index 8538b60a1f..aa6d78cb9c 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/PulsarTokenAuthenticationBaseSuite.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/PulsarTokenAuthenticationBaseSuite.java
@@ -1,394 +1,394 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.auth.token;
-
-import static java.util.stream.Collectors.joining;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.concurrent.TimeUnit;
-import java.util.stream.Stream;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.AuthenticationFactory;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.impl.auth.AuthenticationToken;
-import org.apache.pulsar.common.policies.data.AuthAction;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.ProxyContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.containers.ZKContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testcontainers.containers.Network;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-@Slf4j
-public abstract class PulsarTokenAuthenticationBaseSuite extends PulsarClusterTestBase {
-
-    protected String superUserAuthToken;
-    protected String proxyAuthToken;
-    protected String clientAuthToken;
-
-    protected abstract void createKeysAndTokens(PulsarContainer<?> container) throws Exception;
-    protected abstract void configureBroker(BrokerContainer brokerContainer) throws Exception;
-    protected abstract void configureProxy(ProxyContainer proxyContainer) throws Exception;
-
-    protected abstract String createClientTokenWithExpiry(long expiryTime, TimeUnit unit) throws Exception;
-
-    protected static final String SUPER_USER_ROLE = "super-user";
-    protected static final String PROXY_ROLE = "proxy";
-    protected static final String REGULAR_USER_ROLE = "client";
-
-    protected ZKContainer cmdContainer;
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public final void setupCluster() throws Exception {
-        incrementSetupNumber();
-        // Before starting the cluster, generate the secret key and the token
-        // Use Zk container to have 1 container available before starting the cluster
-        this.cmdContainer = new ZKContainer("cli-setup");
-        cmdContainer
-                .withNetwork(Network.newNetwork())
-                .withNetworkAliases(ZKContainer.NAME)
-                .withEnv("zkServers", ZKContainer.NAME);
-        cmdContainer.start();
-
-        createKeysAndTokens(cmdContainer);
-
-        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
-                .filter(s -> s != null && !s.isEmpty())
-                .collect(joining("-"));
-
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .numBookies(2)
-                .numBrokers(2)
-                .numProxies(1)
-                .clusterName(clusterName)
-                .build();
-
-        log.info("Setting up cluster {} with token authentication  and {} bookies, {} brokers",
-                spec.clusterName(), spec.numBookies(), spec.numBrokers());
-
-        pulsarCluster = PulsarCluster.forSpec(spec);
-
-        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
-            configureBroker(brokerContainer);
-            brokerContainer.withEnv("authenticationEnabled", "true");
-            brokerContainer.withEnv("authenticationProviders",
-                    "org.apache.pulsar.broker.authentication.AuthenticationProviderToken");
-            brokerContainer.withEnv("authorizationEnabled", "true");
-            brokerContainer.withEnv("superUserRoles", SUPER_USER_ROLE + "," + PROXY_ROLE);
-            brokerContainer.withEnv("brokerClientAuthenticationPlugin", AuthenticationToken.class.getName());
-            brokerContainer.withEnv("brokerClientAuthenticationParameters", "token:" + superUserAuthToken);
-            brokerContainer.withEnv("authenticationRefreshCheckSeconds", "1");
-            brokerContainer.withEnv("authenticateOriginalAuthData", "true");
-        }
-
-        ProxyContainer proxyContainer = pulsarCluster.getProxy();
-        configureProxy(proxyContainer);
-        proxyContainer.withEnv("authenticationEnabled", "true");
-        proxyContainer.withEnv("authenticationProviders",
-                "org.apache.pulsar.broker.authentication.AuthenticationProviderToken");
-        proxyContainer.withEnv("authorizationEnabled", "true");
-        proxyContainer.withEnv("brokerClientAuthenticationPlugin", AuthenticationToken.class.getName());
-        proxyContainer.withEnv("brokerClientAuthenticationParameters", "token:" + proxyAuthToken);
-        proxyContainer.withEnv("forwardAuthorizationCredentials", "true");
-
-        pulsarCluster.start();
-
-        log.info("Cluster {} is setup", spec.clusterName());
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    public final void tearDownCluster() throws Exception {
-        super.tearDownCluster();
-        cmdContainer.close();
-    }
-
-    @Test
-    public void testPublishWithTokenAuth() throws Exception {
-        final String tenant = "token-test-tenant" + randomName(4);
-        final String namespace = tenant + "/ns-1";
-        final String topic = "persistent://" + namespace + "/topic-1";
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-                .authentication(AuthenticationFactory.token(superUserAuthToken))
-                .build();
-
-        try {
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
-                        Collections.singleton(pulsarCluster.getClusterName())));
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE, EnumSet.allOf(AuthAction.class));
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .authentication(AuthenticationFactory.token(clientAuthToken))
-                .build();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topic)
-                .create();
-
-        @Cleanup
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topic)
-                .subscriptionName("my-sub")
-                .subscribe();
-
-        final int numMessages = 10;
-
-        for (int i = 0; i < numMessages; i++) {
-            producer.send("hello-" + i);
-        }
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<String> msg = consumer.receive();
-            assertEquals(msg.getValue(), "hello-" + i);
-
-            consumer.acknowledge(msg);
-        }
-
-        // Test client with no auth and expect it to fail
-        @Cleanup
-        PulsarClient clientNoAuth = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        try {
-            clientNoAuth.newProducer(Schema.STRING).topic(topic)
-                    .create();
-            fail("Should have failed to create producer");
-        } catch (PulsarClientException e) {
-            // Expected
-        }
-    }
-
-    @Test
-    public void testProxyRedirectWithTokenAuth() throws Exception {
-
-        final String tenant = "token-test-tenant" + randomName(4);
-        final String namespace = tenant + "/ns-1";
-        final String topic = namespace + "/my-topic-1";
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-                .authentication(AuthenticationFactory.token(superUserAuthToken))
-                .build();
-
-        try {
-            admin.tenants().createTenant(tenant,
-                    new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
-                            Collections.singleton(pulsarCluster.getClusterName())));
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE,
-                EnumSet.allOf(AuthAction.class));
-
-        admin.topics().createPartitionedTopic(topic, 16);
-
-        // Create the partitions
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .authentication(AuthenticationFactory.token(REGULAR_USER_ROLE))
-                .build();
-
-        // Force the topics to be created
-        client.newProducer()
-                .topic(topic)
-                .create()
-                .close();
-
-        admin.topics().getList(namespace);
-
-        // Test multiple stats request to make sure the proxy will try against all brokers and receive 307
-        // responses that it will handle internally.
-        for (int i = 0; i < 10; i++) {
-            admin.topics().getStats(topic);
-        }
-    }
-
-    @DataProvider(name = "shouldRefreshToken")
-    public static Object[][] shouldRefreshToken() {
-        return new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } };
-    }
-
-    @Test(dataProvider = "shouldRefreshToken")
-    public void testExpiringToken(boolean shouldRefreshToken) throws Exception {
-        final String tenant = "token-test-tenant" + randomName(4);
-        final String namespace = tenant + "/ns-1";
-        final String topic = "persistent://" + namespace + "/topic-1";
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-                .authentication(AuthenticationFactory.token(superUserAuthToken))
-                .build();
-
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
-                        Collections.singleton(pulsarCluster.getClusterName())));
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE, EnumSet.allOf(AuthAction.class));
-
-        String initialToken = this.createClientTokenWithExpiry(5, TimeUnit.SECONDS);
-        String refreshedToken = this.createClientTokenWithExpiry(30, TimeUnit.SECONDS);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .authentication(AuthenticationFactory.token(() -> {
-                    if (shouldRefreshToken) {
-                        try {
-                            return refreshedToken;
-                        } catch (Exception e) {
-                            return null;
-                        }
-                    } else {
-                        return initialToken;
-                    }
-                }))
-                .build();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topic)
-                .sendTimeout(3, TimeUnit.SECONDS)
-                .create();
-        // Initially the token is valid and producer will be able to publish
-        producer.send("hello-1");
-        long lastDisconnectedTimestamp = producer.getLastDisconnectedTimestamp();
-
-        Thread.sleep(TimeUnit.SECONDS.toMillis(10));
-
-        if (shouldRefreshToken) {
-            // The token will have been refreshed, so the app won't see any error
-            producer.send("hello-2");
-            long timestamp = producer.getLastDisconnectedTimestamp();
-            assertEquals(timestamp, lastDisconnectedTimestamp);
-        } else {
-            // The token has expired, so this next message will be rejected
-            try {
-                producer.send("hello-2");
-                fail("Publish should have failed");
-            } catch (PulsarClientException e) {
-                // Expected
-            }
-        }
-    }
-
-    @Test
-    public void testExpiringTokenWithRefreshAndProducerRestart() throws Exception {
-        final String tenant = "token-expiry-test-tenant" + randomName(4);
-        final String namespace = tenant + "/ns-1";
-        final String topic = "persistent://" + namespace + "/topic-1";
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-                .authentication(AuthenticationFactory.token(superUserAuthToken))
-                .build();
-
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
-                        Collections.singleton(pulsarCluster.getClusterName())));
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE, EnumSet.allOf(AuthAction.class));
-
-        final int tokenExpiryTimeSecs = 2;
-        String initialToken = this.createClientTokenWithExpiry(tokenExpiryTimeSecs, TimeUnit.SECONDS);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .authentication(AuthenticationFactory.token(() -> {
-                    try {
-                        return createClientTokenWithExpiry(tokenExpiryTimeSecs, TimeUnit.SECONDS);
-                    } catch (Exception e) {
-                        return null;
-                    }
-                }))
-                .build();
-
-        Producer<String> producer1 = client.newProducer(Schema.STRING)
-                .topic(topic)
-                .sendTimeout(1, TimeUnit.SECONDS)
-                .create();
-
-        // Initially the token is valid and producer will be able to publish
-        producer1.send("hello-1");
-
-        producer1.close();
-
-        Thread.sleep(TimeUnit.SECONDS.toMillis(tokenExpiryTimeSecs));
-
-        @Cleanup
-        Producer<String> producer2 = client.newProducer(Schema.STRING)
-                    .topic(topic)
-                    .sendTimeout(1, TimeUnit.SECONDS)
-                    .create();
-    }
-
-    @Test
-    public void testAuthenticationFailedImmediately() throws PulsarClientException {
-        try {
-            @Cleanup
-            PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .authentication(AuthenticationFactory.token("invalid_token"))
-                .build();
-            client.newProducer().topic("test_token_topic" + randomName(4));
-        } catch (PulsarClientException.AuthenticationException pae) {
-            // expected error
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.auth.token;
+
+import static java.util.stream.Collectors.joining;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Stream;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.AuthenticationFactory;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.impl.auth.AuthenticationToken;
+import org.apache.pulsar.common.policies.data.AuthAction;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.ProxyContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.containers.ZKContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testcontainers.containers.Network;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+@Slf4j
+public abstract class PulsarTokenAuthenticationBaseSuite extends PulsarClusterTestBase {
+
+    protected String superUserAuthToken;
+    protected String proxyAuthToken;
+    protected String clientAuthToken;
+
+    protected abstract void createKeysAndTokens(PulsarContainer<?> container) throws Exception;
+    protected abstract void configureBroker(BrokerContainer brokerContainer) throws Exception;
+    protected abstract void configureProxy(ProxyContainer proxyContainer) throws Exception;
+
+    protected abstract String createClientTokenWithExpiry(long expiryTime, TimeUnit unit) throws Exception;
+
+    protected static final String SUPER_USER_ROLE = "super-user";
+    protected static final String PROXY_ROLE = "proxy";
+    protected static final String REGULAR_USER_ROLE = "client";
+
+    protected ZKContainer cmdContainer;
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public final void setupCluster() throws Exception {
+        incrementSetupNumber();
+        // Before starting the cluster, generate the secret key and the token
+        // Use Zk container to have 1 container available before starting the cluster
+        this.cmdContainer = new ZKContainer("cli-setup");
+        cmdContainer
+                .withNetwork(Network.newNetwork())
+                .withNetworkAliases(ZKContainer.NAME)
+                .withEnv("zkServers", ZKContainer.NAME);
+        cmdContainer.start();
+
+        createKeysAndTokens(cmdContainer);
+
+        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
+                .filter(s -> s != null && !s.isEmpty())
+                .collect(joining("-"));
+
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .numBookies(2)
+                .numBrokers(2)
+                .numProxies(1)
+                .clusterName(clusterName)
+                .build();
+
+        log.info("Setting up cluster {} with token authentication  and {} bookies, {} brokers",
+                spec.clusterName(), spec.numBookies(), spec.numBrokers());
+
+        pulsarCluster = PulsarCluster.forSpec(spec);
+
+        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
+            configureBroker(brokerContainer);
+            brokerContainer.withEnv("authenticationEnabled", "true");
+            brokerContainer.withEnv("authenticationProviders",
+                    "org.apache.pulsar.broker.authentication.AuthenticationProviderToken");
+            brokerContainer.withEnv("authorizationEnabled", "true");
+            brokerContainer.withEnv("superUserRoles", SUPER_USER_ROLE + "," + PROXY_ROLE);
+            brokerContainer.withEnv("brokerClientAuthenticationPlugin", AuthenticationToken.class.getName());
+            brokerContainer.withEnv("brokerClientAuthenticationParameters", "token:" + superUserAuthToken);
+            brokerContainer.withEnv("authenticationRefreshCheckSeconds", "1");
+            brokerContainer.withEnv("authenticateOriginalAuthData", "true");
+        }
+
+        ProxyContainer proxyContainer = pulsarCluster.getProxy();
+        configureProxy(proxyContainer);
+        proxyContainer.withEnv("authenticationEnabled", "true");
+        proxyContainer.withEnv("authenticationProviders",
+                "org.apache.pulsar.broker.authentication.AuthenticationProviderToken");
+        proxyContainer.withEnv("authorizationEnabled", "true");
+        proxyContainer.withEnv("brokerClientAuthenticationPlugin", AuthenticationToken.class.getName());
+        proxyContainer.withEnv("brokerClientAuthenticationParameters", "token:" + proxyAuthToken);
+        proxyContainer.withEnv("forwardAuthorizationCredentials", "true");
+
+        pulsarCluster.start();
+
+        log.info("Cluster {} is setup", spec.clusterName());
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    public final void tearDownCluster() throws Exception {
+        super.tearDownCluster();
+        cmdContainer.close();
+    }
+
+    @Test
+    public void testPublishWithTokenAuth() throws Exception {
+        final String tenant = "token-test-tenant" + randomName(4);
+        final String namespace = tenant + "/ns-1";
+        final String topic = "persistent://" + namespace + "/topic-1";
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+                .authentication(AuthenticationFactory.token(superUserAuthToken))
+                .build();
+
+        try {
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
+                        Collections.singleton(pulsarCluster.getClusterName())));
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE, EnumSet.allOf(AuthAction.class));
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .authentication(AuthenticationFactory.token(clientAuthToken))
+                .build();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topic)
+                .create();
+
+        @Cleanup
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topic)
+                .subscriptionName("my-sub")
+                .subscribe();
+
+        final int numMessages = 10;
+
+        for (int i = 0; i < numMessages; i++) {
+            producer.send("hello-" + i);
+        }
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<String> msg = consumer.receive();
+            assertEquals(msg.getValue(), "hello-" + i);
+
+            consumer.acknowledge(msg);
+        }
+
+        // Test client with no auth and expect it to fail
+        @Cleanup
+        PulsarClient clientNoAuth = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        try {
+            clientNoAuth.newProducer(Schema.STRING).topic(topic)
+                    .create();
+            fail("Should have failed to create producer");
+        } catch (PulsarClientException e) {
+            // Expected
+        }
+    }
+
+    @Test
+    public void testProxyRedirectWithTokenAuth() throws Exception {
+
+        final String tenant = "token-test-tenant" + randomName(4);
+        final String namespace = tenant + "/ns-1";
+        final String topic = namespace + "/my-topic-1";
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+                .authentication(AuthenticationFactory.token(superUserAuthToken))
+                .build();
+
+        try {
+            admin.tenants().createTenant(tenant,
+                    new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
+                            Collections.singleton(pulsarCluster.getClusterName())));
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE,
+                EnumSet.allOf(AuthAction.class));
+
+        admin.topics().createPartitionedTopic(topic, 16);
+
+        // Create the partitions
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .authentication(AuthenticationFactory.token(REGULAR_USER_ROLE))
+                .build();
+
+        // Force the topics to be created
+        client.newProducer()
+                .topic(topic)
+                .create()
+                .close();
+
+        admin.topics().getList(namespace);
+
+        // Test multiple stats request to make sure the proxy will try against all brokers and receive 307
+        // responses that it will handle internally.
+        for (int i = 0; i < 10; i++) {
+            admin.topics().getStats(topic);
+        }
+    }
+
+    @DataProvider(name = "shouldRefreshToken")
+    public static Object[][] shouldRefreshToken() {
+        return new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } };
+    }
+
+    @Test(dataProvider = "shouldRefreshToken")
+    public void testExpiringToken(boolean shouldRefreshToken) throws Exception {
+        final String tenant = "token-test-tenant" + randomName(4);
+        final String namespace = tenant + "/ns-1";
+        final String topic = "persistent://" + namespace + "/topic-1";
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+                .authentication(AuthenticationFactory.token(superUserAuthToken))
+                .build();
+
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
+                        Collections.singleton(pulsarCluster.getClusterName())));
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE, EnumSet.allOf(AuthAction.class));
+
+        String initialToken = this.createClientTokenWithExpiry(5, TimeUnit.SECONDS);
+        String refreshedToken = this.createClientTokenWithExpiry(30, TimeUnit.SECONDS);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .authentication(AuthenticationFactory.token(() -> {
+                    if (shouldRefreshToken) {
+                        try {
+                            return refreshedToken;
+                        } catch (Exception e) {
+                            return null;
+                        }
+                    } else {
+                        return initialToken;
+                    }
+                }))
+                .build();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topic)
+                .sendTimeout(3, TimeUnit.SECONDS)
+                .create();
+        // Initially the token is valid and producer will be able to publish
+        producer.send("hello-1");
+        long lastDisconnectedTimestamp = producer.getLastDisconnectedTimestamp();
+
+        Thread.sleep(TimeUnit.SECONDS.toMillis(10));
+
+        if (shouldRefreshToken) {
+            // The token will have been refreshed, so the app won't see any error
+            producer.send("hello-2");
+            long timestamp = producer.getLastDisconnectedTimestamp();
+            assertEquals(timestamp, lastDisconnectedTimestamp);
+        } else {
+            // The token has expired, so this next message will be rejected
+            try {
+                producer.send("hello-2");
+                fail("Publish should have failed");
+            } catch (PulsarClientException e) {
+                // Expected
+            }
+        }
+    }
+
+    @Test
+    public void testExpiringTokenWithRefreshAndProducerRestart() throws Exception {
+        final String tenant = "token-expiry-test-tenant" + randomName(4);
+        final String namespace = tenant + "/ns-1";
+        final String topic = "persistent://" + namespace + "/topic-1";
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+                .authentication(AuthenticationFactory.token(superUserAuthToken))
+                .build();
+
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(Collections.singleton(REGULAR_USER_ROLE),
+                        Collections.singleton(pulsarCluster.getClusterName())));
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+        admin.namespaces().grantPermissionOnNamespace(namespace, REGULAR_USER_ROLE, EnumSet.allOf(AuthAction.class));
+
+        final int tokenExpiryTimeSecs = 2;
+        String initialToken = this.createClientTokenWithExpiry(tokenExpiryTimeSecs, TimeUnit.SECONDS);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .authentication(AuthenticationFactory.token(() -> {
+                    try {
+                        return createClientTokenWithExpiry(tokenExpiryTimeSecs, TimeUnit.SECONDS);
+                    } catch (Exception e) {
+                        return null;
+                    }
+                }))
+                .build();
+
+        Producer<String> producer1 = client.newProducer(Schema.STRING)
+                .topic(topic)
+                .sendTimeout(1, TimeUnit.SECONDS)
+                .create();
+
+        // Initially the token is valid and producer will be able to publish
+        producer1.send("hello-1");
+
+        producer1.close();
+
+        Thread.sleep(TimeUnit.SECONDS.toMillis(tokenExpiryTimeSecs));
+
+        @Cleanup
+        Producer<String> producer2 = client.newProducer(Schema.STRING)
+                    .topic(topic)
+                    .sendTimeout(1, TimeUnit.SECONDS)
+                    .create();
+    }
+
+    @Test
+    public void testAuthenticationFailedImmediately() throws PulsarClientException {
+        try {
+            @Cleanup
+            PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .authentication(AuthenticationFactory.token("invalid_token"))
+                .build();
+            client.newProducer().topic("test_token_topic" + randomName(4));
+        } catch (PulsarClientException.AuthenticationException pae) {
+            // expected error
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithPublicPrivateKeys.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithPublicPrivateKeys.java
index 1ccdf90194..3ca8e0f2d7 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithPublicPrivateKeys.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithPublicPrivateKeys.java
@@ -1,98 +1,98 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.auth.token;
-
-import com.google.common.io.Files;
-import java.io.File;
-import java.util.concurrent.TimeUnit;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.ProxyContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-
-@Slf4j
-public class TokenAuthWithPublicPrivateKeys extends PulsarTokenAuthenticationBaseSuite {
-
-    private static final String PRIVATE_KEY_PATH_INSIDE_CONTAINER = "/tmp/private.key";
-    private static final String PUBLIC_KEY_PATH_INSIDE_CONTAINER = "/tmp/public.key";
-
-    private File publicKeyFile;
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    protected void createKeysAndTokens(PulsarContainer container) throws Exception {
-        container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create-key-pair",
-                        "--output-private-key", PRIVATE_KEY_PATH_INSIDE_CONTAINER,
-                        "--output-public-key", PUBLIC_KEY_PATH_INSIDE_CONTAINER);
-
-        byte[] publicKeyBytes = DockerUtils
-                .runCommandWithRawOutput(container.getDockerClient(), container.getContainerId(),
-                        "/bin/cat", PUBLIC_KEY_PATH_INSIDE_CONTAINER)
-                .getStdout();
-
-        publicKeyFile = File.createTempFile("public-", ".key", new File("/tmp"));
-        Files.write(publicKeyBytes, publicKeyFile);
-
-        clientAuthToken = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
-                        "--subject", REGULAR_USER_ROLE)
-                .getStdout().trim();
-        log.info("Created client token: {}", clientAuthToken);
-
-        superUserAuthToken = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
-                        "--subject", SUPER_USER_ROLE)
-                .getStdout().trim();
-        log.info("Created super-user token: {}", superUserAuthToken);
-
-        proxyAuthToken = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
-                        "--subject", PROXY_ROLE)
-                .getStdout().trim();
-        log.info("Created proxy token: {}", proxyAuthToken);
-    }
-
-    @Override
-    protected void configureBroker(BrokerContainer brokerContainer) throws Exception {
-        brokerContainer.withFileSystemBind(publicKeyFile.toString(), PUBLIC_KEY_PATH_INSIDE_CONTAINER);
-        brokerContainer.withEnv("tokenPublicKey", "file://" + PUBLIC_KEY_PATH_INSIDE_CONTAINER);
-    }
-
-    @Override
-    protected void configureProxy(ProxyContainer proxyContainer) throws Exception {
-        proxyContainer.withFileSystemBind(publicKeyFile.toString(), PUBLIC_KEY_PATH_INSIDE_CONTAINER);
-        proxyContainer.withEnv("tokenPublicKey", "file://" + PUBLIC_KEY_PATH_INSIDE_CONTAINER);
-    }
-
-    @Override
-    protected String createClientTokenWithExpiry(long expiryTime, TimeUnit unit) throws Exception {
-        return cmdContainer
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
-                        "--subject", REGULAR_USER_ROLE,
-                        "--expiry-time", unit.toSeconds(expiryTime) + "s")
-                .getStdout().trim();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.auth.token;
+
+import com.google.common.io.Files;
+import java.io.File;
+import java.util.concurrent.TimeUnit;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.ProxyContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+
+@Slf4j
+public class TokenAuthWithPublicPrivateKeys extends PulsarTokenAuthenticationBaseSuite {
+
+    private static final String PRIVATE_KEY_PATH_INSIDE_CONTAINER = "/tmp/private.key";
+    private static final String PUBLIC_KEY_PATH_INSIDE_CONTAINER = "/tmp/public.key";
+
+    private File publicKeyFile;
+
+    @Override
+    @SuppressWarnings("rawtypes")
+    protected void createKeysAndTokens(PulsarContainer container) throws Exception {
+        container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create-key-pair",
+                        "--output-private-key", PRIVATE_KEY_PATH_INSIDE_CONTAINER,
+                        "--output-public-key", PUBLIC_KEY_PATH_INSIDE_CONTAINER);
+
+        byte[] publicKeyBytes = DockerUtils
+                .runCommandWithRawOutput(container.getDockerClient(), container.getContainerId(),
+                        "/bin/cat", PUBLIC_KEY_PATH_INSIDE_CONTAINER)
+                .getStdout();
+
+        publicKeyFile = File.createTempFile("public-", ".key", new File("/tmp"));
+        Files.write(publicKeyBytes, publicKeyFile);
+
+        clientAuthToken = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
+                        "--subject", REGULAR_USER_ROLE)
+                .getStdout().trim();
+        log.info("Created client token: {}", clientAuthToken);
+
+        superUserAuthToken = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
+                        "--subject", SUPER_USER_ROLE)
+                .getStdout().trim();
+        log.info("Created super-user token: {}", superUserAuthToken);
+
+        proxyAuthToken = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
+                        "--subject", PROXY_ROLE)
+                .getStdout().trim();
+        log.info("Created proxy token: {}", proxyAuthToken);
+    }
+
+    @Override
+    protected void configureBroker(BrokerContainer brokerContainer) throws Exception {
+        brokerContainer.withFileSystemBind(publicKeyFile.toString(), PUBLIC_KEY_PATH_INSIDE_CONTAINER);
+        brokerContainer.withEnv("tokenPublicKey", "file://" + PUBLIC_KEY_PATH_INSIDE_CONTAINER);
+    }
+
+    @Override
+    protected void configureProxy(ProxyContainer proxyContainer) throws Exception {
+        proxyContainer.withFileSystemBind(publicKeyFile.toString(), PUBLIC_KEY_PATH_INSIDE_CONTAINER);
+        proxyContainer.withEnv("tokenPublicKey", "file://" + PUBLIC_KEY_PATH_INSIDE_CONTAINER);
+    }
+
+    @Override
+    protected String createClientTokenWithExpiry(long expiryTime, TimeUnit unit) throws Exception {
+        return cmdContainer
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--private-key", "file://" + PRIVATE_KEY_PATH_INSIDE_CONTAINER,
+                        "--subject", REGULAR_USER_ROLE,
+                        "--expiry-time", unit.toSeconds(expiryTime) + "s")
+                .getStdout().trim();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithSymmetricKeys.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithSymmetricKeys.java
index 744e1d0d0c..08720c0670 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithSymmetricKeys.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/auth/token/TokenAuthWithSymmetricKeys.java
@@ -1,82 +1,82 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.auth.token;
-
-import java.util.concurrent.TimeUnit;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.ProxyContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-@Slf4j
-public class TokenAuthWithSymmetricKeys extends PulsarTokenAuthenticationBaseSuite {
-
-    private String secretKey;
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    protected void createKeysAndTokens(PulsarContainer container) throws Exception {
-        secretKey = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create-secret-key", "--base64")
-                .getStdout();
-        log.info("Created secret key: {}", secretKey);
-
-        clientAuthToken = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--secret-key", "data:;base64," + secretKey,
-                        "--subject", REGULAR_USER_ROLE)
-                .getStdout().trim();
-        log.info("Created client token: {}", clientAuthToken);
-
-        superUserAuthToken = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--secret-key", "data:;base64," + secretKey,
-                        "--subject", SUPER_USER_ROLE)
-                .getStdout().trim();
-        log.info("Created super-user token: {}", superUserAuthToken);
-
-        proxyAuthToken = container
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--secret-key", "data:;base64," + secretKey,
-                        "--subject", PROXY_ROLE)
-                .getStdout().trim();
-        log.info("Created proxy token: {}", proxyAuthToken);
-    }
-
-    @Override
-    protected void configureBroker(BrokerContainer brokerContainer) throws Exception {
-        brokerContainer.withEnv("tokenSecretKey", "data:;base64," + secretKey);
-    }
-
-    @Override
-    protected void configureProxy(ProxyContainer proxyContainer) throws Exception {
-        proxyContainer.withEnv("tokenSecretKey", "data:;base64," + secretKey);
-    }
-
-    @Override
-    protected String createClientTokenWithExpiry(long expiryTime, TimeUnit unit) throws Exception {
-        return cmdContainer
-                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
-                        "--secret-key", "data:;base64," + secretKey,
-                        "--subject", REGULAR_USER_ROLE,
-                        "--expiry-time", unit.toSeconds(expiryTime) + "s")
-                .getStdout().trim();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.auth.token;
+
+import java.util.concurrent.TimeUnit;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.ProxyContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+@Slf4j
+public class TokenAuthWithSymmetricKeys extends PulsarTokenAuthenticationBaseSuite {
+
+    private String secretKey;
+
+    @Override
+    @SuppressWarnings("rawtypes")
+    protected void createKeysAndTokens(PulsarContainer container) throws Exception {
+        secretKey = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create-secret-key", "--base64")
+                .getStdout();
+        log.info("Created secret key: {}", secretKey);
+
+        clientAuthToken = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--secret-key", "data:;base64," + secretKey,
+                        "--subject", REGULAR_USER_ROLE)
+                .getStdout().trim();
+        log.info("Created client token: {}", clientAuthToken);
+
+        superUserAuthToken = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--secret-key", "data:;base64," + secretKey,
+                        "--subject", SUPER_USER_ROLE)
+                .getStdout().trim();
+        log.info("Created super-user token: {}", superUserAuthToken);
+
+        proxyAuthToken = container
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--secret-key", "data:;base64," + secretKey,
+                        "--subject", PROXY_ROLE)
+                .getStdout().trim();
+        log.info("Created proxy token: {}", proxyAuthToken);
+    }
+
+    @Override
+    protected void configureBroker(BrokerContainer brokerContainer) throws Exception {
+        brokerContainer.withEnv("tokenSecretKey", "data:;base64," + secretKey);
+    }
+
+    @Override
+    protected void configureProxy(ProxyContainer proxyContainer) throws Exception {
+        proxyContainer.withEnv("tokenSecretKey", "data:;base64," + secretKey);
+    }
+
+    @Override
+    protected String createClientTokenWithExpiry(long expiryTime, TimeUnit unit) throws Exception {
+        return cmdContainer
+                .execCmd(PulsarCluster.PULSAR_COMMAND_SCRIPT, "tokens", "create",
+                        "--secret-key", "data:;base64," + secretKey,
+                        "--subject", REGULAR_USER_ROLE,
+                        "--expiry-time", unit.toSeconds(expiryTime) + "s")
+                .getStdout().trim();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest22.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest22.java
index a2a9846125..e992d91f90 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest22.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest22.java
@@ -1,37 +1,37 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-
-import java.util.function.Supplier;
-import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
-import org.testng.annotations.Test;
-
-public class ClientTest22 extends PulsarStandaloneTestSuite22 {
-
-    private final ClientTestBase clientTestBase = new ClientTestBase();
-
-    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
-    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
-            throws Exception {
-        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
-        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+
+import java.util.function.Supplier;
+import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
+import org.testng.annotations.Test;
+
+public class ClientTest22 extends PulsarStandaloneTestSuite22 {
+
+    private final ClientTestBase clientTestBase = new ClientTestBase();
+
+    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
+    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
+            throws Exception {
+        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
+        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest23.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest23.java
index d898b11b83..6af0a4217c 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest23.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest23.java
@@ -1,37 +1,37 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-
-import java.util.function.Supplier;
-import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
-import org.testng.annotations.Test;
-
-public class ClientTest23 extends PulsarStandaloneTestSuite23 {
-
-    private final ClientTestBase clientTestBase = new ClientTestBase();
-
-    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
-    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
-            throws Exception {
-        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
-        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+
+import java.util.function.Supplier;
+import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
+import org.testng.annotations.Test;
+
+public class ClientTest23 extends PulsarStandaloneTestSuite23 {
+
+    private final ClientTestBase clientTestBase = new ClientTestBase();
+
+    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
+    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
+            throws Exception {
+        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
+        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest24.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest24.java
index 2875666f98..b0503b64a3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest24.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest24.java
@@ -1,37 +1,37 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-
-import java.util.function.Supplier;
-import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
-import org.testng.annotations.Test;
-
-public class ClientTest24 extends PulsarStandaloneTestSuite24 {
-
-    private final ClientTestBase clientTestBase = new ClientTestBase();
-
-    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
-    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
-            throws Exception {
-        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
-        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+
+import java.util.function.Supplier;
+import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
+import org.testng.annotations.Test;
+
+public class ClientTest24 extends PulsarStandaloneTestSuite24 {
+
+    private final ClientTestBase clientTestBase = new ClientTestBase();
+
+    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
+    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
+            throws Exception {
+        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
+        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest25.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest25.java
index 9fcbf66765..eaac6656b7 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest25.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/ClientTest25.java
@@ -1,91 +1,91 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageIdAdv;
-import org.apache.pulsar.client.api.MessageRouter;
-import org.apache.pulsar.client.api.MessageRoutingMode;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.TopicMetadata;
-import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-public class ClientTest25 extends PulsarStandaloneTestSuite25 {
-
-    private final ClientTestBase clientTestBase = new ClientTestBase();
-
-    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
-    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
-            throws Exception {
-        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
-        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
-    }
-
-    @Test(timeOut = 20000)
-    public void testAutoPartitionsUpdate() throws Exception {
-        @Cleanup final var pulsarClient = PulsarClient.builder()
-                .serviceUrl(getContainer().getPlainTextServiceUrl())
-                .build();
-        final var topic = "test-auto-part-update";
-        final var topic2 = "dummy-topic";
-        @Cleanup final var admin = PulsarAdmin.builder().serviceHttpUrl(getContainer().getHttpServiceUrl()).build();
-        // Use 2 as the initial partition number because old version broker cannot update partitions on a topic that
-        // has only 1 partition.
-        admin.topics().createPartitionedTopic(topic, 2);
-        admin.topics().createPartitionedTopic(topic2, 2);
-        @Cleanup final var producer = pulsarClient.newProducer().autoUpdatePartitions(true)
-                .autoUpdatePartitionsInterval(1, TimeUnit.SECONDS)
-                .messageRoutingMode(MessageRoutingMode.CustomPartition)
-                .messageRouter(new MessageRouter() {
-                    @Override
-                    public int choosePartition(Message<?> msg, TopicMetadata metadata) {
-                        return metadata.numPartitions() - 1;
-                    }
-                })
-                .topic(topic)
-                .create();
-        @Cleanup final var consumer = pulsarClient.newConsumer().autoUpdatePartitions(true)
-                .autoUpdatePartitionsInterval(1, TimeUnit.SECONDS)
-                .topic(topic).subscriptionName("sub")
-                .subscribe();
-        @Cleanup final var multiTopicsConsumer = pulsarClient.newConsumer().autoUpdatePartitions(true)
-                .autoUpdatePartitionsInterval(1, TimeUnit.SECONDS)
-                .topics(List.of(topic, topic2)).subscriptionName("sub-2").subscribe();
-
-        admin.topics().updatePartitionedTopic(topic, 3);
-        Thread.sleep(1500);
-        final var msgId = (MessageIdAdv) producer.send("msg".getBytes());
-        Assert.assertEquals(msgId.getPartitionIndex(), 2);
-
-        final var msg = consumer.receive(3, TimeUnit.SECONDS);
-        Assert.assertNotNull(msg);
-        Assert.assertEquals(((MessageIdAdv) msg.getMessageId()).getPartitionIndex(), 2);
-        final var msg2 = multiTopicsConsumer.receive(3, TimeUnit.SECONDS);
-        Assert.assertNotNull(msg2);
-        Assert.assertEquals(msg2.getMessageId(), msg.getMessageId());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageIdAdv;
+import org.apache.pulsar.client.api.MessageRouter;
+import org.apache.pulsar.client.api.MessageRoutingMode;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.TopicMetadata;
+import org.apache.pulsar.tests.integration.topologies.ClientTestBase;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public class ClientTest25 extends PulsarStandaloneTestSuite25 {
+
+    private final ClientTestBase clientTestBase = new ClientTestBase();
+
+    @Test(dataProvider = "StandaloneServiceUrlAndHttpUrl")
+    public void testResetCursorCompatibility(Supplier<String> serviceUrl, Supplier<String> httpServiceUrl)
+            throws Exception {
+        String topicName = generateTopicName("test-reset-cursor-compatibility", true);
+        clientTestBase.resetCursorCompatibility(serviceUrl.get(), httpServiceUrl.get(), topicName);
+    }
+
+    @Test(timeOut = 20000)
+    public void testAutoPartitionsUpdate() throws Exception {
+        @Cleanup final var pulsarClient = PulsarClient.builder()
+                .serviceUrl(getContainer().getPlainTextServiceUrl())
+                .build();
+        final var topic = "test-auto-part-update";
+        final var topic2 = "dummy-topic";
+        @Cleanup final var admin = PulsarAdmin.builder().serviceHttpUrl(getContainer().getHttpServiceUrl()).build();
+        // Use 2 as the initial partition number because old version broker cannot update partitions on a topic that
+        // has only 1 partition.
+        admin.topics().createPartitionedTopic(topic, 2);
+        admin.topics().createPartitionedTopic(topic2, 2);
+        @Cleanup final var producer = pulsarClient.newProducer().autoUpdatePartitions(true)
+                .autoUpdatePartitionsInterval(1, TimeUnit.SECONDS)
+                .messageRoutingMode(MessageRoutingMode.CustomPartition)
+                .messageRouter(new MessageRouter() {
+                    @Override
+                    public int choosePartition(Message<?> msg, TopicMetadata metadata) {
+                        return metadata.numPartitions() - 1;
+                    }
+                })
+                .topic(topic)
+                .create();
+        @Cleanup final var consumer = pulsarClient.newConsumer().autoUpdatePartitions(true)
+                .autoUpdatePartitionsInterval(1, TimeUnit.SECONDS)
+                .topic(topic).subscriptionName("sub")
+                .subscribe();
+        @Cleanup final var multiTopicsConsumer = pulsarClient.newConsumer().autoUpdatePartitions(true)
+                .autoUpdatePartitionsInterval(1, TimeUnit.SECONDS)
+                .topics(List.of(topic, topic2)).subscriptionName("sub-2").subscribe();
+
+        admin.topics().updatePartitionedTopic(topic, 3);
+        Thread.sleep(1500);
+        final var msgId = (MessageIdAdv) producer.send("msg".getBytes());
+        Assert.assertEquals(msgId.getPartitionIndex(), 2);
+
+        final var msg = consumer.receive(3, TimeUnit.SECONDS);
+        Assert.assertNotNull(msg);
+        Assert.assertEquals(((MessageIdAdv) msg.getMessageId()).getPartitionIndex(), 2);
+        final var msg2 = multiTopicsConsumer.receive(3, TimeUnit.SECONDS);
+        Assert.assertNotNull(msg2);
+        Assert.assertEquals(msg2.getMessageId(), msg.getMessageId());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite22.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite22.java
index afed606cae..6da74f8495 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite22.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite22.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-
-public abstract class PulsarStandaloneTestSuite22  extends PulsarStandaloneTestSuite {
-    public PulsarStandaloneTestSuite22() {
-        super(PulsarContainer.PULSAR_2_2_IMAGE_NAME);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+
+public abstract class PulsarStandaloneTestSuite22  extends PulsarStandaloneTestSuite {
+    public PulsarStandaloneTestSuite22() {
+        super(PulsarContainer.PULSAR_2_2_IMAGE_NAME);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite23.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite23.java
index 494d2be4fb..29084d3d33 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite23.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite23.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-
-public abstract class PulsarStandaloneTestSuite23  extends PulsarStandaloneTestSuite {
-    public PulsarStandaloneTestSuite23() {
-        super(PulsarContainer.PULSAR_2_3_IMAGE_NAME);
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+
+public abstract class PulsarStandaloneTestSuite23  extends PulsarStandaloneTestSuite {
+    public PulsarStandaloneTestSuite23() {
+        super(PulsarContainer.PULSAR_2_3_IMAGE_NAME);
+    }
 }
\ No newline at end of file
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite24.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite24.java
index 06a36528cb..19441df0bb 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite24.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite24.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-
-public abstract class PulsarStandaloneTestSuite24 extends PulsarStandaloneTestSuite {
-    public PulsarStandaloneTestSuite24() {
-        super(PulsarContainer.PULSAR_2_4_IMAGE_NAME);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+
+public abstract class PulsarStandaloneTestSuite24 extends PulsarStandaloneTestSuite {
+    public PulsarStandaloneTestSuite24() {
+        super(PulsarContainer.PULSAR_2_4_IMAGE_NAME);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite25.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite25.java
index 6cfa921b4a..2d70266757 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite25.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/PulsarStandaloneTestSuite25.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-
-public abstract class PulsarStandaloneTestSuite25 extends PulsarStandaloneTestSuite {
-    public PulsarStandaloneTestSuite25() {
-        super(PulsarContainer.PULSAR_2_5_IMAGE_NAME);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+
+public abstract class PulsarStandaloneTestSuite25 extends PulsarStandaloneTestSuite {
+    public PulsarStandaloneTestSuite25() {
+        super(PulsarContainer.PULSAR_2_5_IMAGE_NAME);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest22.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest22.java
index dba17ae0e1..903950dc8d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest22.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest22.java
@@ -1,35 +1,35 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import java.util.function.Supplier;
-import org.testng.annotations.Test;
-
-public class SmokeTest22 extends PulsarStandaloneTestSuite22 {
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import java.util.function.Supplier;
+import org.testng.annotations.Test;
+
+public class SmokeTest22 extends PulsarStandaloneTestSuite22 {
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest23.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest23.java
index 61d04bbc02..ddef30b581 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest23.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest23.java
@@ -1,35 +1,35 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import java.util.function.Supplier;
-import org.testng.annotations.Test;
-
-public class SmokeTest23 extends PulsarStandaloneTestSuite23 {
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import java.util.function.Supplier;
+import org.testng.annotations.Test;
+
+public class SmokeTest23 extends PulsarStandaloneTestSuite23 {
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest24.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest24.java
index 15e862c929..60c3465227 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest24.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest24.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import java.util.function.Supplier;
-import org.testng.annotations.Test;
-
-public class SmokeTest24 extends PulsarStandaloneTestSuite24 {
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testBatchIndexAckDisabled(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testBatchIndexAckDisabled(serviceUrl.get());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import java.util.function.Supplier;
+import org.testng.annotations.Test;
+
+public class SmokeTest24 extends PulsarStandaloneTestSuite24 {
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testBatchIndexAckDisabled(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testBatchIndexAckDisabled(serviceUrl.get());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest25.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest25.java
index d194b7dcc9..213b96b76e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest25.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/backwardscompatibility/SmokeTest25.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.backwardscompatibility;
-
-import java.util.function.Supplier;
-import org.testng.annotations.Test;
-
-public class SmokeTest25 extends PulsarStandaloneTestSuite25 {
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testBatchIndexAckDisabled(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testBatchIndexAckDisabled(serviceUrl.get());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.backwardscompatibility;
+
+import java.util.function.Supplier;
+import org.testng.annotations.Test;
+
+public class SmokeTest25 extends PulsarStandaloneTestSuite25 {
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testBatchMessagePublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testBatchMessagePublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testBatchIndexAckDisabled(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testBatchIndexAckDisabled(serviceUrl.get());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BookkeeperInstallWithHttpServerEnabledTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BookkeeperInstallWithHttpServerEnabledTest.java
index bd593e5b91..503bb70617 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BookkeeperInstallWithHttpServerEnabledTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BookkeeperInstallWithHttpServerEnabledTest.java
@@ -1,92 +1,92 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.bookkeeper;
-
-import static java.util.stream.Collectors.joining;
-import static org.testng.Assert.assertEquals;
-import java.util.stream.Stream;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-/**
- * Test bookkeeper setup with http server enabled.
- */
-@Slf4j
-public class BookkeeperInstallWithHttpServerEnabledTest extends PulsarClusterTestBase {
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public final void setupCluster() throws Exception {
-        incrementSetupNumber();
-
-        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
-                .filter(s -> !s.isEmpty())
-                .collect(joining("-"));
-        bookkeeperEnvs.put("httpServerEnabled", "true");
-        bookieAdditionalPorts.add(8000);
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .numBookies(2)
-                .numBrokers(1)
-                .bookkeeperEnvs(bookkeeperEnvs)
-                .bookieAdditionalPorts(bookieAdditionalPorts)
-                .clusterName(clusterName)
-                .build();
-
-        log.info("Setting up cluster {} with {} bookies, {} brokers",
-                spec.clusterName(), spec.numBookies(), spec.numBrokers());
-
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-
-        log.info("Cluster {} is setup", spec.clusterName());
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    public final void tearDownCluster() throws Exception {
-        super.tearDownCluster();
-    }
-
-    @Test
-    public void testBookieHttpServerIsRunning() throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyBookie().execCmd(
-                PulsarCluster.CURL,
-                "-X",
-                "GET",
-                "http://localhost:8000/heartbeat");
-        assertEquals(result.getExitCode(), 0);
-        assertEquals(result.getStdout(), "OK\n");
-    }
-
-    @Test
-    public void testGetBookieMetrics() throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyBookie().execCmd(
-                PulsarCluster.CURL,
-                "-X",
-                "GET",
-                "http://localhost:8000/metrics");
-        assertEquals(result.getExitCode(), 0);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.bookkeeper;
+
+import static java.util.stream.Collectors.joining;
+import static org.testng.Assert.assertEquals;
+import java.util.stream.Stream;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+/**
+ * Test bookkeeper setup with http server enabled.
+ */
+@Slf4j
+public class BookkeeperInstallWithHttpServerEnabledTest extends PulsarClusterTestBase {
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public final void setupCluster() throws Exception {
+        incrementSetupNumber();
+
+        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
+                .filter(s -> !s.isEmpty())
+                .collect(joining("-"));
+        bookkeeperEnvs.put("httpServerEnabled", "true");
+        bookieAdditionalPorts.add(8000);
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .numBookies(2)
+                .numBrokers(1)
+                .bookkeeperEnvs(bookkeeperEnvs)
+                .bookieAdditionalPorts(bookieAdditionalPorts)
+                .clusterName(clusterName)
+                .build();
+
+        log.info("Setting up cluster {} with {} bookies, {} brokers",
+                spec.clusterName(), spec.numBookies(), spec.numBrokers());
+
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+
+        log.info("Cluster {} is setup", spec.clusterName());
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    public final void tearDownCluster() throws Exception {
+        super.tearDownCluster();
+    }
+
+    @Test
+    public void testBookieHttpServerIsRunning() throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyBookie().execCmd(
+                PulsarCluster.CURL,
+                "-X",
+                "GET",
+                "http://localhost:8000/heartbeat");
+        assertEquals(result.getExitCode(), 0);
+        assertEquals(result.getStdout(), "OK\n");
+    }
+
+    @Test
+    public void testGetBookieMetrics() throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyBookie().execCmd(
+                PulsarCluster.CURL,
+                "-X",
+                "GET",
+                "http://localhost:8000/metrics");
+        assertEquals(result.getExitCode(), 0);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BrokerInstallWithEntryMetadataInterceptorsTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BrokerInstallWithEntryMetadataInterceptorsTest.java
index 10c8bfbf57..907cc1d30b 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BrokerInstallWithEntryMetadataInterceptorsTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/bookkeeper/BrokerInstallWithEntryMetadataInterceptorsTest.java
@@ -1,85 +1,85 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.bookkeeper;
-
-import static java.util.stream.Collectors.joining;
-import static org.testng.AssertJUnit.assertEquals;
-import java.util.stream.Stream;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-/***
- * Test that verifies that regression in BookKeeper 4.16.0 is fixed.
- *
- * Anti-regression test for issue https://github.com/apache/pulsar/issues/20091.
- */
-@Slf4j
-public class BrokerInstallWithEntryMetadataInterceptorsTest extends PulsarClusterTestBase {
-    private static final String PREFIX = "PULSAR_PREFIX_";
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public final void setupCluster() throws Exception {
-        incrementSetupNumber();
-
-        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
-                .filter(s -> !s.isEmpty())
-                .collect(joining("-"));
-        brokerEnvs.put(PREFIX + "exposingBrokerEntryMetadataToClientEnabled", "true");
-        brokerEnvs.put(PREFIX + "brokerEntryMetadataInterceptors",
-                "org.apache.pulsar.common.intercept.AppendBrokerTimestampMetadataInterceptor");
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .numBookies(2)
-                .numBrokers(1)
-                .brokerEnvs(brokerEnvs)
-                .clusterName(clusterName)
-                .build();
-
-        log.info("Setting up cluster {} with {} bookies, {} brokers",
-                spec.clusterName(), spec.numBookies(), spec.numBrokers());
-
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-
-        log.info("Cluster {} is setup", spec.clusterName());
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    public final void tearDownCluster() throws Exception {
-        super.tearDownCluster();
-    }
-
-    @Test
-    public void testBrokerHttpServerIsRunning() throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
-                PulsarCluster.CURL,
-                "-X",
-                "GET",
-                "http://localhost:8080/admin/v2/brokers/health");
-        assertEquals(result.getExitCode(), 0);
-        assertEquals("ok", result.getStdout());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.bookkeeper;
+
+import static java.util.stream.Collectors.joining;
+import static org.testng.AssertJUnit.assertEquals;
+import java.util.stream.Stream;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+/***
+ * Test that verifies that regression in BookKeeper 4.16.0 is fixed.
+ *
+ * Anti-regression test for issue https://github.com/apache/pulsar/issues/20091.
+ */
+@Slf4j
+public class BrokerInstallWithEntryMetadataInterceptorsTest extends PulsarClusterTestBase {
+    private static final String PREFIX = "PULSAR_PREFIX_";
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public final void setupCluster() throws Exception {
+        incrementSetupNumber();
+
+        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
+                .filter(s -> !s.isEmpty())
+                .collect(joining("-"));
+        brokerEnvs.put(PREFIX + "exposingBrokerEntryMetadataToClientEnabled", "true");
+        brokerEnvs.put(PREFIX + "brokerEntryMetadataInterceptors",
+                "org.apache.pulsar.common.intercept.AppendBrokerTimestampMetadataInterceptor");
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .numBookies(2)
+                .numBrokers(1)
+                .brokerEnvs(brokerEnvs)
+                .clusterName(clusterName)
+                .build();
+
+        log.info("Setting up cluster {} with {} bookies, {} brokers",
+                spec.clusterName(), spec.numBookies(), spec.numBrokers());
+
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+
+        log.info("Cluster {} is setup", spec.clusterName());
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    public final void tearDownCluster() throws Exception {
+        super.tearDownCluster();
+    }
+
+    @Test
+    public void testBrokerHttpServerIsRunning() throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
+                PulsarCluster.CURL,
+                "-X",
+                "GET",
+                "http://localhost:8080/admin/v2/brokers/health");
+        assertEquals(result.getExitCode(), 0);
+        assertEquals("ok", result.getStdout());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/AdminMultiHostTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/AdminMultiHostTest.java
index c9c32e689b..f5817b3ec9 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/AdminMultiHostTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/AdminMultiHostTest.java
@@ -1,98 +1,98 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import java.util.UUID;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.FutureTask;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.common.naming.TopicVersion;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.Assert;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-/**
- * Test for admin service url is multi host.
- */
-public class AdminMultiHostTest extends TestRetrySupport {
-
-    private final String clusterName = "MultiHostTest-" + UUID.randomUUID();
-    private final PulsarClusterSpec spec = PulsarClusterSpec.builder().clusterName(clusterName).numBrokers(3).build();
-    private PulsarCluster pulsarCluster = null;
-
-    @BeforeMethod(alwaysRun = true)
-    public void setup() throws Exception {
-        incrementSetupNumber();
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-    }
-
-    @AfterMethod(alwaysRun = true)
-    public void cleanup() {
-        markCurrentSetupNumberCleaned();
-        if (pulsarCluster != null) {
-            pulsarCluster.stop();
-            pulsarCluster = null;
-        }
-    }
-
-    @Test
-    public void testAdminMultiHost() throws Exception {
-        String hosts = pulsarCluster.getAllBrokersHttpServiceUrl();
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(hosts).build();
-        // all brokers alive
-        Assert.assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), 3);
-
-        // kill one broker admin should be usable
-        BrokerContainer one = pulsarCluster.getBroker(0);
-        // admin.brokers().
-        one.stop();
-        waitBrokerDown(admin, 2, 60);
-        Assert.assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), 2);
-
-        // kill another broker
-        BrokerContainer two = pulsarCluster.getBroker(1);
-        two.stop();
-        waitBrokerDown(admin, 1, 60);
-        Assert.assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), 1);
-    }
-
-    // Because zookeeper session timeout is 30ms and ticktime is 2ms, so we need wait more than 32ms
-    private void waitBrokerDown(PulsarAdmin admin, int expectBrokers, int timeout)
-        throws InterruptedException, ExecutionException, TimeoutException {
-        FutureTask<Boolean> futureTask = new FutureTask<>(() -> {
-            while (admin.brokers().getActiveBrokers(clusterName).size() != expectBrokers) {
-                admin.brokers().healthcheck(TopicVersion.V1);
-                TimeUnit.MILLISECONDS.sleep(1000);
-            }
-            return true;
-        });
-        new Thread(futureTask).start();
-        futureTask.get(timeout, TimeUnit.SECONDS);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.common.naming.TopicVersion;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.Assert;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/**
+ * Test for admin service url is multi host.
+ */
+public class AdminMultiHostTest extends TestRetrySupport {
+
+    private final String clusterName = "MultiHostTest-" + UUID.randomUUID();
+    private final PulsarClusterSpec spec = PulsarClusterSpec.builder().clusterName(clusterName).numBrokers(3).build();
+    private PulsarCluster pulsarCluster = null;
+
+    @BeforeMethod(alwaysRun = true)
+    public void setup() throws Exception {
+        incrementSetupNumber();
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+    }
+
+    @AfterMethod(alwaysRun = true)
+    public void cleanup() {
+        markCurrentSetupNumberCleaned();
+        if (pulsarCluster != null) {
+            pulsarCluster.stop();
+            pulsarCluster = null;
+        }
+    }
+
+    @Test
+    public void testAdminMultiHost() throws Exception {
+        String hosts = pulsarCluster.getAllBrokersHttpServiceUrl();
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(hosts).build();
+        // all brokers alive
+        Assert.assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), 3);
+
+        // kill one broker admin should be usable
+        BrokerContainer one = pulsarCluster.getBroker(0);
+        // admin.brokers().
+        one.stop();
+        waitBrokerDown(admin, 2, 60);
+        Assert.assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), 2);
+
+        // kill another broker
+        BrokerContainer two = pulsarCluster.getBroker(1);
+        two.stop();
+        waitBrokerDown(admin, 1, 60);
+        Assert.assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), 1);
+    }
+
+    // Because zookeeper session timeout is 30ms and ticktime is 2ms, so we need wait more than 32ms
+    private void waitBrokerDown(PulsarAdmin admin, int expectBrokers, int timeout)
+        throws InterruptedException, ExecutionException, TimeoutException {
+        FutureTask<Boolean> futureTask = new FutureTask<>(() -> {
+            while (admin.brokers().getActiveBrokers(clusterName).size() != expectBrokers) {
+                admin.brokers().healthcheck(TopicVersion.V1);
+                TimeUnit.MILLISECONDS.sleep(1000);
+            }
+            return true;
+        });
+        new Thread(futureTask).start();
+        futureTask.get(timeout, TimeUnit.SECONDS);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/CLITest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/CLITest.java
index 2eabaed32e..5638758358 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/CLITest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/CLITest.java
@@ -1,599 +1,599 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.http.client.methods.CloseableHttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.CloseableHttpClient;
-import org.apache.http.impl.client.HttpClients;
-import org.apache.http.util.EntityUtils;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.naming.NamespaceName;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.functions.api.examples.pojo.Tick;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * Test Pulsar CLI.
- */
-public class CLITest extends PulsarTestSuite {
-
-    @Test
-    public void testDeprecatedCommands() throws Exception {
-        String tenantName = "test-deprecated-commands";
-
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("--help");
-        assertFalse(result.getStdout().isEmpty());
-        assertFalse(result.getStdout().contains("Usage: properties "));
-        result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "properties", "create", tenantName,
-            "--allowed-clusters", pulsarCluster.getClusterName(),
-            "--admin-roles", "admin"
-        );
-        assertEquals(result.getExitCode(), 0L);
-
-        result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "properties", "list");
-        assertTrue(result.getStdout().contains(tenantName));
-        result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "tenants", "list");
-        assertTrue(result.getStdout().contains(tenantName));
-    }
-
-    @Test
-    public void testGetTopicListCommand() throws Exception {
-        ContainerExecResult result;
-
-        final String namespaceLocalName = "list-topics-" + randomName(8);
-        result = pulsarCluster.createNamespace(namespaceLocalName);
-        final String namespace = "public/" + namespaceLocalName;
-        assertEquals(0, result.getExitCode());
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
-
-        final String persistentTopicName = TopicName.get(
-                "persistent",
-                NamespaceName.get(namespace),
-                "get_topics_mode_" + UUID.randomUUID()).toString();
-
-        final String nonPersistentTopicName = TopicName.get(
-                "non-persistent",
-                NamespaceName.get(namespace),
-                "get_topics_mode_" + UUID.randomUUID()).toString();
-
-        Producer<byte[]> producer1 = client.newProducer()
-                .topic(persistentTopicName)
-                .create();
-
-        Producer<byte[]> producer2 = client.newProducer()
-                .topic(nonPersistentTopicName)
-                .create();
-
-        BrokerContainer container = pulsarCluster.getAnyBroker();
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "topics",
-                "list",
-                namespace);
-
-        assertTrue(result.getStdout().contains(persistentTopicName));
-        assertTrue(result.getStdout().contains(nonPersistentTopicName));
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "topics",
-                "list",
-                "--topic-domain",
-                "persistent",
-                namespace);
-
-        assertTrue(result.getStdout().contains(persistentTopicName));
-        assertFalse(result.getStdout().contains(nonPersistentTopicName));
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "topics",
-                "list",
-                "--topic-domain",
-                "non_persistent",
-                namespace);
-
-        assertFalse(result.getStdout().contains(persistentTopicName));
-        assertTrue(result.getStdout().contains(nonPersistentTopicName));
-
-        try {
-            container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "topics",
-                "list",
-                "--topic-domain",
-                "none",
-                namespace);
-            fail();
-        } catch (ContainerExecException ignore) {
-        }
-
-        producer1.close();
-        producer2.close();
-    }
-
-    @Test
-    public void testCreateSubscriptionCommand() throws Exception {
-        String topic = "testCreateSubscriptionCommmand";
-
-        String subscriptionPrefix = "subscription-";
-
-        int i = 0;
-        for (BrokerContainer container : pulsarCluster.getBrokers()) {
-            ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "topics",
-                "create-subscription",
-                "persistent://public/default/" + topic,
-                "--subscription",
-                "" + subscriptionPrefix + i
-            );
-            result.assertNoOutput();
-            i++;
-        }
-    }
-
-    @Test
-    public void testCreateUpdateSubscriptionWithPropertiesCommand() throws Exception {
-        String topic = "testCreateSubscriptionCommmand";
-
-        String subscriptionPrefix = "subscription-";
-
-        int i = 0;
-        for (BrokerContainer container : pulsarCluster.getBrokers()) {
-            ContainerExecResult result = container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "topics",
-                    "create-subscription",
-                    "-p",
-                    "a=b",
-                    "-p",
-                    "c=d",
-                    "persistent://public/default/" + topic,
-                    "--subscription",
-                    "" + subscriptionPrefix + i
-            );
-            result.assertNoOutput();
-
-            ContainerExecResult resultUpdate = container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "topics",
-                    "update-subscription-properties",
-                    "-p",
-                    "a=e",
-                    "persistent://public/default/" + topic,
-                    "--subscription",
-                    "" + subscriptionPrefix + i
-            );
-            resultUpdate.assertNoOutput();
-
-            ContainerExecResult resultGet = container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "topics",
-                    "get-subscription-properties",
-                    "persistent://public/default/" + topic,
-                    "--subscription",
-                    "" + subscriptionPrefix + i
-            );
-            assertEquals(
-                    resultGet.getStdout().trim(), "{\"a\":\"e\"}",
-                    "unexpected output " + resultGet.getStdout() + " - error " + resultGet.getStderr());
-
-            ContainerExecResult resultClear = container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "topics",
-                    "update-subscription-properties",
-                    "-c",
-                    "persistent://public/default/" + topic,
-                    "--subscription",
-                    "" + subscriptionPrefix + i
-            );
-            resultClear.assertNoOutput();
-
-            ContainerExecResult resultGetAfterClear = container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "topics",
-                    "get-subscription-properties",
-                    "persistent://public/default/" + topic,
-                    "--subscription",
-                    "" + subscriptionPrefix + i
-            );
-            assertEquals(
-                    resultGetAfterClear.getStdout().trim(), "{}",
-                    "unexpected output " + resultGetAfterClear.getStdout()
-                            + " - error " + resultGetAfterClear.getStderr());
-
-            i++;
-        }
-    }
-
-    @Test
-    public void testTopicTerminationOnTopicsWithoutConnectedConsumers() throws Exception {
-        String topicName = "persistent://public/default/test-topic-termination";
-        BrokerContainer container = pulsarCluster.getAnyBroker();
-        container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "topics",
-                "create",
-                topicName);
-
-        ContainerExecResult result = container.execCmd(
-            PulsarCluster.CLIENT_SCRIPT,
-            "produce",
-            "-m",
-            "\"test topic termination\"",
-            "-n",
-            "1",
-            topicName);
-
-        assertTrue(result.getStdout().contains("1 messages successfully produced"));
-
-        // terminate the topic
-        result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "topics",
-            "terminate",
-            topicName);
-        assertTrue(result.getStdout().contains("Topic successfully terminated at"));
-
-        // try to produce should fail
-        try {
-            pulsarCluster.getAnyBroker().execCmd(PulsarCluster.CLIENT_SCRIPT,
-                                                 "produce",
-                                                 "-m",
-                                                 "\"test topic termination\"",
-                                                 "-n",
-                                                 "1",
-                                                 topicName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStdout().contains("Topic was already terminated"));
-        }
-    }
-
-    @Test
-    public void testPropertiesCLI() throws Exception {
-        final BrokerContainer container = pulsarCluster.getAnyBroker();
-        final String namespace = "public/default";
-
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "set-property",
-                "-k",
-                "a",
-                "-v",
-                "a",
-                namespace);
-        assertTrue(result.getStdout().isEmpty());
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "get-property",
-                "-k",
-                "a",
-                namespace);
-        assertTrue(result.getStdout().contains("a"));
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "remove-property",
-                "-k",
-                "a",
-                namespace);
-        assertTrue(result.getStdout().contains("a"));
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "remove-property",
-                "-k",
-                "a",
-                namespace);
-        assertTrue(result.getStdout().contains("null"));
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "set-properties",
-                "-p",
-                "a=a,b=b,c=c",
-                namespace);
-        assertTrue(result.getStdout().isEmpty());
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "get-properties",
-                namespace);
-        assertFalse(result.getStdout().isEmpty());
-
-        result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "namespaces",
-                "clear-properties",
-                namespace);
-        assertTrue(result.getStdout().isEmpty());
-
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "bookies",
-                    "set-bookie-rack",
-                    "-b", "localhost:8082",
-                    "-r", "");
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(
-                    e.getResult().getStderr().startsWith("rack name is invalid, it should not be null, empty or '/'"));
-        }
-
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "namespaces",
-                    "set-schema-autoupdate-strategy",
-                    namespace);
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().startsWith("Either --compatibility or --disabled must be specified"));
-        }
-    }
-
-    @Test
-    public void testSchemaCLI() throws Exception {
-        BrokerContainer container = pulsarCluster.getAnyBroker();
-        String topicName = "persistent://public/default/test-schema-cli";
-
-        ContainerExecResult result = container.execCmd(
-            PulsarCluster.CLIENT_SCRIPT,
-            "produce",
-            "-m",
-            "\"test topic schema\"",
-            "-n",
-            "1",
-            topicName);
-        assertTrue(result.getStdout().contains("1 messages successfully produced"));
-
-        result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "schemas",
-            "upload",
-            topicName,
-            "-f",
-            "/pulsar/conf/schema_example.json"
-        );
-        result.assertNoOutput();
-
-        // get schema
-        result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "schemas",
-            "get",
-            topicName);
-        assertTrue(result.getStdout().contains("\"type\": \"STRING\""));
-
-        // delete the schema
-        result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "schemas",
-            "delete",
-            topicName);
-        result.assertNoOutput();
-
-        // get schema again
-        try {
-            container.execCmd(PulsarCluster.ADMIN_SCRIPT,
-                              "schemas",
-                              "get",
-                              "persistent://public/default/test-schema-cli"
-                              );
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Schema not found"));
-        }
-
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "schemas",
-                    "extract",
-                    "--jar", "/pulsar/examples/api-examples.jar",
-                    "--type", "xml",
-                    "--classname", "org.apache.pulsar.functions.api.examples.pojo.Tick",
-                    topicName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().startsWith("Invalid schema type xml. Valid options are: avro, json"));
-        }
-    }
-
-    @Test
-    public void testSetInfiniteRetention() throws Exception {
-        ContainerExecResult result;
-
-        String namespace = "get-and-set-retention" + randomName(8);
-        pulsarCluster.createNamespace(namespace);
-
-        String[] setCommand = {
-            "namespaces", "set-retention", "public/" + namespace,
-            "--size", "-1",
-            "--time", "-1"
-        };
-
-        result = pulsarCluster.runAdminCommandOnAnyBroker(setCommand);
-        result.assertNoOutput();
-
-        String[] getCommand = {
-            "namespaces", "get-retention", "public/" + namespace
-        };
-
-        result = pulsarCluster.runAdminCommandOnAnyBroker(getCommand);
-        assertTrue(
-            result.getStdout().contains("\"retentionTimeInMinutes\" : -1"),
-            result.getStdout());
-        assertTrue(
-            result.getStdout().contains("\"retentionSizeInMB\" : -1"),
-            result.getStdout());
-    }
-
-    // authorization related tests
-
-    @Test
-    public void testGrantPermissionsAuthorizationDisabled() throws Exception {
-        ContainerExecResult result;
-
-        String namespace = "grant-permissions-" + randomName(8);
-        result = pulsarCluster.createNamespace(namespace);
-        assertEquals(0, result.getExitCode());
-
-        String[] grantCommand = {
-            "namespaces", "grant-permission", "public/" + namespace,
-            "--actions", "produce",
-            "--role", "test-role"
-        };
-        try {
-            pulsarCluster.runAdminCommandOnAnyBroker(grantCommand);
-        } catch (ContainerExecException cee) {
-            result = cee.getResult();
-            assertTrue(result.getStderr().contains("HTTP 501 Not Implemented"), result.getStderr());
-        }
-    }
-
-    @Test
-    public void testJarPojoSchemaUploadAvro() throws Exception {
-
-        ContainerExecResult containerExecResult = pulsarCluster.runAdminCommandOnAnyBroker(
-                "schemas",
-                "extract", "--jar", "/pulsar/examples/api-examples.jar", "--type", "avro",
-                "--classname", "org.apache.pulsar.functions.api.examples.pojo.Tick",
-                "persistent://public/default/pojo-avro");
-
-        Assert.assertEquals(containerExecResult.getExitCode(), 0);
-        testPublishAndConsume("persistent://public/default/pojo-avro", "avro", Schema.AVRO(Tick.class));
-    }
-
-    @Test
-    public void testJarPojoSchemaUploadJson() throws Exception {
-
-        ContainerExecResult containerExecResult = pulsarCluster.runAdminCommandOnAnyBroker(
-                "schemas",
-                "extract", "--jar", "/pulsar/examples/api-examples.jar", "--type", "json",
-                "--classname", "org.apache.pulsar.functions.api.examples.pojo.Tick",
-                "persistent://public/default/pojo-json");
-
-        Assert.assertEquals(containerExecResult.getExitCode(), 0);
-        testPublishAndConsume("persistent://public/default/pojo-json", "json", Schema.JSON(Tick.class));
-    }
-
-    private void testPublishAndConsume(String topic, String sub, Schema<Tick> type) throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
-
-        @Cleanup
-        Producer<Tick> producer = client.newProducer(type)
-                .topic(topic + "-message")
-                .create();
-
-        @Cleanup
-        Consumer<Tick> consumer = client.newConsumer(type)
-                .topic(topic + "-message")
-                .subscriptionName(sub)
-                .subscribe();
-
-        final int numOfMessages = 10;
-
-        for (int i = 1; i < numOfMessages; ++i) {
-            producer.send(new Tick(i, "Stock_" + i, 100 + i, 110 + i));
-        }
-
-        for (int i = 1; i < numOfMessages; ++i) {
-            Tick expected = new Tick(i, "Stock_" + i, 100 + i, 110 + i);
-            Message<Tick> receive = consumer.receive(5, TimeUnit.SECONDS);
-            Assert.assertEquals(receive.getValue(), expected);
-        }
-    }
-
-    @Test
-    public void testListNonPersistentTopicsCmd() throws Exception {
-        String persistentTopic = "test-list-non-persistent-topic";
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("topics", "create", persistentTopic);
-        assertEquals(result.getExitCode(), 0);
-        HttpGet get = new HttpGet(pulsarCluster.getHttpServiceUrl() + "/admin/v2/non-persistent/public/default");
-        try (CloseableHttpClient client = HttpClients.createDefault();
-             CloseableHttpResponse response = client.execute(get)) {
-            assertFalse(EntityUtils.toString(response.getEntity()).contains(persistentTopic));
-        }
-    }
-
-    @Test
-    public void testGenerateDocForModule() throws Exception {
-        String[] moduleNames = {
-                "clusters",
-                "tenants",
-                "brokers",
-                "broker-stats",
-                "namespaces",
-                "topics",
-                "schemas",
-                "bookies",
-                "functions",
-                "ns-isolation-policy",
-                "resource-quotas",
-                "functions",
-                "sources",
-                "sinks"
-        };
-        BrokerContainer container = pulsarCluster.getAnyBroker();
-        for (int i = 0; i < moduleNames.length; i++) {
-            ContainerExecResult result = container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "documents", "generate", moduleNames[i]);
-            Assert.assertTrue(result.getStdout().contains("# " + moduleNames[i]));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.naming.NamespaceName;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.functions.api.examples.pojo.Tick;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * Test Pulsar CLI.
+ */
+public class CLITest extends PulsarTestSuite {
+
+    @Test
+    public void testDeprecatedCommands() throws Exception {
+        String tenantName = "test-deprecated-commands";
+
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("--help");
+        assertFalse(result.getStdout().isEmpty());
+        assertFalse(result.getStdout().contains("Usage: properties "));
+        result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "properties", "create", tenantName,
+            "--allowed-clusters", pulsarCluster.getClusterName(),
+            "--admin-roles", "admin"
+        );
+        assertEquals(result.getExitCode(), 0L);
+
+        result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "properties", "list");
+        assertTrue(result.getStdout().contains(tenantName));
+        result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "tenants", "list");
+        assertTrue(result.getStdout().contains(tenantName));
+    }
+
+    @Test
+    public void testGetTopicListCommand() throws Exception {
+        ContainerExecResult result;
+
+        final String namespaceLocalName = "list-topics-" + randomName(8);
+        result = pulsarCluster.createNamespace(namespaceLocalName);
+        final String namespace = "public/" + namespaceLocalName;
+        assertEquals(0, result.getExitCode());
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
+
+        final String persistentTopicName = TopicName.get(
+                "persistent",
+                NamespaceName.get(namespace),
+                "get_topics_mode_" + UUID.randomUUID()).toString();
+
+        final String nonPersistentTopicName = TopicName.get(
+                "non-persistent",
+                NamespaceName.get(namespace),
+                "get_topics_mode_" + UUID.randomUUID()).toString();
+
+        Producer<byte[]> producer1 = client.newProducer()
+                .topic(persistentTopicName)
+                .create();
+
+        Producer<byte[]> producer2 = client.newProducer()
+                .topic(nonPersistentTopicName)
+                .create();
+
+        BrokerContainer container = pulsarCluster.getAnyBroker();
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "topics",
+                "list",
+                namespace);
+
+        assertTrue(result.getStdout().contains(persistentTopicName));
+        assertTrue(result.getStdout().contains(nonPersistentTopicName));
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "topics",
+                "list",
+                "--topic-domain",
+                "persistent",
+                namespace);
+
+        assertTrue(result.getStdout().contains(persistentTopicName));
+        assertFalse(result.getStdout().contains(nonPersistentTopicName));
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "topics",
+                "list",
+                "--topic-domain",
+                "non_persistent",
+                namespace);
+
+        assertFalse(result.getStdout().contains(persistentTopicName));
+        assertTrue(result.getStdout().contains(nonPersistentTopicName));
+
+        try {
+            container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "topics",
+                "list",
+                "--topic-domain",
+                "none",
+                namespace);
+            fail();
+        } catch (ContainerExecException ignore) {
+        }
+
+        producer1.close();
+        producer2.close();
+    }
+
+    @Test
+    public void testCreateSubscriptionCommand() throws Exception {
+        String topic = "testCreateSubscriptionCommmand";
+
+        String subscriptionPrefix = "subscription-";
+
+        int i = 0;
+        for (BrokerContainer container : pulsarCluster.getBrokers()) {
+            ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "topics",
+                "create-subscription",
+                "persistent://public/default/" + topic,
+                "--subscription",
+                "" + subscriptionPrefix + i
+            );
+            result.assertNoOutput();
+            i++;
+        }
+    }
+
+    @Test
+    public void testCreateUpdateSubscriptionWithPropertiesCommand() throws Exception {
+        String topic = "testCreateSubscriptionCommmand";
+
+        String subscriptionPrefix = "subscription-";
+
+        int i = 0;
+        for (BrokerContainer container : pulsarCluster.getBrokers()) {
+            ContainerExecResult result = container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "topics",
+                    "create-subscription",
+                    "-p",
+                    "a=b",
+                    "-p",
+                    "c=d",
+                    "persistent://public/default/" + topic,
+                    "--subscription",
+                    "" + subscriptionPrefix + i
+            );
+            result.assertNoOutput();
+
+            ContainerExecResult resultUpdate = container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "topics",
+                    "update-subscription-properties",
+                    "-p",
+                    "a=e",
+                    "persistent://public/default/" + topic,
+                    "--subscription",
+                    "" + subscriptionPrefix + i
+            );
+            resultUpdate.assertNoOutput();
+
+            ContainerExecResult resultGet = container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "topics",
+                    "get-subscription-properties",
+                    "persistent://public/default/" + topic,
+                    "--subscription",
+                    "" + subscriptionPrefix + i
+            );
+            assertEquals(
+                    resultGet.getStdout().trim(), "{\"a\":\"e\"}",
+                    "unexpected output " + resultGet.getStdout() + " - error " + resultGet.getStderr());
+
+            ContainerExecResult resultClear = container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "topics",
+                    "update-subscription-properties",
+                    "-c",
+                    "persistent://public/default/" + topic,
+                    "--subscription",
+                    "" + subscriptionPrefix + i
+            );
+            resultClear.assertNoOutput();
+
+            ContainerExecResult resultGetAfterClear = container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "topics",
+                    "get-subscription-properties",
+                    "persistent://public/default/" + topic,
+                    "--subscription",
+                    "" + subscriptionPrefix + i
+            );
+            assertEquals(
+                    resultGetAfterClear.getStdout().trim(), "{}",
+                    "unexpected output " + resultGetAfterClear.getStdout()
+                            + " - error " + resultGetAfterClear.getStderr());
+
+            i++;
+        }
+    }
+
+    @Test
+    public void testTopicTerminationOnTopicsWithoutConnectedConsumers() throws Exception {
+        String topicName = "persistent://public/default/test-topic-termination";
+        BrokerContainer container = pulsarCluster.getAnyBroker();
+        container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "topics",
+                "create",
+                topicName);
+
+        ContainerExecResult result = container.execCmd(
+            PulsarCluster.CLIENT_SCRIPT,
+            "produce",
+            "-m",
+            "\"test topic termination\"",
+            "-n",
+            "1",
+            topicName);
+
+        assertTrue(result.getStdout().contains("1 messages successfully produced"));
+
+        // terminate the topic
+        result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "topics",
+            "terminate",
+            topicName);
+        assertTrue(result.getStdout().contains("Topic successfully terminated at"));
+
+        // try to produce should fail
+        try {
+            pulsarCluster.getAnyBroker().execCmd(PulsarCluster.CLIENT_SCRIPT,
+                                                 "produce",
+                                                 "-m",
+                                                 "\"test topic termination\"",
+                                                 "-n",
+                                                 "1",
+                                                 topicName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStdout().contains("Topic was already terminated"));
+        }
+    }
+
+    @Test
+    public void testPropertiesCLI() throws Exception {
+        final BrokerContainer container = pulsarCluster.getAnyBroker();
+        final String namespace = "public/default";
+
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "set-property",
+                "-k",
+                "a",
+                "-v",
+                "a",
+                namespace);
+        assertTrue(result.getStdout().isEmpty());
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "get-property",
+                "-k",
+                "a",
+                namespace);
+        assertTrue(result.getStdout().contains("a"));
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "remove-property",
+                "-k",
+                "a",
+                namespace);
+        assertTrue(result.getStdout().contains("a"));
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "remove-property",
+                "-k",
+                "a",
+                namespace);
+        assertTrue(result.getStdout().contains("null"));
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "set-properties",
+                "-p",
+                "a=a,b=b,c=c",
+                namespace);
+        assertTrue(result.getStdout().isEmpty());
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "get-properties",
+                namespace);
+        assertFalse(result.getStdout().isEmpty());
+
+        result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "namespaces",
+                "clear-properties",
+                namespace);
+        assertTrue(result.getStdout().isEmpty());
+
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "bookies",
+                    "set-bookie-rack",
+                    "-b", "localhost:8082",
+                    "-r", "");
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(
+                    e.getResult().getStderr().startsWith("rack name is invalid, it should not be null, empty or '/'"));
+        }
+
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "namespaces",
+                    "set-schema-autoupdate-strategy",
+                    namespace);
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().startsWith("Either --compatibility or --disabled must be specified"));
+        }
+    }
+
+    @Test
+    public void testSchemaCLI() throws Exception {
+        BrokerContainer container = pulsarCluster.getAnyBroker();
+        String topicName = "persistent://public/default/test-schema-cli";
+
+        ContainerExecResult result = container.execCmd(
+            PulsarCluster.CLIENT_SCRIPT,
+            "produce",
+            "-m",
+            "\"test topic schema\"",
+            "-n",
+            "1",
+            topicName);
+        assertTrue(result.getStdout().contains("1 messages successfully produced"));
+
+        result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "schemas",
+            "upload",
+            topicName,
+            "-f",
+            "/pulsar/conf/schema_example.json"
+        );
+        result.assertNoOutput();
+
+        // get schema
+        result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "schemas",
+            "get",
+            topicName);
+        assertTrue(result.getStdout().contains("\"type\": \"STRING\""));
+
+        // delete the schema
+        result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "schemas",
+            "delete",
+            topicName);
+        result.assertNoOutput();
+
+        // get schema again
+        try {
+            container.execCmd(PulsarCluster.ADMIN_SCRIPT,
+                              "schemas",
+                              "get",
+                              "persistent://public/default/test-schema-cli"
+                              );
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Schema not found"));
+        }
+
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "schemas",
+                    "extract",
+                    "--jar", "/pulsar/examples/api-examples.jar",
+                    "--type", "xml",
+                    "--classname", "org.apache.pulsar.functions.api.examples.pojo.Tick",
+                    topicName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().startsWith("Invalid schema type xml. Valid options are: avro, json"));
+        }
+    }
+
+    @Test
+    public void testSetInfiniteRetention() throws Exception {
+        ContainerExecResult result;
+
+        String namespace = "get-and-set-retention" + randomName(8);
+        pulsarCluster.createNamespace(namespace);
+
+        String[] setCommand = {
+            "namespaces", "set-retention", "public/" + namespace,
+            "--size", "-1",
+            "--time", "-1"
+        };
+
+        result = pulsarCluster.runAdminCommandOnAnyBroker(setCommand);
+        result.assertNoOutput();
+
+        String[] getCommand = {
+            "namespaces", "get-retention", "public/" + namespace
+        };
+
+        result = pulsarCluster.runAdminCommandOnAnyBroker(getCommand);
+        assertTrue(
+            result.getStdout().contains("\"retentionTimeInMinutes\" : -1"),
+            result.getStdout());
+        assertTrue(
+            result.getStdout().contains("\"retentionSizeInMB\" : -1"),
+            result.getStdout());
+    }
+
+    // authorization related tests
+
+    @Test
+    public void testGrantPermissionsAuthorizationDisabled() throws Exception {
+        ContainerExecResult result;
+
+        String namespace = "grant-permissions-" + randomName(8);
+        result = pulsarCluster.createNamespace(namespace);
+        assertEquals(0, result.getExitCode());
+
+        String[] grantCommand = {
+            "namespaces", "grant-permission", "public/" + namespace,
+            "--actions", "produce",
+            "--role", "test-role"
+        };
+        try {
+            pulsarCluster.runAdminCommandOnAnyBroker(grantCommand);
+        } catch (ContainerExecException cee) {
+            result = cee.getResult();
+            assertTrue(result.getStderr().contains("HTTP 501 Not Implemented"), result.getStderr());
+        }
+    }
+
+    @Test
+    public void testJarPojoSchemaUploadAvro() throws Exception {
+
+        ContainerExecResult containerExecResult = pulsarCluster.runAdminCommandOnAnyBroker(
+                "schemas",
+                "extract", "--jar", "/pulsar/examples/api-examples.jar", "--type", "avro",
+                "--classname", "org.apache.pulsar.functions.api.examples.pojo.Tick",
+                "persistent://public/default/pojo-avro");
+
+        Assert.assertEquals(containerExecResult.getExitCode(), 0);
+        testPublishAndConsume("persistent://public/default/pojo-avro", "avro", Schema.AVRO(Tick.class));
+    }
+
+    @Test
+    public void testJarPojoSchemaUploadJson() throws Exception {
+
+        ContainerExecResult containerExecResult = pulsarCluster.runAdminCommandOnAnyBroker(
+                "schemas",
+                "extract", "--jar", "/pulsar/examples/api-examples.jar", "--type", "json",
+                "--classname", "org.apache.pulsar.functions.api.examples.pojo.Tick",
+                "persistent://public/default/pojo-json");
+
+        Assert.assertEquals(containerExecResult.getExitCode(), 0);
+        testPublishAndConsume("persistent://public/default/pojo-json", "json", Schema.JSON(Tick.class));
+    }
+
+    private void testPublishAndConsume(String topic, String sub, Schema<Tick> type) throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
+
+        @Cleanup
+        Producer<Tick> producer = client.newProducer(type)
+                .topic(topic + "-message")
+                .create();
+
+        @Cleanup
+        Consumer<Tick> consumer = client.newConsumer(type)
+                .topic(topic + "-message")
+                .subscriptionName(sub)
+                .subscribe();
+
+        final int numOfMessages = 10;
+
+        for (int i = 1; i < numOfMessages; ++i) {
+            producer.send(new Tick(i, "Stock_" + i, 100 + i, 110 + i));
+        }
+
+        for (int i = 1; i < numOfMessages; ++i) {
+            Tick expected = new Tick(i, "Stock_" + i, 100 + i, 110 + i);
+            Message<Tick> receive = consumer.receive(5, TimeUnit.SECONDS);
+            Assert.assertEquals(receive.getValue(), expected);
+        }
+    }
+
+    @Test
+    public void testListNonPersistentTopicsCmd() throws Exception {
+        String persistentTopic = "test-list-non-persistent-topic";
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("topics", "create", persistentTopic);
+        assertEquals(result.getExitCode(), 0);
+        HttpGet get = new HttpGet(pulsarCluster.getHttpServiceUrl() + "/admin/v2/non-persistent/public/default");
+        try (CloseableHttpClient client = HttpClients.createDefault();
+             CloseableHttpResponse response = client.execute(get)) {
+            assertFalse(EntityUtils.toString(response.getEntity()).contains(persistentTopic));
+        }
+    }
+
+    @Test
+    public void testGenerateDocForModule() throws Exception {
+        String[] moduleNames = {
+                "clusters",
+                "tenants",
+                "brokers",
+                "broker-stats",
+                "namespaces",
+                "topics",
+                "schemas",
+                "bookies",
+                "functions",
+                "ns-isolation-policy",
+                "resource-quotas",
+                "functions",
+                "sources",
+                "sinks"
+        };
+        BrokerContainer container = pulsarCluster.getAnyBroker();
+        for (int i = 0; i < moduleNames.length; i++) {
+            ContainerExecResult result = container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "documents", "generate", moduleNames[i]);
+            Assert.assertTrue(result.getStdout().contains("# " + moduleNames[i]));
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClientToolTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClientToolTest.java
index a497c4b76e..394ae1e803 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClientToolTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClientToolTest.java
@@ -1,100 +1,100 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.ChaosContainer;
-import org.apache.pulsar.tests.integration.containers.ProxyContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.containers.ZKContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
-import org.testng.annotations.Test;
-
-public class ClientToolTest extends TopicMessagingBase {
-
-    private static final int MESSAGE_COUNT = 10;
-
-    @Test
-    public void testProduceConsumeThroughBrokers() throws Exception {
-        BrokerContainer broker = pulsarCluster.getAnyBroker();
-
-        final String serviceUrl = "pulsar://" + broker.getContainerName() + ":" + PulsarContainer.BROKER_PORT;
-        final String topicName = getNonPartitionedTopic("testProduceConsumeBroker", true);
-        testProduceConsume(serviceUrl, topicName);
-    }
-
-    @Test
-    public void testProduceConsumeThroughProxy() throws Exception {
-        ProxyContainer proxy = pulsarCluster.getProxy();
-        String serviceUrl = "pulsar://" + proxy.getContainerName() + ":" + PulsarContainer.BROKER_PORT;
-        final String topicName = getNonPartitionedTopic("testProduceConsumeProxy", true);
-        testProduceConsume(serviceUrl, topicName);
-    }
-
-    private void testProduceConsume(String serviceUrl, String topicName) throws Exception {
-        List<String> data = randomStrings();
-        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
-        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
-        produce(clientToolContainer, serviceUrl, topicName, data);
-        List<String> consumed = consume(clientToolContainer, serviceUrl, topicName);
-        assertEquals(consumed, data);
-    }
-
-    private static List<String> randomStrings() {
-        return IntStream.range(0, MESSAGE_COUNT).mapToObj(i -> randomName(10)).collect(Collectors.toList());
-    }
-
-    private void produce(ChaosContainer<?> container, String url, String topic, List<String> messages)
-            throws Exception {
-        ContainerExecResult result = container.execCmd("bin/pulsar-client", "--url", url, "produce", topic,
-                "-m", String.join(",", messages));
-        if (result.getExitCode() != 0) {
-            fail("Producing failed. Command output:\n" + result.getStdout()
-                    + "\nError output:\n" + result.getStderr());
-        }
-    }
-
-    private List<String> consume(ChaosContainer<?> container, String url, String topic) throws Exception {
-        ContainerExecResult result = container.execCmd("bin/pulsar-client", "--url", url, "consume",
-                "-s", randomName(8), "-n", String.valueOf(MESSAGE_COUNT), "-p", "Earliest", topic);
-        if (result.getExitCode() != 0) {
-            fail("Consuming failed. Command output:\n" + result.getStdout()
-                    + "\nError output:\n" + result.getStderr());
-        }
-        String output = result.getStdout();
-        Pattern message = Pattern.compile(
-                "----- got message -----\npublishTime:\\[(.*)\\], eventTime:\\[(.*)\\], key:\\[null\\], "
-                        + "properties:\\[\\], content:(.*)");
-        Matcher matcher = message.matcher(output);
-        List<String> received = new ArrayList<>(MESSAGE_COUNT);
-        while (matcher.find()) {
-            received.add(matcher.group(3));
-        }
-        return received;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.ChaosContainer;
+import org.apache.pulsar.tests.integration.containers.ProxyContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.containers.ZKContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
+import org.testng.annotations.Test;
+
+public class ClientToolTest extends TopicMessagingBase {
+
+    private static final int MESSAGE_COUNT = 10;
+
+    @Test
+    public void testProduceConsumeThroughBrokers() throws Exception {
+        BrokerContainer broker = pulsarCluster.getAnyBroker();
+
+        final String serviceUrl = "pulsar://" + broker.getContainerName() + ":" + PulsarContainer.BROKER_PORT;
+        final String topicName = getNonPartitionedTopic("testProduceConsumeBroker", true);
+        testProduceConsume(serviceUrl, topicName);
+    }
+
+    @Test
+    public void testProduceConsumeThroughProxy() throws Exception {
+        ProxyContainer proxy = pulsarCluster.getProxy();
+        String serviceUrl = "pulsar://" + proxy.getContainerName() + ":" + PulsarContainer.BROKER_PORT;
+        final String topicName = getNonPartitionedTopic("testProduceConsumeProxy", true);
+        testProduceConsume(serviceUrl, topicName);
+    }
+
+    private void testProduceConsume(String serviceUrl, String topicName) throws Exception {
+        List<String> data = randomStrings();
+        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
+        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
+        produce(clientToolContainer, serviceUrl, topicName, data);
+        List<String> consumed = consume(clientToolContainer, serviceUrl, topicName);
+        assertEquals(consumed, data);
+    }
+
+    private static List<String> randomStrings() {
+        return IntStream.range(0, MESSAGE_COUNT).mapToObj(i -> randomName(10)).collect(Collectors.toList());
+    }
+
+    private void produce(ChaosContainer<?> container, String url, String topic, List<String> messages)
+            throws Exception {
+        ContainerExecResult result = container.execCmd("bin/pulsar-client", "--url", url, "produce", topic,
+                "-m", String.join(",", messages));
+        if (result.getExitCode() != 0) {
+            fail("Producing failed. Command output:\n" + result.getStdout()
+                    + "\nError output:\n" + result.getStderr());
+        }
+    }
+
+    private List<String> consume(ChaosContainer<?> container, String url, String topic) throws Exception {
+        ContainerExecResult result = container.execCmd("bin/pulsar-client", "--url", url, "consume",
+                "-s", randomName(8), "-n", String.valueOf(MESSAGE_COUNT), "-p", "Earliest", topic);
+        if (result.getExitCode() != 0) {
+            fail("Consuming failed. Command output:\n" + result.getStdout()
+                    + "\nError output:\n" + result.getStderr());
+        }
+        String output = result.getStdout();
+        Pattern message = Pattern.compile(
+                "----- got message -----\npublishTime:\\[(.*)\\], eventTime:\\[(.*)\\], key:\\[null\\], "
+                        + "properties:\\[\\], content:(.*)");
+        Matcher matcher = message.matcher(output);
+        List<String> received = new ArrayList<>(MESSAGE_COUNT);
+        while (matcher.find()) {
+            received.add(matcher.group(3));
+        }
+        return received;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClusterMetadataTearDownTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClusterMetadataTearDownTest.java
index 899daa5dff..c630b184f9 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClusterMetadataTearDownTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/ClusterMetadataTearDownTest.java
@@ -1,232 +1,232 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.io.IOException;
-import java.net.URI;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.bookkeeper.client.BKException;
-import org.apache.bookkeeper.conf.ServerConfiguration;
-import org.apache.bookkeeper.meta.LedgerManager;
-import org.apache.bookkeeper.meta.MetadataBookieDriver;
-import org.apache.bookkeeper.meta.MetadataDrivers;
-import org.apache.bookkeeper.stats.NullStatsLogger;
-import org.apache.pulsar.PulsarClusterMetadataTeardown;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.metadata.api.MetadataStore;
-import org.apache.pulsar.metadata.api.MetadataStoreConfig;
-import org.apache.pulsar.metadata.api.MetadataStoreFactory;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.containers.ChaosContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class ClusterMetadataTearDownTest extends TestRetrySupport {
-
-    private final PulsarClusterSpec spec = PulsarClusterSpec.builder()
-            .clusterName("ClusterMetadataTearDownTest-" + UUID.randomUUID().toString().substring(0, 8))
-            .numProxies(0)
-            .numFunctionWorkers(0)
-            .build();
-
-    private PulsarCluster pulsarCluster;
-
-    private MetadataStore localMetadataStore;
-    private MetadataStore configStore;
-
-    private String metadataServiceUri;
-    private MetadataBookieDriver driver;
-    private LedgerManager ledgerManager;
-
-    private PulsarClient client;
-    private PulsarAdmin admin;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup() throws Exception {
-        incrementSetupNumber();
-        Map<String, String> brokerEnvs = new HashMap<>();
-        brokerEnvs.put("systemTopicEnabled", "false");
-        brokerEnvs.put("topicLevelPoliciesEnabled", "false");
-        spec.brokerEnvs(brokerEnvs);
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-        metadataServiceUri = "zk+null://" + pulsarCluster.getZKConnString() + "/ledgers";
-
-        localMetadataStore = MetadataStoreFactory.create(pulsarCluster.getZKConnString(),
-                MetadataStoreConfig.builder().build());
-        configStore = MetadataStoreFactory.create(pulsarCluster.getCSConnString(),
-                MetadataStoreConfig.builder().build());
-
-        driver = MetadataDrivers.getBookieDriver(URI.create(metadataServiceUri));
-        driver.initialize(new ServerConfiguration().setMetadataServiceUri(metadataServiceUri),
-                NullStatsLogger.INSTANCE);
-        ledgerManager = driver.getLedgerManagerFactory().newLedgerManager();
-
-        client = PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
-        admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup() throws PulsarClientException {
-        markCurrentSetupNumberCleaned();
-        if (client != null) {
-            client.close();
-        }
-        if (admin != null) {
-            admin.close();
-        }
-
-        try {
-            ledgerManager.close();
-        } catch (IOException e) {
-            log.warn("Failed to close ledger manager: ", e);
-        }
-        driver.close();
-        try {
-            configStore.close();
-        } catch (Exception ignored) {
-        }
-        try {
-            localMetadataStore.close();
-        } catch (Exception ignored) {
-        }
-        pulsarCluster.stop();
-    }
-
-    @Test
-    public void testDeleteCluster() throws Exception {
-        assertEquals(getNumOfLedgers(), 0);
-        final String tenant = "my-tenant";
-        final String namespace = tenant + "/my-ns";
-
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(new HashSet<>(), Collections.singleton(pulsarCluster.getClusterName())));
-        admin.namespaces().createNamespace(namespace);
-
-        String[] topics = { "topic-1", "topic-2", namespace + "/topic-1" };
-        for (String topic : topics) {
-            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
-                producer.send("msg");
-            }
-            String[] subscriptions = { "sub-1", "sub-2" };
-            for (String subscription : subscriptions) {
-                try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                        .topic(topic)
-                        .subscriptionName(subscription)
-                        .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                        .subscribe()) {
-                    Message<String> msg = consumer.receive(5, TimeUnit.SECONDS);
-                    consumer.acknowledge(msg);
-                }
-            }
-        }
-
-        final String partitionedTopic = namespace + "/par-topic";
-        admin.topics().createPartitionedTopic(partitionedTopic, 3);
-
-        // TODO: the schema ledgers of a partitioned topic cannot be deleted completely now,
-        //   so we create producers/consumers without schema here
-        try (Producer<byte[]> producer = client.newProducer().topic(partitionedTopic).create()) {
-            producer.send("msg".getBytes());
-            try (Consumer<byte[]> consumer = client.newConsumer()
-                    .topic(partitionedTopic)
-                    .subscriptionName("my-sub")
-                    .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                    .subscribe()) {
-                Message<byte[]> msg = consumer.receive(5, TimeUnit.SECONDS);
-                consumer.acknowledge(msg);
-            }
-        }
-
-        pulsarCluster.getBrokers().forEach(ChaosContainer::stop);
-
-        assertTrue(getNumOfLedgers() > 0);
-        log.info("Before delete, cluster name: {}, num of ledgers: {}", pulsarCluster.getClusterName(),
-                getNumOfLedgers());
-
-        String[] args = { "-zk", pulsarCluster.getZKConnString(),
-                "-cs", pulsarCluster.getCSConnString(),
-                "-c", pulsarCluster.getClusterName(),
-                "--bookkeeper-metadata-service-uri", metadataServiceUri };
-        PulsarClusterMetadataTeardown.main(args);
-
-
-        // 1. Check Bookie for number of ledgers
-        assertEquals(getNumOfLedgers(), 0);
-
-        // 2. Check ZooKeeper for relative nodes
-        final int zkOpTimeoutMs = 10000;
-        List<String> localNodes = localMetadataStore.getChildren("/").join();
-        for (String node : PulsarClusterMetadataTeardown.localZkNodes) {
-            assertFalse(localNodes.contains(node));
-        }
-        List<String> clusterNodes = configStore.getChildren("/admin/clusters").join();
-        assertFalse(clusterNodes.contains(pulsarCluster.getClusterName()));
-
-        // Try delete again, should not fail
-        PulsarClusterMetadataTeardown.main(args);
-    }
-
-    private long getNumOfLedgers() {
-        final AtomicInteger returnCode = new AtomicInteger(BKException.Code.OK);
-        final CountDownLatch processDone = new CountDownLatch(1);
-        final AtomicLong numOfLedgers = new AtomicLong(0L);
-
-        ledgerManager.asyncProcessLedgers((ledgerId, cb) -> numOfLedgers.incrementAndGet(), (rc, path, ctx) -> {
-            returnCode.set(rc);
-            processDone.countDown();
-        }, null, BKException.Code.OK, BKException.Code.ReadException);
-
-        try {
-            processDone.await(5, TimeUnit.SECONDS); // a timeout which is long enough
-        } catch (InterruptedException e) {
-            fail("asyncProcessLedgers failed", e);
-        }
-        return numOfLedgers.get();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.io.IOException;
+import java.net.URI;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.bookkeeper.client.BKException;
+import org.apache.bookkeeper.conf.ServerConfiguration;
+import org.apache.bookkeeper.meta.LedgerManager;
+import org.apache.bookkeeper.meta.MetadataBookieDriver;
+import org.apache.bookkeeper.meta.MetadataDrivers;
+import org.apache.bookkeeper.stats.NullStatsLogger;
+import org.apache.pulsar.PulsarClusterMetadataTeardown;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.metadata.api.MetadataStore;
+import org.apache.pulsar.metadata.api.MetadataStoreConfig;
+import org.apache.pulsar.metadata.api.MetadataStoreFactory;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.containers.ChaosContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class ClusterMetadataTearDownTest extends TestRetrySupport {
+
+    private final PulsarClusterSpec spec = PulsarClusterSpec.builder()
+            .clusterName("ClusterMetadataTearDownTest-" + UUID.randomUUID().toString().substring(0, 8))
+            .numProxies(0)
+            .numFunctionWorkers(0)
+            .build();
+
+    private PulsarCluster pulsarCluster;
+
+    private MetadataStore localMetadataStore;
+    private MetadataStore configStore;
+
+    private String metadataServiceUri;
+    private MetadataBookieDriver driver;
+    private LedgerManager ledgerManager;
+
+    private PulsarClient client;
+    private PulsarAdmin admin;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup() throws Exception {
+        incrementSetupNumber();
+        Map<String, String> brokerEnvs = new HashMap<>();
+        brokerEnvs.put("systemTopicEnabled", "false");
+        brokerEnvs.put("topicLevelPoliciesEnabled", "false");
+        spec.brokerEnvs(brokerEnvs);
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+        metadataServiceUri = "zk+null://" + pulsarCluster.getZKConnString() + "/ledgers";
+
+        localMetadataStore = MetadataStoreFactory.create(pulsarCluster.getZKConnString(),
+                MetadataStoreConfig.builder().build());
+        configStore = MetadataStoreFactory.create(pulsarCluster.getCSConnString(),
+                MetadataStoreConfig.builder().build());
+
+        driver = MetadataDrivers.getBookieDriver(URI.create(metadataServiceUri));
+        driver.initialize(new ServerConfiguration().setMetadataServiceUri(metadataServiceUri),
+                NullStatsLogger.INSTANCE);
+        ledgerManager = driver.getLedgerManagerFactory().newLedgerManager();
+
+        client = PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
+        admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup() throws PulsarClientException {
+        markCurrentSetupNumberCleaned();
+        if (client != null) {
+            client.close();
+        }
+        if (admin != null) {
+            admin.close();
+        }
+
+        try {
+            ledgerManager.close();
+        } catch (IOException e) {
+            log.warn("Failed to close ledger manager: ", e);
+        }
+        driver.close();
+        try {
+            configStore.close();
+        } catch (Exception ignored) {
+        }
+        try {
+            localMetadataStore.close();
+        } catch (Exception ignored) {
+        }
+        pulsarCluster.stop();
+    }
+
+    @Test
+    public void testDeleteCluster() throws Exception {
+        assertEquals(getNumOfLedgers(), 0);
+        final String tenant = "my-tenant";
+        final String namespace = tenant + "/my-ns";
+
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(new HashSet<>(), Collections.singleton(pulsarCluster.getClusterName())));
+        admin.namespaces().createNamespace(namespace);
+
+        String[] topics = { "topic-1", "topic-2", namespace + "/topic-1" };
+        for (String topic : topics) {
+            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
+                producer.send("msg");
+            }
+            String[] subscriptions = { "sub-1", "sub-2" };
+            for (String subscription : subscriptions) {
+                try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                        .topic(topic)
+                        .subscriptionName(subscription)
+                        .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                        .subscribe()) {
+                    Message<String> msg = consumer.receive(5, TimeUnit.SECONDS);
+                    consumer.acknowledge(msg);
+                }
+            }
+        }
+
+        final String partitionedTopic = namespace + "/par-topic";
+        admin.topics().createPartitionedTopic(partitionedTopic, 3);
+
+        // TODO: the schema ledgers of a partitioned topic cannot be deleted completely now,
+        //   so we create producers/consumers without schema here
+        try (Producer<byte[]> producer = client.newProducer().topic(partitionedTopic).create()) {
+            producer.send("msg".getBytes());
+            try (Consumer<byte[]> consumer = client.newConsumer()
+                    .topic(partitionedTopic)
+                    .subscriptionName("my-sub")
+                    .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                    .subscribe()) {
+                Message<byte[]> msg = consumer.receive(5, TimeUnit.SECONDS);
+                consumer.acknowledge(msg);
+            }
+        }
+
+        pulsarCluster.getBrokers().forEach(ChaosContainer::stop);
+
+        assertTrue(getNumOfLedgers() > 0);
+        log.info("Before delete, cluster name: {}, num of ledgers: {}", pulsarCluster.getClusterName(),
+                getNumOfLedgers());
+
+        String[] args = { "-zk", pulsarCluster.getZKConnString(),
+                "-cs", pulsarCluster.getCSConnString(),
+                "-c", pulsarCluster.getClusterName(),
+                "--bookkeeper-metadata-service-uri", metadataServiceUri };
+        PulsarClusterMetadataTeardown.main(args);
+
+
+        // 1. Check Bookie for number of ledgers
+        assertEquals(getNumOfLedgers(), 0);
+
+        // 2. Check ZooKeeper for relative nodes
+        final int zkOpTimeoutMs = 10000;
+        List<String> localNodes = localMetadataStore.getChildren("/").join();
+        for (String node : PulsarClusterMetadataTeardown.localZkNodes) {
+            assertFalse(localNodes.contains(node));
+        }
+        List<String> clusterNodes = configStore.getChildren("/admin/clusters").join();
+        assertFalse(clusterNodes.contains(pulsarCluster.getClusterName()));
+
+        // Try delete again, should not fail
+        PulsarClusterMetadataTeardown.main(args);
+    }
+
+    private long getNumOfLedgers() {
+        final AtomicInteger returnCode = new AtomicInteger(BKException.Code.OK);
+        final CountDownLatch processDone = new CountDownLatch(1);
+        final AtomicLong numOfLedgers = new AtomicLong(0L);
+
+        ledgerManager.asyncProcessLedgers((ledgerId, cb) -> numOfLedgers.incrementAndGet(), (rc, path, ctx) -> {
+            returnCode.set(rc);
+            processDone.countDown();
+        }, null, BKException.Code.OK, BKException.Code.ReadException);
+
+        try {
+            processDone.await(5, TimeUnit.SECONDS); // a timeout which is long enough
+        } catch (InterruptedException e) {
+            fail("asyncProcessLedgers failed", e);
+        }
+        return numOfLedgers.get();
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FileSystemPackagesCliTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FileSystemPackagesCliTest.java
index 59b8a6c400..99eb7d2951 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FileSystemPackagesCliTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FileSystemPackagesCliTest.java
@@ -1,130 +1,130 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import java.util.HashMap;
-import java.util.Map;
-import org.apache.commons.lang3.RandomStringUtils;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class FileSystemPackagesCliTest extends TestRetrySupport {
-
-    private static final String clusterNamePrefix = "file-system-packages-service";
-    private PulsarCluster pulsarCluster;
-
-    @BeforeClass(alwaysRun = true)
-    public final void setup() throws Exception {
-        incrementSetupNumber();
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .clusterName(String.format("%s-%s", clusterNamePrefix, RandomStringUtils.randomAlphabetic(6)))
-                .brokerEnvs(getPackagesManagementServiceEnvs())
-                .build();
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public final void cleanup() {
-        markCurrentSetupNumberCleaned();
-        if (pulsarCluster != null) {
-            pulsarCluster.stop();
-            pulsarCluster = null;
-        }
-    }
-
-    private Map<String, String> getPackagesManagementServiceEnvs() {
-        Map<String, String> envs = new HashMap<>();
-        envs.put("enablePackagesManagement", "true");
-        envs.put("packagesManagementStorageProvider",
-                "org.apache.pulsar.packages.management.storage.filesystem.FileSystemPackagesStorageProvider");
-        return envs;
-    }
-
-    @Test(timeOut = 60000 * 8)
-    public void testPackagesOperationsWithUploadingPackagesUsingFileSystemStorageProvider() throws Exception {
-        BrokerContainer container = pulsarCluster.getBroker(0);
-
-        String testPackageName = "function://public/default/test@v1";
-        String[] uploadCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "upload", "--description",
-                "a test package", "--path", PulsarCluster.ADMIN_SCRIPT, testPackageName};
-        ContainerExecResult result = container.execCmd(uploadCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        String downloadFile = "tmp-file-" + RandomStringUtils.randomAlphabetic(8);
-        String[] downloadCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "download",
-                "--path", downloadFile, testPackageName};
-        result = container.execCmd(downloadCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        String[] diffCmd = new String[]{"diff", PulsarCluster.ADMIN_SCRIPT, downloadFile};
-        result = container.execCmd(diffCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        String[] getMetadataCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "get-metadata", testPackageName};
-        result = container.execCmd(getMetadataCmd);
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("a test package"));
-
-        String[] listCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "list", "--type", "function",
-                "public/default"};
-        result = container.execCmd(listCmd);
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("test"));
-
-        String[] listVersionsCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "list-versions",
-                "function://public/default/test"};
-        result = container.execCmd(listVersionsCmd);
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("v1"));
-
-        String contact = "test@apache.org";
-        String[] updateMetadataCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "update-metadata",
-                "--description", "a test package", "--contact", contact, "-PpropertyA=A", testPackageName};
-        result = container.execCmd(updateMetadataCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        result = container.execCmd(getMetadataCmd);
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("a test package"));
-        assertTrue(result.getStdout().contains(contact));
-        assertTrue(result.getStdout().contains("propertyA"));
-
-        String[] deleteCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "delete", testPackageName};
-        result = container.execCmd(deleteCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        result = container.execCmd(listVersionsCmd);
-        assertEquals(result.getExitCode(), 0);
-        result.assertNoStdout();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class FileSystemPackagesCliTest extends TestRetrySupport {
+
+    private static final String clusterNamePrefix = "file-system-packages-service";
+    private PulsarCluster pulsarCluster;
+
+    @BeforeClass(alwaysRun = true)
+    public final void setup() throws Exception {
+        incrementSetupNumber();
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .clusterName(String.format("%s-%s", clusterNamePrefix, RandomStringUtils.randomAlphabetic(6)))
+                .brokerEnvs(getPackagesManagementServiceEnvs())
+                .build();
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public final void cleanup() {
+        markCurrentSetupNumberCleaned();
+        if (pulsarCluster != null) {
+            pulsarCluster.stop();
+            pulsarCluster = null;
+        }
+    }
+
+    private Map<String, String> getPackagesManagementServiceEnvs() {
+        Map<String, String> envs = new HashMap<>();
+        envs.put("enablePackagesManagement", "true");
+        envs.put("packagesManagementStorageProvider",
+                "org.apache.pulsar.packages.management.storage.filesystem.FileSystemPackagesStorageProvider");
+        return envs;
+    }
+
+    @Test(timeOut = 60000 * 8)
+    public void testPackagesOperationsWithUploadingPackagesUsingFileSystemStorageProvider() throws Exception {
+        BrokerContainer container = pulsarCluster.getBroker(0);
+
+        String testPackageName = "function://public/default/test@v1";
+        String[] uploadCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "upload", "--description",
+                "a test package", "--path", PulsarCluster.ADMIN_SCRIPT, testPackageName};
+        ContainerExecResult result = container.execCmd(uploadCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        String downloadFile = "tmp-file-" + RandomStringUtils.randomAlphabetic(8);
+        String[] downloadCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "download",
+                "--path", downloadFile, testPackageName};
+        result = container.execCmd(downloadCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        String[] diffCmd = new String[]{"diff", PulsarCluster.ADMIN_SCRIPT, downloadFile};
+        result = container.execCmd(diffCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        String[] getMetadataCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "get-metadata", testPackageName};
+        result = container.execCmd(getMetadataCmd);
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("a test package"));
+
+        String[] listCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "list", "--type", "function",
+                "public/default"};
+        result = container.execCmd(listCmd);
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("test"));
+
+        String[] listVersionsCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "list-versions",
+                "function://public/default/test"};
+        result = container.execCmd(listVersionsCmd);
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("v1"));
+
+        String contact = "test@apache.org";
+        String[] updateMetadataCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "update-metadata",
+                "--description", "a test package", "--contact", contact, "-PpropertyA=A", testPackageName};
+        result = container.execCmd(updateMetadataCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        result = container.execCmd(getMetadataCmd);
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("a test package"));
+        assertTrue(result.getStdout().contains(contact));
+        assertTrue(result.getStdout().contains("propertyA"));
+
+        String[] deleteCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "delete", testPackageName};
+        result = container.execCmd(deleteCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        result = container.execCmd(listVersionsCmd);
+        assertEquals(result.getExitCode(), 0);
+        result.assertNoStdout();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FunctionsCLITest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FunctionsCLITest.java
index b8b54636cb..90e311e5ad 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FunctionsCLITest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/FunctionsCLITest.java
@@ -1,91 +1,91 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.WorkerContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTestBase;
-import org.apache.pulsar.tests.integration.functions.utils.UploadDownloadCommandGenerator;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-@Slf4j
-public class FunctionsCLITest extends PulsarFunctionsTestBase {
-
-    //
-    // Tests on uploading/downloading function packages.
-    //
-
-    public String uploadFunction() throws Exception {
-        String bkPkgPath = String.format("%s/%s/%s",
-            "tenant-" + randomName(8),
-            "ns-" + randomName(8),
-            "fn-" + randomName(8));
-
-        UploadDownloadCommandGenerator generator = UploadDownloadCommandGenerator.createUploader(
-            PulsarCluster.ADMIN_SCRIPT,
-            bkPkgPath);
-        String actualCommand = generator.generateCommand();
-
-        log.info(actualCommand);
-
-        String[] commands = {
-            "sh", "-c", actualCommand
-        };
-        ContainerExecResult output = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertEquals(0, output.getExitCode());
-        assertTrue(output.getStdout().contains("Uploaded successfully"));
-        return bkPkgPath;
-    }
-
-    // Flaky Test: https://github.com/apache/pulsar/issues/6179
-    // @Test
-    public void testUploadDownload() throws Exception {
-        String bkPkgPath = uploadFunction();
-        String localPkgFile = "/tmp/checkdownload-" + randomName(16);
-
-        UploadDownloadCommandGenerator generator = UploadDownloadCommandGenerator.createDownloader(
-                localPkgFile,
-                bkPkgPath);
-        String actualCommand = generator.generateCommand();
-
-        log.info(actualCommand);
-
-        String[] commands = {
-            "sh", "-c", actualCommand
-        };
-        WorkerContainer container = pulsarCluster.getAnyWorker();
-        ContainerExecResult output = container.execCmd(commands);
-        assertEquals(0, output.getExitCode());
-        assertTrue(output.getStdout().contains("Downloaded successfully"));
-        String[] diffCommand = {
-            "diff",
-            PulsarCluster.ADMIN_SCRIPT,
-            localPkgFile
-        };
-        output = container.execCmd(diffCommand);
-        assertEquals(0, output.getExitCode());
-        output.assertNoOutput();
-    }
-
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.WorkerContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTestBase;
+import org.apache.pulsar.tests.integration.functions.utils.UploadDownloadCommandGenerator;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+@Slf4j
+public class FunctionsCLITest extends PulsarFunctionsTestBase {
+
+    //
+    // Tests on uploading/downloading function packages.
+    //
+
+    public String uploadFunction() throws Exception {
+        String bkPkgPath = String.format("%s/%s/%s",
+            "tenant-" + randomName(8),
+            "ns-" + randomName(8),
+            "fn-" + randomName(8));
+
+        UploadDownloadCommandGenerator generator = UploadDownloadCommandGenerator.createUploader(
+            PulsarCluster.ADMIN_SCRIPT,
+            bkPkgPath);
+        String actualCommand = generator.generateCommand();
+
+        log.info(actualCommand);
+
+        String[] commands = {
+            "sh", "-c", actualCommand
+        };
+        ContainerExecResult output = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertEquals(0, output.getExitCode());
+        assertTrue(output.getStdout().contains("Uploaded successfully"));
+        return bkPkgPath;
+    }
+
+    // Flaky Test: https://github.com/apache/pulsar/issues/6179
+    // @Test
+    public void testUploadDownload() throws Exception {
+        String bkPkgPath = uploadFunction();
+        String localPkgFile = "/tmp/checkdownload-" + randomName(16);
+
+        UploadDownloadCommandGenerator generator = UploadDownloadCommandGenerator.createDownloader(
+                localPkgFile,
+                bkPkgPath);
+        String actualCommand = generator.generateCommand();
+
+        log.info(actualCommand);
+
+        String[] commands = {
+            "sh", "-c", actualCommand
+        };
+        WorkerContainer container = pulsarCluster.getAnyWorker();
+        ContainerExecResult output = container.execCmd(commands);
+        assertEquals(0, output.getExitCode());
+        assertTrue(output.getStdout().contains("Downloaded successfully"));
+        String[] diffCommand = {
+            "diff",
+            PulsarCluster.ADMIN_SCRIPT,
+            localPkgFile
+        };
+        output = container.execCmd(diffCommand);
+        assertEquals(0, output.getExitCode());
+        output.assertNoOutput();
+    }
+
+
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/HealthCheckTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/HealthCheckTest.java
index 4cacad3f76..3ae182f64a 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/HealthCheckTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/HealthCheckTest.java
@@ -1,118 +1,118 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import com.fasterxml.jackson.core.type.TypeReference;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.containers.BKContainer;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-/**
- * Test the healthcheck command.
- */
-public class HealthCheckTest extends TestRetrySupport {
-
-    private static final Logger log = LoggerFactory.getLogger(HealthCheckTest.class);
-
-    private final PulsarClusterSpec spec = PulsarClusterSpec.builder()
-        .clusterName("HealthCheckTest-" + UUID.randomUUID().toString().substring(0, 8))
-        .numProxies(0)
-        .numFunctionWorkers(0)
-        .build();
-
-    private PulsarCluster pulsarCluster = null;
-
-    @BeforeMethod(alwaysRun = true)
-    public final void setup() throws Exception {
-        incrementSetupNumber();
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-    }
-
-    @AfterMethod(alwaysRun = true)
-    public final void cleanup() {
-        markCurrentSetupNumberCleaned();
-        if (pulsarCluster != null) {
-            pulsarCluster.stop();
-            pulsarCluster = null;
-        }
-    }
-
-    @Test
-    public void testEverythingOK() throws Exception {
-        for (BrokerContainer b : pulsarCluster.getBrokers()) {
-            ContainerExecResult result = b.execCmd(PulsarCluster.ADMIN_SCRIPT, "brokers", "healthcheck");
-            Assert.assertEquals(result.getExitCode(), 0);
-            Assert.assertEquals(result.getStdout().trim(), "ok");
-        }
-    }
-
-    private void assertHealthcheckFailure() throws Exception {
-        for (BrokerContainer b : pulsarCluster.getBrokers()) {
-            try {
-                b.execCmd(PulsarCluster.ADMIN_SCRIPT, "brokers", "healthcheck");
-                Assert.fail("Should always fail");
-            } catch (ContainerExecException e) {
-                Assert.assertEquals(e.getResult().getExitCode(), 1);
-            }
-        }
-    }
-
-    @Test
-    public void testZooKeeperDown() throws Exception {
-        pulsarCluster.getZooKeeper().execCmd("pkill", "-STOP", "java");
-        assertHealthcheckFailure();
-    }
-
-    // Disabled until PulsarAdmin can time out (#2891)
-    // @Test
-    // public void testBrokerDown() throws Exception {
-    //     for (BrokerContainer b : pulsarCluster.getBrokers()) {
-    //         b.execCmd("pkill", "-STOP", "java");
-    //     }
-    //     assertHealthcheckFailure();
-    // }
-
-    @Test
-    public void testBookKeeperDown() throws Exception {
-        for (BKContainer b : pulsarCluster.getBookies()) {
-            b.execCmd("pkill", "-STOP", "java");
-        }
-        assertHealthcheckFailure();
-    }
-
-    private static Map<String, String> parseOutput(String output) throws Exception {
-        ObjectMapper mapper = new ObjectMapper();
-        return mapper.readValue(output, new TypeReference<HashMap<String, String>>() {});
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.containers.BKContainer;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.AfterMethod;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+/**
+ * Test the healthcheck command.
+ */
+public class HealthCheckTest extends TestRetrySupport {
+
+    private static final Logger log = LoggerFactory.getLogger(HealthCheckTest.class);
+
+    private final PulsarClusterSpec spec = PulsarClusterSpec.builder()
+        .clusterName("HealthCheckTest-" + UUID.randomUUID().toString().substring(0, 8))
+        .numProxies(0)
+        .numFunctionWorkers(0)
+        .build();
+
+    private PulsarCluster pulsarCluster = null;
+
+    @BeforeMethod(alwaysRun = true)
+    public final void setup() throws Exception {
+        incrementSetupNumber();
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+    }
+
+    @AfterMethod(alwaysRun = true)
+    public final void cleanup() {
+        markCurrentSetupNumberCleaned();
+        if (pulsarCluster != null) {
+            pulsarCluster.stop();
+            pulsarCluster = null;
+        }
+    }
+
+    @Test
+    public void testEverythingOK() throws Exception {
+        for (BrokerContainer b : pulsarCluster.getBrokers()) {
+            ContainerExecResult result = b.execCmd(PulsarCluster.ADMIN_SCRIPT, "brokers", "healthcheck");
+            Assert.assertEquals(result.getExitCode(), 0);
+            Assert.assertEquals(result.getStdout().trim(), "ok");
+        }
+    }
+
+    private void assertHealthcheckFailure() throws Exception {
+        for (BrokerContainer b : pulsarCluster.getBrokers()) {
+            try {
+                b.execCmd(PulsarCluster.ADMIN_SCRIPT, "brokers", "healthcheck");
+                Assert.fail("Should always fail");
+            } catch (ContainerExecException e) {
+                Assert.assertEquals(e.getResult().getExitCode(), 1);
+            }
+        }
+    }
+
+    @Test
+    public void testZooKeeperDown() throws Exception {
+        pulsarCluster.getZooKeeper().execCmd("pkill", "-STOP", "java");
+        assertHealthcheckFailure();
+    }
+
+    // Disabled until PulsarAdmin can time out (#2891)
+    // @Test
+    // public void testBrokerDown() throws Exception {
+    //     for (BrokerContainer b : pulsarCluster.getBrokers()) {
+    //         b.execCmd("pkill", "-STOP", "java");
+    //     }
+    //     assertHealthcheckFailure();
+    // }
+
+    @Test
+    public void testBookKeeperDown() throws Exception {
+        for (BKContainer b : pulsarCluster.getBookies()) {
+            b.execCmd("pkill", "-STOP", "java");
+        }
+        assertHealthcheckFailure();
+    }
+
+    private static Map<String, String> parseOutput(String output) throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+        return mapper.readValue(output, new TypeReference<HashMap<String, String>>() {});
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PackagesCliTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PackagesCliTest.java
index 440ab2fb3b..e985a50c82 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PackagesCliTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PackagesCliTest.java
@@ -1,144 +1,144 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.HashMap;
-import java.util.Map;
-import org.apache.commons.lang3.RandomStringUtils;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class PackagesCliTest extends TestRetrySupport {
-
-    private static final String clusterNamePrefix = "packages-service";
-    private PulsarCluster pulsarCluster;
-
-    @BeforeClass(alwaysRun = true)
-    public final void setup() throws Exception {
-        incrementSetupNumber();
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .clusterName(String.format("%s-%s", clusterNamePrefix, RandomStringUtils.randomAlphabetic(6)))
-                .brokerEnvs(getPackagesManagementServiceEnvs())
-                .build();
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public final void cleanup() {
-        markCurrentSetupNumberCleaned();
-        if (pulsarCluster != null) {
-            pulsarCluster.stop();
-            pulsarCluster = null;
-        }
-    }
-
-    private Map<String, String> getPackagesManagementServiceEnvs() {
-        Map<String, String> envs = new HashMap<>();
-        envs.put("enablePackagesManagement", "true");
-        envs.put("packagesManagementLedgerRootPath", "/ledgers");
-        return envs;
-    }
-
-    @Test(timeOut = 60000 * 5)
-    public void testPackagesOperationsWithoutUploadingPackages() throws Exception {
-        ContainerExecResult result = runPackagesCommand("list", "--type", "function", "public/default");
-        assertEquals(result.getExitCode(), 0);
-
-        result = runPackagesCommand("list-versions", "function://public/default/test");
-        assertEquals(result.getExitCode(), 0);
-
-        try {
-            result = runPackagesCommand("download", "function://public/default/test@v1", "--path", "test-admin");
-            fail("this command should be failed");
-        } catch (Exception e) {
-            // expected exception
-        }
-    }
-
-    @Test(timeOut = 60000 * 8)
-    public void testPackagesOperationsWithUploadingPackages() throws Exception {
-        String testPackageName = "function://public/default/test@v1";
-        ContainerExecResult result = runPackagesCommand("upload", "--description", "a test package",
-                "--path", PulsarCluster.ADMIN_SCRIPT, testPackageName);
-        assertEquals(result.getExitCode(), 0);
-
-        BrokerContainer container = pulsarCluster.getBroker(0);
-        String downloadFile = "tmp-file-" + RandomStringUtils.randomAlphabetic(8);
-        String[] downloadCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "download",
-                "--path", downloadFile, testPackageName};
-        result = container.execCmd(downloadCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        String[] diffCmd = new String[]{"diff", PulsarCluster.ADMIN_SCRIPT, downloadFile};
-        result = container.execCmd(diffCmd);
-        assertEquals(result.getExitCode(), 0);
-
-        result = runPackagesCommand("get-metadata", testPackageName);
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("a test package"));
-
-        result = runPackagesCommand("list", "--type", "function", "public/default");
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("test"));
-
-        result = runPackagesCommand("list-versions", "function://public/default/test");
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("v1"));
-
-        String contact = "test@apache.org";
-        result = runPackagesCommand("update-metadata", "--description", "a test package",
-                "--contact", contact, "-PpropertyA=A", testPackageName);
-        assertEquals(result.getExitCode(), 0);
-
-        result = runPackagesCommand("get-metadata", testPackageName);
-        assertEquals(result.getExitCode(), 0);
-        assertFalse(result.getStdout().isEmpty());
-        assertTrue(result.getStdout().contains("a test package"));
-        assertTrue(result.getStdout().contains(contact));
-        assertTrue(result.getStdout().contains("propertyA"));
-
-        result = runPackagesCommand("delete", testPackageName);
-        assertEquals(result.getExitCode(), 0);
-
-        result = runPackagesCommand("list-versions", "function://public/default/test");
-        assertEquals(result.getExitCode(), 0);
-        result.assertNoStdout();
-    }
-
-    private ContainerExecResult runPackagesCommand(String... commands) throws Exception {
-        String[] cmds = new String[commands.length + 1];
-        cmds[0] = "packages";
-        System.arraycopy(commands, 0, cmds, 1, commands.length);
-        return pulsarCluster.runAdminCommandOnAnyBroker(cmds);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class PackagesCliTest extends TestRetrySupport {
+
+    private static final String clusterNamePrefix = "packages-service";
+    private PulsarCluster pulsarCluster;
+
+    @BeforeClass(alwaysRun = true)
+    public final void setup() throws Exception {
+        incrementSetupNumber();
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .clusterName(String.format("%s-%s", clusterNamePrefix, RandomStringUtils.randomAlphabetic(6)))
+                .brokerEnvs(getPackagesManagementServiceEnvs())
+                .build();
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public final void cleanup() {
+        markCurrentSetupNumberCleaned();
+        if (pulsarCluster != null) {
+            pulsarCluster.stop();
+            pulsarCluster = null;
+        }
+    }
+
+    private Map<String, String> getPackagesManagementServiceEnvs() {
+        Map<String, String> envs = new HashMap<>();
+        envs.put("enablePackagesManagement", "true");
+        envs.put("packagesManagementLedgerRootPath", "/ledgers");
+        return envs;
+    }
+
+    @Test(timeOut = 60000 * 5)
+    public void testPackagesOperationsWithoutUploadingPackages() throws Exception {
+        ContainerExecResult result = runPackagesCommand("list", "--type", "function", "public/default");
+        assertEquals(result.getExitCode(), 0);
+
+        result = runPackagesCommand("list-versions", "function://public/default/test");
+        assertEquals(result.getExitCode(), 0);
+
+        try {
+            result = runPackagesCommand("download", "function://public/default/test@v1", "--path", "test-admin");
+            fail("this command should be failed");
+        } catch (Exception e) {
+            // expected exception
+        }
+    }
+
+    @Test(timeOut = 60000 * 8)
+    public void testPackagesOperationsWithUploadingPackages() throws Exception {
+        String testPackageName = "function://public/default/test@v1";
+        ContainerExecResult result = runPackagesCommand("upload", "--description", "a test package",
+                "--path", PulsarCluster.ADMIN_SCRIPT, testPackageName);
+        assertEquals(result.getExitCode(), 0);
+
+        BrokerContainer container = pulsarCluster.getBroker(0);
+        String downloadFile = "tmp-file-" + RandomStringUtils.randomAlphabetic(8);
+        String[] downloadCmd = new String[]{PulsarCluster.ADMIN_SCRIPT, "packages", "download",
+                "--path", downloadFile, testPackageName};
+        result = container.execCmd(downloadCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        String[] diffCmd = new String[]{"diff", PulsarCluster.ADMIN_SCRIPT, downloadFile};
+        result = container.execCmd(diffCmd);
+        assertEquals(result.getExitCode(), 0);
+
+        result = runPackagesCommand("get-metadata", testPackageName);
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("a test package"));
+
+        result = runPackagesCommand("list", "--type", "function", "public/default");
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("test"));
+
+        result = runPackagesCommand("list-versions", "function://public/default/test");
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("v1"));
+
+        String contact = "test@apache.org";
+        result = runPackagesCommand("update-metadata", "--description", "a test package",
+                "--contact", contact, "-PpropertyA=A", testPackageName);
+        assertEquals(result.getExitCode(), 0);
+
+        result = runPackagesCommand("get-metadata", testPackageName);
+        assertEquals(result.getExitCode(), 0);
+        assertFalse(result.getStdout().isEmpty());
+        assertTrue(result.getStdout().contains("a test package"));
+        assertTrue(result.getStdout().contains(contact));
+        assertTrue(result.getStdout().contains("propertyA"));
+
+        result = runPackagesCommand("delete", testPackageName);
+        assertEquals(result.getExitCode(), 0);
+
+        result = runPackagesCommand("list-versions", "function://public/default/test");
+        assertEquals(result.getExitCode(), 0);
+        result.assertNoStdout();
+    }
+
+    private ContainerExecResult runPackagesCommand(String... commands) throws Exception {
+        String[] cmds = new String[commands.length + 1];
+        cmds[0] = "packages";
+        System.arraycopy(commands, 0, cmds, 1, commands.length);
+        return pulsarCluster.runAdminCommandOnAnyBroker(cmds);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PerfToolTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PerfToolTest.java
index 2c428bfea0..68fd71d6ea 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PerfToolTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PerfToolTest.java
@@ -1,117 +1,117 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.fail;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.TimeUnit;
-import org.apache.pulsar.tests.integration.containers.ChaosContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.containers.ZKContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-public class PerfToolTest extends TopicMessagingBase {
-
-    private static final int MESSAGE_COUNT = 50;
-
-    @Test
-    public void testProduce() throws Exception {
-        String serviceUrl = "pulsar://" + pulsarCluster.getProxy().getContainerName() + ":"
-                + PulsarContainer.BROKER_PORT;
-        final String topicName = getNonPartitionedTopic("testProduce", true);
-        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
-        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
-        ContainerExecResult produceResult =
-                produceWithPerfTool(clientToolContainer, serviceUrl, topicName, MESSAGE_COUNT);
-        checkOutputForLogs(produceResult, "PerformanceProducer - Aggregated throughput stats",
-                "PerformanceProducer - Aggregated latency stats");
-    }
-
-    @Test
-    public void testConsume() throws Exception {
-        String serviceUrl = "pulsar://" + pulsarCluster.getProxy().getContainerName() + ":"
-                + PulsarContainer.BROKER_PORT;
-        final String topicName = getNonPartitionedTopic("testConsume", true);
-        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
-        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
-        ContainerExecResult consumeResult = consumeWithPerfTool(clientToolContainer, serviceUrl, topicName);
-        checkOutputForLogs(consumeResult, "PerformanceConsumer - Aggregated throughput stats",
-                "PerformanceConsumer - Aggregated latency stats");
-    }
-
-    @Test
-    public void testRead() throws Exception {
-        String serviceUrl = "pulsar://" + pulsarCluster.getProxy().getContainerName() + ":"
-                + PulsarContainer.BROKER_PORT;
-        final String topicName = getNonPartitionedTopic("testRead", true);
-        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
-        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
-        ContainerExecResult readResult = readWithPerfTool(clientToolContainer, serviceUrl, topicName);
-        checkOutputForLogs(readResult, "PerformanceReader - Aggregated throughput stats ",
-                "PerformanceReader - Aggregated latency stats");
-    }
-
-    private ContainerExecResult produceWithPerfTool(ChaosContainer<?> container, String url, String topic,
-                                                    int messageCount) throws Exception {
-        ContainerExecResult result = container.execCmd("bin/pulsar-perf", "produce", "-u", url, "-m",
-                String.valueOf(messageCount), topic);
-
-        return failOnError("Performance producer", result);
-    }
-
-    private ContainerExecResult consumeWithPerfTool(ChaosContainer<?> container, String url, String topic)
-            throws Exception {
-        CompletableFuture<ContainerExecResult> resultFuture = container.execCmdAsync("bin/pulsar-perf", "consume", "-u",
-                url, "-m", String.valueOf(MESSAGE_COUNT), topic);
-        produceWithPerfTool(container, url, topic, MESSAGE_COUNT);
-
-        ContainerExecResult result = resultFuture.get(5, TimeUnit.SECONDS);
-        return failOnError("Performance consumer", result);
-    }
-
-    private ContainerExecResult readWithPerfTool(ChaosContainer<?> container, String url, String topic)
-            throws Exception {
-        CompletableFuture<ContainerExecResult> resultFuture = container.execCmdAsync("bin/pulsar-perf", "read", "-u",
-                url, "-n", String.valueOf(MESSAGE_COUNT), topic);
-        produceWithPerfTool(container, url, topic, MESSAGE_COUNT);
-
-        ContainerExecResult result = resultFuture.get(5, TimeUnit.SECONDS);
-        return failOnError("Performance consumer", result);
-    }
-
-    private static ContainerExecResult failOnError(String processDesc, ContainerExecResult result) {
-        if (result.getExitCode() != 0) {
-            fail(processDesc + " failed. Command output:\n" + result.getStdout()
-                    + "\nError output:\n" + result.getStderr());
-        }
-        return result;
-    }
-
-    private static void checkOutputForLogs(ContainerExecResult result, String... logs) {
-        String output = result.getStdout();
-        for (String log : logs) {
-            Assert.assertTrue(output.contains(log),
-                    "command output did not contain log message '" + log + "'.\nFull stdout is:\n" + output);
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.fail;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import org.apache.pulsar.tests.integration.containers.ChaosContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.containers.ZKContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public class PerfToolTest extends TopicMessagingBase {
+
+    private static final int MESSAGE_COUNT = 50;
+
+    @Test
+    public void testProduce() throws Exception {
+        String serviceUrl = "pulsar://" + pulsarCluster.getProxy().getContainerName() + ":"
+                + PulsarContainer.BROKER_PORT;
+        final String topicName = getNonPartitionedTopic("testProduce", true);
+        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
+        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
+        ContainerExecResult produceResult =
+                produceWithPerfTool(clientToolContainer, serviceUrl, topicName, MESSAGE_COUNT);
+        checkOutputForLogs(produceResult, "PerformanceProducer - Aggregated throughput stats",
+                "PerformanceProducer - Aggregated latency stats");
+    }
+
+    @Test
+    public void testConsume() throws Exception {
+        String serviceUrl = "pulsar://" + pulsarCluster.getProxy().getContainerName() + ":"
+                + PulsarContainer.BROKER_PORT;
+        final String topicName = getNonPartitionedTopic("testConsume", true);
+        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
+        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
+        ContainerExecResult consumeResult = consumeWithPerfTool(clientToolContainer, serviceUrl, topicName);
+        checkOutputForLogs(consumeResult, "PerformanceConsumer - Aggregated throughput stats",
+                "PerformanceConsumer - Aggregated latency stats");
+    }
+
+    @Test
+    public void testRead() throws Exception {
+        String serviceUrl = "pulsar://" + pulsarCluster.getProxy().getContainerName() + ":"
+                + PulsarContainer.BROKER_PORT;
+        final String topicName = getNonPartitionedTopic("testRead", true);
+        // Using the ZK container as it is separate from brokers, so its environment resembles real world usage more
+        ZKContainer clientToolContainer = pulsarCluster.getZooKeeper();
+        ContainerExecResult readResult = readWithPerfTool(clientToolContainer, serviceUrl, topicName);
+        checkOutputForLogs(readResult, "PerformanceReader - Aggregated throughput stats ",
+                "PerformanceReader - Aggregated latency stats");
+    }
+
+    private ContainerExecResult produceWithPerfTool(ChaosContainer<?> container, String url, String topic,
+                                                    int messageCount) throws Exception {
+        ContainerExecResult result = container.execCmd("bin/pulsar-perf", "produce", "-u", url, "-m",
+                String.valueOf(messageCount), topic);
+
+        return failOnError("Performance producer", result);
+    }
+
+    private ContainerExecResult consumeWithPerfTool(ChaosContainer<?> container, String url, String topic)
+            throws Exception {
+        CompletableFuture<ContainerExecResult> resultFuture = container.execCmdAsync("bin/pulsar-perf", "consume", "-u",
+                url, "-m", String.valueOf(MESSAGE_COUNT), topic);
+        produceWithPerfTool(container, url, topic, MESSAGE_COUNT);
+
+        ContainerExecResult result = resultFuture.get(5, TimeUnit.SECONDS);
+        return failOnError("Performance consumer", result);
+    }
+
+    private ContainerExecResult readWithPerfTool(ChaosContainer<?> container, String url, String topic)
+            throws Exception {
+        CompletableFuture<ContainerExecResult> resultFuture = container.execCmdAsync("bin/pulsar-perf", "read", "-u",
+                url, "-n", String.valueOf(MESSAGE_COUNT), topic);
+        produceWithPerfTool(container, url, topic, MESSAGE_COUNT);
+
+        ContainerExecResult result = resultFuture.get(5, TimeUnit.SECONDS);
+        return failOnError("Performance consumer", result);
+    }
+
+    private static ContainerExecResult failOnError(String processDesc, ContainerExecResult result) {
+        if (result.getExitCode() != 0) {
+            fail(processDesc + " failed. Command output:\n" + result.getStdout()
+                    + "\nError output:\n" + result.getStderr());
+        }
+        return result;
+    }
+
+    private static void checkOutputForLogs(ContainerExecResult result, String... logs) {
+        String output = result.getStdout();
+        for (String log : logs) {
+            Assert.assertTrue(output.contains(log),
+                    "command output did not contain log message '" + log + "'.\nFull stdout is:\n" + output);
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PulsarVersionTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PulsarVersionTest.java
index 711dd3b9c0..7c5ff206fc 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PulsarVersionTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/PulsarVersionTest.java
@@ -1,76 +1,76 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-import static org.testng.Assert.assertTrue;
-import org.apache.commons.lang3.RandomStringUtils;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-/**
- * Pulsar version test class.
- */
-public class PulsarVersionTest extends TestRetrySupport {
-
-    private static final String clusterNamePrefix = "pulsar-version";
-    private PulsarCluster pulsarCluster;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup() throws Exception {
-        incrementSetupNumber();
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .clusterName(String.format("%s-%s", clusterNamePrefix, RandomStringUtils.randomAlphabetic(6)))
-                .build();
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup() {
-        markCurrentSetupNumberCleaned();
-        if (pulsarCluster != null) {
-            pulsarCluster.stop();
-            pulsarCluster = null;
-        }
-    }
-
-    @Test
-    public void getVersion() throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("brokers", "version");
-        String version = result.getStdout();
-        ContainerExecResult adminVersionShortOption = pulsarCluster.runAdminCommandOnAnyBroker("-v");
-        assertTrue(adminVersionShortOption.getStdout().contains(version));
-        ContainerExecResult adminVersionLongOption = pulsarCluster.runAdminCommandOnAnyBroker("--version");
-        assertTrue(adminVersionLongOption.getStdout().contains(version));
-        ContainerExecResult clientVersionShortOption = pulsarCluster.getAnyBroker().execCmd(
-                PulsarCluster.CLIENT_SCRIPT, "-v");
-        assertTrue(clientVersionShortOption.getStdout().contains(version));
-        ContainerExecResult clientVersionLongOption = pulsarCluster.getAnyBroker().execCmd(
-                PulsarCluster.CLIENT_SCRIPT, "--version");
-        assertTrue(clientVersionLongOption.getStdout().contains(version));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+import static org.testng.Assert.assertTrue;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+/**
+ * Pulsar version test class.
+ */
+public class PulsarVersionTest extends TestRetrySupport {
+
+    private static final String clusterNamePrefix = "pulsar-version";
+    private PulsarCluster pulsarCluster;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup() throws Exception {
+        incrementSetupNumber();
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .clusterName(String.format("%s-%s", clusterNamePrefix, RandomStringUtils.randomAlphabetic(6)))
+                .build();
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup() {
+        markCurrentSetupNumberCleaned();
+        if (pulsarCluster != null) {
+            pulsarCluster.stop();
+            pulsarCluster = null;
+        }
+    }
+
+    @Test
+    public void getVersion() throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("brokers", "version");
+        String version = result.getStdout();
+        ContainerExecResult adminVersionShortOption = pulsarCluster.runAdminCommandOnAnyBroker("-v");
+        assertTrue(adminVersionShortOption.getStdout().contains(version));
+        ContainerExecResult adminVersionLongOption = pulsarCluster.runAdminCommandOnAnyBroker("--version");
+        assertTrue(adminVersionLongOption.getStdout().contains(version));
+        ContainerExecResult clientVersionShortOption = pulsarCluster.getAnyBroker().execCmd(
+                PulsarCluster.CLIENT_SCRIPT, "-v");
+        assertTrue(clientVersionShortOption.getStdout().contains(version));
+        ContainerExecResult clientVersionLongOption = pulsarCluster.getAnyBroker().execCmd(
+                PulsarCluster.CLIENT_SCRIPT, "--version");
+        assertTrue(clientVersionLongOption.getStdout().contains(version));
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/SchemaUpdateStrategyTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/SchemaUpdateStrategyTest.java
index dbbe4c5dc4..e4502ddc47 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/SchemaUpdateStrategyTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/SchemaUpdateStrategyTest.java
@@ -1,502 +1,502 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli;
-
-
-import static org.testng.Assert.assertEquals;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-import org.apache.avro.reflect.AvroAlias;
-import org.apache.avro.reflect.AvroDefault;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * Test setting the schema update strategy via the CLI.
- */
-@SuppressWarnings("try")
-public class SchemaUpdateStrategyTest extends PulsarTestSuite {
-    private static final Logger log = LoggerFactory.getLogger(SchemaUpdateStrategyTest.class);
-
-    private void testAutoUpdateBackward(String namespace, String topicName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-schema-autoupdate-strategy", namespace);
-        Assert.assertEquals(result.getStdout().trim(), "FULL");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
-                "--compatibility", "BACKWARD", namespace);
-
-        try (PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
-            V1Data v1Data = new V1Data("test1", 1);
-            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
-                p.send(v1Data);
-            }
-
-            log.info("try with forward compat, should fail");
-            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
-                Assert.fail("Forward compat schema should be rejected");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("try with backward compat, should succeed");
-            V2Data v2Data = new V2Data("test2");
-            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
-                p.send(v2Data);
-            }
-
-            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
-            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
-                 .topic(topicName)
-                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                 .subscriptionName("sub")
-                 .subscribe()
-            ) {
-                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
-
-                Message<GenericRecord> msg1 = consumer.receive();
-                v1Data.assertEqualToRecord(msg1.getValue());
-
-                Message<GenericRecord> msg2 = consumer.receive();
-                v2Data.assertEqualToRecord(msg2.getValue());
-            }
-        }
-    }
-
-    private void testNone(String namespace, String topicName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-schema-autoupdate-strategy", namespace);
-        Assert.assertEquals(result.getStdout().trim(), "FULL");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
-                "--compatibility", "NONE", namespace);
-
-        try (PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
-            V1Data v1Data = new V1Data("test1", 1);
-            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
-                p.send(v1Data);
-            }
-
-            log.info("try with forward compat, should succeed");
-            V3Data v3Data = new V3Data("test3", 1, 2);
-            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
-                p.send(v3Data);
-            }
-
-            log.info("try with backward compat, should succeed");
-            V2Data v2Data = new V2Data("test2");
-            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
-                p.send(v2Data);
-            }
-
-            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
-            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
-                 .topic(topicName)
-                 .subscriptionName("sub")
-                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                 .subscribe()
-            ) {
-                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
-
-                Message<GenericRecord> msg1 = consumer.receive();
-                v1Data.assertEqualToRecord(msg1.getValue());
-
-                Message<GenericRecord> msg2 = consumer.receive();
-                v3Data.assertEqualToRecord(msg2.getValue());
-
-                Message<GenericRecord> msg3 = consumer.receive();
-                v2Data.assertEqualToRecord(msg3.getValue());
-            }
-        }
-    }
-
-    private void testAutoUpdateForward(String namespace, String topicName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-schema-autoupdate-strategy", namespace);
-        Assert.assertEquals(result.getStdout().trim(), "FULL");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
-                                                 "--compatibility", "FORWARD", namespace);
-
-        try (PulsarClient pulsarClient = PulsarClient.builder()
-             .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
-
-            V1Data v1Data = new V1Data("test1", 1);
-            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
-                p.send(v1Data);
-            }
-
-            log.info("try with backward compat, should fail");
-            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
-                Assert.fail("Backward compat schema should be rejected");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("try with forward compat, should succeed");
-            V3Data v3Data = new V3Data("test2", 1, 2);
-            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
-                p.send(v3Data);
-            }
-
-            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
-            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
-                 .topic(topicName)
-                 .subscriptionName("sub")
-                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                 .subscribe()
-            ) {
-                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
-
-                Message<GenericRecord> msg1 = consumer.receive();
-                v1Data.assertEqualToRecord(msg1.getValue());
-
-                Message<GenericRecord> msg2 = consumer.receive();
-                v3Data.assertEqualToRecord(msg2.getValue());
-            }
-        }
-
-    }
-
-    private void testAutoUpdateFull(String namespace, String topicName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-schema-autoupdate-strategy", namespace);
-        Assert.assertEquals(result.getStdout().trim(), "FULL");
-
-        try (PulsarClient pulsarClient = PulsarClient.builder()
-             .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
-
-            V1Data v1Data = new V1Data("test1", 1);
-            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
-                p.send(v1Data);
-            }
-
-            log.info("try with backward compat only, should fail");
-            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
-                Assert.fail("Backward compat only schema should fail");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("try with forward compat only, should fail");
-            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
-                Assert.fail("Forward compat only schema should fail");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("try with fully compat");
-            V4Data v4Data = new V4Data("test2", 1, (short) 100);
-            try (Producer<V4Data> p = pulsarClient.newProducer(Schema.AVRO(V4Data.class)).topic(topicName).create()) {
-                p.send(v4Data);
-            }
-
-            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
-            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
-                 .topic(topicName)
-                 .subscriptionName("sub")
-                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                 .subscribe()
-            ) {
-                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
-
-                Message<GenericRecord> msg1 = consumer.receive();
-                v1Data.assertEqualToRecord(msg1.getValue());
-
-                Message<GenericRecord> msg2 = consumer.receive();
-                v4Data.assertEqualToRecord(msg2.getValue());
-            }
-        }
-    }
-
-    private void testAutoUpdateDisabled(String namespace, String topicName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-schema-autoupdate-strategy", namespace);
-        Assert.assertEquals(result.getStdout().trim(), "FULL");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
-                                                 "--disabled", namespace);
-
-        try (PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
-            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
-                p.send(new V1Data("test1", 1));
-            }
-            log.info("try with backward compat only, should fail");
-            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
-                Assert.fail("Backward compat only schema should fail");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("try with forward compat only, should fail");
-            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
-                Assert.fail("Forward compat only schema should fail");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("try with fully compat, should fail");
-            try (Producer<V4Data> p = pulsarClient.newProducer(Schema.AVRO(V4Data.class)).topic(topicName).create()) {
-                Assert.fail("Fully compat schema should fail, autoupdate disabled");
-            } catch (PulsarClientException e) {
-                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
-            }
-
-            log.info("Manually set new schema");
-            ObjectMapper mapper = new ObjectMapper();
-            Map<String, String> schema = new HashMap<>();
-            schema.put("type", "AVRO");
-            schema.put("schema", Schema.AVRO(V4Data.class).getSchemaInfo().getSchemaDefinition());
-            BrokerContainer b = pulsarCluster.getAnyBroker();
-            String schemaFile = String.format("/tmp/schema-%s", UUID.randomUUID().toString());
-            b.putFile(schemaFile, mapper.writeValueAsBytes(schema));
-
-            b.execCmd(PulsarCluster.ADMIN_SCRIPT, "schemas", "upload", "-f", schemaFile, topicName);
-
-            boolean success = false;
-            for (int i = 0; i < 50; i++) {
-                try (Producer<V4Data> p = pulsarClient.newProducer(Schema.AVRO(V4Data.class))
-                        .topic(topicName).create()) {
-                    p.send(new V4Data("test2", 1, (short) 100));
-                    success = true;
-                    break;
-                } catch (Throwable t) {
-                    // expected a few times until the broker sees the new schema
-                }
-                Thread.sleep(100);
-            }
-            Assert.assertTrue(success, "Should have been able to use new schema");
-        }
-    }
-
-    @AvroAlias(space = "blah", alias = "data")
-    static class V1Data {
-        String foo;
-        int bar;
-
-        V1Data(String foo, int bar) {
-            this.foo = foo;
-            this.bar = bar;
-        }
-
-        void assertEqualToRecord(GenericRecord record) {
-            assertEquals(
-                2, record.getFields().size(),
-                record.getFields().size() + " fields in found : " + record.getFields());
-            assertEquals(foo, record.getField("foo"));
-            assertEquals(Integer.valueOf(bar), record.getField("bar"));
-        }
-    }
-
-    // backward compatible with V1Data
-    @AvroAlias(space = "blah", alias = "data")
-    static class V2Data {
-        String foo;
-
-        V2Data(String foo) {
-            this.foo = foo;
-        }
-
-        void assertEqualToRecord(GenericRecord record) {
-            assertEquals(
-                1, record.getFields().size(),
-                record.getFields().size() + " fields in found : " + record.getFields());
-            assertEquals(foo, record.getField("foo"));
-        }
-    }
-
-    // forward compatible with V1Data
-    @AvroAlias(space = "blah", alias = "data")
-    static class V3Data {
-        String foo;
-        int bar;
-        long baz;
-
-        V3Data(String foo, int bar, long baz) {
-            this.foo = foo;
-            this.bar = bar;
-            this.baz = baz;
-        }
-
-        void assertEqualToRecord(GenericRecord record) {
-            assertEquals(
-                3, record.getFields().size(),
-                record.getFields().size() + " fields in found : " + record.getFields());
-            assertEquals(foo, record.getField("foo"));
-            assertEquals(Integer.valueOf(bar), record.getField("bar"));
-            assertEquals(Long.valueOf(baz), record.getField("baz"));
-        }
-    }
-
-    // fully compatible with V1Data
-    @AvroAlias(space = "blah", alias = "data")
-    static class V4Data {
-        String foo;
-        int bar;
-        @AvroDefault(value = "10")
-        short blah;
-
-        V4Data(String foo, int bar, short blah) {
-            this.foo = foo;
-            this.bar = bar;
-            this.blah = blah;
-        }
-
-        void assertEqualToRecord(GenericRecord record) {
-            assertEquals(
-                3, record.getFields().size(),
-                record.getFields().size() + " fields in found : " + record.getFields());
-            assertEquals(foo, record.getField("foo"));
-            assertEquals(Integer.valueOf(bar), record.getField("bar"));
-            // NOTE: in generic record, avro returns integer. we can consider improving the
-            // the behavior in future to reflect the right java class.
-            assertEquals(Integer.valueOf(blah), record.getField("blah"));
-        }
-    }
-
-    @Test
-    public void testBackwardV2() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/bw-p-v2");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/bw-np-v2");
-
-        testAutoUpdateBackward("public/bw-p-v2", "persistent://public/bw-p-v2/topic1");
-        testAutoUpdateBackward("public/bw-np-v2", "non-persistent://public/bw-np-v2/topic1");
-    }
-
-    @Test
-    public void testForwardV2() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/fw-p-v2");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/fw-np-v2");
-
-        testAutoUpdateForward("public/fw-p-v2", "persistent://public/fw-p-v2/topic1");
-        testAutoUpdateForward("public/fw-np-v2", "non-persistent://public/fw-np-v2/topic1");
-    }
-
-    @Test
-    public void testFullV2() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/full-p-v2");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/full-np-v2");
-
-        testAutoUpdateFull("public/full-p-v2", "persistent://public/full-p-v2/topic1");
-        testAutoUpdateFull("public/full-np-v2", "non-persistent://public/full-np-v2/topic1");
-    }
-
-    @Test
-    public void testNoneV2() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                pulsarCluster.getClusterName(), "public/none-p-v2");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                pulsarCluster.getClusterName(), "public/none-np-v2");
-
-        testNone("public/none-p-v2", "persistent://public/none-p-v2/topic1");
-        testNone("public/none-np-v2", "non-persistent://public/none-np-v2/topic1");
-    }
-
-    @Test
-    public void testDisabledV2() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/dis-p-v2");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
-                                                 pulsarCluster.getClusterName(), "public/dis-np-v2");
-
-        testAutoUpdateDisabled("public/dis-p-v2", "persistent://public/dis-p-v2/topic1");
-        testAutoUpdateDisabled("public/dis-np-v2", "non-persistent://public/dis-np-v2/topic1");
-    }
-
-    @Test
-    public void testBackwardV1() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/b-p-v1");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/b-np-v1");
-        testAutoUpdateBackward("public/" + pulsarCluster.getClusterName() + "/b-p-v1",
-                               "persistent://public/" + pulsarCluster.getClusterName() + "/b-p-v1/topic1");
-        testAutoUpdateBackward("public/" + pulsarCluster.getClusterName() + "/b-np-v1",
-                               "persistent://public/" + pulsarCluster.getClusterName() + "/b-np-v1/topic1");
-    }
-
-    @Test
-    public void testForwardV1() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/f-p-v1");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/f-np-v1");
-        testAutoUpdateForward("public/" + pulsarCluster.getClusterName() + "/f-p-v1",
-                              "persistent://public/" + pulsarCluster.getClusterName() + "/f-p-v1/topic1");
-        testAutoUpdateForward("public/" + pulsarCluster.getClusterName() + "/f-np-v1",
-                              "persistent://public/" + pulsarCluster.getClusterName() + "/f-np-v1/topic1");
-    }
-
-    @Test
-    public void testFullV1() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/full-p-v1");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/full-np-v1");
-        testAutoUpdateFull("public/" + pulsarCluster.getClusterName() + "/full-p-v1",
-                           "persistent://public/" + pulsarCluster.getClusterName() + "/full-p-v1/topic1");
-        testAutoUpdateFull("public/" + pulsarCluster.getClusterName() + "/full-np-v1",
-                           "persistent://public/" + pulsarCluster.getClusterName() + "/full-np-v1/topic1");
-    }
-
-    @Test
-    public void testNoneV1() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                "public/" + pulsarCluster.getClusterName() + "/none-p-v1");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                "public/" + pulsarCluster.getClusterName() + "/none-np-v1");
-        testNone("public/" + pulsarCluster.getClusterName() + "/none-p-v1",
-                "persistent://public/" + pulsarCluster.getClusterName() + "/none-p-v1/topic1");
-        testNone("public/" + pulsarCluster.getClusterName() + "/none-np-v1",
-                "persistent://public/" + pulsarCluster.getClusterName() + "/none-np-v1/topic1");
-    }
-
-    @Test
-    public void testDisabledV1() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/dis-p-v1");
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
-                                                 "public/" + pulsarCluster.getClusterName() + "/dis-np-v1");
-        testAutoUpdateDisabled("public/" + pulsarCluster.getClusterName() + "/dis-p-v1",
-                               "persistent://public/" + pulsarCluster.getClusterName() + "/dis-p-v1/topic1");
-        testAutoUpdateDisabled("public/" + pulsarCluster.getClusterName() + "/dis-np-v1",
-                               "persistent://public/" + pulsarCluster.getClusterName() + "/dis-np-v1/topic1");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli;
+
+
+import static org.testng.Assert.assertEquals;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import org.apache.avro.reflect.AvroAlias;
+import org.apache.avro.reflect.AvroDefault;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * Test setting the schema update strategy via the CLI.
+ */
+@SuppressWarnings("try")
+public class SchemaUpdateStrategyTest extends PulsarTestSuite {
+    private static final Logger log = LoggerFactory.getLogger(SchemaUpdateStrategyTest.class);
+
+    private void testAutoUpdateBackward(String namespace, String topicName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-schema-autoupdate-strategy", namespace);
+        Assert.assertEquals(result.getStdout().trim(), "FULL");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
+                "--compatibility", "BACKWARD", namespace);
+
+        try (PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
+            V1Data v1Data = new V1Data("test1", 1);
+            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
+                p.send(v1Data);
+            }
+
+            log.info("try with forward compat, should fail");
+            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
+                Assert.fail("Forward compat schema should be rejected");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("try with backward compat, should succeed");
+            V2Data v2Data = new V2Data("test2");
+            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
+                p.send(v2Data);
+            }
+
+            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
+            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
+                 .topic(topicName)
+                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                 .subscriptionName("sub")
+                 .subscribe()
+            ) {
+                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
+
+                Message<GenericRecord> msg1 = consumer.receive();
+                v1Data.assertEqualToRecord(msg1.getValue());
+
+                Message<GenericRecord> msg2 = consumer.receive();
+                v2Data.assertEqualToRecord(msg2.getValue());
+            }
+        }
+    }
+
+    private void testNone(String namespace, String topicName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-schema-autoupdate-strategy", namespace);
+        Assert.assertEquals(result.getStdout().trim(), "FULL");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
+                "--compatibility", "NONE", namespace);
+
+        try (PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
+            V1Data v1Data = new V1Data("test1", 1);
+            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
+                p.send(v1Data);
+            }
+
+            log.info("try with forward compat, should succeed");
+            V3Data v3Data = new V3Data("test3", 1, 2);
+            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
+                p.send(v3Data);
+            }
+
+            log.info("try with backward compat, should succeed");
+            V2Data v2Data = new V2Data("test2");
+            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
+                p.send(v2Data);
+            }
+
+            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
+            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
+                 .topic(topicName)
+                 .subscriptionName("sub")
+                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                 .subscribe()
+            ) {
+                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
+
+                Message<GenericRecord> msg1 = consumer.receive();
+                v1Data.assertEqualToRecord(msg1.getValue());
+
+                Message<GenericRecord> msg2 = consumer.receive();
+                v3Data.assertEqualToRecord(msg2.getValue());
+
+                Message<GenericRecord> msg3 = consumer.receive();
+                v2Data.assertEqualToRecord(msg3.getValue());
+            }
+        }
+    }
+
+    private void testAutoUpdateForward(String namespace, String topicName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-schema-autoupdate-strategy", namespace);
+        Assert.assertEquals(result.getStdout().trim(), "FULL");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
+                                                 "--compatibility", "FORWARD", namespace);
+
+        try (PulsarClient pulsarClient = PulsarClient.builder()
+             .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
+
+            V1Data v1Data = new V1Data("test1", 1);
+            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
+                p.send(v1Data);
+            }
+
+            log.info("try with backward compat, should fail");
+            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
+                Assert.fail("Backward compat schema should be rejected");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("try with forward compat, should succeed");
+            V3Data v3Data = new V3Data("test2", 1, 2);
+            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
+                p.send(v3Data);
+            }
+
+            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
+            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
+                 .topic(topicName)
+                 .subscriptionName("sub")
+                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                 .subscribe()
+            ) {
+                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
+
+                Message<GenericRecord> msg1 = consumer.receive();
+                v1Data.assertEqualToRecord(msg1.getValue());
+
+                Message<GenericRecord> msg2 = consumer.receive();
+                v3Data.assertEqualToRecord(msg2.getValue());
+            }
+        }
+
+    }
+
+    private void testAutoUpdateFull(String namespace, String topicName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-schema-autoupdate-strategy", namespace);
+        Assert.assertEquals(result.getStdout().trim(), "FULL");
+
+        try (PulsarClient pulsarClient = PulsarClient.builder()
+             .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
+
+            V1Data v1Data = new V1Data("test1", 1);
+            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
+                p.send(v1Data);
+            }
+
+            log.info("try with backward compat only, should fail");
+            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
+                Assert.fail("Backward compat only schema should fail");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("try with forward compat only, should fail");
+            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
+                Assert.fail("Forward compat only schema should fail");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("try with fully compat");
+            V4Data v4Data = new V4Data("test2", 1, (short) 100);
+            try (Producer<V4Data> p = pulsarClient.newProducer(Schema.AVRO(V4Data.class)).topic(topicName).create()) {
+                p.send(v4Data);
+            }
+
+            Schema<GenericRecord> schema = Schema.AUTO_CONSUME();
+            try (Consumer<GenericRecord> consumer = pulsarClient.newConsumer(schema)
+                 .topic(topicName)
+                 .subscriptionName("sub")
+                 .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                 .subscribe()
+            ) {
+                log.info("Schema Info : {}", schema.getSchemaInfo().getSchemaDefinition());
+
+                Message<GenericRecord> msg1 = consumer.receive();
+                v1Data.assertEqualToRecord(msg1.getValue());
+
+                Message<GenericRecord> msg2 = consumer.receive();
+                v4Data.assertEqualToRecord(msg2.getValue());
+            }
+        }
+    }
+
+    private void testAutoUpdateDisabled(String namespace, String topicName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-schema-autoupdate-strategy", namespace);
+        Assert.assertEquals(result.getStdout().trim(), "FULL");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-schema-autoupdate-strategy",
+                                                 "--disabled", namespace);
+
+        try (PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build()) {
+            try (Producer<V1Data> p = pulsarClient.newProducer(Schema.AVRO(V1Data.class)).topic(topicName).create()) {
+                p.send(new V1Data("test1", 1));
+            }
+            log.info("try with backward compat only, should fail");
+            try (Producer<V2Data> p = pulsarClient.newProducer(Schema.AVRO(V2Data.class)).topic(topicName).create()) {
+                Assert.fail("Backward compat only schema should fail");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("try with forward compat only, should fail");
+            try (Producer<V3Data> p = pulsarClient.newProducer(Schema.AVRO(V3Data.class)).topic(topicName).create()) {
+                Assert.fail("Forward compat only schema should fail");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("try with fully compat, should fail");
+            try (Producer<V4Data> p = pulsarClient.newProducer(Schema.AVRO(V4Data.class)).topic(topicName).create()) {
+                Assert.fail("Fully compat schema should fail, autoupdate disabled");
+            } catch (PulsarClientException e) {
+                Assert.assertTrue(e.getMessage().contains("IncompatibleSchemaException"));
+            }
+
+            log.info("Manually set new schema");
+            ObjectMapper mapper = new ObjectMapper();
+            Map<String, String> schema = new HashMap<>();
+            schema.put("type", "AVRO");
+            schema.put("schema", Schema.AVRO(V4Data.class).getSchemaInfo().getSchemaDefinition());
+            BrokerContainer b = pulsarCluster.getAnyBroker();
+            String schemaFile = String.format("/tmp/schema-%s", UUID.randomUUID().toString());
+            b.putFile(schemaFile, mapper.writeValueAsBytes(schema));
+
+            b.execCmd(PulsarCluster.ADMIN_SCRIPT, "schemas", "upload", "-f", schemaFile, topicName);
+
+            boolean success = false;
+            for (int i = 0; i < 50; i++) {
+                try (Producer<V4Data> p = pulsarClient.newProducer(Schema.AVRO(V4Data.class))
+                        .topic(topicName).create()) {
+                    p.send(new V4Data("test2", 1, (short) 100));
+                    success = true;
+                    break;
+                } catch (Throwable t) {
+                    // expected a few times until the broker sees the new schema
+                }
+                Thread.sleep(100);
+            }
+            Assert.assertTrue(success, "Should have been able to use new schema");
+        }
+    }
+
+    @AvroAlias(space = "blah", alias = "data")
+    static class V1Data {
+        String foo;
+        int bar;
+
+        V1Data(String foo, int bar) {
+            this.foo = foo;
+            this.bar = bar;
+        }
+
+        void assertEqualToRecord(GenericRecord record) {
+            assertEquals(
+                2, record.getFields().size(),
+                record.getFields().size() + " fields in found : " + record.getFields());
+            assertEquals(foo, record.getField("foo"));
+            assertEquals(Integer.valueOf(bar), record.getField("bar"));
+        }
+    }
+
+    // backward compatible with V1Data
+    @AvroAlias(space = "blah", alias = "data")
+    static class V2Data {
+        String foo;
+
+        V2Data(String foo) {
+            this.foo = foo;
+        }
+
+        void assertEqualToRecord(GenericRecord record) {
+            assertEquals(
+                1, record.getFields().size(),
+                record.getFields().size() + " fields in found : " + record.getFields());
+            assertEquals(foo, record.getField("foo"));
+        }
+    }
+
+    // forward compatible with V1Data
+    @AvroAlias(space = "blah", alias = "data")
+    static class V3Data {
+        String foo;
+        int bar;
+        long baz;
+
+        V3Data(String foo, int bar, long baz) {
+            this.foo = foo;
+            this.bar = bar;
+            this.baz = baz;
+        }
+
+        void assertEqualToRecord(GenericRecord record) {
+            assertEquals(
+                3, record.getFields().size(),
+                record.getFields().size() + " fields in found : " + record.getFields());
+            assertEquals(foo, record.getField("foo"));
+            assertEquals(Integer.valueOf(bar), record.getField("bar"));
+            assertEquals(Long.valueOf(baz), record.getField("baz"));
+        }
+    }
+
+    // fully compatible with V1Data
+    @AvroAlias(space = "blah", alias = "data")
+    static class V4Data {
+        String foo;
+        int bar;
+        @AvroDefault(value = "10")
+        short blah;
+
+        V4Data(String foo, int bar, short blah) {
+            this.foo = foo;
+            this.bar = bar;
+            this.blah = blah;
+        }
+
+        void assertEqualToRecord(GenericRecord record) {
+            assertEquals(
+                3, record.getFields().size(),
+                record.getFields().size() + " fields in found : " + record.getFields());
+            assertEquals(foo, record.getField("foo"));
+            assertEquals(Integer.valueOf(bar), record.getField("bar"));
+            // NOTE: in generic record, avro returns integer. we can consider improving the
+            // the behavior in future to reflect the right java class.
+            assertEquals(Integer.valueOf(blah), record.getField("blah"));
+        }
+    }
+
+    @Test
+    public void testBackwardV2() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/bw-p-v2");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/bw-np-v2");
+
+        testAutoUpdateBackward("public/bw-p-v2", "persistent://public/bw-p-v2/topic1");
+        testAutoUpdateBackward("public/bw-np-v2", "non-persistent://public/bw-np-v2/topic1");
+    }
+
+    @Test
+    public void testForwardV2() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/fw-p-v2");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/fw-np-v2");
+
+        testAutoUpdateForward("public/fw-p-v2", "persistent://public/fw-p-v2/topic1");
+        testAutoUpdateForward("public/fw-np-v2", "non-persistent://public/fw-np-v2/topic1");
+    }
+
+    @Test
+    public void testFullV2() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/full-p-v2");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/full-np-v2");
+
+        testAutoUpdateFull("public/full-p-v2", "persistent://public/full-p-v2/topic1");
+        testAutoUpdateFull("public/full-np-v2", "non-persistent://public/full-np-v2/topic1");
+    }
+
+    @Test
+    public void testNoneV2() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                pulsarCluster.getClusterName(), "public/none-p-v2");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                pulsarCluster.getClusterName(), "public/none-np-v2");
+
+        testNone("public/none-p-v2", "persistent://public/none-p-v2/topic1");
+        testNone("public/none-np-v2", "non-persistent://public/none-np-v2/topic1");
+    }
+
+    @Test
+    public void testDisabledV2() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/dis-p-v2");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create", "-c",
+                                                 pulsarCluster.getClusterName(), "public/dis-np-v2");
+
+        testAutoUpdateDisabled("public/dis-p-v2", "persistent://public/dis-p-v2/topic1");
+        testAutoUpdateDisabled("public/dis-np-v2", "non-persistent://public/dis-np-v2/topic1");
+    }
+
+    @Test
+    public void testBackwardV1() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/b-p-v1");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/b-np-v1");
+        testAutoUpdateBackward("public/" + pulsarCluster.getClusterName() + "/b-p-v1",
+                               "persistent://public/" + pulsarCluster.getClusterName() + "/b-p-v1/topic1");
+        testAutoUpdateBackward("public/" + pulsarCluster.getClusterName() + "/b-np-v1",
+                               "persistent://public/" + pulsarCluster.getClusterName() + "/b-np-v1/topic1");
+    }
+
+    @Test
+    public void testForwardV1() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/f-p-v1");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/f-np-v1");
+        testAutoUpdateForward("public/" + pulsarCluster.getClusterName() + "/f-p-v1",
+                              "persistent://public/" + pulsarCluster.getClusterName() + "/f-p-v1/topic1");
+        testAutoUpdateForward("public/" + pulsarCluster.getClusterName() + "/f-np-v1",
+                              "persistent://public/" + pulsarCluster.getClusterName() + "/f-np-v1/topic1");
+    }
+
+    @Test
+    public void testFullV1() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/full-p-v1");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/full-np-v1");
+        testAutoUpdateFull("public/" + pulsarCluster.getClusterName() + "/full-p-v1",
+                           "persistent://public/" + pulsarCluster.getClusterName() + "/full-p-v1/topic1");
+        testAutoUpdateFull("public/" + pulsarCluster.getClusterName() + "/full-np-v1",
+                           "persistent://public/" + pulsarCluster.getClusterName() + "/full-np-v1/topic1");
+    }
+
+    @Test
+    public void testNoneV1() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                "public/" + pulsarCluster.getClusterName() + "/none-p-v1");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                "public/" + pulsarCluster.getClusterName() + "/none-np-v1");
+        testNone("public/" + pulsarCluster.getClusterName() + "/none-p-v1",
+                "persistent://public/" + pulsarCluster.getClusterName() + "/none-p-v1/topic1");
+        testNone("public/" + pulsarCluster.getClusterName() + "/none-np-v1",
+                "persistent://public/" + pulsarCluster.getClusterName() + "/none-np-v1/topic1");
+    }
+
+    @Test
+    public void testDisabledV1() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/dis-p-v1");
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "create",
+                                                 "public/" + pulsarCluster.getClusterName() + "/dis-np-v1");
+        testAutoUpdateDisabled("public/" + pulsarCluster.getClusterName() + "/dis-p-v1",
+                               "persistent://public/" + pulsarCluster.getClusterName() + "/dis-p-v1/topic1");
+        testAutoUpdateDisabled("public/" + pulsarCluster.getClusterName() + "/dis-np-v1",
+                               "persistent://public/" + pulsarCluster.getClusterName() + "/dis-np-v1/topic1");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/tenant/TenantTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/tenant/TenantTest.java
index 4755af3f18..82ffe907d1 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/tenant/TenantTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/tenant/TenantTest.java
@@ -1,121 +1,121 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli.tenant;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.expectThrows;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import org.apache.pulsar.common.policies.data.TenantInfo;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.annotations.Test;
-
-public class TenantTest extends PulsarTestSuite {
-    @Test
-    public void testListTenantCmd() throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "list");
-        assertTrue(result.getStdout().contains("public"));
-    }
-
-    @Test
-    public void testGetTenantCmd() throws Exception {
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", "public");
-    }
-
-    @Test
-    public void testGetNonExistTenantCmd() {
-        String tenantName = randomName();
-        ContainerExecException ex = expectThrows(ContainerExecException.class,
-                () -> pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName));
-        assertTrue(ex.getResult().getStderr().contains("Tenant does not exist"));
-    }
-
-    @Test
-    public void testCreateTenantCmd() throws Exception {
-        String tenantName = randomName();
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", tenantName);
-
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
-        TenantInfo tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
-        assertNotNull(tenantInfo);
-        assertTrue(tenantInfo.getAdminRoles().isEmpty());
-        assertFalse(tenantInfo.getAllowedClusters().isEmpty());
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "delete", tenantName);
-    }
-
-    @Test
-    public void testCreateTenantCmdWithAdminRolesAndAllowClustersFlags() throws Exception {
-        String tenantName = randomName();
-        List<String> adminRoles = Arrays.asList("role1", "role2");
-        List<String> allowedClusters = Collections.singletonList(pulsarCluster.getClusterName());
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", tenantName, "--admin-roles",
-                String.join(",", adminRoles), "--allowed-clusters", String.join(",", allowedClusters));
-
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
-        TenantInfo tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
-        assertNotNull(tenantInfo);
-        assertNotNull(tenantInfo.getAdminRoles());
-        assertEquals(tenantInfo.getAdminRoles().stream().sorted().toArray(), adminRoles.stream().sorted().toArray());
-        assertEquals(tenantInfo.getAllowedClusters(), allowedClusters);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "delete", tenantName);
-    }
-
-    @Test
-    public void testCreateExistTenantCmd() {
-        ContainerExecException ex = expectThrows(ContainerExecException.class,
-                () -> pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", "public"));
-        assertTrue(ex.getResult().getStderr().contains("Tenant already exist"));
-    }
-
-    @Test
-    public void testUpdateTenantCmdWithAdminRolesAndAllowedClustersFlags() throws Exception {
-        String tenantName = randomName();
-        List<String> adminRoles = Arrays.asList("role1", "role2");
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", tenantName, "--admin-roles",
-                String.join(",", adminRoles));
-
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
-        TenantInfo tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
-        assertNotNull(tenantInfo);
-        assertNotNull(tenantInfo.getAdminRoles());
-        assertEquals(tenantInfo.getAdminRoles().stream().sorted().toArray(), adminRoles.stream().sorted().toArray());
-        assertFalse(tenantInfo.getAllowedClusters().isEmpty());
-
-        adminRoles = Arrays.asList("role3", "role4");
-        List<String> allowedClusters = Collections.singletonList(pulsarCluster.getClusterName());
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "update", tenantName, "--admin-roles",
-                String.join(",", adminRoles), "--allowed-clusters", String.join(",", allowedClusters));
-
-        result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
-        tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
-        assertNotNull(tenantInfo);
-        assertEquals(tenantInfo.getAdminRoles().stream().sorted().toArray(), adminRoles.stream().sorted().toArray());
-        assertEquals(tenantInfo.getAllowedClusters(), allowedClusters);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "delete", tenantName);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli.tenant;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.expectThrows;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import org.apache.pulsar.common.policies.data.TenantInfo;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.annotations.Test;
+
+public class TenantTest extends PulsarTestSuite {
+    @Test
+    public void testListTenantCmd() throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "list");
+        assertTrue(result.getStdout().contains("public"));
+    }
+
+    @Test
+    public void testGetTenantCmd() throws Exception {
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", "public");
+    }
+
+    @Test
+    public void testGetNonExistTenantCmd() {
+        String tenantName = randomName();
+        ContainerExecException ex = expectThrows(ContainerExecException.class,
+                () -> pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName));
+        assertTrue(ex.getResult().getStderr().contains("Tenant does not exist"));
+    }
+
+    @Test
+    public void testCreateTenantCmd() throws Exception {
+        String tenantName = randomName();
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", tenantName);
+
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
+        TenantInfo tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
+        assertNotNull(tenantInfo);
+        assertTrue(tenantInfo.getAdminRoles().isEmpty());
+        assertFalse(tenantInfo.getAllowedClusters().isEmpty());
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "delete", tenantName);
+    }
+
+    @Test
+    public void testCreateTenantCmdWithAdminRolesAndAllowClustersFlags() throws Exception {
+        String tenantName = randomName();
+        List<String> adminRoles = Arrays.asList("role1", "role2");
+        List<String> allowedClusters = Collections.singletonList(pulsarCluster.getClusterName());
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", tenantName, "--admin-roles",
+                String.join(",", adminRoles), "--allowed-clusters", String.join(",", allowedClusters));
+
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
+        TenantInfo tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
+        assertNotNull(tenantInfo);
+        assertNotNull(tenantInfo.getAdminRoles());
+        assertEquals(tenantInfo.getAdminRoles().stream().sorted().toArray(), adminRoles.stream().sorted().toArray());
+        assertEquals(tenantInfo.getAllowedClusters(), allowedClusters);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "delete", tenantName);
+    }
+
+    @Test
+    public void testCreateExistTenantCmd() {
+        ContainerExecException ex = expectThrows(ContainerExecException.class,
+                () -> pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", "public"));
+        assertTrue(ex.getResult().getStderr().contains("Tenant already exist"));
+    }
+
+    @Test
+    public void testUpdateTenantCmdWithAdminRolesAndAllowedClustersFlags() throws Exception {
+        String tenantName = randomName();
+        List<String> adminRoles = Arrays.asList("role1", "role2");
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "create", tenantName, "--admin-roles",
+                String.join(",", adminRoles));
+
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
+        TenantInfo tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
+        assertNotNull(tenantInfo);
+        assertNotNull(tenantInfo.getAdminRoles());
+        assertEquals(tenantInfo.getAdminRoles().stream().sorted().toArray(), adminRoles.stream().sorted().toArray());
+        assertFalse(tenantInfo.getAllowedClusters().isEmpty());
+
+        adminRoles = Arrays.asList("role3", "role4");
+        List<String> allowedClusters = Collections.singletonList(pulsarCluster.getClusterName());
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "update", tenantName, "--admin-roles",
+                String.join(",", adminRoles), "--allowed-clusters", String.join(",", allowedClusters));
+
+        result = pulsarCluster.runAdminCommandOnAnyBroker("tenants", "get", tenantName);
+        tenantInfo = jsonMapper().readValue(result.getStdout(), TenantInfo.class);
+        assertNotNull(tenantInfo);
+        assertEquals(tenantInfo.getAdminRoles().stream().sorted().toArray(), adminRoles.stream().sorted().toArray());
+        assertEquals(tenantInfo.getAllowedClusters(), allowedClusters);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants", "delete", tenantName);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/topicpolicies/SchemaCompatibilityStrategyTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/topicpolicies/SchemaCompatibilityStrategyTest.java
index 54cb2a1b17..e659a73f92 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/topicpolicies/SchemaCompatibilityStrategyTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/cli/topicpolicies/SchemaCompatibilityStrategyTest.java
@@ -1,90 +1,90 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.cli.topicpolicies;
-
-import static org.testng.Assert.assertEquals;
-import org.apache.pulsar.common.policies.data.SchemaCompatibilityStrategy;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarCliTestSuite;
-import org.awaitility.Awaitility;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SchemaCompatibilityStrategyTest extends PulsarCliTestSuite {
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public void before() throws Exception {
-        enableTopicPolicies();
-        super.before();
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    public void after() throws Exception {
-        super.after();
-    }
-
-    @Test
-    public void testSchemaCompatibilityStrategyCmd() throws Exception {
-        String topicName = generateTopicName("test-schema-compatibility-strategy", true);
-        pulsarAdmin.topics().createNonPartitionedTopic(topicName);
-
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
-                "get-schema-compatibility-strategy", topicName);
-        assertEquals(result.getStdout().trim(), "null");
-
-        result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies", "get-schema-compatibility-strategy",
-                "--applied", topicName);
-        assertEquals(result.getStdout().trim(), SchemaCompatibilityStrategy.FULL.name());
-
-        pulsarAdmin.topicPolicies().removeSchemaCompatibilityStrategy(topicName);
-        Awaitility.await().untilAsserted(() -> {
-            assertEquals(pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
-                    "get-schema-compatibility-strategy", topicName).getStdout().trim(), "null");
-        });
-    }
-
-    @Test
-    public void testSchemaCompatibilityStrategyCmdWithNamespaceLevel() throws Exception {
-        String ns = generateNamespaceName();
-        String fullNS = "public/" + ns;
-        pulsarAdmin.namespaces().createNamespace("public/" + ns);
-
-        String topicName = generateTopicName(ns, "test-schema-compatibility-strategy",
-                true);
-        pulsarAdmin.namespaces().setSchemaCompatibilityStrategy(fullNS,
-                SchemaCompatibilityStrategy.ALWAYS_INCOMPATIBLE);
-        pulsarAdmin.topics().createNonPartitionedTopic(topicName);
-
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
-                "get-schema-compatibility-strategy", topicName);
-        assertEquals(result.getStdout().trim(), "null");
-
-        result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
-                "get-schema-compatibility-strategy", "--applied", topicName);
-        assertEquals(result.getStdout().trim(), SchemaCompatibilityStrategy.ALWAYS_INCOMPATIBLE.name());
-
-        pulsarAdmin.namespaces()
-                .setSchemaCompatibilityStrategy(fullNS, SchemaCompatibilityStrategy.UNDEFINED);
-        result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies", "get-schema-compatibility-strategy",
-                topicName);
-        assertEquals(result.getStdout().trim(), "null");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.cli.topicpolicies;
+
+import static org.testng.Assert.assertEquals;
+import org.apache.pulsar.common.policies.data.SchemaCompatibilityStrategy;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarCliTestSuite;
+import org.awaitility.Awaitility;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SchemaCompatibilityStrategyTest extends PulsarCliTestSuite {
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public void before() throws Exception {
+        enableTopicPolicies();
+        super.before();
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    public void after() throws Exception {
+        super.after();
+    }
+
+    @Test
+    public void testSchemaCompatibilityStrategyCmd() throws Exception {
+        String topicName = generateTopicName("test-schema-compatibility-strategy", true);
+        pulsarAdmin.topics().createNonPartitionedTopic(topicName);
+
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
+                "get-schema-compatibility-strategy", topicName);
+        assertEquals(result.getStdout().trim(), "null");
+
+        result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies", "get-schema-compatibility-strategy",
+                "--applied", topicName);
+        assertEquals(result.getStdout().trim(), SchemaCompatibilityStrategy.FULL.name());
+
+        pulsarAdmin.topicPolicies().removeSchemaCompatibilityStrategy(topicName);
+        Awaitility.await().untilAsserted(() -> {
+            assertEquals(pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
+                    "get-schema-compatibility-strategy", topicName).getStdout().trim(), "null");
+        });
+    }
+
+    @Test
+    public void testSchemaCompatibilityStrategyCmdWithNamespaceLevel() throws Exception {
+        String ns = generateNamespaceName();
+        String fullNS = "public/" + ns;
+        pulsarAdmin.namespaces().createNamespace("public/" + ns);
+
+        String topicName = generateTopicName(ns, "test-schema-compatibility-strategy",
+                true);
+        pulsarAdmin.namespaces().setSchemaCompatibilityStrategy(fullNS,
+                SchemaCompatibilityStrategy.ALWAYS_INCOMPATIBLE);
+        pulsarAdmin.topics().createNonPartitionedTopic(topicName);
+
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
+                "get-schema-compatibility-strategy", topicName);
+        assertEquals(result.getStdout().trim(), "null");
+
+        result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies",
+                "get-schema-compatibility-strategy", "--applied", topicName);
+        assertEquals(result.getStdout().trim(), SchemaCompatibilityStrategy.ALWAYS_INCOMPATIBLE.name());
+
+        pulsarAdmin.namespaces()
+                .setSchemaCompatibilityStrategy(fullNS, SchemaCompatibilityStrategy.UNDEFINED);
+        result = pulsarCluster.runAdminCommandOnAnyBroker("topicPolicies", "get-schema-compatibility-strategy",
+                topicName);
+        assertEquals(result.getStdout().trim(), "null");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/compaction/TestCompaction.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/compaction/TestCompaction.java
index a3d534158d..822e5f0679 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/compaction/TestCompaction.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/compaction/TestCompaction.java
@@ -1,376 +1,376 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.compaction;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
-import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageRouter;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.TopicMetadata;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.annotations.Test;
-import org.testng.collections.Maps;
-
-/**
- * Test cases for compaction.
- */
-@Slf4j
-public class TestCompaction extends PulsarTestSuite {
-
-    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
-    public void testPublishCompactAndConsumeCLI(Supplier<String> serviceUrl) throws Exception {
-
-        final String tenant = "compaction-test-cli-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
-
-        this.createNamespace(namespace);
-
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
-            client.newConsumer().topic(topic).subscriptionName("sub1").subscribe().close();
-
-            try (Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topic).create()) {
-                producer.newMessage()
-                    .key("key0")
-                    .value("content0")
-                    .send();
-                producer.newMessage()
-                    .key("key0")
-                    .value("content1")
-                    .send();
-            }
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topic)
-                .readCompacted(true)
-                .subscriptionName("sub1")
-                .subscribe()) {
-                Message<String> m = consumer.receive();
-                assertEquals(m.getKey(), "key0");
-                assertEquals(m.getValue(), "content0");
-
-                m = consumer.receive();
-                assertEquals(m.getKey(), "key0");
-                assertEquals(m.getValue(), "content1");
-            }
-
-            pulsarCluster.runPulsarBaseCommandOnAnyBroker("compact-topic", "-t", topic);
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topic)
-                .readCompacted(true)
-                .subscriptionName("sub1")
-                .subscribe()) {
-                Message<String> m = consumer.receive();
-                assertEquals(m.getKey(), "key0");
-                assertEquals(m.getValue(), "content1");
-            }
-        }
-    }
-
-    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
-    public void testPublishCompactAndConsumeRest(Supplier<String> serviceUrl) throws Exception {
-
-        final String tenant = "compaction-test-rest-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
-
-        this.createNamespace(namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-clusters", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
-            client.newConsumer().topic(topic).subscriptionName("sub1").subscribe().close();
-
-            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
-                producer.newMessage()
-                    .key("key0")
-                    .value("content0")
-                    .send();
-                producer.newMessage()
-                    .key("key0")
-                    .value("content1")
-                    .send();
-            }
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
-                    .readCompacted(true).subscriptionName("sub1").subscribe()) {
-                Message<String> m = consumer.receive();
-                assertEquals(m.getKey(), "key0");
-                assertEquals(m.getValue(), "content0");
-
-                m = consumer.receive();
-                assertEquals(m.getKey(), "key0");
-                assertEquals(m.getValue(), "content1");
-            }
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "compact", topic);
-
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                "compaction-status", "-w", topic);
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
-                    .readCompacted(true).subscriptionName("sub1").subscribe()) {
-                Message<String> m = consumer.receive();
-                assertEquals(m.getKey(), "key0");
-                assertEquals(m.getValue(), "content1");
-            }
-        }
-    }
-
-    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
-    public void testPublishCompactAndConsumePartitionedTopics(Supplier<String> serviceUrl) throws Exception {
-
-        final String tenant = "compaction-test-partitioned-topic-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/partitioned-topic";
-        final int numKeys = 10;
-        final int numValuesPerKey = 10;
-        final String subscriptionName = "sub1";
-
-        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
-
-        this.createNamespace(namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-clusters", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        this.createPartitionedTopic(topic, 2);
-
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
-            // force creating individual partitions
-            client.newConsumer().topic(topic + "-partition-0").subscriptionName(subscriptionName).subscribe().close();
-            client.newConsumer().topic(topic + "-partition-1").subscriptionName(subscriptionName).subscribe().close();
-
-            try (Producer<byte[]> producer = client.newProducer()
-                .topic(topic)
-                .messageRouter(new MessageRouter() {
-                    @Override
-                    public int choosePartition(Message<?> msg, TopicMetadata metadata) {
-                        return Integer.parseInt(msg.getKey()) % metadata.numPartitions();
-                    }
-                })
-                .create()
-            ) {
-                for (int i = 0; i < numKeys; i++) {
-                    for (int j = 0; j < numValuesPerKey; j++) {
-                        producer.newMessage()
-                            .key("" + i)
-                            .value(("key-" + i + "-value-" + j).getBytes(UTF_8))
-                            .send();
-                    }
-                    log.info("Successfully write {} values for key {}", numValuesPerKey, i);
-                }
-            }
-
-            // test even partition
-            consumePartition(
-                client,
-                topic + "-partition-0",
-                subscriptionName,
-                IntStream.range(0, numKeys).filter(i -> i % 2 == 0).boxed().collect(Collectors.toList()),
-                numValuesPerKey,
-                0);
-            // test odd partition
-            consumePartition(
-                client,
-                topic + "-partition-1",
-                subscriptionName,
-                IntStream.range(0, numKeys).filter(i -> i % 2 != 0).boxed().collect(Collectors.toList()),
-                numValuesPerKey,
-                0);
-
-
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                "compact", topic + "-partition-0");
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                "compact", topic + "-partition-1");
-
-            // wait for compaction to be completed. we don't need to sleep here, but sleep will reduce
-            // the times of polling compaction-status from brokers
-            Thread.sleep(30000);
-
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                "compaction-status", "-w", topic + "-partition-0");
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                "compaction-status", "-w", topic + "-partition-1");
-
-            Map<Integer, String> compactedData = consumeCompactedTopic(client, topic, subscriptionName, numKeys);
-            assertEquals(compactedData.size(), numKeys);
-            for (int i = 0; i < numKeys; i++) {
-                assertEquals("key-" + i + "-value-" + (numValuesPerKey - 1), compactedData.get(i));
-            }
-        }
-    }
-
-    private static void consumePartition(PulsarClient client,
-                                         String topic,
-                                         String subscription,
-                                         List<Integer> keys,
-                                         int numValuesPerKey,
-                                         int startValue) throws PulsarClientException {
-        try (Consumer<byte[]> consumer = client.newConsumer()
-             .readCompacted(true)
-             .topic(topic)
-             .subscriptionName(subscription)
-             .subscribe()
-        ) {
-            for (Integer key : keys) {
-                for (int i = 0; i < numValuesPerKey; i++) {
-                    Message<byte[]> m = consumer.receive();
-                    assertEquals("" + key, m.getKey());
-                    assertEquals("key-" + key + "-value-" + (startValue + i), new String(m.getValue(), UTF_8));
-                }
-                log.info("Read {} values from key {}", numValuesPerKey, key);
-            }
-
-        }
-    }
-
-    private static Map<Integer, String> consumeCompactedTopic(PulsarClient client,
-                                                              String topic,
-                                                              String subscription,
-                                                              int numKeys) throws PulsarClientException {
-        Map<Integer, String> keys = Maps.newHashMap();
-        try (Consumer<byte[]> consumer = client.newConsumer()
-             .readCompacted(true)
-             .topic(topic)
-             .subscriptionName(subscription)
-             .subscribe()
-        ) {
-            for (int i = 0; i < numKeys; i++) {
-                Message<byte[]> m = consumer.receive();
-                keys.put(Integer.parseInt(m.getKey()), new String(m.getValue(), UTF_8));
-            }
-        }
-        return keys;
-    }
-
-    private static void waitAndVerifyCompacted(PulsarClient client, String topic,
-                                               String sub, String expectedKey, String expectedValue) throws Exception {
-        for (int i = 0; i < 60; i++) {
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
-                 .readCompacted(true).subscriptionName(sub).subscribe()) {
-                Message<String> m = consumer.receive();
-                assertEquals(m.getKey(), expectedKey);
-                if (m.getValue().equals(expectedValue)) {
-                    break;
-                }
-            }
-            Thread.sleep(1000);
-        }
-        try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
-                .readCompacted(true).subscriptionName(sub).subscribe()) {
-            Message<String> m = consumer.receive();
-            assertEquals(m.getKey(), expectedKey);
-            assertEquals(m.getValue(), expectedValue);
-        }
-    }
-
-    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
-    public void testPublishWithAutoCompaction(Supplier<String> serviceUrl) throws Exception {
-
-        final String tenant = "compaction-test-auto-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
-
-        this.createNamespace(namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-compaction-threshold", "--threshold", "1", namespace);
-
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
-            client.newConsumer(Schema.STRING).topic(topic).subscriptionName("sub1").subscribe().close();
-
-            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
-                producer.newMessage()
-                    .key("key0")
-                    .value("content0")
-                    .send();
-                producer.newMessage()
-                    .key("key0")
-                    .value("content1")
-                    .send();
-            }
-
-            waitAndVerifyCompacted(client, topic, "sub1", "key0", "content1");
-
-            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
-                producer.newMessage()
-                    .key("key0")
-                    .value("content2")
-                    .send();
-            }
-            waitAndVerifyCompacted(client, topic, "sub1", "key0", "content2");
-        }
-    }
-
-    private ContainerExecResult createTenantName(final String tenantName,
-                                                 final String allowedClusterName,
-                                                 final String adminRoleName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "tenants", "create", "--allowed-clusters", allowedClusterName,
-            "--admin-roles", adminRoleName, tenantName);
-        assertEquals(0, result.getExitCode());
-        return result;
-    }
-
-    private ContainerExecResult createNamespace(final String ns) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces",
-                "create",
-                "--clusters",
-                pulsarCluster.getClusterName(), ns);
-        assertEquals(0, result.getExitCode());
-        return result;
-    }
-
-    private ContainerExecResult createPartitionedTopic(final String partitionedTopicName, int numPartitions)
-            throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "topics",
-            "create-partitioned-topic",
-            "--partitions", "" + numPartitions,
-            partitionedTopicName);
-        assertEquals(0, result.getExitCode());
-        return result;
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.compaction;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageRouter;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.TopicMetadata;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.annotations.Test;
+import org.testng.collections.Maps;
+
+/**
+ * Test cases for compaction.
+ */
+@Slf4j
+public class TestCompaction extends PulsarTestSuite {
+
+    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
+    public void testPublishCompactAndConsumeCLI(Supplier<String> serviceUrl) throws Exception {
+
+        final String tenant = "compaction-test-cli-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
+
+        this.createNamespace(namespace);
+
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
+            client.newConsumer().topic(topic).subscriptionName("sub1").subscribe().close();
+
+            try (Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topic).create()) {
+                producer.newMessage()
+                    .key("key0")
+                    .value("content0")
+                    .send();
+                producer.newMessage()
+                    .key("key0")
+                    .value("content1")
+                    .send();
+            }
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topic)
+                .readCompacted(true)
+                .subscriptionName("sub1")
+                .subscribe()) {
+                Message<String> m = consumer.receive();
+                assertEquals(m.getKey(), "key0");
+                assertEquals(m.getValue(), "content0");
+
+                m = consumer.receive();
+                assertEquals(m.getKey(), "key0");
+                assertEquals(m.getValue(), "content1");
+            }
+
+            pulsarCluster.runPulsarBaseCommandOnAnyBroker("compact-topic", "-t", topic);
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topic)
+                .readCompacted(true)
+                .subscriptionName("sub1")
+                .subscribe()) {
+                Message<String> m = consumer.receive();
+                assertEquals(m.getKey(), "key0");
+                assertEquals(m.getValue(), "content1");
+            }
+        }
+    }
+
+    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
+    public void testPublishCompactAndConsumeRest(Supplier<String> serviceUrl) throws Exception {
+
+        final String tenant = "compaction-test-rest-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
+
+        this.createNamespace(namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-clusters", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
+            client.newConsumer().topic(topic).subscriptionName("sub1").subscribe().close();
+
+            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
+                producer.newMessage()
+                    .key("key0")
+                    .value("content0")
+                    .send();
+                producer.newMessage()
+                    .key("key0")
+                    .value("content1")
+                    .send();
+            }
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
+                    .readCompacted(true).subscriptionName("sub1").subscribe()) {
+                Message<String> m = consumer.receive();
+                assertEquals(m.getKey(), "key0");
+                assertEquals(m.getValue(), "content0");
+
+                m = consumer.receive();
+                assertEquals(m.getKey(), "key0");
+                assertEquals(m.getValue(), "content1");
+            }
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "compact", topic);
+
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                "compaction-status", "-w", topic);
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
+                    .readCompacted(true).subscriptionName("sub1").subscribe()) {
+                Message<String> m = consumer.receive();
+                assertEquals(m.getKey(), "key0");
+                assertEquals(m.getValue(), "content1");
+            }
+        }
+    }
+
+    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
+    public void testPublishCompactAndConsumePartitionedTopics(Supplier<String> serviceUrl) throws Exception {
+
+        final String tenant = "compaction-test-partitioned-topic-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/partitioned-topic";
+        final int numKeys = 10;
+        final int numValuesPerKey = 10;
+        final String subscriptionName = "sub1";
+
+        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
+
+        this.createNamespace(namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-clusters", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        this.createPartitionedTopic(topic, 2);
+
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
+            // force creating individual partitions
+            client.newConsumer().topic(topic + "-partition-0").subscriptionName(subscriptionName).subscribe().close();
+            client.newConsumer().topic(topic + "-partition-1").subscriptionName(subscriptionName).subscribe().close();
+
+            try (Producer<byte[]> producer = client.newProducer()
+                .topic(topic)
+                .messageRouter(new MessageRouter() {
+                    @Override
+                    public int choosePartition(Message<?> msg, TopicMetadata metadata) {
+                        return Integer.parseInt(msg.getKey()) % metadata.numPartitions();
+                    }
+                })
+                .create()
+            ) {
+                for (int i = 0; i < numKeys; i++) {
+                    for (int j = 0; j < numValuesPerKey; j++) {
+                        producer.newMessage()
+                            .key("" + i)
+                            .value(("key-" + i + "-value-" + j).getBytes(UTF_8))
+                            .send();
+                    }
+                    log.info("Successfully write {} values for key {}", numValuesPerKey, i);
+                }
+            }
+
+            // test even partition
+            consumePartition(
+                client,
+                topic + "-partition-0",
+                subscriptionName,
+                IntStream.range(0, numKeys).filter(i -> i % 2 == 0).boxed().collect(Collectors.toList()),
+                numValuesPerKey,
+                0);
+            // test odd partition
+            consumePartition(
+                client,
+                topic + "-partition-1",
+                subscriptionName,
+                IntStream.range(0, numKeys).filter(i -> i % 2 != 0).boxed().collect(Collectors.toList()),
+                numValuesPerKey,
+                0);
+
+
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                "compact", topic + "-partition-0");
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                "compact", topic + "-partition-1");
+
+            // wait for compaction to be completed. we don't need to sleep here, but sleep will reduce
+            // the times of polling compaction-status from brokers
+            Thread.sleep(30000);
+
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                "compaction-status", "-w", topic + "-partition-0");
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                "compaction-status", "-w", topic + "-partition-1");
+
+            Map<Integer, String> compactedData = consumeCompactedTopic(client, topic, subscriptionName, numKeys);
+            assertEquals(compactedData.size(), numKeys);
+            for (int i = 0; i < numKeys; i++) {
+                assertEquals("key-" + i + "-value-" + (numValuesPerKey - 1), compactedData.get(i));
+            }
+        }
+    }
+
+    private static void consumePartition(PulsarClient client,
+                                         String topic,
+                                         String subscription,
+                                         List<Integer> keys,
+                                         int numValuesPerKey,
+                                         int startValue) throws PulsarClientException {
+        try (Consumer<byte[]> consumer = client.newConsumer()
+             .readCompacted(true)
+             .topic(topic)
+             .subscriptionName(subscription)
+             .subscribe()
+        ) {
+            for (Integer key : keys) {
+                for (int i = 0; i < numValuesPerKey; i++) {
+                    Message<byte[]> m = consumer.receive();
+                    assertEquals("" + key, m.getKey());
+                    assertEquals("key-" + key + "-value-" + (startValue + i), new String(m.getValue(), UTF_8));
+                }
+                log.info("Read {} values from key {}", numValuesPerKey, key);
+            }
+
+        }
+    }
+
+    private static Map<Integer, String> consumeCompactedTopic(PulsarClient client,
+                                                              String topic,
+                                                              String subscription,
+                                                              int numKeys) throws PulsarClientException {
+        Map<Integer, String> keys = Maps.newHashMap();
+        try (Consumer<byte[]> consumer = client.newConsumer()
+             .readCompacted(true)
+             .topic(topic)
+             .subscriptionName(subscription)
+             .subscribe()
+        ) {
+            for (int i = 0; i < numKeys; i++) {
+                Message<byte[]> m = consumer.receive();
+                keys.put(Integer.parseInt(m.getKey()), new String(m.getValue(), UTF_8));
+            }
+        }
+        return keys;
+    }
+
+    private static void waitAndVerifyCompacted(PulsarClient client, String topic,
+                                               String sub, String expectedKey, String expectedValue) throws Exception {
+        for (int i = 0; i < 60; i++) {
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
+                 .readCompacted(true).subscriptionName(sub).subscribe()) {
+                Message<String> m = consumer.receive();
+                assertEquals(m.getKey(), expectedKey);
+                if (m.getValue().equals(expectedValue)) {
+                    break;
+                }
+            }
+            Thread.sleep(1000);
+        }
+        try (Consumer<String> consumer = client.newConsumer(Schema.STRING).topic(topic)
+                .readCompacted(true).subscriptionName(sub).subscribe()) {
+            Message<String> m = consumer.receive();
+            assertEquals(m.getKey(), expectedKey);
+            assertEquals(m.getValue(), expectedValue);
+        }
+    }
+
+    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
+    public void testPublishWithAutoCompaction(Supplier<String> serviceUrl) throws Exception {
+
+        final String tenant = "compaction-test-auto-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
+
+        this.createNamespace(namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-compaction-threshold", "--threshold", "1", namespace);
+
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
+            client.newConsumer(Schema.STRING).topic(topic).subscriptionName("sub1").subscribe().close();
+
+            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
+                producer.newMessage()
+                    .key("key0")
+                    .value("content0")
+                    .send();
+                producer.newMessage()
+                    .key("key0")
+                    .value("content1")
+                    .send();
+            }
+
+            waitAndVerifyCompacted(client, topic, "sub1", "key0", "content1");
+
+            try (Producer<String> producer = client.newProducer(Schema.STRING).topic(topic).create()) {
+                producer.newMessage()
+                    .key("key0")
+                    .value("content2")
+                    .send();
+            }
+            waitAndVerifyCompacted(client, topic, "sub1", "key0", "content2");
+        }
+    }
+
+    private ContainerExecResult createTenantName(final String tenantName,
+                                                 final String allowedClusterName,
+                                                 final String adminRoleName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "tenants", "create", "--allowed-clusters", allowedClusterName,
+            "--admin-roles", adminRoleName, tenantName);
+        assertEquals(0, result.getExitCode());
+        return result;
+    }
+
+    private ContainerExecResult createNamespace(final String ns) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces",
+                "create",
+                "--clusters",
+                pulsarCluster.getClusterName(), ns);
+        assertEquals(0, result.getExitCode());
+        return result;
+    }
+
+    private ContainerExecResult createPartitionedTopic(final String partitionedTopicName, int numPartitions)
+            throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "topics",
+            "create-partitioned-topic",
+            "--partitions", "" + numPartitions,
+            partitionedTopicName);
+        assertEquals(0, result.getExitCode());
+        return result;
+    }
+
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BKContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BKContainer.java
index 64806a1f9a..30af2130ab 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BKContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BKContainer.java
@@ -1,38 +1,38 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-/**
- * A pulsar container that runs bookkeeper.
- */
-public class BKContainer extends PulsarContainer<BKContainer> {
-
-    public static final String NAME = "bookie";
-
-    public BKContainer(String clusterName, String hostName) {
-        super(
-            clusterName, hostName, hostName, "bin/run-bookie.sh", BOOKIE_PORT, INVALID_PORT);
-        tailContainerLog();
-    }
-
-    @Override
-    protected boolean isPassNettyLeakDetectionSystemProperties() {
-        return false;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+/**
+ * A pulsar container that runs bookkeeper.
+ */
+public class BKContainer extends PulsarContainer<BKContainer> {
+
+    public static final String NAME = "bookie";
+
+    public BKContainer(String clusterName, String hostName) {
+        super(
+            clusterName, hostName, hostName, "bin/run-bookie.sh", BOOKIE_PORT, INVALID_PORT);
+        tailContainerLog();
+    }
+
+    @Override
+    protected boolean isPassNettyLeakDetectionSystemProperties() {
+        return false;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BrokerContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BrokerContainer.java
index a51397050b..9a5f20f707 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BrokerContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/BrokerContainer.java
@@ -1,50 +1,50 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-
-/**
- * A pulsar container that runs bookkeeper.
- */
-public class BrokerContainer extends PulsarContainer<BrokerContainer> {
-
-    public static final String NAME = "pulsar-broker";
-
-    public BrokerContainer(String clusterName, String hostName) {
-        this(clusterName, hostName, false);
-    }
-
-    public BrokerContainer(String clusterName, String hostName, boolean enableTls) {
-        super(clusterName, hostName, hostName, "bin/run-broker.sh", BROKER_PORT,
-                enableTls ? BROKER_PORT_TLS : 0, BROKER_HTTP_PORT,
-                enableTls ? BROKER_HTTPS_PORT : 0, DEFAULT_HTTP_PATH, DEFAULT_IMAGE_NAME);
-        tailContainerLog();
-    }
-
-    public String getHostName() {
-        return super.hostname;
-    }
-
-    @Override
-    protected void afterStart() {
-        DockerUtils.runCommandAsyncWithLogging(this.dockerClient, this.getContainerId(),
-                "tail", "-f", "/var/log/pulsar/broker.log");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+
+/**
+ * A pulsar container that runs bookkeeper.
+ */
+public class BrokerContainer extends PulsarContainer<BrokerContainer> {
+
+    public static final String NAME = "pulsar-broker";
+
+    public BrokerContainer(String clusterName, String hostName) {
+        this(clusterName, hostName, false);
+    }
+
+    public BrokerContainer(String clusterName, String hostName, boolean enableTls) {
+        super(clusterName, hostName, hostName, "bin/run-broker.sh", BROKER_PORT,
+                enableTls ? BROKER_PORT_TLS : 0, BROKER_HTTP_PORT,
+                enableTls ? BROKER_HTTPS_PORT : 0, DEFAULT_HTTP_PATH, DEFAULT_IMAGE_NAME);
+        tailContainerLog();
+    }
+
+    public String getHostName() {
+        return super.hostname;
+    }
+
+    @Override
+    protected void afterStart() {
+        DockerUtils.runCommandAsyncWithLogging(this.dockerClient, this.getContainerId(),
+                "tail", "-f", "/var/log/pulsar/broker.log");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CSContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CSContainer.java
index 20c7a79dc4..5613adec58 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CSContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CSContainer.java
@@ -1,47 +1,47 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-/**
- * A pulsar container that runs configuration store.
- */
-public class CSContainer extends PulsarContainer<CSContainer> {
-
-    public static final String NAME = "configuration-store";
-
-    public CSContainer(String clusterName) {
-        super(
-            clusterName,
-            NAME,
-            NAME,
-            "bin/run-global-zk.sh",
-            CS_PORT,
-            INVALID_PORT);
-    }
-
-    @Override
-    protected boolean isCodeCoverageEnabled() {
-        return false;
-    }
-
-    @Override
-    protected boolean isPassNettyLeakDetectionSystemProperties() {
-        return false;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+/**
+ * A pulsar container that runs configuration store.
+ */
+public class CSContainer extends PulsarContainer<CSContainer> {
+
+    public static final String NAME = "configuration-store";
+
+    public CSContainer(String clusterName) {
+        super(
+            clusterName,
+            NAME,
+            NAME,
+            "bin/run-global-zk.sh",
+            CS_PORT,
+            INVALID_PORT);
+    }
+
+    @Override
+    protected boolean isCodeCoverageEnabled() {
+        return false;
+    }
+
+    @Override
+    protected boolean isPassNettyLeakDetectionSystemProperties() {
+        return false;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CassandraContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CassandraContainer.java
index c9cdcdf2c4..4b40fff154 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CassandraContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/CassandraContainer.java
@@ -1,52 +1,52 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import lombok.extern.slf4j.Slf4j;
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-/**
- * Cassandra Container.
- */
-@Slf4j
-public class CassandraContainer<SelfT extends ChaosContainer<SelfT>> extends ChaosContainer<SelfT> {
-
-    public static final String NAME = "cassandra";
-    public static final int PORT = 9042;
-
-    public CassandraContainer(String clusterName) {
-        super(clusterName, "cassandra:3");
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(NAME)
-            .withExposedPorts(PORT)
-            .withCreateContainerCmdModifier(createContainerCmd -> {
-                createContainerCmd.withHostName(NAME);
-                createContainerCmd.withName(clusterName + "-" + NAME);
-            })
-            .waitingFor(new HostPortWaitStrategy());
-    }
-
-    public int getCassandraPort() {
-        return getMappedPort(PORT);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import lombok.extern.slf4j.Slf4j;
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+/**
+ * Cassandra Container.
+ */
+@Slf4j
+public class CassandraContainer<SelfT extends ChaosContainer<SelfT>> extends ChaosContainer<SelfT> {
+
+    public static final String NAME = "cassandra";
+    public static final int PORT = 9042;
+
+    public CassandraContainer(String clusterName) {
+        super(clusterName, "cassandra:3");
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+            .withExposedPorts(PORT)
+            .withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(NAME);
+                createContainerCmd.withName(clusterName + "-" + NAME);
+            })
+            .waitingFor(new HostPortWaitStrategy());
+    }
+
+    public int getCassandraPort() {
+        return getMappedPort(PORT);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ChaosContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ChaosContainer.java
index 369801d6b6..6df14dd957 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ChaosContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ChaosContainer.java
@@ -1,147 +1,147 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import com.github.dockerjava.api.DockerClient;
-import java.util.Base64;
-import java.util.Objects;
-import java.util.concurrent.CompletableFuture;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-import org.testcontainers.containers.GenericContainer;
-
-/**
- * A base container provides chaos capability.
- */
-@Slf4j
-public class ChaosContainer<SelfT extends ChaosContainer<SelfT>> extends GenericContainer<SelfT> {
-
-    protected final String clusterName;
-
-    protected ChaosContainer(String clusterName, String image) {
-        super(image);
-        this.clusterName = clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        addEnv("MALLOC_ARENA_MAX", "1");
-    }
-
-    protected void appendToEnv(String key, String value) {
-        String existingValue = getEnvMap().get(key);
-        if (existingValue == null) {
-            addEnv(key, value);
-        } else {
-            addEnv(key, existingValue + " " + value);
-        }
-    }
-
-    protected void passSystemPropertyInEnv(String envKey, String systemPropertyName) {
-        passSystemPropertyInEnv(envKey, systemPropertyName, System.getProperty(systemPropertyName));
-    }
-
-    protected void passSystemPropertyInEnv(String envKey, String systemPropertyName, String systemPropertyValue) {
-        if (systemPropertyValue != null) {
-            String entryValue = "-D" + systemPropertyName + "=" + systemPropertyValue;
-            if (StringUtils.containsWhitespace(systemPropertyValue)) {
-                entryValue = "\"" + entryValue + "\"";
-            }
-            appendToEnv(envKey, entryValue);
-        }
-    }
-
-    protected void beforeStop() {
-        if (null == getContainerId()) {
-            return;
-        }
-
-        // dump the container log
-        DockerUtils.dumpContainerLogToTarget(
-            getDockerClient(),
-            getContainerId()
-        );
-    }
-
-    @Override
-    public void stop() {
-        beforeStop();
-        doStop();
-    }
-
-    protected void doStop() {
-        super.stop();
-    }
-
-    protected void tailContainerLog() {
-        withLogConsumer(item -> log.info(item.getUtf8String()));
-    }
-
-    public void putFile(String path, byte[] contents) throws Exception {
-        String base64contents = Base64.getEncoder().encodeToString(contents);
-        String cmd = String.format("echo %s | base64 -d > %s", base64contents, path);
-        execCmd("bash", "-c", cmd);
-    }
-
-    public ContainerExecResult execCmd(String... commands) throws Exception {
-        DockerClient client = this.getDockerClient();
-        String dockerId = this.getContainerId();
-        return DockerUtils.runCommand(client, dockerId, commands);
-    }
-
-    public CompletableFuture<ContainerExecResult> execCmdAsync(String... commands) throws Exception {
-        DockerClient client = this.getDockerClient();
-        String dockerId = this.getContainerId();
-        return DockerUtils.runCommandAsync(client, dockerId, commands);
-    }
-
-    public ContainerExecResult execCmdAsUser(String userId, String... commands) throws Exception {
-        DockerClient client = this.getDockerClient();
-        String dockerId = this.getContainerId();
-        return DockerUtils.runCommandAsUser(userId, client, dockerId, commands);
-    }
-
-    public CompletableFuture<ContainerExecResult> execCmdAsyncAsUser(String userId, String... commands)
-            throws Exception {
-        DockerClient client = this.getDockerClient();
-        String dockerId = this.getContainerId();
-        return DockerUtils.runCommandAsyncAsUser(userId, client, dockerId, commands);
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (!(o instanceof ChaosContainer)) {
-            return false;
-        }
-
-        ChaosContainer<?> another = (ChaosContainer<?>) o;
-        return clusterName.equals(another.clusterName)
-            && super.equals(another);
-    }
-
-    @Override
-    public int hashCode() {
-        return 31 * super.hashCode() + Objects.hash(
-            clusterName);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import com.github.dockerjava.api.DockerClient;
+import java.util.Base64;
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+import org.testcontainers.containers.GenericContainer;
+
+/**
+ * A base container provides chaos capability.
+ */
+@Slf4j
+public class ChaosContainer<SelfT extends ChaosContainer<SelfT>> extends GenericContainer<SelfT> {
+
+    protected final String clusterName;
+
+    protected ChaosContainer(String clusterName, String image) {
+        super(image);
+        this.clusterName = clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        addEnv("MALLOC_ARENA_MAX", "1");
+    }
+
+    protected void appendToEnv(String key, String value) {
+        String existingValue = getEnvMap().get(key);
+        if (existingValue == null) {
+            addEnv(key, value);
+        } else {
+            addEnv(key, existingValue + " " + value);
+        }
+    }
+
+    protected void passSystemPropertyInEnv(String envKey, String systemPropertyName) {
+        passSystemPropertyInEnv(envKey, systemPropertyName, System.getProperty(systemPropertyName));
+    }
+
+    protected void passSystemPropertyInEnv(String envKey, String systemPropertyName, String systemPropertyValue) {
+        if (systemPropertyValue != null) {
+            String entryValue = "-D" + systemPropertyName + "=" + systemPropertyValue;
+            if (StringUtils.containsWhitespace(systemPropertyValue)) {
+                entryValue = "\"" + entryValue + "\"";
+            }
+            appendToEnv(envKey, entryValue);
+        }
+    }
+
+    protected void beforeStop() {
+        if (null == getContainerId()) {
+            return;
+        }
+
+        // dump the container log
+        DockerUtils.dumpContainerLogToTarget(
+            getDockerClient(),
+            getContainerId()
+        );
+    }
+
+    @Override
+    public void stop() {
+        beforeStop();
+        doStop();
+    }
+
+    protected void doStop() {
+        super.stop();
+    }
+
+    protected void tailContainerLog() {
+        withLogConsumer(item -> log.info(item.getUtf8String()));
+    }
+
+    public void putFile(String path, byte[] contents) throws Exception {
+        String base64contents = Base64.getEncoder().encodeToString(contents);
+        String cmd = String.format("echo %s | base64 -d > %s", base64contents, path);
+        execCmd("bash", "-c", cmd);
+    }
+
+    public ContainerExecResult execCmd(String... commands) throws Exception {
+        DockerClient client = this.getDockerClient();
+        String dockerId = this.getContainerId();
+        return DockerUtils.runCommand(client, dockerId, commands);
+    }
+
+    public CompletableFuture<ContainerExecResult> execCmdAsync(String... commands) throws Exception {
+        DockerClient client = this.getDockerClient();
+        String dockerId = this.getContainerId();
+        return DockerUtils.runCommandAsync(client, dockerId, commands);
+    }
+
+    public ContainerExecResult execCmdAsUser(String userId, String... commands) throws Exception {
+        DockerClient client = this.getDockerClient();
+        String dockerId = this.getContainerId();
+        return DockerUtils.runCommandAsUser(userId, client, dockerId, commands);
+    }
+
+    public CompletableFuture<ContainerExecResult> execCmdAsyncAsUser(String userId, String... commands)
+            throws Exception {
+        DockerClient client = this.getDockerClient();
+        String dockerId = this.getContainerId();
+        return DockerUtils.runCommandAsyncAsUser(userId, client, dockerId, commands);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof ChaosContainer)) {
+            return false;
+        }
+
+        ChaosContainer<?> another = (ChaosContainer<?>) o;
+        return clusterName.equals(another.clusterName)
+            && super.equals(another);
+    }
+
+    @Override
+    public int hashCode() {
+        return 31 * super.hashCode() + Objects.hash(
+            clusterName);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMongoDbContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMongoDbContainer.java
index 6fa2e9ff47..9ccbc6dae7 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMongoDbContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMongoDbContainer.java
@@ -1,51 +1,51 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-public class DebeziumMongoDbContainer extends ChaosContainer<DebeziumMongoDbContainer> {
-
-    public static final String NAME = "debezium-mongodb-example";
-
-    public static final Integer[] PORTS = { 27017 };
-    private static final String IMAGE_NAME = "debezium/example-mongodb:3.0.0.Final";
-
-    public DebeziumMongoDbContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-        this.withEnv("MONGODB_USER", "mongodb");
-        this.withEnv("MONGODB_PASSWORD", "mongodb");
-    }
-    @Override
-    public String getContainerName() {
-        return clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(NAME)
-                .withExposedPorts(PORTS)
-                .withCreateContainerCmdModifier(createContainerCmd -> {
-                    createContainerCmd.withHostName(NAME);
-                    createContainerCmd.withName(getContainerName());
-                })
-                .waitingFor(new HostPortWaitStrategy());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+public class DebeziumMongoDbContainer extends ChaosContainer<DebeziumMongoDbContainer> {
+
+    public static final String NAME = "debezium-mongodb-example";
+
+    public static final Integer[] PORTS = { 27017 };
+    private static final String IMAGE_NAME = "debezium/example-mongodb:3.0.0.Final";
+
+    public DebeziumMongoDbContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+        this.withEnv("MONGODB_USER", "mongodb");
+        this.withEnv("MONGODB_PASSWORD", "mongodb");
+    }
+    @Override
+    public String getContainerName() {
+        return clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+                .withExposedPorts(PORTS)
+                .withCreateContainerCmdModifier(createContainerCmd -> {
+                    createContainerCmd.withHostName(NAME);
+                    createContainerCmd.withName(getContainerName());
+                })
+                .waitingFor(new HostPortWaitStrategy());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMsSqlContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMsSqlContainer.java
index 36edca570a..8da2b061f8 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMsSqlContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMsSqlContainer.java
@@ -1,70 +1,70 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import java.time.Duration;
-import java.time.temporal.ChronoUnit;
-import org.testcontainers.containers.wait.strategy.Wait;
-
-public class DebeziumMsSqlContainer extends ChaosContainer<DebeziumMsSqlContainer> {
-
-    // This password needs to include at least 8 characters of at least three of these four categories:
-    // uppercase letters, lowercase letters, numbers and non-alphanumeric symbols
-    public static final String SA_PASSWORD = "p@ssw0rD";
-    public static final String NAME = "debezium-mssql";
-    static final Integer[] PORTS = { 1433 };
-
-    // https://hub.docker.com/_/microsoft-mssql-server
-    // EULA: https://go.microsoft.com/fwlink/?linkid=857698
-    // "You may install and use copies of the software on any device,
-    // including third party shared devices, to design, develop, test and demonstrate your programs.
-    // You may not use the software on a device or server in a production environment."
-    private static final String IMAGE_NAME = "mcr.microsoft.com/mssql/server:2019-CU28-ubuntu-20.04";
-
-    public DebeziumMsSqlContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        // leaving default MSSQL_PID (aka Developer edition)
-        this.withNetworkAliases(NAME)
-            .withExposedPorts(PORTS)
-            .withEnv("ACCEPT_EULA", "Y")
-            .withEnv("SA_PASSWORD", SA_PASSWORD)
-            .withEnv("MSSQL_SA_PASSWORD", SA_PASSWORD)
-            .withEnv("MSSQL_AGENT_ENABLED", "true")
-            .withStartupTimeout(Duration.of(300, ChronoUnit.SECONDS))
-            .withCreateContainerCmdModifier(createContainerCmd -> {
-                createContainerCmd.withHostName(NAME);
-                createContainerCmd.withName(getContainerName());
-            })
-            // wait strategy to address problem with MS SQL responding to the connection
-            // before service starts up completely
-            // https://github.com/microsoft/mssql-docker/issues/625#issuecomment-882025521
-            .waitingFor(Wait.forLogMessage(".*The tempdb database has .*", 2));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+import org.testcontainers.containers.wait.strategy.Wait;
+
+public class DebeziumMsSqlContainer extends ChaosContainer<DebeziumMsSqlContainer> {
+
+    // This password needs to include at least 8 characters of at least three of these four categories:
+    // uppercase letters, lowercase letters, numbers and non-alphanumeric symbols
+    public static final String SA_PASSWORD = "p@ssw0rD";
+    public static final String NAME = "debezium-mssql";
+    static final Integer[] PORTS = { 1433 };
+
+    // https://hub.docker.com/_/microsoft-mssql-server
+    // EULA: https://go.microsoft.com/fwlink/?linkid=857698
+    // "You may install and use copies of the software on any device,
+    // including third party shared devices, to design, develop, test and demonstrate your programs.
+    // You may not use the software on a device or server in a production environment."
+    private static final String IMAGE_NAME = "mcr.microsoft.com/mssql/server:2019-CU28-ubuntu-20.04";
+
+    public DebeziumMsSqlContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        // leaving default MSSQL_PID (aka Developer edition)
+        this.withNetworkAliases(NAME)
+            .withExposedPorts(PORTS)
+            .withEnv("ACCEPT_EULA", "Y")
+            .withEnv("SA_PASSWORD", SA_PASSWORD)
+            .withEnv("MSSQL_SA_PASSWORD", SA_PASSWORD)
+            .withEnv("MSSQL_AGENT_ENABLED", "true")
+            .withStartupTimeout(Duration.of(300, ChronoUnit.SECONDS))
+            .withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(NAME);
+                createContainerCmd.withName(getContainerName());
+            })
+            // wait strategy to address problem with MS SQL responding to the connection
+            // before service starts up completely
+            // https://github.com/microsoft/mssql-docker/issues/625#issuecomment-882025521
+            .waitingFor(Wait.forLogMessage(".*The tempdb database has .*", 2));
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMySQLContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMySQLContainer.java
index cf59cda868..2c0ae6b2d2 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMySQLContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumMySQLContainer.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-public class DebeziumMySQLContainer extends ChaosContainer<DebeziumMySQLContainer> {
-
-    public static final String NAME = "debezium-mysql-example";
-    static final Integer[] PORTS = { 3306 };
-
-    private static final String IMAGE_NAME = "debezium/example-mysql:3.0.0.Final";
-
-    public DebeziumMySQLContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-        this.withEnv("MYSQL_USER", "mysqluser");
-        this.withEnv("MYSQL_PASSWORD", "mysqlpw");
-        this.withEnv("MYSQL_ROOT_PASSWORD", "debezium");
-
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(NAME)
-            .withExposedPorts(PORTS)
-            .withCreateContainerCmdModifier(createContainerCmd -> {
-                createContainerCmd.withHostName(NAME);
-                createContainerCmd.withName(getContainerName());
-            })
-            .waitingFor(new HostPortWaitStrategy());
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+public class DebeziumMySQLContainer extends ChaosContainer<DebeziumMySQLContainer> {
+
+    public static final String NAME = "debezium-mysql-example";
+    static final Integer[] PORTS = { 3306 };
+
+    private static final String IMAGE_NAME = "debezium/example-mysql:3.0.0.Final";
+
+    public DebeziumMySQLContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+        this.withEnv("MYSQL_USER", "mysqluser");
+        this.withEnv("MYSQL_PASSWORD", "mysqlpw");
+        this.withEnv("MYSQL_ROOT_PASSWORD", "debezium");
+
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+            .withExposedPorts(PORTS)
+            .withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(NAME);
+                createContainerCmd.withName(getContainerName());
+            })
+            .waitingFor(new HostPortWaitStrategy());
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumOracleDbContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumOracleDbContainer.java
index d9196b2d3b..3ee23395e6 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumOracleDbContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumOracleDbContainer.java
@@ -1,61 +1,61 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import java.time.Duration;
-import java.time.temporal.ChronoUnit;
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-public class DebeziumOracleDbContainer extends ChaosContainer<DebeziumOracleDbContainer> {
-
-    public static final String NAME = "debezium-oracledb-12c";
-    static final Integer[] PORTS = { 1521 };
-
-    // https://github.com/MaksymBilenko/docker-oracle-12c
-    // Apache 2.0 license.
-    // Newer versions don't have LigMiner in XE (Standard) Edition and require Enterprise.
-    // Debezium 1.5 didn't work with 11g out of the box
-    // and it is not tested with 11.g according to https://debezium.io/releases/1.5/
-    private static final String IMAGE_NAME = "quay.io/maksymbilenko/oracle-12c:master";
-
-    public DebeziumOracleDbContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(NAME)
-            .withExposedPorts(PORTS)
-            .withEnv("DBCA_TOTAL_MEMORY", "2048")
-            .withEnv("WEB_CONSOLE", "false")
-            .withStartupTimeout(Duration.of(300, ChronoUnit.SECONDS))
-            .withCreateContainerCmdModifier(createContainerCmd -> {
-                createContainerCmd.withHostName(NAME);
-                createContainerCmd.withName(getContainerName());
-            })
-            .waitingFor(new HostPortWaitStrategy());
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+public class DebeziumOracleDbContainer extends ChaosContainer<DebeziumOracleDbContainer> {
+
+    public static final String NAME = "debezium-oracledb-12c";
+    static final Integer[] PORTS = { 1521 };
+
+    // https://github.com/MaksymBilenko/docker-oracle-12c
+    // Apache 2.0 license.
+    // Newer versions don't have LigMiner in XE (Standard) Edition and require Enterprise.
+    // Debezium 1.5 didn't work with 11g out of the box
+    // and it is not tested with 11.g according to https://debezium.io/releases/1.5/
+    private static final String IMAGE_NAME = "quay.io/maksymbilenko/oracle-12c:master";
+
+    public DebeziumOracleDbContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+            .withExposedPorts(PORTS)
+            .withEnv("DBCA_TOTAL_MEMORY", "2048")
+            .withEnv("WEB_CONSOLE", "false")
+            .withStartupTimeout(Duration.of(300, ChronoUnit.SECONDS))
+            .withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(NAME);
+                createContainerCmd.withName(getContainerName());
+            })
+            .waitingFor(new HostPortWaitStrategy());
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumPostgreSqlContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumPostgreSqlContainer.java
index 4fd391fd92..1001553dd0 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumPostgreSqlContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/DebeziumPostgreSqlContainer.java
@@ -1,54 +1,54 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-public class DebeziumPostgreSqlContainer extends ChaosContainer<DebeziumPostgreSqlContainer> {
-
-    public static final String NAME = "debezium-postgresql-example";
-    static final Integer[] PORTS = { 5432 };
-
-    private static final String IMAGE_NAME = "debezium/example-postgres:3.0.0.Final";
-
-    public DebeziumPostgreSqlContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-        this.withEnv("POSTGRES_USER", "postgres");
-        this.withEnv("POSTGRES_PASSWORD", "postgres");
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(NAME)
-            .withExposedPorts(PORTS)
-            .withCreateContainerCmdModifier(createContainerCmd -> {
-                createContainerCmd.withHostName(NAME);
-                createContainerCmd.withName(getContainerName());
-            })
-            .waitingFor(new HostPortWaitStrategy());
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+public class DebeziumPostgreSqlContainer extends ChaosContainer<DebeziumPostgreSqlContainer> {
+
+    public static final String NAME = "debezium-postgresql-example";
+    static final Integer[] PORTS = { 5432 };
+
+    private static final String IMAGE_NAME = "debezium/example-postgres:3.0.0.Final";
+
+    public DebeziumPostgreSqlContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+        this.withEnv("POSTGRES_USER", "postgres");
+        this.withEnv("POSTGRES_PASSWORD", "postgres");
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+            .withExposedPorts(PORTS)
+            .withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(NAME);
+                createContainerCmd.withName(getContainerName());
+            })
+            .waitingFor(new HostPortWaitStrategy());
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/HdfsContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/HdfsContainer.java
index 275e6d0d48..7b135cbe21 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/HdfsContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/HdfsContainer.java
@@ -1,51 +1,51 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-public class HdfsContainer extends ChaosContainer<HdfsContainer> {
-
-    public static final String NAME = "HDFS";
-    static final Integer[] PORTS = { 8020, 8032, 8088, 9000, 10020, 19888, 50010, 50020, 50070, 50070, 50090 };
-
-    private static final String IMAGE_NAME = "harisekhon/hadoop:latest";
-
-    public HdfsContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(NAME)
-        .withExposedPorts(PORTS)
-        .withCreateContainerCmdModifier(createContainerCmd -> {
-            createContainerCmd.withHostName(NAME);
-            createContainerCmd.withName(clusterName + "-" + NAME);
-        })
-        .waitingFor(new HostPortWaitStrategy());
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+public class HdfsContainer extends ChaosContainer<HdfsContainer> {
+
+    public static final String NAME = "HDFS";
+    static final Integer[] PORTS = { 8020, 8032, 8088, 9000, 10020, 19888, 50010, 50020, 50070, 50070, 50090 };
+
+    private static final String IMAGE_NAME = "harisekhon/hadoop:latest";
+
+    public HdfsContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+        .withExposedPorts(PORTS)
+        .withCreateContainerCmdModifier(createContainerCmd -> {
+            createContainerCmd.withHostName(NAME);
+            createContainerCmd.withName(clusterName + "-" + NAME);
+        })
+        .waitingFor(new HostPortWaitStrategy());
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/OpenTelemetryCollectorContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/OpenTelemetryCollectorContainer.java
index 2b115ca6b9..e6cd347f6d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/OpenTelemetryCollectorContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/OpenTelemetryCollectorContainer.java
@@ -1,63 +1,63 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import java.time.Duration;
-import org.apache.http.HttpStatus;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-import org.testcontainers.utility.MountableFile;
-
-public class OpenTelemetryCollectorContainer extends ChaosContainer<OpenTelemetryCollectorContainer> {
-
-    private static final String IMAGE_NAME = "otel/opentelemetry-collector-contrib:latest";
-    private static final String NAME = "otel-collector";
-
-    public static final int PROMETHEUS_EXPORTER_PORT = 8889;
-    private static final int OTLP_RECEIVER_PORT = 4317;
-    private static final int ZPAGES_PORT = 55679;
-
-    public OpenTelemetryCollectorContainer(String clusterName) {
-        super(clusterName, IMAGE_NAME);
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-
-        this.withCopyFileToContainer(
-                MountableFile.forClasspathResource("containers/otel-collector-config.yaml", 0644),
-                "/etc/otel-collector-config.yaml")
-            .withCommand("--config=/etc/otel-collector-config.yaml")
-            .withExposedPorts(OTLP_RECEIVER_PORT, PROMETHEUS_EXPORTER_PORT, ZPAGES_PORT)
-            .waitingFor(new HttpWaitStrategy()
-                    .forPath("/debug/servicez")
-                    .forPort(ZPAGES_PORT)
-                    .forStatusCode(HttpStatus.SC_OK)
-                    .withStartupTimeout(Duration.ofSeconds(300)));
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName + "-" + NAME;
-    }
-
-    public String getOtlpEndpoint() {
-        return String.format("http://%s:%d", NAME, OTLP_RECEIVER_PORT);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import java.time.Duration;
+import org.apache.http.HttpStatus;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+import org.testcontainers.utility.MountableFile;
+
+public class OpenTelemetryCollectorContainer extends ChaosContainer<OpenTelemetryCollectorContainer> {
+
+    private static final String IMAGE_NAME = "otel/opentelemetry-collector-contrib:latest";
+    private static final String NAME = "otel-collector";
+
+    public static final int PROMETHEUS_EXPORTER_PORT = 8889;
+    private static final int OTLP_RECEIVER_PORT = 4317;
+    private static final int ZPAGES_PORT = 55679;
+
+    public OpenTelemetryCollectorContainer(String clusterName) {
+        super(clusterName, IMAGE_NAME);
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+
+        this.withCopyFileToContainer(
+                MountableFile.forClasspathResource("containers/otel-collector-config.yaml", 0644),
+                "/etc/otel-collector-config.yaml")
+            .withCommand("--config=/etc/otel-collector-config.yaml")
+            .withExposedPorts(OTLP_RECEIVER_PORT, PROMETHEUS_EXPORTER_PORT, ZPAGES_PORT)
+            .waitingFor(new HttpWaitStrategy()
+                    .forPath("/debug/servicez")
+                    .forPort(ZPAGES_PORT)
+                    .forStatusCode(HttpStatus.SC_OK)
+                    .withStartupTimeout(Duration.ofSeconds(300)));
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName + "-" + NAME;
+    }
+
+    public String getOtlpEndpoint() {
+        return String.format("http://%s:%d", NAME, OTLP_RECEIVER_PORT);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ProxyContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ProxyContainer.java
index f3926878f3..3b32290aa3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ProxyContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ProxyContainer.java
@@ -1,45 +1,45 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-
-/**
- * A pulsar container that runs bookkeeper.
- */
-public class ProxyContainer extends PulsarContainer<ProxyContainer> {
-
-    public static final String NAME = "pulsar-proxy";
-
-    public ProxyContainer(String clusterName, String hostName) {
-        this(clusterName, hostName, false);
-    }
-
-    public ProxyContainer(String clusterName, String hostName, boolean enableTls) {
-        super(clusterName, hostName, hostName, "bin/run-proxy.sh", BROKER_PORT,
-                enableTls ? BROKER_PORT_TLS : 0, BROKER_HTTP_PORT,
-                enableTls ? BROKER_HTTPS_PORT : 0, DEFAULT_HTTP_PATH, DEFAULT_IMAGE_NAME);
-    }
-
-    @Override
-    protected void afterStart() {
-        DockerUtils.runCommandAsyncWithLogging(this.dockerClient, this.getContainerId(),
-                "tail", "-f", "/var/log/pulsar/proxy.log");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+
+/**
+ * A pulsar container that runs bookkeeper.
+ */
+public class ProxyContainer extends PulsarContainer<ProxyContainer> {
+
+    public static final String NAME = "pulsar-proxy";
+
+    public ProxyContainer(String clusterName, String hostName) {
+        this(clusterName, hostName, false);
+    }
+
+    public ProxyContainer(String clusterName, String hostName, boolean enableTls) {
+        super(clusterName, hostName, hostName, "bin/run-proxy.sh", BROKER_PORT,
+                enableTls ? BROKER_PORT_TLS : 0, BROKER_HTTP_PORT,
+                enableTls ? BROKER_HTTPS_PORT : 0, DEFAULT_HTTP_PATH, DEFAULT_IMAGE_NAME);
+    }
+
+    @Override
+    protected void afterStart() {
+        DockerUtils.runCommandAsyncWithLogging(this.dockerClient, this.getContainerId(),
+                "tail", "-f", "/var/log/pulsar/proxy.log");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarContainer.java
index 692bca2589..d88e208e77 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarContainer.java
@@ -1,360 +1,360 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.io.File;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.time.Duration;
-import java.util.Objects;
-import java.util.UUID;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.io.FileUtils;
-import org.apache.pulsar.tests.ExtendedNettyLeakDetector;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-import org.testcontainers.containers.BindMode;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-/**
- * Abstract Test Container for Pulsar.
- */
-@Slf4j
-public abstract class PulsarContainer<SelfT extends PulsarContainer<SelfT>> extends ChaosContainer<SelfT> {
-
-    public static final int INVALID_PORT = -1;
-    public static final int ZK_PORT = 2181;
-    public static final int CS_PORT = 2184;
-    public static final int BOOKIE_PORT = 3181;
-    public static final int BROKER_PORT = 6650;
-    public static final int BROKER_PORT_TLS = 6651;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final int BROKER_HTTPS_PORT = 8081;
-
-    public static final String ALPINE_IMAGE_NAME = "alpine:3.22";
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-    public static final String UPGRADE_TEST_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_UPGRADE_TEST_IMAGE_NAME",
-            DEFAULT_IMAGE_NAME);
-    public static final String LAST_RELEASE_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_LAST_RELEASE_IMAGE_NAME",
-            "apachepulsar/pulsar:3.0.7");
-    public static final String DEFAULT_HTTP_PATH = "/metrics";
-    public static final String PULSAR_2_5_IMAGE_NAME = "apachepulsar/pulsar:2.5.0";
-    public static final String PULSAR_2_4_IMAGE_NAME = "apachepulsar/pulsar:2.4.0";
-    public static final String PULSAR_2_3_IMAGE_NAME = "apachepulsar/pulsar:2.3.0";
-    public static final String PULSAR_2_2_IMAGE_NAME = "apachepulsar/pulsar:2.2.0";
-    public static final String PULSAR_2_1_IMAGE_NAME = "apachepulsar/pulsar:2.1.0";
-    public static final String PULSAR_2_0_IMAGE_NAME = "apachepulsar/pulsar:2.0.0";
-
-    /**
-     * For debugging purposes, it is useful to have the ability to leave containers running.
-     * This mode can be activated by setting environment variables
-     * PULSAR_CONTAINERS_LEAVE_RUNNING=true and TESTCONTAINERS_REUSE_ENABLE=true
-     * After debugging, one can use this command to kill all containers that were left running:
-     * docker kill $(docker ps -q --filter "label=pulsarcontainer=true")
-     */
-    public static final boolean PULSAR_CONTAINERS_LEAVE_RUNNING =
-            Boolean.parseBoolean(System.getenv("PULSAR_CONTAINERS_LEAVE_RUNNING"));
-
-    @Getter
-    protected final String hostname;
-    private final String serviceName;
-    private final String serviceEntryPoint;
-    private final int servicePort;
-    private final int servicePortTls;
-    private final int httpPort;
-    private final int httpsPort;
-    private final String httpPath;
-
-    public PulsarContainer(String clusterName,
-                           String hostname,
-                           String serviceName,
-                           String serviceEntryPoint,
-                           int servicePort,
-                           int httpPort) {
-        this(clusterName, hostname, serviceName, serviceEntryPoint, servicePort, httpPort, "/metrics");
-    }
-
-    public PulsarContainer(String clusterName,
-                           String hostname,
-                           String serviceName,
-                           String serviceEntryPoint,
-                           int servicePort,
-                           int httpPort,
-                           String httpPath) {
-        this(clusterName, hostname, serviceName, serviceEntryPoint, servicePort, httpPort, httpPath,
-                DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(String clusterName,
-                           String hostname,
-                           String serviceName,
-                           String serviceEntryPoint,
-                           int servicePort,
-                           int httpPort,
-                           String httpPath,
-                           String pulsarImageName) {
-        this(clusterName, hostname, serviceName, serviceEntryPoint, servicePort, 0, httpPort, 0, httpPath,
-                pulsarImageName);
-    }
-
-    public PulsarContainer(String clusterName,
-                           String hostname,
-                           String serviceName,
-                           String serviceEntryPoint,
-                           int servicePort,
-                           int servicePortTls,
-                           int httpPort,
-                           int httpsPort,
-                           String httpPath,
-                           String pulsarImageName) {
-        super(clusterName, pulsarImageName);
-        this.hostname = hostname;
-        this.serviceName = serviceName;
-        this.serviceEntryPoint = serviceEntryPoint;
-        this.servicePort = servicePort;
-        this.servicePortTls = servicePortTls;
-        this.httpPort = httpPort;
-        this.httpsPort = httpsPort;
-        this.httpPath = httpPath;
-
-        configureLeaveContainerRunning(this);
-    }
-
-    public static void configureLeaveContainerRunning(
-            GenericContainer<?> container) {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            // use Testcontainers reuse containers feature to leave the container running
-            container.withReuse(true);
-            // add label that can be used to find containers that are left running.
-            container.withLabel("pulsarcontainer", "true");
-            // add a random label to prevent reuse of containers
-            container.withLabel("pulsarcontainer.random", UUID.randomUUID().toString());
-        }
-    }
-
-    @Override
-    protected void beforeStop() {
-        super.beforeStop();
-        if (null != getContainerId()) {
-            DockerUtils.dumpContainerDirToTargetCompressed(
-                getDockerClient(),
-                getContainerId(),
-                "/var/log/pulsar"
-            );
-            try {
-                // stop the "tail -f ..." commands started in afterStart method
-                // so that shutdown output doesn't clutter logs
-                execCmd("/usr/bin/pkill", "tail");
-            } catch (Exception e) {
-                // will fail if there's no tail running
-                log.debug("Cannot run 'pkill tail'", e);
-            }
-        }
-    }
-
-    @Override
-    public void stop() {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            log.warn("Ignoring stop due to PULSAR_CONTAINERS_LEAVE_RUNNING=true.");
-            return;
-        }
-        super.stop();
-    }
-
-    @Override
-    protected void doStop() {
-        if (getContainerId() != null) {
-            if (serviceEntryPoint.equals("bin/pulsar")) {
-                // attempt graceful shutdown using "docker stop"
-                dockerClient.stopContainerCmd(getContainerId())
-                        .withTimeout(15)
-                        .exec();
-            } else {
-                // use "supervisorctl stop all" for graceful shutdown
-                try {
-                    ContainerExecResult result = execCmd("/usr/bin/supervisorctl", "stop", "all");
-                    log.info("Stopped supervisor services exit code: {}\nstdout: {}\nstderr: {}", result.getExitCode(),
-                            result.getStdout(), result.getStderr());
-                } catch (Exception e) {
-                    log.error("Cannot run 'supervisorctl stop all'", e);
-                }
-            }
-        }
-        super.doStop();
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName + "-" + hostname;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        if (httpPort > 0) {
-            addExposedPorts(httpPort);
-        }
-        if (httpsPort > 0) {
-            addExposedPorts(httpsPort);
-        }
-        if (servicePort > 0) {
-            addExposedPort(servicePort);
-        }
-        if (servicePortTls > 0) {
-            addExposedPort(servicePortTls);
-        }
-    }
-
-    protected void beforeStart() {}
-
-    protected void afterStart() {}
-
-    @Override
-    public void start() {
-        if (httpPort > 0 && servicePort < 0) {
-            this.waitStrategy = new HttpWaitStrategy()
-                .forPort(httpPort)
-                .forStatusCode(200)
-                .forPath(httpPath)
-                .withStartupTimeout(Duration.of(300, SECONDS));
-        } else if (httpPort > 0 || servicePort > 0) {
-            this.waitStrategy = new HostPortWaitStrategy()
-                .withStartupTimeout(Duration.of(300, SECONDS));
-        }
-        this.withCreateContainerCmdModifier(createContainerCmd -> {
-            createContainerCmd.withHostName(hostname);
-            createContainerCmd.withName(getContainerName());
-            createContainerCmd.withEntrypoint(serviceEntryPoint);
-        });
-
-        if (isCodeCoverageEnabled()) {
-            configureCodeCoverage();
-        }
-
-        if (isPassNettyLeakDetectionSystemProperties()) {
-            passNettyLeakDetectionSystemProperties();
-        }
-
-        beforeStart();
-        super.start();
-        afterStart();
-        log.info("[{}] Start pulsar service {} at container {}", getContainerName(), serviceName, getContainerId());
-    }
-
-    protected boolean isPassNettyLeakDetectionSystemProperties() {
-        return true;
-    }
-
-    protected void passNettyLeakDetectionSystemProperties() {
-        if (isPassNettyLeakDetectionSystemProperties()) {
-            String envKey = "PULSAR_EXTRA_OPTS";
-            // pass similar defaults as there is in conf/pulsar_env.sh
-            appendToEnv("PULSAR_EXTRA_OPTS",
-                    "-Dpulsar.allocator.exit_on_oom=true -Dio.netty.recycler.maxCapacityPerThread=4096");
-            passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.NETTY_CUSTOM_LEAK_DETECTOR_SYSTEM_PROPERTY_NAME);
-            if (ExtendedNettyLeakDetector.isExtendedNettyLeakDetectorEnabled()) {
-                // enable shutdown hook for extended leak detector in containers
-                passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.USE_SHUTDOWN_HOOK_SYSTEM_PROPERTY_NAME,
-                        "true");
-            }
-            passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.EXIT_JVM_ON_LEAK_SYSTEM_PROPERTY_NAME);
-            passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.EXIT_JVM_DELAY_MILLIS_SYSTEM_PROPERTY_NAME);
-            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.level");
-            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.targetRecords");
-            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.samplingInterval");
-            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.acquireAndReleaseOnly");
-            addEnv("NETTY_LEAK_DUMP_DIR", "/var/log/pulsar");
-        }
-    }
-
-    protected boolean isCodeCoverageEnabled() {
-        return Boolean.getBoolean("integrationtest.coverage.enabled");
-    }
-
-    protected void configureCodeCoverage() {
-        File coverageDirectory;
-        if (System.getProperty("integrationtest.coverage.dir") != null) {
-            coverageDirectory = new File(System.getProperty("integrationtest.coverage.dir"));
-        } else {
-            coverageDirectory = new File("target");
-        }
-
-        if (!coverageDirectory.isDirectory()) {
-            coverageDirectory.mkdirs();
-        }
-        withFileSystemBind(coverageDirectory.getAbsolutePath(), "/jacocoDir", BindMode.READ_WRITE);
-
-        String jacocoVersion = System.getProperty("jacoco.version");
-        File jacocoAgentJar = new File(System.getProperty("user.home"),
-                ".m2/repository/org/jacoco/org.jacoco.agent/" + jacocoVersion + "/" + "org.jacoco.agent-"
-                        + jacocoVersion + "-runtime.jar");
-
-        if (jacocoAgentJar.isFile()) {
-            try {
-                FileUtils.copyFileToDirectory(jacocoAgentJar, coverageDirectory);
-            } catch (IOException e) {
-                throw new UncheckedIOException(e);
-            }
-            appendToEnv("OPTS", "-javaagent:/jacocoDir/" + jacocoAgentJar.getName()
-                    + "=destfile=/jacocoDir/jacoco_" + getContainerName() + "_" + System.currentTimeMillis() + ".exec"
-                    + ",includes=org.apache.pulsar.*:org.apache.bookkeeper.mledger.*"
-                    + ",excludes=*.proto.*:*.shade.*:*.shaded.*");
-        } else {
-            log.error("Cannot find jacoco agent jar from '" + jacocoAgentJar.getAbsolutePath() + "'");
-        }
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (!(o instanceof PulsarContainer)) {
-            return false;
-        }
-
-        PulsarContainer<?> another = (PulsarContainer<?>) o;
-        return getContainerId().equals(another.getContainerId())
-            && super.equals(another);
-    }
-
-    @Override
-    public int hashCode() {
-        return 31 * super.hashCode() + Objects.hash(
-                getContainerId());
-    }
-
-    public String getPlainTextServiceUrl() {
-        return "pulsar://" + getHost() + ":" + getMappedPort(servicePort);
-    }
-
-    public String getServiceUrlTls() {
-        return "pulsar+ssl://" + getHost() + ":" + getMappedPort(servicePortTls);
-    }
-
-    public String getHttpServiceUrl() {
-        return "http://" + getHost() + ":" + getMappedPort(httpPort);
-    }
-
-    public String getHttpsServiceUrl() {
-        return "https://" + getHost() + ":" + getMappedPort(httpsPort);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.time.Duration;
+import java.util.Objects;
+import java.util.UUID;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.io.FileUtils;
+import org.apache.pulsar.tests.ExtendedNettyLeakDetector;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+import org.testcontainers.containers.BindMode;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+/**
+ * Abstract Test Container for Pulsar.
+ */
+@Slf4j
+public abstract class PulsarContainer<SelfT extends PulsarContainer<SelfT>> extends ChaosContainer<SelfT> {
+
+    public static final int INVALID_PORT = -1;
+    public static final int ZK_PORT = 2181;
+    public static final int CS_PORT = 2184;
+    public static final int BOOKIE_PORT = 3181;
+    public static final int BROKER_PORT = 6650;
+    public static final int BROKER_PORT_TLS = 6651;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final int BROKER_HTTPS_PORT = 8081;
+
+    public static final String ALPINE_IMAGE_NAME = "alpine:3.22";
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+    public static final String UPGRADE_TEST_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_UPGRADE_TEST_IMAGE_NAME",
+            DEFAULT_IMAGE_NAME);
+    public static final String LAST_RELEASE_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_LAST_RELEASE_IMAGE_NAME",
+            "apachepulsar/pulsar:3.0.7");
+    public static final String DEFAULT_HTTP_PATH = "/metrics";
+    public static final String PULSAR_2_5_IMAGE_NAME = "apachepulsar/pulsar:2.5.0";
+    public static final String PULSAR_2_4_IMAGE_NAME = "apachepulsar/pulsar:2.4.0";
+    public static final String PULSAR_2_3_IMAGE_NAME = "apachepulsar/pulsar:2.3.0";
+    public static final String PULSAR_2_2_IMAGE_NAME = "apachepulsar/pulsar:2.2.0";
+    public static final String PULSAR_2_1_IMAGE_NAME = "apachepulsar/pulsar:2.1.0";
+    public static final String PULSAR_2_0_IMAGE_NAME = "apachepulsar/pulsar:2.0.0";
+
+    /**
+     * For debugging purposes, it is useful to have the ability to leave containers running.
+     * This mode can be activated by setting environment variables
+     * PULSAR_CONTAINERS_LEAVE_RUNNING=true and TESTCONTAINERS_REUSE_ENABLE=true
+     * After debugging, one can use this command to kill all containers that were left running:
+     * docker kill $(docker ps -q --filter "label=pulsarcontainer=true")
+     */
+    public static final boolean PULSAR_CONTAINERS_LEAVE_RUNNING =
+            Boolean.parseBoolean(System.getenv("PULSAR_CONTAINERS_LEAVE_RUNNING"));
+
+    @Getter
+    protected final String hostname;
+    private final String serviceName;
+    private final String serviceEntryPoint;
+    private final int servicePort;
+    private final int servicePortTls;
+    private final int httpPort;
+    private final int httpsPort;
+    private final String httpPath;
+
+    public PulsarContainer(String clusterName,
+                           String hostname,
+                           String serviceName,
+                           String serviceEntryPoint,
+                           int servicePort,
+                           int httpPort) {
+        this(clusterName, hostname, serviceName, serviceEntryPoint, servicePort, httpPort, "/metrics");
+    }
+
+    public PulsarContainer(String clusterName,
+                           String hostname,
+                           String serviceName,
+                           String serviceEntryPoint,
+                           int servicePort,
+                           int httpPort,
+                           String httpPath) {
+        this(clusterName, hostname, serviceName, serviceEntryPoint, servicePort, httpPort, httpPath,
+                DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(String clusterName,
+                           String hostname,
+                           String serviceName,
+                           String serviceEntryPoint,
+                           int servicePort,
+                           int httpPort,
+                           String httpPath,
+                           String pulsarImageName) {
+        this(clusterName, hostname, serviceName, serviceEntryPoint, servicePort, 0, httpPort, 0, httpPath,
+                pulsarImageName);
+    }
+
+    public PulsarContainer(String clusterName,
+                           String hostname,
+                           String serviceName,
+                           String serviceEntryPoint,
+                           int servicePort,
+                           int servicePortTls,
+                           int httpPort,
+                           int httpsPort,
+                           String httpPath,
+                           String pulsarImageName) {
+        super(clusterName, pulsarImageName);
+        this.hostname = hostname;
+        this.serviceName = serviceName;
+        this.serviceEntryPoint = serviceEntryPoint;
+        this.servicePort = servicePort;
+        this.servicePortTls = servicePortTls;
+        this.httpPort = httpPort;
+        this.httpsPort = httpsPort;
+        this.httpPath = httpPath;
+
+        configureLeaveContainerRunning(this);
+    }
+
+    public static void configureLeaveContainerRunning(
+            GenericContainer<?> container) {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            // use Testcontainers reuse containers feature to leave the container running
+            container.withReuse(true);
+            // add label that can be used to find containers that are left running.
+            container.withLabel("pulsarcontainer", "true");
+            // add a random label to prevent reuse of containers
+            container.withLabel("pulsarcontainer.random", UUID.randomUUID().toString());
+        }
+    }
+
+    @Override
+    protected void beforeStop() {
+        super.beforeStop();
+        if (null != getContainerId()) {
+            DockerUtils.dumpContainerDirToTargetCompressed(
+                getDockerClient(),
+                getContainerId(),
+                "/var/log/pulsar"
+            );
+            try {
+                // stop the "tail -f ..." commands started in afterStart method
+                // so that shutdown output doesn't clutter logs
+                execCmd("/usr/bin/pkill", "tail");
+            } catch (Exception e) {
+                // will fail if there's no tail running
+                log.debug("Cannot run 'pkill tail'", e);
+            }
+        }
+    }
+
+    @Override
+    public void stop() {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            log.warn("Ignoring stop due to PULSAR_CONTAINERS_LEAVE_RUNNING=true.");
+            return;
+        }
+        super.stop();
+    }
+
+    @Override
+    protected void doStop() {
+        if (getContainerId() != null) {
+            if (serviceEntryPoint.equals("bin/pulsar")) {
+                // attempt graceful shutdown using "docker stop"
+                dockerClient.stopContainerCmd(getContainerId())
+                        .withTimeout(15)
+                        .exec();
+            } else {
+                // use "supervisorctl stop all" for graceful shutdown
+                try {
+                    ContainerExecResult result = execCmd("/usr/bin/supervisorctl", "stop", "all");
+                    log.info("Stopped supervisor services exit code: {}\nstdout: {}\nstderr: {}", result.getExitCode(),
+                            result.getStdout(), result.getStderr());
+                } catch (Exception e) {
+                    log.error("Cannot run 'supervisorctl stop all'", e);
+                }
+            }
+        }
+        super.doStop();
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName + "-" + hostname;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        if (httpPort > 0) {
+            addExposedPorts(httpPort);
+        }
+        if (httpsPort > 0) {
+            addExposedPorts(httpsPort);
+        }
+        if (servicePort > 0) {
+            addExposedPort(servicePort);
+        }
+        if (servicePortTls > 0) {
+            addExposedPort(servicePortTls);
+        }
+    }
+
+    protected void beforeStart() {}
+
+    protected void afterStart() {}
+
+    @Override
+    public void start() {
+        if (httpPort > 0 && servicePort < 0) {
+            this.waitStrategy = new HttpWaitStrategy()
+                .forPort(httpPort)
+                .forStatusCode(200)
+                .forPath(httpPath)
+                .withStartupTimeout(Duration.of(300, SECONDS));
+        } else if (httpPort > 0 || servicePort > 0) {
+            this.waitStrategy = new HostPortWaitStrategy()
+                .withStartupTimeout(Duration.of(300, SECONDS));
+        }
+        this.withCreateContainerCmdModifier(createContainerCmd -> {
+            createContainerCmd.withHostName(hostname);
+            createContainerCmd.withName(getContainerName());
+            createContainerCmd.withEntrypoint(serviceEntryPoint);
+        });
+
+        if (isCodeCoverageEnabled()) {
+            configureCodeCoverage();
+        }
+
+        if (isPassNettyLeakDetectionSystemProperties()) {
+            passNettyLeakDetectionSystemProperties();
+        }
+
+        beforeStart();
+        super.start();
+        afterStart();
+        log.info("[{}] Start pulsar service {} at container {}", getContainerName(), serviceName, getContainerId());
+    }
+
+    protected boolean isPassNettyLeakDetectionSystemProperties() {
+        return true;
+    }
+
+    protected void passNettyLeakDetectionSystemProperties() {
+        if (isPassNettyLeakDetectionSystemProperties()) {
+            String envKey = "PULSAR_EXTRA_OPTS";
+            // pass similar defaults as there is in conf/pulsar_env.sh
+            appendToEnv("PULSAR_EXTRA_OPTS",
+                    "-Dpulsar.allocator.exit_on_oom=true -Dio.netty.recycler.maxCapacityPerThread=4096");
+            passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.NETTY_CUSTOM_LEAK_DETECTOR_SYSTEM_PROPERTY_NAME);
+            if (ExtendedNettyLeakDetector.isExtendedNettyLeakDetectorEnabled()) {
+                // enable shutdown hook for extended leak detector in containers
+                passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.USE_SHUTDOWN_HOOK_SYSTEM_PROPERTY_NAME,
+                        "true");
+            }
+            passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.EXIT_JVM_ON_LEAK_SYSTEM_PROPERTY_NAME);
+            passSystemPropertyInEnv(envKey, ExtendedNettyLeakDetector.EXIT_JVM_DELAY_MILLIS_SYSTEM_PROPERTY_NAME);
+            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.level");
+            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.targetRecords");
+            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.samplingInterval");
+            passSystemPropertyInEnv(envKey, "io.netty.leakDetection.acquireAndReleaseOnly");
+            addEnv("NETTY_LEAK_DUMP_DIR", "/var/log/pulsar");
+        }
+    }
+
+    protected boolean isCodeCoverageEnabled() {
+        return Boolean.getBoolean("integrationtest.coverage.enabled");
+    }
+
+    protected void configureCodeCoverage() {
+        File coverageDirectory;
+        if (System.getProperty("integrationtest.coverage.dir") != null) {
+            coverageDirectory = new File(System.getProperty("integrationtest.coverage.dir"));
+        } else {
+            coverageDirectory = new File("target");
+        }
+
+        if (!coverageDirectory.isDirectory()) {
+            coverageDirectory.mkdirs();
+        }
+        withFileSystemBind(coverageDirectory.getAbsolutePath(), "/jacocoDir", BindMode.READ_WRITE);
+
+        String jacocoVersion = System.getProperty("jacoco.version");
+        File jacocoAgentJar = new File(System.getProperty("user.home"),
+                ".m2/repository/org/jacoco/org.jacoco.agent/" + jacocoVersion + "/" + "org.jacoco.agent-"
+                        + jacocoVersion + "-runtime.jar");
+
+        if (jacocoAgentJar.isFile()) {
+            try {
+                FileUtils.copyFileToDirectory(jacocoAgentJar, coverageDirectory);
+            } catch (IOException e) {
+                throw new UncheckedIOException(e);
+            }
+            appendToEnv("OPTS", "-javaagent:/jacocoDir/" + jacocoAgentJar.getName()
+                    + "=destfile=/jacocoDir/jacoco_" + getContainerName() + "_" + System.currentTimeMillis() + ".exec"
+                    + ",includes=org.apache.pulsar.*:org.apache.bookkeeper.mledger.*"
+                    + ",excludes=*.proto.*:*.shade.*:*.shaded.*");
+        } else {
+            log.error("Cannot find jacoco agent jar from '" + jacocoAgentJar.getAbsolutePath() + "'");
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof PulsarContainer)) {
+            return false;
+        }
+
+        PulsarContainer<?> another = (PulsarContainer<?>) o;
+        return getContainerId().equals(another.getContainerId())
+            && super.equals(another);
+    }
+
+    @Override
+    public int hashCode() {
+        return 31 * super.hashCode() + Objects.hash(
+                getContainerId());
+    }
+
+    public String getPlainTextServiceUrl() {
+        return "pulsar://" + getHost() + ":" + getMappedPort(servicePort);
+    }
+
+    public String getServiceUrlTls() {
+        return "pulsar+ssl://" + getHost() + ":" + getMappedPort(servicePortTls);
+    }
+
+    public String getHttpServiceUrl() {
+        return "http://" + getHost() + ":" + getMappedPort(httpPort);
+    }
+
+    public String getHttpsServiceUrl() {
+        return "https://" + getHost() + ":" + getMappedPort(httpsPort);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarInitMetadataContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarInitMetadataContainer.java
index 68757d9fec..9edd4ee45d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarInitMetadataContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/PulsarInitMetadataContainer.java
@@ -1,76 +1,76 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.apache.pulsar.tests.integration.containers;
-
-import java.io.IOException;
-import lombok.extern.slf4j.Slf4j;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.Network;
-
-/**
- * Initialize the Pulsar metadata.
- */
-@Slf4j
-public class PulsarInitMetadataContainer extends GenericContainer<PulsarInitMetadataContainer> {
-
-    public static final String NAME = "init-metadata";
-
-    private final String clusterName;
-    private final String metadataStoreUrl;
-    private final String configurationMetadataStoreUrl;
-    private final String brokerHostname;
-
-    public PulsarInitMetadataContainer(Network network,
-                                       String clusterName,
-                                       String metadataStoreUrl,
-                                       String configurationMetadataStoreUrl,
-                                       String brokerHostname) {
-        this.clusterName = clusterName;
-        this.metadataStoreUrl = metadataStoreUrl;
-        this.configurationMetadataStoreUrl = configurationMetadataStoreUrl;
-        this.brokerHostname = brokerHostname;
-        setDockerImageName(PulsarContainer.DEFAULT_IMAGE_NAME);
-        withNetwork(network);
-
-        setCommand("sleep 1000000");
-    }
-
-
-    public void initialize() throws Exception {
-        start();
-        ExecResult res = this.execInContainer(
-                "/pulsar/bin/pulsar", "initialize-cluster-metadata",
-                "--cluster", clusterName,
-                "--metadata-store", metadataStoreUrl,
-                "--configuration-metadata-store", configurationMetadataStoreUrl,
-                "--web-service-url", "http://" + brokerHostname + ":8080/",
-                "--broker-service-url", "pulsar://" + brokerHostname + ":6650/"
-        );
-
-        if (res.getExitCode() == 0) {
-            log.info("Successfully initialized cluster");
-        } else {
-            log.warn("Failed to initialize Pulsar cluster. exit code: " + res.getExitCode());
-            log.warn("STDOUT: " + res.getStdout());
-            log.warn("STDERR: " + res.getStderr());
-            throw new IOException("Failed to initialized Pulsar Cluster");
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.pulsar.tests.integration.containers;
+
+import java.io.IOException;
+import lombok.extern.slf4j.Slf4j;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.Network;
+
+/**
+ * Initialize the Pulsar metadata.
+ */
+@Slf4j
+public class PulsarInitMetadataContainer extends GenericContainer<PulsarInitMetadataContainer> {
+
+    public static final String NAME = "init-metadata";
+
+    private final String clusterName;
+    private final String metadataStoreUrl;
+    private final String configurationMetadataStoreUrl;
+    private final String brokerHostname;
+
+    public PulsarInitMetadataContainer(Network network,
+                                       String clusterName,
+                                       String metadataStoreUrl,
+                                       String configurationMetadataStoreUrl,
+                                       String brokerHostname) {
+        this.clusterName = clusterName;
+        this.metadataStoreUrl = metadataStoreUrl;
+        this.configurationMetadataStoreUrl = configurationMetadataStoreUrl;
+        this.brokerHostname = brokerHostname;
+        setDockerImageName(PulsarContainer.DEFAULT_IMAGE_NAME);
+        withNetwork(network);
+
+        setCommand("sleep 1000000");
+    }
+
+
+    public void initialize() throws Exception {
+        start();
+        ExecResult res = this.execInContainer(
+                "/pulsar/bin/pulsar", "initialize-cluster-metadata",
+                "--cluster", clusterName,
+                "--metadata-store", metadataStoreUrl,
+                "--configuration-metadata-store", configurationMetadataStoreUrl,
+                "--web-service-url", "http://" + brokerHostname + ":8080/",
+                "--broker-service-url", "pulsar://" + brokerHostname + ":6650/"
+        );
+
+        if (res.getExitCode() == 0) {
+            log.info("Successfully initialized cluster");
+        } else {
+            log.warn("Failed to initialize Pulsar cluster. exit code: " + res.getExitCode());
+            log.warn("STDOUT: " + res.getStdout());
+            log.warn("STDERR: " + res.getStderr());
+            throw new IOException("Failed to initialized Pulsar Cluster");
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/RabbitMQContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/RabbitMQContainer.java
index fbec62b324..7043685a6b 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/RabbitMQContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/RabbitMQContainer.java
@@ -1,46 +1,46 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
-
-public class RabbitMQContainer extends ChaosContainer<RabbitMQContainer> {
-    public static final String NAME = "RabbitMQ";
-    public static final Integer[] PORTS = { 5672 };
-    private static final String IMAGE_NAME = "rabbitmq:3.8-management";
-
-    private String networkAlias;
-
-    public RabbitMQContainer(String clusterName, String networkAlias) {
-        super(clusterName, IMAGE_NAME);
-        this.networkAlias = networkAlias;
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        this.withNetworkAliases(networkAlias)
-                .withExposedPorts(PORTS)
-                .withCreateContainerCmdModifier(createContainerCmd -> {
-                    createContainerCmd.withHostName(NAME);
-                    createContainerCmd.withName(clusterName + "-" + NAME);
-                })
-                .waitingFor(new HostPortWaitStrategy());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+public class RabbitMQContainer extends ChaosContainer<RabbitMQContainer> {
+    public static final String NAME = "RabbitMQ";
+    public static final Integer[] PORTS = { 5672 };
+    private static final String IMAGE_NAME = "rabbitmq:3.8-management";
+
+    private String networkAlias;
+
+    public RabbitMQContainer(String clusterName, String networkAlias) {
+        super(clusterName, IMAGE_NAME);
+        this.networkAlias = networkAlias;
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(networkAlias)
+                .withExposedPorts(PORTS)
+                .withCreateContainerCmdModifier(createContainerCmd -> {
+                    createContainerCmd.withHostName(NAME);
+                    createContainerCmd.withName(clusterName + "-" + NAME);
+                })
+                .waitingFor(new HostPortWaitStrategy());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/S3Container.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/S3Container.java
index 5ffa5ea65e..1f3de877d9 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/S3Container.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/S3Container.java
@@ -1,54 +1,54 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import lombok.extern.slf4j.Slf4j;
-
-/**
- * S3 simulation container.
- */
-@Slf4j
-public class S3Container extends ChaosContainer<S3Container> {
-
-    public static final String NAME = "s3";
-    private static final String IMAGE_NAME = "apachepulsar/s3mock:latest";
-    private final String hostname;
-
-    public S3Container(String clusterName, String hostname) {
-        super(clusterName, IMAGE_NAME);
-        this.hostname = hostname;
-        this.withEnv("initialBuckets", "pulsar-integtest");
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName + "-" + hostname;
-    }
-
-    @Override
-    public void start() {
-        this.withCreateContainerCmdModifier(createContainerCmd -> {
-            createContainerCmd.withHostName(hostname);
-            createContainerCmd.withName(getContainerName());
-        });
-
-        super.start();
-        log.info("Start s3 service");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import lombok.extern.slf4j.Slf4j;
+
+/**
+ * S3 simulation container.
+ */
+@Slf4j
+public class S3Container extends ChaosContainer<S3Container> {
+
+    public static final String NAME = "s3";
+    private static final String IMAGE_NAME = "apachepulsar/s3mock:latest";
+    private final String hostname;
+
+    public S3Container(String clusterName, String hostname) {
+        super(clusterName, IMAGE_NAME);
+        this.hostname = hostname;
+        this.withEnv("initialBuckets", "pulsar-integtest");
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName + "-" + hostname;
+    }
+
+    @Override
+    public void start() {
+        this.withCreateContainerCmdModifier(createContainerCmd -> {
+            createContainerCmd.withHostName(hostname);
+            createContainerCmd.withName(getContainerName());
+        });
+
+        super.start();
+        log.info("Start s3 service");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ScyllaDBContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ScyllaDBContainer.java
new file mode 100644
index 0000000000..1e7824bfeb
--- /dev/null
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ScyllaDBContainer.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import lombok.extern.slf4j.Slf4j;
+import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
+
+/**
+ * ScyllaDB Container.
+ *
+ * ScyllaDB is a drop-in replacement for Apache Cassandra that uses the same
+ * CQL protocol and is compatible with Cassandra drivers. This container
+ * demonstrates ScyllaDB's compatibility by reusing the existing Cassandra
+ * sink connector without any modifications.
+ */
+@Slf4j
+public class ScyllaDBContainer<SelfT extends ChaosContainer<SelfT>> extends ChaosContainer<SelfT> {
+
+    public static final String NAME = "scylladb";
+    public static final int PORT = 9042;
+
+    public ScyllaDBContainer(String clusterName) {
+        super(clusterName, "scylladb/scylla:2025.1.4");
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        this.withNetworkAliases(NAME)
+            .withExposedPorts(PORT)
+            .withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(NAME);
+                createContainerCmd.withName(clusterName + "-" + NAME);
+            })
+            .withCommand(
+                "--smp", "1",                    // Single CPU core for container efficiency
+                "--memory", "1G",                // Memory limit
+                "--overprovisioned", "1",        // Container mode flag
+                "--api-address", "0.0.0.0"       // Enable API access
+                // Note: --reactor-backend=epoll is needed for macOS multi-node clusters
+                // but single-node containers work without it
+            )
+            .waitingFor(new HostPortWaitStrategy());
+    }
+
+    public int getScyllaDBPort() {
+        return getMappedPort(PORT);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/StandaloneContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/StandaloneContainer.java
index 7e0b347640..bdb7567c64 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/StandaloneContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/StandaloneContainer.java
@@ -1,68 +1,68 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-/**
- * A pulsar container that runs standalone.
- */
-public class StandaloneContainer extends PulsarContainer<StandaloneContainer> {
-
-    public static final String NAME = "standalone";
-
-    public StandaloneContainer(String clusterName) {
-        super(clusterName,
-            NAME,
-            NAME + "-cluster",
-            "bin/pulsar",
-            BROKER_PORT,
-            BROKER_HTTP_PORT);
-    }
-
-    public StandaloneContainer(String clusterName, String pulsarImageName) {
-        super(clusterName,
-                NAME,
-                NAME + "-cluster",
-                "bin/pulsar",
-                BROKER_PORT,
-                BROKER_HTTP_PORT,
-                "",
-                pulsarImageName);
-    }
-
-    @Override
-    protected void configure() {
-        super.configure();
-        setCommand("standalone");
-        addEnv("PULSAR_MEM", "-Xms128M -Xmx1g -XX:MaxDirectMemorySize=1g");
-    }
-
-    @Override
-    protected void beforeStart() {
-        // update the wait strategy until public/default namespace is created
-        this.waitStrategy = new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+/**
+ * A pulsar container that runs standalone.
+ */
+public class StandaloneContainer extends PulsarContainer<StandaloneContainer> {
+
+    public static final String NAME = "standalone";
+
+    public StandaloneContainer(String clusterName) {
+        super(clusterName,
+            NAME,
+            NAME + "-cluster",
+            "bin/pulsar",
+            BROKER_PORT,
+            BROKER_HTTP_PORT);
+    }
+
+    public StandaloneContainer(String clusterName, String pulsarImageName) {
+        super(clusterName,
+                NAME,
+                NAME + "-cluster",
+                "bin/pulsar",
+                BROKER_PORT,
+                BROKER_HTTP_PORT,
+                "",
+                pulsarImageName);
+    }
+
+    @Override
+    protected void configure() {
+        super.configure();
+        setCommand("standalone");
+        addEnv("PULSAR_MEM", "-Xms128M -Xmx1g -XX:MaxDirectMemorySize=1g");
+    }
+
+    @Override
+    protected void beforeStart() {
+        // update the wait strategy until public/default namespace is created
+        this.waitStrategy = new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS));
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WebSocketContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WebSocketContainer.java
index aa87c045f1..b83e6e3198 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WebSocketContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WebSocketContainer.java
@@ -1,41 +1,41 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-
-public class WebSocketContainer extends PulsarContainer<WebSocketContainer> {
-
-    public WebSocketContainer(String clusterName, String hostName) {
-        super(clusterName, hostName, hostName,
-                "bin/run-websocket.sh",
-                -1,
-                BROKER_HTTP_PORT, "/admin/v2/proxy-stats/stats");
-    }
-
-    public String getWSUrl() {
-        return "ws://" + getHost() + ":" + getMappedPort(BROKER_HTTP_PORT);
-    }
-
-    @Override
-    protected void afterStart() {
-        DockerUtils.runCommandAsyncWithLogging(this.dockerClient, this.getContainerId(),
-                "tail", "-f", "/var/log/pulsar/pulsar-websocket.log");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+
+public class WebSocketContainer extends PulsarContainer<WebSocketContainer> {
+
+    public WebSocketContainer(String clusterName, String hostName) {
+        super(clusterName, hostName, hostName,
+                "bin/run-websocket.sh",
+                -1,
+                BROKER_HTTP_PORT, "/admin/v2/proxy-stats/stats");
+    }
+
+    public String getWSUrl() {
+        return "ws://" + getHost() + ":" + getMappedPort(BROKER_HTTP_PORT);
+    }
+
+    @Override
+    protected void afterStart() {
+        DockerUtils.runCommandAsyncWithLogging(this.dockerClient, this.getContainerId(),
+                "tail", "-f", "/var/log/pulsar/pulsar-websocket.log");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WorkerContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WorkerContainer.java
index 9233b8f3f3..5f127f3ed6 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WorkerContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/WorkerContainer.java
@@ -1,52 +1,52 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-import org.apache.pulsar.tests.integration.utils.DockerUtils;
-
-/**
- * A pulsar container that runs functions worker.
- */
-public class WorkerContainer extends PulsarContainer<WorkerContainer> {
-
-    public static final String NAME = "pulsar-worker";
-
-    public WorkerContainer(String clusterName, String hostname) {
-        super(
-            clusterName,
-            hostname,
-            hostname,
-            "bin/run-functions-worker.sh",
-            -1,
-            BROKER_HTTP_PORT,
-            "/admin/v2/worker/cluster");
-    }
-
-    @Override
-    protected void beforeStop() {
-        super.beforeStop();
-        if (null != getContainerId()) {
-            DockerUtils.dumpContainerDirToTargetCompressed(
-                    getDockerClient(),
-                    getContainerId(),
-                    "/pulsar/logs/functions"
-            );
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+
+/**
+ * A pulsar container that runs functions worker.
+ */
+public class WorkerContainer extends PulsarContainer<WorkerContainer> {
+
+    public static final String NAME = "pulsar-worker";
+
+    public WorkerContainer(String clusterName, String hostname) {
+        super(
+            clusterName,
+            hostname,
+            hostname,
+            "bin/run-functions-worker.sh",
+            -1,
+            BROKER_HTTP_PORT,
+            "/admin/v2/worker/cluster");
+    }
+
+    @Override
+    protected void beforeStop() {
+        super.beforeStop();
+        if (null != getContainerId()) {
+            DockerUtils.dumpContainerDirToTargetCompressed(
+                    getDockerClient(),
+                    getContainerId(),
+                    "/pulsar/logs/functions"
+            );
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ZKContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ZKContainer.java
index 2a37247512..7d8a235f7d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ZKContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/ZKContainer.java
@@ -1,48 +1,48 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.containers;
-
-/**
- * A pulsar container that runs zookeeper.
- */
-public class ZKContainer extends PulsarContainer<ZKContainer> {
-
-    public static final String NAME = "zookeeper";
-
-    public ZKContainer(String clusterName) {
-        super(
-            clusterName,
-            NAME,
-            NAME,
-            "bin/run-local-zk.sh",
-            ZK_PORT,
-            INVALID_PORT);
-    }
-
-    @Override
-    protected boolean isCodeCoverageEnabled() {
-        return false;
-    }
-
-
-    @Override
-    protected boolean isPassNettyLeakDetectionSystemProperties() {
-        return false;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.containers;
+
+/**
+ * A pulsar container that runs zookeeper.
+ */
+public class ZKContainer extends PulsarContainer<ZKContainer> {
+
+    public static final String NAME = "zookeeper";
+
+    public ZKContainer(String clusterName) {
+        super(
+            clusterName,
+            NAME,
+            NAME,
+            "bin/run-local-zk.sh",
+            ZK_PORT,
+            INVALID_PORT);
+    }
+
+    @Override
+    protected boolean isCodeCoverageEnabled() {
+        return false;
+    }
+
+
+    @Override
+    protected boolean isPassNettyLeakDetectionSystemProperties() {
+        return false;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/package-info.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/package-info.java
index c0b2978614..c724d833a8 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/package-info.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/containers/package-info.java
@@ -1,22 +1,22 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-/**
- * Test containers used for running integration tests.
- */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Test containers used for running integration tests.
+ */
 package org.apache.pulsar.tests.integration.containers;
\ No newline at end of file
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecException.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecException.java
index ce724a3b27..de03badce1 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecException.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecException.java
@@ -1,32 +1,32 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.docker;
-
-public class ContainerExecException extends Exception {
-    private final ContainerExecResult result;
-
-    public ContainerExecException(String cmd, String containerId, ContainerExecResult result) {
-        super(String.format("%s failed on %s with error code %d", cmd, containerId, result.getExitCode()));
-        this.result = result;
-    }
-
-    public ContainerExecResult getResult() {
-        return result;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.docker;
+
+public class ContainerExecException extends Exception {
+    private final ContainerExecResult result;
+
+    public ContainerExecException(String cmd, String containerId, ContainerExecResult result) {
+        super(String.format("%s failed on %s with error code %d", cmd, containerId, result.getExitCode()));
+        this.result = result;
+    }
+
+    public ContainerExecResult getResult() {
+        return result;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResult.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResult.java
index 1df417863b..7e5f3c09a6 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResult.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResult.java
@@ -1,48 +1,48 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.docker;
-
-import static org.testng.Assert.assertTrue;
-import lombok.Data;
-
-/**
- * Represents the result of executing a command.
- */
-@Data(staticConstructor = "of")
-public class ContainerExecResult {
-
-    private final long exitCode;
-    private final String stdout;
-    private final String stderr;
-
-    public void assertNoOutput() {
-        assertNoStdout();
-        assertNoStderr();
-    }
-
-    public void assertNoStdout() {
-        assertTrue(stdout.isEmpty(),
-                "stdout should be empty, but was '" + stdout + "'");
-    }
-
-    public void assertNoStderr() {
-        assertTrue(stderr.isEmpty(),
-                "stderr should be empty, but was '" + stderr + "'");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.docker;
+
+import static org.testng.Assert.assertTrue;
+import lombok.Data;
+
+/**
+ * Represents the result of executing a command.
+ */
+@Data(staticConstructor = "of")
+public class ContainerExecResult {
+
+    private final long exitCode;
+    private final String stdout;
+    private final String stderr;
+
+    public void assertNoOutput() {
+        assertNoStdout();
+        assertNoStderr();
+    }
+
+    public void assertNoStdout() {
+        assertTrue(stdout.isEmpty(),
+                "stdout should be empty, but was '" + stdout + "'");
+    }
+
+    public void assertNoStderr() {
+        assertTrue(stderr.isEmpty(),
+                "stderr should be empty, but was '" + stderr + "'");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResultBytes.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResultBytes.java
index 285fba1e28..d2a99d0d7f 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResultBytes.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/docker/ContainerExecResultBytes.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.docker;
-
-import lombok.Data;
-
-/**
- * Represents the result of executing a command.
- */
-@Data(staticConstructor = "of")
-public class ContainerExecResultBytes {
-
-    private final long exitCode;
-    private final byte[] stdout;
-    private final byte[] stderr;
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.docker;
+
+import lombok.Data;
+
+/**
+ * Represents the result of executing a command.
+ */
+@Data(staticConstructor = "of")
+public class ContainerExecResultBytes {
+
+    private final long exitCode;
+    private final byte[] stdout;
+    private final byte[] stderr;
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarBKStateStoreTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarBKStateStoreTest.java
index 482dddb46d..e96a0003ac 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarBKStateStoreTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarBKStateStoreTest.java
@@ -1,27 +1,27 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import org.apache.pulsar.functions.instance.state.BKStateStoreProviderImpl;
-
-public class PulsarBKStateStoreTest extends PulsarStateTest {
-    protected PulsarBKStateStoreTest() {
-        super(BKStateStoreProviderImpl.class.getName());
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import org.apache.pulsar.functions.instance.state.BKStateStoreProviderImpl;
+
+public class PulsarBKStateStoreTest extends PulsarStateTest {
+    protected PulsarBKStateStoreTest() {
+        super(BKStateStoreProviderImpl.class.getName());
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTest.java
index fdda3144e8..5f85f713a2 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTest.java
@@ -1,2311 +1,2311 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import com.fasterxml.jackson.databind.JsonNode;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.node.ObjectNode;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.stream.Collectors;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.BatcherBuilder;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Reader;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.client.impl.PulsarClientImpl;
-import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;
-import org.apache.pulsar.common.functions.BatchingConfig;
-import org.apache.pulsar.common.functions.ConsumerConfig;
-import org.apache.pulsar.common.functions.FunctionConfig;
-import org.apache.pulsar.common.functions.MessagePayloadProcessorConfig;
-import org.apache.pulsar.common.functions.ProducerConfig;
-import org.apache.pulsar.common.policies.data.FunctionStatsImpl;
-import org.apache.pulsar.common.policies.data.FunctionStatus;
-import org.apache.pulsar.common.policies.data.FunctionStatusUtil;
-import org.apache.pulsar.common.policies.data.SchemaCompatibilityStrategy;
-import org.apache.pulsar.common.policies.data.SubscriptionStats;
-import org.apache.pulsar.common.policies.data.TopicStats;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.common.schema.SchemaInfo;
-import org.apache.pulsar.common.schema.SchemaType;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.functions.api.examples.AutoSchemaFunction;
-import org.apache.pulsar.functions.api.examples.AvroSchemaTestFunction;
-import org.apache.pulsar.functions.api.examples.InitializableFunction;
-import org.apache.pulsar.functions.api.examples.MergeTopicFunction;
-import org.apache.pulsar.functions.api.examples.RecordFunction;
-import org.apache.pulsar.functions.api.examples.pojo.AvroTestObject;
-import org.apache.pulsar.functions.api.examples.pojo.Users;
-import org.apache.pulsar.functions.api.examples.serde.CustomObject;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.assertj.core.api.Assertions;
-import org.awaitility.Awaitility;
-
-/**
- * A test base for testing functions.
- */
-@Slf4j
-public abstract class PulsarFunctionsTest extends PulsarFunctionsTestBase {
-
-    private final ObjectMapper objectMapper = new ObjectMapper();
-
-    public PulsarFunctionsTest(FunctionRuntimeType functionRuntimeType) {
-        super(functionRuntimeType);
-    }
-
-    protected Map<String, String> produceMessagesToInputTopic(String inputTopicName,
-                                                              int numMessages) throws Exception {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopicName)
-                .create();
-
-        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
-        for (int i = 0; i < numMessages; i++) {
-            String key = "key-" + i;
-            String value = "value-" + i;
-            kvs.put(key, value);
-            producer.newMessage()
-                    .key(key)
-                    .value(value)
-                    .send();
-        }
-        return kvs;
-    }
-
-    protected void testFunctionLocalRun(Runtime runtime) throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
-            return;
-        }
-
-
-        String inputTopicName =
-                "persistent://public/default/test-function-local-run-" + runtime + "-input-" + randomName(8);
-        String outputTopicName = "test-function-local-run-" + runtime + "-output-" + randomName(8);
-
-        final int numMessages = 10;
-        String cmd = "";
-        CommandGenerator commandGenerator = new CommandGenerator();
-        commandGenerator.setAdminUrl("pulsar://pulsar-broker-0:6650");
-        commandGenerator.setSourceTopic(inputTopicName);
-        commandGenerator.setSinkTopic(outputTopicName);
-        commandGenerator.setFunctionName("localRunTest-" + randomName(8));
-        commandGenerator.setRuntime(runtime);
-        switch (runtime) {
-            case JAVA:
-                commandGenerator.setFunctionClassName(EXCLAMATION_JAVA_CLASS);
-                cmd = commandGenerator.generateLocalRunCommand(null);
-                break;
-            case PYTHON:
-                commandGenerator.setFunctionClassName(EXCLAMATION_PYTHON_CLASS);
-                cmd = commandGenerator.generateLocalRunCommand(EXCLAMATION_PYTHON_FILE);
-                break;
-            case GO:
-                commandGenerator.setFunctionClassName(null);
-                cmd = commandGenerator.generateLocalRunCommand(EXCLAMATION_GO_FILE);
-                break;
-        }
-
-        log.info("cmd: {}", cmd);
-        pulsarCluster.getAnyWorker().execCmdAsync(cmd.split(" "));
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-            retryStrategically((test) -> {
-                try {
-                    return admin.topics().getStats(inputTopicName).getSubscriptions().size() == 1;
-                } catch (PulsarAdminException e) {
-                    return false;
-                }
-            }, 30, 200);
-
-            assertEquals(admin.topics().getStats(inputTopicName).getSubscriptions().size(), 1);
-
-            // publish and consume result
-            if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-                // java and python supports schema
-                @Cleanup PulsarClient client = PulsarClient.builder()
-                        .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                        .build();
-
-                @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                        .topic(outputTopicName)
-                        .subscriptionType(SubscriptionType.Exclusive)
-                        .subscriptionName("test-sub")
-                        .subscribe();
-
-                @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
-                        .topic(inputTopicName)
-                        .create();
-
-                for (int i = 0; i < numMessages; i++) {
-                    producer.send("message-" + i);
-                }
-
-                Set<String> expectedMessages = new HashSet<>();
-                for (int i = 0; i < numMessages; i++) {
-                    expectedMessages.add("message-" + i + "!");
-                }
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<String> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
-                    log.info("Received: {}", msg.getValue());
-                    assertTrue(expectedMessages.contains(msg.getValue()));
-                    expectedMessages.remove(msg.getValue());
-                }
-                assertEquals(expectedMessages.size(), 0);
-
-            } else {
-                // golang doesn't support schema
-
-                @Cleanup PulsarClient client = PulsarClient.builder()
-                        .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                        .build();
-                @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
-                        .topic(outputTopicName)
-                        .subscriptionType(SubscriptionType.Exclusive)
-                        .subscriptionName("test-sub")
-                        .subscribe();
-
-                @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
-                        .topic(inputTopicName)
-                        .enableBatching(true)
-                        .batcherBuilder(BatcherBuilder.DEFAULT)
-                        .create();
-
-                for (int i = 0; i < numMessages; i++) {
-                    producer.newMessage().value(("message-" + i).getBytes(UTF_8)).send();
-                }
-
-                Set<String> expectedMessages = new HashSet<>();
-                for (int i = 0; i < numMessages; i++) {
-                    expectedMessages.add("message-" + i + "!");
-                }
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<byte[]> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
-                    String msgValue = new String(msg.getValue(), UTF_8);
-                    log.info("Received: {}", msgValue);
-                    assertTrue(expectedMessages.contains(msgValue));
-                    expectedMessages.remove(msgValue);
-                }
-                assertEquals(expectedMessages.size(), 0);
-            }
-        }
-
-    }
-
-    protected void testWindowFunction(String type, String[] expectedResults) throws Exception {
-        int numOfMessages = 100;
-        int windowLengthCount = 10;
-        int slidingIntervalCount = 5;
-        String functionName = "test-" + type + "-window-fn-" + randomName(8);
-
-        String inputTopicName = "test-" + type + "-count-window-" + functionRuntimeType + "-input-" + randomName(8);
-        String outputTopicName = "test-" + type + "-count-window-" + functionRuntimeType + "-output-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-
-        CommandGenerator generator = CommandGenerator.createDefaultGenerator(
-                inputTopicName,
-                "org.apache.pulsar.functions.api.examples.WindowDurationFunction");
-        generator.setFunctionName(functionName);
-        generator.setSinkTopic(outputTopicName);
-        generator.setWindowLengthCount(windowLengthCount);
-        if (type.equals("sliding")) {
-            generator.setSlidingIntervalCount(slidingIntervalCount);
-        }
-
-
-        String[] commands = {
-                "sh", "-c", generator.generateCreateFunctionCommand()
-        };
-
-        ContainerExecResult containerExecResult = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(containerExecResult.getStdout().contains("Created successfully"));
-
-        // get function info
-        getFunctionInfoSuccess(functionName);
-
-        containerExecResult = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        FunctionStatus functionStatus = FunctionStatusUtil.decode(containerExecResult.getStdout());
-        assertEquals(functionStatus.getNumInstances(), 1);
-        assertEquals(functionStatus.getNumRunning(), 1);
-        assertEquals(functionStatus.getInstances().size(), 1);
-        assertEquals(functionStatus.getInstances().get(0).getInstanceId(), 0);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumReceived(), 0);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumSuccessfullyProcessed(), 0);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestUserExceptions().size(), 0);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        Reader<byte[]> reader = client.newReader().startMessageId(MessageId.earliest)
-                .topic(outputTopicName)
-                .create();
-
-        @Cleanup
-        Producer<byte[]> producer = client.newProducer(Schema.BYTES)
-                .topic(inputTopicName)
-                .enableBatching(false)
-                .create();
-
-        // send 3 messages first, and it won't trigger the window and so these 3 messages will not be acked
-        for (int i = 0; i < 3; i++) {
-            producer.send(String.format("%d", i).getBytes());
-        }
-        TopicStats stats = pulsarAdmin.topics().getStats(inputTopicName, true);
-        SubscriptionStats subStats = stats.getSubscriptions().get("public/default/" + functionName);
-        assertNotNull(subStats);
-        assertEquals(3, subStats.getMsgBacklog());
-        assertEquals(3, subStats.getUnackedMessages());
-
-        for (int i = 3; i < numOfMessages; i++) {
-            producer.send(String.format("%d", i).getBytes());
-        }
-
-        int i = 0;
-        while (true) {
-            if (i > expectedResults.length) {
-                Assertions.fail("More results than expected");
-            }
-
-            Message<byte[]> msg = reader.readNext(30, TimeUnit.SECONDS);
-            if (msg == null) {
-                break;
-            }
-            String msgStr = new String(msg.getData());
-            log.info("[testWindowFunction] i: {} RECV: {}", i, msgStr);
-            String result = msgStr.split(":")[0];
-            assertThat(result).contains(expectedResults[i]);
-            i++;
-        }
-
-        getFunctionStatus(functionName, numOfMessages, true);
-
-        // in case last commit is not updated
-        assertThat(i).isGreaterThanOrEqualTo(expectedResults.length - 1);
-
-        // test that all messages are acked
-        stats = pulsarAdmin.topics().getStats(inputTopicName, true);
-        subStats = stats.getSubscriptions().get("public/default/" + functionName);
-        assertNotNull(subStats);
-        assertEquals(0, subStats.getMsgBacklog());
-        assertEquals(0, subStats.getUnackedMessages());
-
-        deleteFunction(functionName);
-
-        getFunctionInfoNotFound(functionName);
-    }
-
-    protected void testFunctionNegAck(Runtime runtime) throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
-            return;
-        }
-
-
-        Schema<?> schema;
-        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-            schema = Schema.STRING;
-        } else {
-            schema = Schema.BYTES;
-        }
-
-        String inputTopicName = "persistent://public/default/test-neg-ack-" + runtime + "-input-" + randomName(8);
-        String outputTopicName = "test-neg-ack-" + runtime + "-output-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-
-        String functionName = "test-neg-ack-fn-" + randomName(8);
-        final int numMessages = 20;
-
-        // submit the exclamation function
-
-        if (runtime == Runtime.PYTHON) {
-            submitFunction(
-                    runtime, inputTopicName, outputTopicName, functionName, EXCEPTION_FUNCTION_PYTHON_FILE,
-                    EXCEPTION_PYTHON_CLASS, schema, null);
-        } else {
-            submitFunction(
-                    runtime, inputTopicName, outputTopicName, functionName, null, EXCEPTION_JAVA_CLASS, schema, null);
-        }
-
-        // get function info
-        getFunctionInfoSuccess(functionName);
-
-        // get function stats
-        getFunctionStatsEmpty(functionName);
-
-        // publish and consume result
-        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-            // java and python supports schema
-            @Cleanup PulsarClient client = PulsarClient.builder()
-                    .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                    .build();
-            @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                    .topic(outputTopicName)
-                    .subscriptionType(SubscriptionType.Exclusive)
-                    .subscriptionName("test-sub")
-                    .subscribe();
-            @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                producer.send("message-" + i);
-            }
-
-            Set<String> expectedMessages = new HashSet<>();
-            for (int i = 0; i < numMessages; i++) {
-                expectedMessages.add("message-" + i + "!");
-            }
-
-            for (int i = 0; i < numMessages; i++) {
-                Message<String> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
-                log.info("Received: {}", msg.getValue());
-                assertTrue(expectedMessages.contains(msg.getValue()));
-                expectedMessages.remove(msg.getValue());
-            }
-            assertEquals(expectedMessages.size(), 0);
-
-        } else {
-            // golang doesn't support schema
-
-            @Cleanup PulsarClient client = PulsarClient.builder()
-                    .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                    .build();
-
-            @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
-                    .topic(outputTopicName)
-                    .subscriptionType(SubscriptionType.Exclusive)
-                    .subscriptionName("test-sub")
-                    .subscribe();
-
-            @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                producer.newMessage().value(("message-" + i).getBytes(UTF_8)).send();
-            }
-
-            Set<String> expectedMessages = new HashSet<>();
-            for (int i = 0; i < numMessages; i++) {
-                expectedMessages.add("message-" + i + "!");
-            }
-
-            for (int i = 0; i < numMessages; i++) {
-                Message<byte[]> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
-                String msgValue = new String(msg.getValue(), UTF_8);
-                log.info("Received: {}", msgValue);
-                assertTrue(expectedMessages.contains(msgValue));
-                expectedMessages.remove(msgValue);
-            }
-            assertEquals(expectedMessages.size(), 0);
-        }
-
-        // get function status
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
-
-        assertEquals(functionStatus.getNumInstances(), 1);
-        assertEquals(functionStatus.getNumRunning(), 1);
-        assertEquals(functionStatus.getInstances().size(), 1);
-        assertEquals(functionStatus.getInstances().get(0).getInstanceId(), 0);
-        assertTrue(functionStatus.getInstances().get(0).getStatus().getAverageLatency() > 0.0);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertTrue(functionStatus.getInstances().get(0).getStatus().getLastInvocationTime() > 0);
-        // going to receive two more tuples because of delivery
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumReceived(), numMessages + 2);
-        // only going to successfully process 20
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumSuccessfullyProcessed(), numMessages);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestUserExceptions().size(), 2);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-
-        // get function stats
-        result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "stats",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        log.info("FUNCTION STATS: {}", result.getStdout());
-
-        FunctionStatsImpl functionStats = FunctionStatsImpl.decode(result.getStdout());
-        assertEquals(functionStats.getReceivedTotal(), numMessages + 2);
-        assertEquals(functionStats.getProcessedSuccessfullyTotal(), numMessages);
-        assertEquals(functionStats.getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.getUserExceptionsTotal(), 2);
-        assertTrue(functionStats.avgProcessLatency > 0);
-        assertTrue(functionStats.getLastInvocation() > 0);
-
-        assertEquals(functionStats.instances.size(), 1);
-        assertEquals(functionStats.instances.get(0).getInstanceId(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getReceivedTotal(), numMessages + 2);
-        assertEquals(functionStats.instances.get(0).getMetrics().getProcessedSuccessfullyTotal(), numMessages);
-        assertEquals(functionStats.instances.get(0).getMetrics().getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getUserExceptionsTotal(), 2);
-        assertTrue(functionStats.instances.get(0).getMetrics().getAvgProcessLatency() > 0);
-
-        // delete function
-        deleteFunction(functionName);
-
-        // get function info
-        getFunctionInfoNotFound(functionName);
-
-        // make sure subscriptions are cleanup
-        checkSubscriptionsCleanup(inputTopicName);
-    }
-
-    public void testGoPublishFunction() throws Exception {
-        testPublishFunction(Runtime.GO);
-    }
-
-    protected void testPublishFunction(Runtime runtime) throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
-            return;
-        }
-
-        Schema<?> schema;
-        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-            schema = Schema.STRING;
-        } else {
-            schema = Schema.BYTES;
-        }
-
-
-        String inputTopicName = "persistent://public/default/test-publish-" + runtime + "-input-" + randomName(8);
-        String outputTopicName = "test-publish-" + runtime + "-output-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-
-        String functionName = "test-publish-fn-" + randomName(8);
-        final int numMessages = 10;
-
-        // submit the exclamation function
-        switch (runtime) {
-            case JAVA:
-                submitFunction(
-                        runtime,
-                        inputTopicName,
-                        outputTopicName,
-                        functionName,
-                        null,
-                        PUBLISH_JAVA_CLASS,
-                        schema,
-                        Collections.singletonMap("publish-topic", outputTopicName),
-                        null, null, null, null, null, null);
-                break;
-            case PYTHON:
-                ConsumerConfig consumerConfig = new ConsumerConfig();
-                consumerConfig.setSchemaType("string");
-                Map<String, String> inputSpecs = new HashMap<>() {{
-                    put(inputTopicName, objectMapper.writeValueAsString(consumerConfig));
-                }};
-                submitFunction(
-                        runtime,
-                        inputTopicName,
-                        outputTopicName,
-                        functionName,
-                        PUBLISH_FUNCTION_PYTHON_FILE,
-                        PUBLISH_PYTHON_CLASS,
-                        schema,
-                        Collections.singletonMap("publish-topic", outputTopicName),
-                        objectMapper.writeValueAsString(inputSpecs), "string", null, null, null, null);
-                break;
-            case GO:
-                submitFunction(
-                        runtime,
-                        inputTopicName,
-                        outputTopicName,
-                        functionName,
-                        PUBLISH_FUNCTION_GO_FILE,
-                        null,
-                        schema,
-                        Collections.singletonMap("publish-topic", outputTopicName),
-                        null, null, null, null, null, null);
-        }
-
-        // get function info
-        getFunctionInfoSuccess(functionName);
-
-        // get function stats
-        getFunctionStatsEmpty(functionName);
-
-        // publish and consume result
-
-        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-            // java and python supports schema
-            publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
-        } else {
-            // Does Go support schema? Maybe we need a switch instead for the Go case.
-
-            @Cleanup PulsarClient client = PulsarClient.builder()
-                    .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                    .build();
-
-            @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
-                    .topic(outputTopicName)
-                    .subscriptionType(SubscriptionType.Exclusive)
-                    .subscriptionName("test-sub")
-                    .subscribe();
-
-            @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                producer.newMessage().key(String.valueOf(i)).property("count", String.valueOf(i))
-                        .value(("message-" + i).getBytes(UTF_8)).send();
-            }
-
-            Set<String> expectedMessages = new HashSet<>();
-            for (int i = 0; i < numMessages; i++) {
-                expectedMessages.add("message-" + i + "!");
-            }
-
-            for (int i = 0; i < numMessages; i++) {
-                Message<byte[]> msg = consumer.receive(30, TimeUnit.SECONDS);
-                String msgValue = new String(msg.getValue(), UTF_8);
-                log.info("Received: {}", msgValue);
-                assertEquals(msg.getKey(), String.valueOf(i));
-                assertEquals(msg.getProperties().get("count"), String.valueOf(i));
-                assertEquals(msg.getProperties().get("input_topic"), inputTopicName);
-                assertTrue(msg.getEventTime() > 0);
-                assertTrue(expectedMessages.contains(msgValue));
-                expectedMessages.remove(msgValue);
-            }
-        }
-
-        // get function status
-        getFunctionStatus(functionName, numMessages, true);
-
-        // get function stats
-        getFunctionStats(functionName, numMessages);
-
-        // delete function
-        deleteFunction(functionName);
-
-        // get function info
-        getFunctionInfoNotFound(functionName);
-
-        // make sure subscriptions are cleanup
-        checkSubscriptionsCleanup(inputTopicName);
-    }
-
-    protected void testExclamationFunction(Runtime runtime,
-                                           boolean isTopicPattern,
-                                           boolean pyZip,
-                                           boolean multipleInput,
-                                           boolean withExtraDeps) throws Exception {
-        testExclamationFunction(runtime, isTopicPattern, pyZip, multipleInput, withExtraDeps, null, null, null);
-    }
-
-    protected void testExclamationFunction(Runtime runtime,
-                                           boolean isTopicPattern,
-                                           boolean pyZip,
-                                           boolean multipleInput,
-                                           boolean withExtraDeps,
-                                           ConsumerConfig consumerConfig) throws Exception {
-        testExclamationFunction(runtime, isTopicPattern, pyZip, multipleInput, withExtraDeps, null, null, null);
-    }
-
-    protected void testExclamationFunction(Runtime runtime,
-                                           boolean isTopicPattern,
-                                           boolean pyZip,
-                                           boolean multipleInput,
-                                           boolean withExtraDeps,
-                                           ProducerConfig producerConfig) throws Exception {
-        testExclamationFunction(runtime, isTopicPattern, pyZip, multipleInput, withExtraDeps, null,
-                producerConfig, null);
-    }
-
-    protected void testExclamationFunction(Runtime runtime,
-                                           boolean isTopicPattern,
-                                           boolean pyZip,
-                                           boolean multipleInput,
-                                           boolean withExtraDeps,
-                                           ConsumerConfig consumerConfig,
-                                           ProducerConfig producerConfig,
-                                           java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
-            throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD && (runtime == Runtime.PYTHON || runtime == Runtime.GO)) {
-            // python&go can only run on process mode
-            return;
-        }
-
-
-        Schema<?> schema;
-        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-            schema = Schema.STRING;
-        } else {
-            schema = Schema.BYTES;
-        }
-
-        String inputTopicName = "persistent://public/default/test-exclamation-" + runtime + "-input-" + randomName(8);
-        String outputTopicName = "test-exclamation-" + runtime + "-output-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-        if (isTopicPattern) {
-            inputTopicName = inputTopicName + ".*";
-        } else if (multipleInput) {
-            inputTopicName = inputTopicName + "1," + inputTopicName + "2";
-        }
-        String functionName = "test-exclamation-fn-" + randomName(8);
-        final int numMessages = 10;
-
-        // submit the exclamation function
-        submitExclamationFunction(
-                runtime, inputTopicName, outputTopicName, functionName, pyZip, withExtraDeps, schema,
-                commandGeneratorConsumer);
-
-        // get function info
-        final String info = getFunctionInfoSuccess(functionName);
-        FunctionConfig config = ObjectMapperFactory.getMapper().getObjectMapper().readValue(info, FunctionConfig.class);
-
-        // get function stats
-        getFunctionStatsEmpty(functionName);
-
-        // publish and consume result
-        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
-            // java supports schema
-            publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
-        } else {
-            // golang doesn't support schema
-            publishAndConsumeMessagesBytes(inputTopicName, outputTopicName, numMessages);
-        }
-
-        // check batching config
-        if (runtime == Runtime.JAVA) {
-            BatchingConfig batchingConfig = null;
-            if (producerConfig != null && producerConfig.getBatchingConfig() != null) {
-                batchingConfig = producerConfig.getBatchingConfig();
-            }
-            checkLogs(functionName, batchingConfig, consumerConfig, config, inputTopicName);
-        }
-
-        // get function status
-        getFunctionStatus(functionName, numMessages, true);
-
-        if (Runtime.GO != runtime) {
-            // TODO: Go runtime doesn't collect `process_latency_ms_1min` metric
-            // get function stats
-            getFunctionStats(functionName, numMessages);
-        }
-
-        // update parallelism
-        updateFunctionParallelism(functionName, 2);
-
-        //get function status
-        getFunctionStatus(functionName, 0, true, 2);
-
-        // update code file
-        switch (runtime) {
-            case JAVA:
-                updateFunctionCodeFile(functionName, Runtime.JAVA, "test");
-                break;
-            case PYTHON:
-                updateFunctionCodeFile(functionName, Runtime.PYTHON, EXCLAMATION_PYTHON_FILE);
-                break;
-            case GO:
-                updateFunctionCodeFile(functionName, Runtime.GO, EXCLAMATION_GO_FILE);
-                break;
-        }
-
-        // check subscription type
-        checkSubscriptionType(inputTopicName, config);
-
-        // delete function
-        deleteFunction(functionName);
-
-        // get function info
-        getFunctionInfoNotFound(functionName);
-
-        // make sure subscriptions are cleanup
-        checkSubscriptionsCleanup(inputTopicName);
-
-    }
-
-    private void checkSubscriptionType(String topic, FunctionConfig config) {
-        List<String> topics = new ArrayList<>();
-        if (topic.endsWith(".*")) {
-            topics.add(topic.substring(0, topic.length() - 2) + "1");
-            topics.add(topic.substring(0, topic.length() - 2) + "2");
-        } else if (topic.contains(",")) {
-            topics.addAll(Arrays.asList(topic.split(",")));
-        } else {
-            topics.add(topic);
-        }
-        topics.stream().forEach(t -> {
-            try {
-                ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
-                        PulsarCluster.ADMIN_SCRIPT,
-                        "topics",
-                        "stats",
-                        t);
-                TopicStats topicStats = ObjectMapperFactory.getMapper().reader()
-                        .readValue(result.getStdout(), TopicStats.class);
-                assertEquals(topicStats.getSubscriptions().size(), 1);
-                final SubscriptionStats sub = topicStats.getSubscriptions().values().iterator()
-                        .next();
-                if (config.getRetainOrdering()) {
-                    assertEquals(sub.getType(), "Failover");
-                } else if (config.getRetainKeyOrdering()) {
-                    assertEquals(sub.getType(), "Key_Shared");
-                } else {
-                    assertEquals(sub.getType(), "Shared");
-                }
-            } catch (Exception e) {
-                fail("Command should have exited with non-zero");
-            }
-        });
-    }
-
-    // checking batching config/consumer config, we can only check this by checking the logs for now
-    private void checkLogs(String functionName, BatchingConfig config, ConsumerConfig consumerConfig,
-                           FunctionConfig functionConfig, String topic) {
-        if (config != null) {
-            assertNotNull(functionConfig.getProducerConfig());
-            assertNotNull(functionConfig.getProducerConfig().getBatchingConfig());
-            assertEquals(config.toString(), functionConfig.getProducerConfig().getBatchingConfig().toString());
-        }
-
-        String functionLogs = pulsarCluster.getFunctionLogs(functionName);
-        if (config == null || config.isEnabled()) {
-            BatchingConfig finalConfig = config;
-            if (finalConfig == null) {
-                finalConfig = BatchingConfig.builder().build();
-            }
-            assertTrue(functionLogs.contains(finalConfig.toString()));
-
-            // THREAD runtime doesn't include producer&consumer related logs in the function logs
-            if (functionRuntimeType == FunctionRuntimeType.PROCESS) {
-                if (finalConfig.getBatchingMaxMessages() == null) {
-                    finalConfig.setBatchingMaxMessages(1000);
-                }
-                if (finalConfig.getBatchingMaxBytes() == null) {
-                    finalConfig.setBatchingMaxBytes(128 * 1024);
-                }
-                if (finalConfig.getBatchingMaxPublishDelayMs() == null) {
-                    finalConfig.setBatchingMaxPublishDelayMs(10);
-                }
-                if (finalConfig.getRoundRobinRouterBatchingPartitionSwitchFrequency() == null) {
-                    finalConfig.setRoundRobinRouterBatchingPartitionSwitchFrequency(10);
-                }
-                String producerSpec = String.format(
-                        "\"batchingMaxPublishDelayMicros\":%d,\"batchingPartitionSwitchFrequencyByPublishDelay\":%d,"
-                                + "\"batchingMaxMessages\":%d,\"batchingMaxBytes\":%d,\"batchingEnabled\":%s",
-                        finalConfig.getBatchingMaxPublishDelayMs() * 1000,
-                        finalConfig.getRoundRobinRouterBatchingPartitionSwitchFrequency(),
-                        finalConfig.getBatchingMaxMessages(),
-                        finalConfig.getBatchingMaxBytes(), finalConfig.isEnabled());
-                assertTrue(functionLogs.contains(producerSpec));
-            }
-        } else {
-            assertTrue(functionLogs.contains("BatchingConfig(enabled=false"));
-            // THREAD runtime doesn't include producer&consumer related logs in the function logs
-            if (functionRuntimeType == FunctionRuntimeType.PROCESS) {
-                assertTrue(functionLogs.contains("\"batchingEnabled\":false"));
-            }
-        }
-
-        if (consumerConfig != null && consumerConfig.getMessagePayloadProcessorConfig() != null) {
-            MessagePayloadProcessorConfig payloadProcessorConfig = consumerConfig.getMessagePayloadProcessorConfig();
-            assertNotNull(functionConfig.getInputSpecs().get(topic));
-            assertNotNull(functionConfig.getInputSpecs().get(topic).getMessagePayloadProcessorConfig());
-            assertEquals(payloadProcessorConfig.toString(),
-                    functionConfig.getInputSpecs().get(topic).getMessagePayloadProcessorConfig().toString());
-
-            // THREAD runtime doesn't include producer&consumer related logs in the function logs
-            if (functionRuntimeType == FunctionRuntimeType.PROCESS) {
-                assertTrue(functionLogs.contains("Processing message using TestPayloadProcessor"));
-            }
-            if (payloadProcessorConfig.getConfig() == null || payloadProcessorConfig.getConfig().isEmpty()) {
-                assertTrue(functionLogs.contains("TestPayloadProcessor constructor without configs"));
-            } else {
-                String configs = payloadProcessorConfig.getConfig().entrySet().stream()
-                        .map(entry -> entry.getKey() + "=" + entry.getValue())
-                        .collect(Collectors.joining(", "));
-                String expectedLogs = String.format("TestPayloadProcessor constructor with configs %s", configs);
-                assertTrue(functionLogs.contains(expectedLogs));
-            }
-        }
-    }
-
-    private void submitExclamationFunction(Runtime runtime,
-                                           String inputTopicName,
-                                           String outputTopicName,
-                                           String functionName,
-                                           boolean pyZip,
-                                           boolean withExtraDeps,
-                                           Schema<?> schema) throws Exception {
-        submitExclamationFunction(runtime, inputTopicName, outputTopicName, functionName, pyZip,
-                withExtraDeps, schema, null);
-    }
-
-    private void submitExclamationFunction(Runtime runtime,
-                                           String inputTopicName,
-                                           String outputTopicName,
-                                           String functionName,
-                                           boolean pyZip,
-                                           boolean withExtraDeps,
-                                           Schema<?> schema,
-                                           java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
-            throws Exception {
-        submitFunction(
-                runtime,
-                inputTopicName,
-                outputTopicName,
-                functionName,
-                pyZip,
-                withExtraDeps,
-                false,
-                getExclamationClass(runtime, pyZip, withExtraDeps),
-                schema,
-                commandGeneratorConsumer);
-    }
-
-    private <T> void submitFunction(Runtime runtime,
-                                    String inputTopicName,
-                                    String outputTopicName,
-                                    String functionName,
-                                    boolean pyZip,
-                                    boolean withExtraDeps,
-                                    boolean isPublishFunction,
-                                    String functionClass,
-                                    Schema<T> inputTopicSchema,
-                                    java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
-            throws Exception {
-
-        String file = null;
-        if (Runtime.JAVA == runtime) {
-            file = null;
-        } else if (Runtime.PYTHON == runtime) {
-            if (isPublishFunction) {
-                file = PUBLISH_FUNCTION_PYTHON_FILE;
-            } else if (pyZip) {
-                file = EXCLAMATION_PYTHON_ZIP_FILE;
-            } else if (withExtraDeps) {
-                file = EXCLAMATION_WITH_DEPS_PYTHON_FILE;
-            } else {
-                file = EXCLAMATION_PYTHON_FILE;
-            }
-        } else if (Runtime.GO == runtime) {
-            if (isPublishFunction) {
-                file = PUBLISH_FUNCTION_GO_FILE;
-            } else {
-                file = EXCLAMATION_GO_FILE;
-            }
-        }
-
-        submitFunction(runtime, inputTopicName, outputTopicName, functionName, file, functionClass, inputTopicSchema,
-                commandGeneratorConsumer);
-    }
-
-    private <T> void submitFunction(Runtime runtime,
-                                    String inputTopicName,
-                                    String outputTopicName,
-                                    String functionName,
-                                    String functionFile,
-                                    String functionClass,
-                                    Schema<T> inputTopicSchema,
-                                    java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
-            throws Exception {
-        submitFunction(runtime, inputTopicName, outputTopicName, functionName, functionFile, functionClass,
-                inputTopicSchema, null, null, null, null, null, null,
-                commandGeneratorConsumer);
-    }
-
-    private <T> void submitFunction(Runtime runtime,
-                                    String inputTopicName,
-                                    String outputTopicName,
-                                    String functionName,
-                                    String functionFile,
-                                    String functionClass,
-                                    Schema<T> inputTopicSchema,
-                                    Map<String, String> userConfigs,
-                                    String customSchemaInputs,
-                                    String outputSchemaType,
-                                    SubscriptionInitialPosition subscriptionInitialPosition,
-                                    String inputTypeClassName,
-                                    String outputTypeClassName,
-                                    java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
-            throws Exception {
-
-        if (StringUtils.isNotEmpty(inputTopicName)) {
-            ensureSubscriptionCreated(
-                    inputTopicName, String.format("public/default/%s", functionName), inputTopicSchema);
-        }
-
-        CommandGenerator generator;
-        log.info("------- INPUT TOPIC: '{}', customSchemaInputs: {}", inputTopicName, customSchemaInputs);
-        if (inputTopicName.endsWith(".*")) {
-            log.info("----- CREATING TOPIC PATTERN FUNCTION --- ");
-            generator = CommandGenerator.createTopicPatternGenerator(inputTopicName, functionClass);
-        } else {
-            log.info("----- CREATING REGULAR FUNCTION --- ");
-            generator = CommandGenerator.createDefaultGenerator(inputTopicName, functionClass);
-        }
-        generator.setSinkTopic(outputTopicName);
-        generator.setFunctionName(functionName);
-        if (userConfigs != null) {
-            generator.setUserConfig(userConfigs);
-        }
-        if (customSchemaInputs != null) {
-            generator.setCustomSchemaInputs(customSchemaInputs);
-        }
-        if (outputSchemaType != null) {
-            generator.setSchemaType(outputSchemaType);
-        }
-        if (subscriptionInitialPosition != null) {
-            generator.setSubscriptionInitialPosition(subscriptionInitialPosition);
-        }
-        if (inputTypeClassName != null) {
-            generator.setInputTypeClassName(inputTypeClassName);
-        }
-        if (outputTypeClassName != null) {
-            generator.setOutputTypeClassName(outputTypeClassName);
-        }
-        if (commandGeneratorConsumer != null) {
-            commandGeneratorConsumer.accept(generator);
-        }
-        String command = "";
-
-        switch (runtime) {
-            case JAVA:
-                command = generator.generateCreateFunctionCommand();
-                break;
-            case PYTHON:
-            case GO:
-                generator.setRuntime(runtime);
-                command = generator.generateCreateFunctionCommand(functionFile);
-                break;
-            default:
-                throw new IllegalArgumentException("Unsupported runtime : " + runtime);
-        }
-
-        log.info("---------- Function command: {}", command);
-        String[] commands = {
-                "sh", "-c", command
-        };
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                commands);
-        log.info("---------- stdout is: {}", result.getStdout());
-        log.info("---------- stderr is: {}", result.getStderr());
-        assertTrue(result.getStdout().contains("Created successfully"));
-    }
-
-    private void updateFunctionParallelism(String functionName, int parallelism) throws Exception {
-
-        CommandGenerator generator = new CommandGenerator();
-        generator.setFunctionName(functionName);
-        generator.setParallelism(parallelism);
-        String command = generator.generateUpdateFunctionCommand();
-
-        log.info("---------- Function command: {}", command);
-        String[] commands = {
-                "sh", "-c", command
-        };
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                commands);
-        assertTrue(result.getStdout().contains("Updated successfully"));
-    }
-
-    private void updateFunctionCodeFile(String functionName, Runtime runtime, String codeFile) throws Exception {
-
-        CommandGenerator generator = new CommandGenerator();
-        generator.setFunctionName(functionName);
-        generator.setRuntime(runtime);
-        String command = generator.generateUpdateFunctionCommand(codeFile);
-
-        log.info("---------- Function command: {}", command);
-        String[] commands = {
-                "sh", "-c", command
-        };
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                commands);
-        assertTrue(result.getStdout().contains("Updated successfully"));
-    }
-
-    protected <T> void submitFunction(Runtime runtime,
-                                      String inputTopicName,
-                                      String outputTopicName,
-                                      String functionName,
-                                      String functionFile,
-                                      String functionClass,
-                                      Map<String, String> inputSerdeClassNames,
-                                      String outputSerdeClassName,
-                                      Map<String, String> userConfigs) throws Exception {
-
-        CommandGenerator generator;
-        log.info("------- INPUT TOPIC: '{}'", inputTopicName);
-        if (inputTopicName.endsWith(".*")) {
-            log.info("----- CREATING TOPIC PATTERN FUNCTION --- ");
-            generator = CommandGenerator.createTopicPatternGenerator(inputTopicName, functionClass);
-        } else {
-            log.info("----- CREATING REGULAR FUNCTION --- ");
-            generator = CommandGenerator.createDefaultGenerator(inputTopicName, functionClass);
-        }
-        generator.setSinkTopic(outputTopicName);
-        generator.setFunctionName(functionName);
-        generator.setCustomSerDeSourceTopics(inputSerdeClassNames);
-        generator.setOutputSerDe(outputSerdeClassName);
-        if (userConfigs != null) {
-            generator.setUserConfig(userConfigs);
-        }
-        String command;
-        if (Runtime.JAVA == runtime) {
-            command = generator.generateCreateFunctionCommand();
-        } else if (Runtime.PYTHON == runtime) {
-            generator.setRuntime(runtime);
-            command = generator.generateCreateFunctionCommand(functionFile);
-        } else {
-            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
-        }
-
-        log.info("---------- Function command: {}", command);
-        String[] commands = {
-                "sh", "-c", command
-        };
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                commands);
-        assertTrue(result.getStdout().contains("Created successfully"));
-    }
-
-    @SuppressWarnings("try")
-    private <T> void ensureSubscriptionCreated(String inputTopicName,
-                                               String subscriptionName,
-                                               Schema<T> inputTopicSchema)
-            throws Exception {
-        // ensure the function subscription exists before we start producing messages
-        try (PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build()) {
-            List<String> topics = new ArrayList<>();
-            if (inputTopicName.endsWith(".*")) {
-                topics.add(inputTopicName.substring(0, inputTopicName.length() - 2) + "1");
-                topics.add(inputTopicName.substring(0, inputTopicName.length() - 2) + "2");
-            } else if (inputTopicName.contains(",")) {
-                topics.addAll(Arrays.asList(inputTopicName.split(",")));
-            } else {
-                topics.add(inputTopicName);
-            }
-            try (Consumer<T> ignored = client.newConsumer(inputTopicSchema)
-                    .topic(topics.toArray(new String[0]))
-                    .subscriptionType(SubscriptionType.Shared)
-                    .subscriptionName(subscriptionName)
-                    .subscribe()) {
-            }
-        }
-    }
-
-    protected String getFunctionInfoSuccess(String functionName) throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        log.info("FUNCTION STATE: {}", result.getStdout());
-        assertTrue(result.getStdout().contains("\"name\": \"" + functionName + "\""));
-        return result.getStdout();
-    }
-
-
-    protected void getFunctionStatsEmpty(String functionName) throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "stats",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        log.info("FUNCTION STATS: {}", result.getStdout());
-        FunctionStatsImpl functionStats = FunctionStatsImpl.decode(result.getStdout());
-
-        assertEquals(functionStats.getReceivedTotal(), 0);
-        assertEquals(functionStats.getProcessedSuccessfullyTotal(), 0);
-        assertEquals(functionStats.getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.getUserExceptionsTotal(), 0);
-        assertEquals(functionStats.avgProcessLatency, null);
-        assertEquals(functionStats.oneMin.getReceivedTotal(), 0);
-        assertEquals(functionStats.oneMin.getProcessedSuccessfullyTotal(), 0);
-        assertEquals(functionStats.oneMin.getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.oneMin.getUserExceptionsTotal(), 0);
-        assertEquals(functionStats.oneMin.getAvgProcessLatency(), null);
-        assertEquals(functionStats.getAvgProcessLatency(), functionStats.oneMin.getAvgProcessLatency());
-        assertEquals(functionStats.getLastInvocation(), null);
-
-        assertEquals(functionStats.instances.size(), 1);
-        assertEquals(functionStats.instances.get(0).getInstanceId(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getReceivedTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getProcessedSuccessfullyTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getUserExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getAvgProcessLatency(), null);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getReceivedTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getProcessedSuccessfullyTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getUserExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getAvgProcessLatency(), null);
-    }
-
-    private void getFunctionStats(String functionName, int numMessages) throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "stats",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        log.info("FUNCTION STATS: {}", result.getStdout());
-
-        FunctionStatsImpl functionStats = FunctionStatsImpl.decode(result.getStdout());
-        assertEquals(functionStats.getReceivedTotal(), numMessages);
-        assertEquals(functionStats.getProcessedSuccessfullyTotal(), numMessages);
-        assertEquals(functionStats.getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.getUserExceptionsTotal(), 0);
-        assertTrue(functionStats.avgProcessLatency > 0);
-        assertEquals(functionStats.oneMin.getReceivedTotal(), numMessages);
-        assertEquals(functionStats.oneMin.getProcessedSuccessfullyTotal(), numMessages);
-        assertEquals(functionStats.oneMin.getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.oneMin.getUserExceptionsTotal(), 0);
-        assertTrue(functionStats.oneMin.getAvgProcessLatency() > 0);
-        assertEquals(functionStats.getAvgProcessLatency(), functionStats.oneMin.getAvgProcessLatency());
-        assertTrue(functionStats.getLastInvocation() > 0);
-
-        assertEquals(functionStats.instances.size(), 1);
-        assertEquals(functionStats.instances.get(0).getInstanceId(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getReceivedTotal(), numMessages);
-        assertEquals(functionStats.instances.get(0).getMetrics().getProcessedSuccessfullyTotal(), numMessages);
-        assertEquals(functionStats.instances.get(0).getMetrics().getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getUserExceptionsTotal(), 0);
-        assertTrue(functionStats.instances.get(0).getMetrics().getAvgProcessLatency() > 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getReceivedTotal(), numMessages);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getProcessedSuccessfullyTotal(),
-                numMessages);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getSystemExceptionsTotal(), 0);
-        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getUserExceptionsTotal(), 0);
-        assertTrue(functionStats.instances.get(0).getMetrics().getOneMin().getAvgProcessLatency() > 0);
-    }
-
-    private void getFunctionInfoNotFound(String functionName) throws Exception {
-        retryStrategically(aVoid -> {
-            try {
-                pulsarCluster.getAnyWorker().execCmd(
-                        PulsarCluster.ADMIN_SCRIPT,
-                        "functions",
-                        "get",
-                        "--tenant", "public",
-                        "--namespace", "default",
-                        "--name", functionName);
-            } catch (ContainerExecException e) {
-                if (e.getResult().getStderr().contains("Reason: Function " + functionName + " doesn't exist")) {
-                    return true;
-                }
-
-            } catch (Exception e) {
-
-            }
-            return false;
-        }, 5, 100, true);
-    }
-
-    private void checkSubscriptionsCleanup(String topic) throws Exception {
-        List<String> topics = new ArrayList<>();
-        if (topic.endsWith(".*")) {
-            topics.add(topic.substring(0, topic.length() - 2) + "1");
-            topics.add(topic.substring(0, topic.length() - 2) + "2");
-        } else if (topic.contains(",")) {
-            topics.addAll(Arrays.asList(topic.split(",")));
-        } else {
-            topics.add(topic);
-        }
-        topics.stream().forEach(t -> {
-            try {
-                ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
-                        PulsarCluster.ADMIN_SCRIPT,
-                        "topics",
-                        "stats",
-                        t);
-                TopicStats topicStats = ObjectMapperFactory.getMapper().reader()
-                        .readValue(result.getStdout(), TopicStats.class);
-                assertEquals(topicStats.getSubscriptions().size(), 0);
-            } catch (Exception e) {
-                fail("Command should have exited with non-zero");
-            }
-        });
-    }
-
-    private void checkPublisherCleanup(String topic) throws Exception {
-        try {
-            ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "topics",
-                    "stats",
-                    topic);
-            TopicStats topicStats = ObjectMapperFactory.getMapper().reader()
-                    .readValue(result.getStdout(), TopicStats.class);
-            assertEquals(topicStats.getPublishers().size(), 0);
-
-        } catch (ContainerExecException e) {
-            fail("Command should have exited with non-zero");
-        }
-    }
-
-    private void getFunctionStatus(String functionName, int numMessages, boolean checkRestarts) throws Exception {
-        getFunctionStatus(functionName, numMessages, checkRestarts, 1);
-    }
-
-    private void getFunctionStatus(String functionName, int numMessages, boolean checkRestarts, int parallelism)
-            throws Exception {
-        Awaitility.await()
-                .pollInterval(Duration.ofSeconds(1))
-                .atMost(Duration.ofSeconds(15))
-                .ignoreExceptions()
-                .untilAsserted(() ->
-                        doGetFunctionStatus(functionName, numMessages, checkRestarts, parallelism));
-    }
-
-    private void doGetFunctionStatus(String functionName, int numMessages, boolean checkRestarts, int parallelism)
-            throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
-
-        assertEquals(functionStatus.getNumInstances(), parallelism);
-        assertEquals(functionStatus.getNumRunning(), parallelism);
-        assertEquals(functionStatus.getInstances().size(), parallelism);
-        boolean avgLatencyGreaterThanZero = false;
-        int totalMessagesProcessed = 0;
-        int totalMessagesSuccessfullyProcessed = 0;
-        boolean lastInvocationTimeGreaterThanZero = false;
-        for (int i = 0; i < parallelism; ++i) {
-            assertEquals(functionStatus.getInstances().get(i).getStatus().isRunning(), true);
-            assertTrue(functionStatus.getInstances().get(i).getInstanceId() >= 0);
-            assertTrue(functionStatus.getInstances().get(i).getInstanceId() < parallelism);
-            avgLatencyGreaterThanZero = avgLatencyGreaterThanZero
-                    || functionStatus.getInstances().get(i).getStatus().getAverageLatency() > 0.0;
-            lastInvocationTimeGreaterThanZero = lastInvocationTimeGreaterThanZero
-                    || functionStatus.getInstances().get(i).getStatus().getLastInvocationTime() > 0;
-            totalMessagesProcessed += functionStatus.getInstances().get(i).getStatus().getNumReceived();
-            totalMessagesSuccessfullyProcessed +=
-                    functionStatus.getInstances().get(i).getStatus().getNumSuccessfullyProcessed();
-            if (checkRestarts) {
-                assertEquals(functionStatus.getInstances().get(i).getStatus().getNumRestarts(), 0);
-            }
-            assertEquals(functionStatus.getInstances().get(i).getStatus().getLatestUserExceptions().size(), 0);
-            assertEquals(functionStatus.getInstances().get(i).getStatus().getLatestSystemExceptions().size(), 0);
-        }
-        if (numMessages > 0) {
-            assertTrue(avgLatencyGreaterThanZero);
-            assertTrue(lastInvocationTimeGreaterThanZero);
-        }
-        assertEquals(totalMessagesProcessed, numMessages);
-        assertEquals(totalMessagesSuccessfullyProcessed, numMessages);
-    }
-
-    private void publishAndConsumeMessages(String inputTopic,
-                                           String outputTopic,
-                                           int numMessages) throws Exception {
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(outputTopic)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-sub")
-                .subscribe();
-
-        if (inputTopic.endsWith(".*")) {
-            @Cleanup Producer<String> producer1 = client.newProducer(Schema.STRING)
-                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "1")
-                    .create();
-
-            @Cleanup Producer<String> producer2 = client.newProducer(Schema.STRING)
-                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "2")
-                    .create();
-
-            for (int i = 0; i < numMessages / 2; i++) {
-                producer1.send("message-" + i);
-            }
-
-            for (int i = numMessages / 2; i < numMessages; i++) {
-                producer2.send("message-" + i);
-            }
-        } else {
-            @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(inputTopic)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                producer.send("message-" + i);
-            }
-        }
-
-        Set<String> expectedMessages = new HashSet<>();
-        for (int i = 0; i < numMessages; i++) {
-            expectedMessages.add("message-" + i + "!");
-        }
-
-        for (int i = 0; i < numMessages; i++) {
-            log.info("Trying to receive message.. {}/{}", i, numMessages);
-            Message<String> msg = consumer.receive(30, TimeUnit.MINUTES);
-            log.info("Received: {}", msg.getValue());
-            assertTrue(expectedMessages.contains(msg.getValue()));
-            expectedMessages.remove(msg.getValue());
-        }
-    }
-
-    private void publishAndConsumeMessagesBytes(String inputTopic,
-                                                String outputTopic,
-                                                int numMessages) throws Exception {
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
-                .topic(outputTopic)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-sub")
-                .subscribe();
-
-        if (inputTopic.endsWith(".*")) {
-            @Cleanup Producer<byte[]> producer1 = client.newProducer(Schema.BYTES)
-                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "1")
-                    .create();
-
-            @Cleanup Producer<byte[]> producer2 = client.newProducer(Schema.BYTES)
-                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "2")
-                    .create();
-
-            for (int i = 0; i < numMessages / 2; i++) {
-                producer1.send(("message-" + i).getBytes(UTF_8));
-            }
-
-            for (int i = numMessages / 2; i < numMessages; i++) {
-                producer2.send(("message-" + i).getBytes(UTF_8));
-            }
-        } else if (inputTopic.contains(",")) {
-            String[] topics = inputTopic.split(",");
-            @Cleanup Producer<byte[]> producer1 = client.newProducer(Schema.BYTES)
-                    .topic(topics[0])
-                    .create();
-
-            @Cleanup Producer<byte[]> producer2 = client.newProducer(Schema.BYTES)
-                    .topic(topics[1])
-                    .create();
-
-            for (int i = 0; i < numMessages / 2; i++) {
-                producer1.send(("message-" + i).getBytes(UTF_8));
-            }
-
-            for (int i = numMessages / 2; i < numMessages; i++) {
-                producer2.send(("message-" + i).getBytes(UTF_8));
-            }
-        } else {
-            @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
-                    .topic(inputTopic)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                producer.send(("message-" + i).getBytes(UTF_8));
-            }
-        }
-
-        Set<String> expectedMessages = new HashSet<>();
-        for (int i = 0; i < numMessages; i++) {
-            expectedMessages.add("message-" + i + "!");
-        }
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<byte[]> msg = consumer.receive(30, TimeUnit.SECONDS);
-            String msgValue = new String(msg.getValue(), UTF_8);
-            log.info("Received: {}", msgValue);
-            assertTrue(expectedMessages.contains(msgValue));
-            expectedMessages.remove(msgValue);
-        }
-    }
-
-    private void deleteFunction(String functionName) throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-        assertTrue(result.getStdout().contains("Deleted successfully"));
-        result.assertNoStderr();
-    }
-
-    protected void testAutoSchemaFunction() throws Exception {
-        String inputTopicName = "test-autoschema-input-" + randomName(8);
-        String outputTopicName = "test-autoschema-output-" + randomName(8);
-        String functionName = "test-autoschema-fn-" + randomName(8);
-        final int numMessages = 10;
-
-
-        // submit the exclamation function
-        submitFunction(
-                Runtime.JAVA,
-                inputTopicName,
-                outputTopicName,
-                functionName,
-                false,
-                false,
-                false,
-                AutoSchemaFunction.class.getName(),
-                Schema.AVRO(CustomObject.class),
-                null);
-
-        // get function info
-        getFunctionInfoSuccess(functionName);
-
-        // publish and consume result
-        publishAndConsumeAvroMessages(inputTopicName, outputTopicName, numMessages);
-
-        // get function status. Note that this function might restart a few times until
-        // the producer above writes the messages.
-        getFunctionStatus(functionName, numMessages, false);
-
-        // delete function
-        deleteFunction(functionName);
-
-        // get function info
-        getFunctionInfoNotFound(functionName);
-    }
-
-    private void publishAndConsumeAvroMessages(String inputTopic,
-                                               String outputTopic,
-                                               int numMessages) throws Exception {
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(outputTopic)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-sub")
-                .subscribe();
-
-        @Cleanup Producer<CustomObject> producer = client.newProducer(Schema.AVRO(CustomObject.class))
-                .topic(inputTopic)
-                .create();
-
-        for (int i = 0; i < numMessages; i++) {
-            CustomObject co = new CustomObject(i);
-            producer.send(co);
-        }
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<String> msg = consumer.receive();
-            assertEquals("value-" + i, msg.getValue());
-        }
-    }
-
-    protected void testAvroSchemaFunction(Runtime runtime) throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD && runtime == Runtime.PYTHON) {
-            // python can only run on process mode
-            return;
-        }
-
-        log.info("testAvroSchemaFunction start ...");
-        final String inputTopic = "test-avroschema-input-" + randomName(8);
-        final String outputTopic = "test-avroschema-output-" + randomName(8);
-        final String functionName = "test-avroschema-fn-" + randomName(8);
-        final int numMessages = 10;
-
-        @Cleanup PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
-        log.info("pulsar client init - input: {}, output: {}", inputTopic, outputTopic);
-
-        @Cleanup Producer<AvroTestObject> producer = pulsarClient
-                .newProducer(Schema.AVRO(AvroTestObject.class))
-                .topic(inputTopic).create();
-        log.info("pulsar producer init - {}", inputTopic);
-
-        @Cleanup Consumer<AvroTestObject> consumer = pulsarClient
-                .newConsumer(Schema.AVRO(AvroTestObject.class))
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-avro-schema")
-                .topic(outputTopic)
-                .subscribe();
-        log.info("pulsar consumer init - {}", outputTopic);
-
-        CompletableFuture<Optional<SchemaInfo>> inputSchemaFuture =
-                ((PulsarClientImpl) pulsarClient).getSchema(inputTopic);
-        inputSchemaFuture.whenComplete((schemaInfo, throwable) -> {
-            if (schemaInfo.isPresent()) {
-                log.info("inputSchemaInfo: {}", schemaInfo.get().toString());
-            } else {
-                log.error("input schema is not present!");
-            }
-        });
-
-        CompletableFuture<Optional<SchemaInfo>> outputSchemaFuture =
-                ((PulsarClientImpl) pulsarClient).getSchema(outputTopic);
-        outputSchemaFuture.whenComplete((schemaInfo, throwable) -> {
-            if (throwable != null) {
-                log.error("get output schemaInfo error", throwable);
-                throwable.printStackTrace();
-                return;
-            }
-            if (schemaInfo.isPresent()) {
-                log.info("outputSchemaInfo: {}", schemaInfo.get().toString());
-            } else {
-                log.error("output schema is not present!");
-            }
-        });
-
-        if (runtime == Runtime.JAVA) {
-            submitFunction(
-                    Runtime.JAVA,
-                    inputTopic,
-                    outputTopic,
-                    functionName,
-                    null,
-                    AvroSchemaTestFunction.class.getName(),
-                    Schema.AVRO(AvroTestObject.class),
-                    null);
-        } else if (runtime == Runtime.PYTHON) {
-            ConsumerConfig consumerConfig = new ConsumerConfig();
-            consumerConfig.setSchemaType("avro");
-            Map<String, String> inputSpecs = new HashMap<>() {{
-                put(inputTopic, objectMapper.writeValueAsString(consumerConfig));
-            }};
-            submitFunction(
-                    Runtime.PYTHON,
-                    inputTopic,
-                    outputTopic,
-                    functionName,
-                    AVRO_SCHEMA_FUNCTION_PYTHON_FILE,
-                    AVRO_SCHEMA_PYTHON_CLASS,
-                    Schema.AVRO(AvroTestObject.class),
-                    null, objectMapper.writeValueAsString(inputSpecs), "avro", null,
-                    "avro_schema_test_function.AvroTestObject", "avro_schema_test_function.AvroTestObject",
-                    null);
-        }
-        log.info("pulsar submitFunction");
-
-        getFunctionInfoSuccess(functionName);
-
-        AvroSchemaTestFunction function = new AvroSchemaTestFunction();
-        Set<Object> expectedSet = new HashSet<>();
-
-        log.info("test-avro-schema producer connected: " + producer.isConnected());
-        for (int i = 0; i < numMessages; i++) {
-            AvroTestObject inputObject = new AvroTestObject();
-            inputObject.setBaseValue(i);
-            MessageId messageId = producer.send(inputObject);
-            log.info("test-avro-schema messageId: {}", messageId.toString());
-            expectedSet.add(function.process(inputObject, null));
-            log.info("test-avro-schema expectedSet size: {}", expectedSet.size());
-        }
-        getFunctionStatus(functionName, numMessages, false);
-        log.info("test-avro-schema producer send message finish");
-
-        CompletableFuture<Optional<SchemaInfo>> outputSchemaFuture2 =
-                ((PulsarClientImpl) pulsarClient).getSchema(outputTopic);
-        outputSchemaFuture2.whenComplete((schemaInfo, throwable) -> {
-            if (throwable != null) {
-                log.error("get output schemaInfo error", throwable);
-                throwable.printStackTrace();
-                return;
-            }
-            if (schemaInfo.isPresent()) {
-                log.info("outputSchemaInfo: {}", schemaInfo.get().toString());
-            } else {
-                log.error("output schema is not present!");
-            }
-        });
-
-        log.info("test-avro-schema consumer connected: " + consumer.isConnected());
-        for (int i = 0; i < numMessages; i++) {
-            log.info("test-avro-schema consumer receive [{}] start", i);
-            Message<AvroTestObject> message = consumer.receive();
-            log.info("test-avro-schema consumer receive [{}] over", i);
-            AvroTestObject outputObject = message.getValue();
-            assertTrue(expectedSet.contains(outputObject));
-            expectedSet.remove(outputObject);
-            consumer.acknowledge(message);
-        }
-        log.info("test-avro-schema consumer receive message finish");
-
-        assertEquals(expectedSet.size(), 0);
-
-        deleteFunction(functionName);
-
-        getFunctionInfoNotFound(functionName);
-    }
-
-
-    protected void testInitFunction(Runtime runtime) throws Exception {
-        if (runtime != Runtime.JAVA) {
-            // only java support init function
-            return;
-        }
-
-        Schema<?> schema = Schema.STRING;
-
-        String inputTopicName = "persistent://public/default/test-init-" + runtime + "-input-" + randomName(8);
-        String outputTopicName = "test-init-" + runtime + "-output-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-
-        String functionName = "test-init-fn-" + randomName(8);
-        final int numMessages = 10;
-
-        // submit the exclamation function
-        submitFunction(runtime, inputTopicName, outputTopicName, functionName, null,
-                InitializableFunction.class.getName(), schema,
-                Collections.singletonMap("publish-topic", outputTopicName), null, null, null, null, null, null);
-
-        // publish and consume result
-        publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
-
-        // delete function
-        deleteFunction(functionName);
-    }
-
-    protected void testLoggingFunction(Runtime runtime) throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD && runtime == Runtime.PYTHON) {
-            // python can only run on process mode
-            return;
-        }
-
-        if (functionRuntimeType == FunctionRuntimeType.THREAD && runtime == Runtime.GO) {
-            // go can only run on process mode
-            return;
-        }
-
-
-        Schema<?> schema;
-        if (Runtime.JAVA == runtime) {
-            schema = Schema.STRING;
-        } else {
-            schema = Schema.BYTES;
-        }
-
-        String inputTopicName = "persistent://public/default/test-log-" + runtime + "-input-" + randomName(8);
-        String logTopicName = "test-log-" + runtime + "-log-topic-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(logTopicName);
-        }
-
-        String functionName = "test-logging-fn-" + randomName(8);
-        final int numMessages = 10;
-
-        // submit the exclamation function
-        submitJavaLoggingFunction(
-                inputTopicName, logTopicName, functionName, schema);
-
-        // get function info
-        getFunctionInfoSuccess(functionName);
-
-        // get function stats
-        getFunctionStatsEmpty(functionName);
-
-        try {
-            // publish and consume result
-            publishAndConsumeMessages(inputTopicName, logTopicName, numMessages, "-log");
-        } finally {
-            // dump function logs so that it's easier to investigate failures
-            pulsarCluster.dumpFunctionLogs(functionName);
-        }
-
-        // get function status
-        getFunctionStatus(functionName, numMessages, true);
-
-        // get function stats
-        getFunctionStats(functionName, numMessages);
-
-        // delete function
-        deleteFunction(functionName);
-
-        // get function info
-        getFunctionInfoNotFound(functionName);
-
-        // make sure subscriptions are cleanup
-        checkSubscriptionsCleanup(inputTopicName);
-        checkPublisherCleanup(logTopicName);
-
-    }
-
-    private void submitJavaLoggingFunction(String inputTopicName,
-                                           String logTopicName,
-                                           String functionName,
-                                           Schema<?> schema) throws Exception {
-        ensureSubscriptionCreated(inputTopicName, String.format("public/default/%s", functionName), schema);
-
-        CommandGenerator generator;
-        log.info("------- INPUT TOPIC: '{}'", inputTopicName);
-        if (inputTopicName.endsWith(".*")) {
-            log.info("----- CREATING TOPIC PATTERN FUNCTION --- ");
-            generator = CommandGenerator.createTopicPatternGenerator(inputTopicName, LOGGING_JAVA_CLASS);
-        } else {
-            log.info("----- CREATING REGULAR FUNCTION --- ");
-            generator = CommandGenerator.createDefaultGenerator(inputTopicName, LOGGING_JAVA_CLASS);
-        }
-        generator.setLogTopic(logTopicName);
-        generator.setFunctionName(functionName);
-        String command = generator.generateCreateFunctionCommand();
-
-        log.info("---------- Function command: {}", command);
-        String[] commands = {
-                "sh", "-c", command
-        };
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                commands);
-        assertTrue(result.getStdout().contains("Created successfully"));
-    }
-
-    private void publishAndConsumeMessages(String inputTopic,
-                                           String outputTopic,
-                                           int numMessages,
-                                           String messagePostfix) throws Exception {
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup Consumer<byte[]> consumer = client.newConsumer()
-                .topic(outputTopic)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-sub")
-                .subscribe();
-
-        @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .create();
-
-        for (int i = 0; i < numMessages; i++) {
-            producer.send("message-" + i);
-        }
-
-        Set<String> expectedMessages = new HashSet<>();
-        for (int i = 0; i < numMessages; i++) {
-            expectedMessages.add("message-" + i + messagePostfix);
-        }
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<byte[]> msg = consumer.receive(30, TimeUnit.SECONDS);
-            if (msg == null) {
-                log.info("Input topic stats: {}",
-                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
-                                pulsarAdmin.topics().getStats(inputTopic, true)));
-                log.info("Output topic stats: {}",
-                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
-                                pulsarAdmin.topics().getStats(outputTopic, true)));
-                log.info("Input topic internal-stats: {}",
-                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
-                                pulsarAdmin.topics().getInternalStats(inputTopic, true)));
-                log.info("Output topic internal-stats: {}",
-                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
-                                pulsarAdmin.topics().getInternalStats(outputTopic, true)));
-            } else {
-                String logMsg = new String(msg.getValue(), UTF_8);
-                log.info("Received message: '{}'", logMsg);
-                assertTrue(expectedMessages.contains(logMsg), "Message '" + logMsg + "' not expected");
-                expectedMessages.remove(logMsg);
-            }
-        }
-
-        consumer.close();
-        producer.close();
-        client.close();
-    }
-
-
-    protected void testGenericObjectFunction(String function, boolean removeAgeField, boolean keyValue)
-            throws Exception {
-        log.info("start {} function test ...", function);
-
-        String ns = "public/ns-genericobject-" + randomName(8);
-        @Cleanup
-        PulsarAdmin pulsarAdmin = getPulsarAdmin();
-        pulsarAdmin.namespaces().createNamespace(ns);
-
-        @Cleanup
-        PulsarClient pulsarClient = getPulsarClient();
-
-        final int numMessages = 10;
-        final String inputTopic = ns + "/test-object-input-" + randomName(8);
-        final String outputTopic = ns + "/test-object-output" + randomName(8);
-        @Cleanup
-        Consumer<GenericRecord> consumer = pulsarClient
-                .newConsumer(Schema.AUTO_CONSUME())
-                .subscriptionName("test")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .topic(outputTopic)
-                .subscribe();
-
-        final String functionName = "test-generic-fn-" + randomName(8);
-        submitFunction(
-                Runtime.JAVA,
-                inputTopic,
-                outputTopic,
-                functionName,
-                null,
-                function,
-                Schema.AUTO_CONSUME(),
-                null,
-                null,
-                SchemaType.NONE.name(),
-                SubscriptionInitialPosition.Earliest, null, null, null);
-        try {
-            if (keyValue) {
-                @Cleanup
-                Producer<KeyValue<Users.UserV1, Users.UserV1>> producer = pulsarClient
-                        .newProducer(Schema.KeyValue(
-                                Schema.AVRO(Users.UserV1.class),
-                                Schema.AVRO(Users.UserV1.class), KeyValueEncodingType.SEPARATED))
-                        .topic(inputTopic)
-                        .create();
-                for (int i = 0; i < numMessages; i++) {
-                    producer.send(new KeyValue<>(new Users.UserV1("foo" + i, i),
-                            new Users.UserV1("bar" + i, i + 100)));
-                }
-            } else {
-                @Cleanup
-                Producer<Users.UserV1> producer = pulsarClient
-                        .newProducer(Schema.AVRO(Users.UserV1.class))
-                        .topic(inputTopic)
-                        .create();
-                for (int i = 0; i < numMessages; i++) {
-                    producer.send(new Users.UserV1("bar" + i, i + 100));
-                }
-            }
-
-            getFunctionInfoSuccess(functionName);
-
-            getFunctionStatus(functionName, numMessages, true);
-
-            int i = 0;
-            Message<GenericRecord> message;
-            do {
-                message = consumer.receive(30, TimeUnit.SECONDS);
-                if (message != null) {
-                    GenericRecord genericRecord = message.getValue();
-                    if (keyValue) {
-                        @SuppressWarnings("unchecked")
-                        KeyValue<GenericRecord, GenericRecord> keyValueObject =
-                                (KeyValue<GenericRecord, GenericRecord>) genericRecord.getNativeObject();
-                        GenericRecord key = keyValueObject.getKey();
-                        GenericRecord value = keyValueObject.getValue();
-                        key.getFields().forEach(f -> {
-                            log.info("key field {} value {}", f.getName(), key.getField(f.getName()));
-                        });
-                        value.getFields().forEach(f -> {
-                            log.info("value field {} value {}", f.getName(), value.getField(f.getName()));
-                        });
-                        assertEquals(i, key.getField("age"));
-                        assertEquals("foo" + i, key.getField("name"));
-
-                        if (removeAgeField) {
-                            // field "age" is removed from the schema
-                            assertFalse(value.getFields().stream().anyMatch(f -> f.getName().equals("age")));
-                        } else {
-                            assertEquals(i + 100, value.getField("age"));
-                        }
-                        assertEquals("bar" + i, value.getField("name"));
-                    } else {
-                        GenericRecord value = genericRecord;
-                        log.info("received value {}", value);
-                        value.getFields().forEach(f -> {
-                            log.info("value field {} value {}", f.getName(), value.getField(f.getName()));
-                        });
-
-                        if (removeAgeField) {
-                            // field "age" is removed from the schema
-                            assertFalse(value.getFields().stream().anyMatch(f -> f.getName().equals("age")));
-                        } else {
-                            assertEquals(i + 100, value.getField("age"));
-                        }
-                        assertEquals("bar" + i, value.getField("name"));
-                    }
-
-                    consumer.acknowledge(message);
-                    i++;
-                }
-            } while (message != null);
-        } finally {
-            pulsarCluster.dumpFunctionLogs(functionName);
-        }
-
-        deleteFunction(functionName);
-
-        getFunctionInfoNotFound(functionName);
-    }
-
-    protected void testRecordFunction() throws Exception {
-        log.info("start RecordFunction function test ...");
-
-        String ns = "public/ns-recordfunction-" + randomName(8);
-        @Cleanup
-        PulsarAdmin pulsarAdmin = getPulsarAdmin();
-        pulsarAdmin.namespaces().createNamespace(ns);
-
-        @Cleanup
-        PulsarClient pulsarClient = getPulsarClient();
-
-        final int numMessages = 10;
-        final String inputTopic = ns + "/test-string-input-" + randomName(8);
-        final String outputTopic = ns + "/test-string-output-" + randomName(8);
-        @Cleanup
-        Consumer<String> consumer = pulsarClient
-                .newConsumer(Schema.STRING)
-                .subscriptionName("test")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .topic("publishtopic")
-                .subscribe();
-
-        final String functionName = "test-record-fn-" + randomName(8);
-        submitFunction(
-                Runtime.JAVA,
-                inputTopic,
-                outputTopic,
-                functionName,
-                null,
-                RecordFunction.class.getName(),
-                Schema.AUTO_CONSUME(),
-                null);
-        try {
-            @Cleanup
-            Producer<String> producer = pulsarClient
-                    .newProducer(Schema.STRING)
-                    .topic(inputTopic)
-                    .create();
-            for (int i = 0; i < numMessages; i++) {
-                producer.send("message" + i);
-            }
-
-            getFunctionInfoSuccess(functionName);
-
-            getFunctionStatus(functionName, numMessages, true);
-
-            for (int i = 0; i < numMessages; i++) {
-                Message<String> msg = consumer.receive(30, TimeUnit.SECONDS);
-                log.info("Received: {}", msg.getValue());
-                assertEquals(msg.getValue(), "message" + i + "!");
-                assertEquals(msg.getProperty("input_topic"), "persistent://" + inputTopic);
-            }
-        } finally {
-            pulsarCluster.dumpFunctionLogs(functionName);
-        }
-
-        deleteFunction(functionName);
-
-        getFunctionInfoNotFound(functionName);
-    }
-
-    protected void testMergeFunction() throws Exception {
-        log.info("start merge function test ...");
-
-        String ns = "public/ns-merge-" + randomName(8);
-        @Cleanup
-        PulsarAdmin pulsarAdmin = getPulsarAdmin();
-        pulsarAdmin.namespaces().createNamespace(ns);
-        pulsarAdmin.namespaces().setSchemaCompatibilityStrategy(ns, SchemaCompatibilityStrategy.ALWAYS_COMPATIBLE);
-        SchemaCompatibilityStrategy strategy = pulsarAdmin.namespaces().getSchemaCompatibilityStrategy(ns);
-        log.info("namespace {} SchemaCompatibilityStrategy is {}", ns, strategy);
-
-        @Cleanup
-        PulsarClient pulsarClient = getPulsarClient();
-
-        ObjectNode inputSpecNode = objectMapper.createObjectNode();
-        Map<String, AtomicInteger> topicMsgCntMap = new ConcurrentHashMap<>();
-        int messagePerTopic = 10;
-        prepareDataForMergeFunction(ns, pulsarClient, inputSpecNode, messagePerTopic, topicMsgCntMap);
-
-        final String outputTopic = ns + "/test-merge-output";
-        @Cleanup
-        Consumer<GenericRecord> consumer = pulsarClient
-                .newConsumer(Schema.AUTO_CONSUME())
-                .subscriptionName("test-merge-fn")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .topic(outputTopic)
-                .subscribe();
-
-        final String functionName = "test-merge-fn-" + randomName(8);
-        submitFunction(
-                Runtime.JAVA,
-                "",
-                outputTopic,
-                functionName,
-                null,
-                MergeTopicFunction.class.getName(),
-                null,
-                null,
-                inputSpecNode.toString(),
-                SchemaType.AUTO_PUBLISH.name().toUpperCase(),
-                SubscriptionInitialPosition.Earliest, null, null, null);
-
-        getFunctionInfoSuccess(functionName);
-
-        getFunctionStatus(functionName, topicMsgCntMap.keySet().size() * messagePerTopic, true);
-
-        try {
-
-            Message<GenericRecord> message;
-            do {
-                message = consumer.receive(30, TimeUnit.SECONDS);
-                if (message != null) {
-                    String baseTopic = message.getProperty("baseTopic");
-                    GenericRecord genericRecord = message.getValue();
-                    log.info("receive msg baseTopic: {}, schemaType: {}, nativeClass: {}, nativeObject: {}",
-                            baseTopic,
-                            genericRecord.getSchemaType(),
-                            genericRecord.getNativeObject().getClass(),
-                            genericRecord.getNativeObject());
-                    checkSchemaForAutoSchema(message, baseTopic);
-                    topicMsgCntMap.get(baseTopic).decrementAndGet();
-                    consumer.acknowledge(message);
-                }
-            } while (message != null);
-
-            for (Map.Entry<String, AtomicInteger> entry : topicMsgCntMap.entrySet()) {
-                assertEquals(entry.getValue().get(), 0,
-                        "topic " + entry.getKey() + " left message cnt is not 0.");
-            }
-        } finally {
-            pulsarCluster.dumpFunctionLogs(functionName);
-        }
-
-        deleteFunction(functionName);
-
-        getFunctionInfoNotFound(functionName);
-        log.info("finish merge function test.");
-    }
-
-    private void prepareDataForMergeFunction(String ns,
-                                             PulsarClient pulsarClient,
-                                             ObjectNode inputSpecNode,
-                                             int messagePerTopic,
-                                             Map<String, AtomicInteger> topicMsgCntMap) throws PulsarClientException {
-        generateDataByDifferentSchema(ns, "merge-schema-bytes", pulsarClient,
-                Schema.BYTES, "bytes schema test".getBytes(), messagePerTopic, inputSpecNode, topicMsgCntMap);
-        generateDataByDifferentSchema(ns, "merge-schema-string", pulsarClient,
-                Schema.STRING, "string schema test", messagePerTopic, inputSpecNode, topicMsgCntMap);
-        generateDataByDifferentSchema(ns, "merge-schema-json-userv1", pulsarClient,
-                Schema.JSON(Users.UserV1.class), new Users.UserV1("ran", 33),
-                messagePerTopic, inputSpecNode, topicMsgCntMap);
-        generateDataByDifferentSchema(ns, "merge-schema-json-userv2", pulsarClient,
-                Schema.JSON(Users.UserV2.class), new Users.UserV2("tang", 18, "123123123"),
-                messagePerTopic, inputSpecNode, topicMsgCntMap);
-        generateDataByDifferentSchema(ns, "merge-schema-avro-userv2", pulsarClient,
-                Schema.AVRO(Users.UserV2.class), new Users.UserV2("tang", 20, "456456456"),
-                messagePerTopic, inputSpecNode, topicMsgCntMap);
-        generateDataByDifferentSchema(ns, "merge-schema-k-int-v-json-userv1-separate", pulsarClient,
-                Schema.KeyValue(Schema.INT32, Schema.JSON(Users.UserV1.class), KeyValueEncodingType.SEPARATED),
-                new KeyValue<>(100, new Users.UserV1("ran", 40)),
-                messagePerTopic, inputSpecNode, topicMsgCntMap);
-        generateDataByDifferentSchema(ns, "merge-schema-k-json-userv2-v-json-userv1-inline", pulsarClient,
-                Schema.KeyValue(Schema.JSON(Users.UserV2.class), Schema.JSON(Users.UserV1.class),
-                        KeyValueEncodingType.INLINE),
-                new KeyValue<>(new Users.UserV2("tang", 20, "789789789"),
-                        new Users.UserV1("ran", 40)),
-                messagePerTopic, inputSpecNode, topicMsgCntMap);
-    }
-
-    private <T> void generateDataByDifferentSchema(String ns,
-                                                   String baseTopic,
-                                                   PulsarClient pulsarClient,
-                                                   Schema<T> schema,
-                                                   T data,
-                                                   int messageCnt,
-                                                   ObjectNode inputSpecNode,
-                                                   Map<String, AtomicInteger> topicMsgCntMap)
-            throws PulsarClientException {
-        String topic = ns + "/" + baseTopic;
-        Producer<T> producer = pulsarClient.newProducer(schema)
-                .topic(topic)
-                .create();
-        for (int i = 0; i < messageCnt; i++) {
-            producer.newMessage().value(data).property("baseTopic", baseTopic).send();
-        }
-        ObjectNode confNode = objectMapper.createObjectNode();
-        confNode.put("schemaType", SchemaType.AUTO_CONSUME.name().toUpperCase());
-        inputSpecNode.put(topic, confNode.toString());
-        topicMsgCntMap.put(baseTopic, new AtomicInteger(messageCnt));
-        producer.close();
-        log.info("[merge-fn] generate {} messages for schema {}", messageCnt, schema.getSchemaInfo());
-    }
-
-    @SuppressWarnings("unchecked")
-    private void checkSchemaForAutoSchema(Message<GenericRecord> message, String baseTopic) {
-        if (message.getReaderSchema().isEmpty()) {
-            fail("Failed to get reader schema for auto consume multiple schema topic.");
-        }
-        Object nativeObject = message.getValue().getNativeObject();
-        JsonNode jsonNode;
-        KeyValue<?, ?> kv;
-        switch (baseTopic) {
-            case "merge-schema-bytes":
-                assertEquals(new String((byte[]) nativeObject), "bytes schema test");
-                break;
-            case "merge-schema-string":
-                assertEquals((String) nativeObject, "string schema test");
-                break;
-            case "merge-schema-json-userv1":
-                jsonNode = (JsonNode) nativeObject;
-                assertEquals(jsonNode.get("name").textValue(), "ran");
-                assertEquals(jsonNode.get("age").intValue(), 33);
-                break;
-            case "merge-schema-json-userv2":
-                jsonNode = (JsonNode) nativeObject;
-                assertEquals(jsonNode.get("name").textValue(), "tang");
-                assertEquals(jsonNode.get("age").intValue(), 18);
-                assertEquals(jsonNode.get("phone").textValue(), "123123123");
-                break;
-            case "merge-schema-avro-userv2":
-                org.apache.avro.generic.GenericRecord genericRecord =
-                        (org.apache.avro.generic.GenericRecord) nativeObject;
-                assertEquals(genericRecord.get("name").toString(), "tang");
-                assertEquals(genericRecord.get("age"), 20);
-                assertEquals(genericRecord.get("phone").toString(), "456456456");
-                break;
-            case "merge-schema-k-int-v-json-userv1-separate":
-                kv = (KeyValue<Integer, GenericRecord>) nativeObject;
-                assertEquals(kv.getKey(), 100);
-                jsonNode = ((GenericJsonRecord) kv.getValue()).getJsonNode();
-                assertEquals(jsonNode.get("name").textValue(), "ran");
-                assertEquals(jsonNode.get("age").intValue(), 40);
-                break;
-            case "merge-schema-k-json-userv2-v-json-userv1-inline":
-                kv = (KeyValue<GenericRecord, GenericRecord>) nativeObject;
-                jsonNode = ((GenericJsonRecord) kv.getKey()).getJsonNode();
-                assertEquals(jsonNode.get("name").textValue(), "tang");
-                assertEquals(jsonNode.get("age").intValue(), 20);
-                assertEquals(jsonNode.get("phone").textValue(), "789789789");
-                jsonNode = ((GenericJsonRecord) kv.getValue()).getJsonNode();
-                assertEquals(jsonNode.get("name").textValue(), "ran");
-                assertEquals(jsonNode.get("age").intValue(), 40);
-                break;
-            default:
-                // nothing to do
-        }
-    }
-
-    private PulsarClient getPulsarClient() throws PulsarClientException {
-        return PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
-    }
-
-    private PulsarAdmin getPulsarAdmin() throws PulsarClientException {
-        return PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.BatcherBuilder;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Reader;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.client.impl.PulsarClientImpl;
+import org.apache.pulsar.client.impl.schema.generic.GenericJsonRecord;
+import org.apache.pulsar.common.functions.BatchingConfig;
+import org.apache.pulsar.common.functions.ConsumerConfig;
+import org.apache.pulsar.common.functions.FunctionConfig;
+import org.apache.pulsar.common.functions.MessagePayloadProcessorConfig;
+import org.apache.pulsar.common.functions.ProducerConfig;
+import org.apache.pulsar.common.policies.data.FunctionStatsImpl;
+import org.apache.pulsar.common.policies.data.FunctionStatus;
+import org.apache.pulsar.common.policies.data.FunctionStatusUtil;
+import org.apache.pulsar.common.policies.data.SchemaCompatibilityStrategy;
+import org.apache.pulsar.common.policies.data.SubscriptionStats;
+import org.apache.pulsar.common.policies.data.TopicStats;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.common.schema.SchemaInfo;
+import org.apache.pulsar.common.schema.SchemaType;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.functions.api.examples.AutoSchemaFunction;
+import org.apache.pulsar.functions.api.examples.AvroSchemaTestFunction;
+import org.apache.pulsar.functions.api.examples.InitializableFunction;
+import org.apache.pulsar.functions.api.examples.MergeTopicFunction;
+import org.apache.pulsar.functions.api.examples.RecordFunction;
+import org.apache.pulsar.functions.api.examples.pojo.AvroTestObject;
+import org.apache.pulsar.functions.api.examples.pojo.Users;
+import org.apache.pulsar.functions.api.examples.serde.CustomObject;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.assertj.core.api.Assertions;
+import org.awaitility.Awaitility;
+
+/**
+ * A test base for testing functions.
+ */
+@Slf4j
+public abstract class PulsarFunctionsTest extends PulsarFunctionsTestBase {
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    public PulsarFunctionsTest(FunctionRuntimeType functionRuntimeType) {
+        super(functionRuntimeType);
+    }
+
+    protected Map<String, String> produceMessagesToInputTopic(String inputTopicName,
+                                                              int numMessages) throws Exception {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopicName)
+                .create();
+
+        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
+        for (int i = 0; i < numMessages; i++) {
+            String key = "key-" + i;
+            String value = "value-" + i;
+            kvs.put(key, value);
+            producer.newMessage()
+                    .key(key)
+                    .value(value)
+                    .send();
+        }
+        return kvs;
+    }
+
+    protected void testFunctionLocalRun(Runtime runtime) throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
+            return;
+        }
+
+
+        String inputTopicName =
+                "persistent://public/default/test-function-local-run-" + runtime + "-input-" + randomName(8);
+        String outputTopicName = "test-function-local-run-" + runtime + "-output-" + randomName(8);
+
+        final int numMessages = 10;
+        String cmd = "";
+        CommandGenerator commandGenerator = new CommandGenerator();
+        commandGenerator.setAdminUrl("pulsar://pulsar-broker-0:6650");
+        commandGenerator.setSourceTopic(inputTopicName);
+        commandGenerator.setSinkTopic(outputTopicName);
+        commandGenerator.setFunctionName("localRunTest-" + randomName(8));
+        commandGenerator.setRuntime(runtime);
+        switch (runtime) {
+            case JAVA:
+                commandGenerator.setFunctionClassName(EXCLAMATION_JAVA_CLASS);
+                cmd = commandGenerator.generateLocalRunCommand(null);
+                break;
+            case PYTHON:
+                commandGenerator.setFunctionClassName(EXCLAMATION_PYTHON_CLASS);
+                cmd = commandGenerator.generateLocalRunCommand(EXCLAMATION_PYTHON_FILE);
+                break;
+            case GO:
+                commandGenerator.setFunctionClassName(null);
+                cmd = commandGenerator.generateLocalRunCommand(EXCLAMATION_GO_FILE);
+                break;
+        }
+
+        log.info("cmd: {}", cmd);
+        pulsarCluster.getAnyWorker().execCmdAsync(cmd.split(" "));
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+            retryStrategically((test) -> {
+                try {
+                    return admin.topics().getStats(inputTopicName).getSubscriptions().size() == 1;
+                } catch (PulsarAdminException e) {
+                    return false;
+                }
+            }, 30, 200);
+
+            assertEquals(admin.topics().getStats(inputTopicName).getSubscriptions().size(), 1);
+
+            // publish and consume result
+            if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+                // java and python supports schema
+                @Cleanup PulsarClient client = PulsarClient.builder()
+                        .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                        .build();
+
+                @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                        .topic(outputTopicName)
+                        .subscriptionType(SubscriptionType.Exclusive)
+                        .subscriptionName("test-sub")
+                        .subscribe();
+
+                @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
+                        .topic(inputTopicName)
+                        .create();
+
+                for (int i = 0; i < numMessages; i++) {
+                    producer.send("message-" + i);
+                }
+
+                Set<String> expectedMessages = new HashSet<>();
+                for (int i = 0; i < numMessages; i++) {
+                    expectedMessages.add("message-" + i + "!");
+                }
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<String> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
+                    log.info("Received: {}", msg.getValue());
+                    assertTrue(expectedMessages.contains(msg.getValue()));
+                    expectedMessages.remove(msg.getValue());
+                }
+                assertEquals(expectedMessages.size(), 0);
+
+            } else {
+                // golang doesn't support schema
+
+                @Cleanup PulsarClient client = PulsarClient.builder()
+                        .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                        .build();
+                @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
+                        .topic(outputTopicName)
+                        .subscriptionType(SubscriptionType.Exclusive)
+                        .subscriptionName("test-sub")
+                        .subscribe();
+
+                @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
+                        .topic(inputTopicName)
+                        .enableBatching(true)
+                        .batcherBuilder(BatcherBuilder.DEFAULT)
+                        .create();
+
+                for (int i = 0; i < numMessages; i++) {
+                    producer.newMessage().value(("message-" + i).getBytes(UTF_8)).send();
+                }
+
+                Set<String> expectedMessages = new HashSet<>();
+                for (int i = 0; i < numMessages; i++) {
+                    expectedMessages.add("message-" + i + "!");
+                }
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<byte[]> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
+                    String msgValue = new String(msg.getValue(), UTF_8);
+                    log.info("Received: {}", msgValue);
+                    assertTrue(expectedMessages.contains(msgValue));
+                    expectedMessages.remove(msgValue);
+                }
+                assertEquals(expectedMessages.size(), 0);
+            }
+        }
+
+    }
+
+    protected void testWindowFunction(String type, String[] expectedResults) throws Exception {
+        int numOfMessages = 100;
+        int windowLengthCount = 10;
+        int slidingIntervalCount = 5;
+        String functionName = "test-" + type + "-window-fn-" + randomName(8);
+
+        String inputTopicName = "test-" + type + "-count-window-" + functionRuntimeType + "-input-" + randomName(8);
+        String outputTopicName = "test-" + type + "-count-window-" + functionRuntimeType + "-output-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+
+        CommandGenerator generator = CommandGenerator.createDefaultGenerator(
+                inputTopicName,
+                "org.apache.pulsar.functions.api.examples.WindowDurationFunction");
+        generator.setFunctionName(functionName);
+        generator.setSinkTopic(outputTopicName);
+        generator.setWindowLengthCount(windowLengthCount);
+        if (type.equals("sliding")) {
+            generator.setSlidingIntervalCount(slidingIntervalCount);
+        }
+
+
+        String[] commands = {
+                "sh", "-c", generator.generateCreateFunctionCommand()
+        };
+
+        ContainerExecResult containerExecResult = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(containerExecResult.getStdout().contains("Created successfully"));
+
+        // get function info
+        getFunctionInfoSuccess(functionName);
+
+        containerExecResult = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        FunctionStatus functionStatus = FunctionStatusUtil.decode(containerExecResult.getStdout());
+        assertEquals(functionStatus.getNumInstances(), 1);
+        assertEquals(functionStatus.getNumRunning(), 1);
+        assertEquals(functionStatus.getInstances().size(), 1);
+        assertEquals(functionStatus.getInstances().get(0).getInstanceId(), 0);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumReceived(), 0);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumSuccessfullyProcessed(), 0);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestUserExceptions().size(), 0);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        Reader<byte[]> reader = client.newReader().startMessageId(MessageId.earliest)
+                .topic(outputTopicName)
+                .create();
+
+        @Cleanup
+        Producer<byte[]> producer = client.newProducer(Schema.BYTES)
+                .topic(inputTopicName)
+                .enableBatching(false)
+                .create();
+
+        // send 3 messages first, and it won't trigger the window and so these 3 messages will not be acked
+        for (int i = 0; i < 3; i++) {
+            producer.send(String.format("%d", i).getBytes());
+        }
+        TopicStats stats = pulsarAdmin.topics().getStats(inputTopicName, true);
+        SubscriptionStats subStats = stats.getSubscriptions().get("public/default/" + functionName);
+        assertNotNull(subStats);
+        assertEquals(3, subStats.getMsgBacklog());
+        assertEquals(3, subStats.getUnackedMessages());
+
+        for (int i = 3; i < numOfMessages; i++) {
+            producer.send(String.format("%d", i).getBytes());
+        }
+
+        int i = 0;
+        while (true) {
+            if (i > expectedResults.length) {
+                Assertions.fail("More results than expected");
+            }
+
+            Message<byte[]> msg = reader.readNext(30, TimeUnit.SECONDS);
+            if (msg == null) {
+                break;
+            }
+            String msgStr = new String(msg.getData());
+            log.info("[testWindowFunction] i: {} RECV: {}", i, msgStr);
+            String result = msgStr.split(":")[0];
+            assertThat(result).contains(expectedResults[i]);
+            i++;
+        }
+
+        getFunctionStatus(functionName, numOfMessages, true);
+
+        // in case last commit is not updated
+        assertThat(i).isGreaterThanOrEqualTo(expectedResults.length - 1);
+
+        // test that all messages are acked
+        stats = pulsarAdmin.topics().getStats(inputTopicName, true);
+        subStats = stats.getSubscriptions().get("public/default/" + functionName);
+        assertNotNull(subStats);
+        assertEquals(0, subStats.getMsgBacklog());
+        assertEquals(0, subStats.getUnackedMessages());
+
+        deleteFunction(functionName);
+
+        getFunctionInfoNotFound(functionName);
+    }
+
+    protected void testFunctionNegAck(Runtime runtime) throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
+            return;
+        }
+
+
+        Schema<?> schema;
+        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+            schema = Schema.STRING;
+        } else {
+            schema = Schema.BYTES;
+        }
+
+        String inputTopicName = "persistent://public/default/test-neg-ack-" + runtime + "-input-" + randomName(8);
+        String outputTopicName = "test-neg-ack-" + runtime + "-output-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+
+        String functionName = "test-neg-ack-fn-" + randomName(8);
+        final int numMessages = 20;
+
+        // submit the exclamation function
+
+        if (runtime == Runtime.PYTHON) {
+            submitFunction(
+                    runtime, inputTopicName, outputTopicName, functionName, EXCEPTION_FUNCTION_PYTHON_FILE,
+                    EXCEPTION_PYTHON_CLASS, schema, null);
+        } else {
+            submitFunction(
+                    runtime, inputTopicName, outputTopicName, functionName, null, EXCEPTION_JAVA_CLASS, schema, null);
+        }
+
+        // get function info
+        getFunctionInfoSuccess(functionName);
+
+        // get function stats
+        getFunctionStatsEmpty(functionName);
+
+        // publish and consume result
+        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+            // java and python supports schema
+            @Cleanup PulsarClient client = PulsarClient.builder()
+                    .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                    .build();
+            @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                    .topic(outputTopicName)
+                    .subscriptionType(SubscriptionType.Exclusive)
+                    .subscriptionName("test-sub")
+                    .subscribe();
+            @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                producer.send("message-" + i);
+            }
+
+            Set<String> expectedMessages = new HashSet<>();
+            for (int i = 0; i < numMessages; i++) {
+                expectedMessages.add("message-" + i + "!");
+            }
+
+            for (int i = 0; i < numMessages; i++) {
+                Message<String> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
+                log.info("Received: {}", msg.getValue());
+                assertTrue(expectedMessages.contains(msg.getValue()));
+                expectedMessages.remove(msg.getValue());
+            }
+            assertEquals(expectedMessages.size(), 0);
+
+        } else {
+            // golang doesn't support schema
+
+            @Cleanup PulsarClient client = PulsarClient.builder()
+                    .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                    .build();
+
+            @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
+                    .topic(outputTopicName)
+                    .subscriptionType(SubscriptionType.Exclusive)
+                    .subscriptionName("test-sub")
+                    .subscribe();
+
+            @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                producer.newMessage().value(("message-" + i).getBytes(UTF_8)).send();
+            }
+
+            Set<String> expectedMessages = new HashSet<>();
+            for (int i = 0; i < numMessages; i++) {
+                expectedMessages.add("message-" + i + "!");
+            }
+
+            for (int i = 0; i < numMessages; i++) {
+                Message<byte[]> msg = consumer.receive(60 * 2, TimeUnit.SECONDS);
+                String msgValue = new String(msg.getValue(), UTF_8);
+                log.info("Received: {}", msgValue);
+                assertTrue(expectedMessages.contains(msgValue));
+                expectedMessages.remove(msgValue);
+            }
+            assertEquals(expectedMessages.size(), 0);
+        }
+
+        // get function status
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
+
+        assertEquals(functionStatus.getNumInstances(), 1);
+        assertEquals(functionStatus.getNumRunning(), 1);
+        assertEquals(functionStatus.getInstances().size(), 1);
+        assertEquals(functionStatus.getInstances().get(0).getInstanceId(), 0);
+        assertTrue(functionStatus.getInstances().get(0).getStatus().getAverageLatency() > 0.0);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertTrue(functionStatus.getInstances().get(0).getStatus().getLastInvocationTime() > 0);
+        // going to receive two more tuples because of delivery
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumReceived(), numMessages + 2);
+        // only going to successfully process 20
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumSuccessfullyProcessed(), numMessages);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestUserExceptions().size(), 2);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+
+        // get function stats
+        result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "stats",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        log.info("FUNCTION STATS: {}", result.getStdout());
+
+        FunctionStatsImpl functionStats = FunctionStatsImpl.decode(result.getStdout());
+        assertEquals(functionStats.getReceivedTotal(), numMessages + 2);
+        assertEquals(functionStats.getProcessedSuccessfullyTotal(), numMessages);
+        assertEquals(functionStats.getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.getUserExceptionsTotal(), 2);
+        assertTrue(functionStats.avgProcessLatency > 0);
+        assertTrue(functionStats.getLastInvocation() > 0);
+
+        assertEquals(functionStats.instances.size(), 1);
+        assertEquals(functionStats.instances.get(0).getInstanceId(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getReceivedTotal(), numMessages + 2);
+        assertEquals(functionStats.instances.get(0).getMetrics().getProcessedSuccessfullyTotal(), numMessages);
+        assertEquals(functionStats.instances.get(0).getMetrics().getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getUserExceptionsTotal(), 2);
+        assertTrue(functionStats.instances.get(0).getMetrics().getAvgProcessLatency() > 0);
+
+        // delete function
+        deleteFunction(functionName);
+
+        // get function info
+        getFunctionInfoNotFound(functionName);
+
+        // make sure subscriptions are cleanup
+        checkSubscriptionsCleanup(inputTopicName);
+    }
+
+    public void testGoPublishFunction() throws Exception {
+        testPublishFunction(Runtime.GO);
+    }
+
+    protected void testPublishFunction(Runtime runtime) throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
+            return;
+        }
+
+        Schema<?> schema;
+        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+            schema = Schema.STRING;
+        } else {
+            schema = Schema.BYTES;
+        }
+
+
+        String inputTopicName = "persistent://public/default/test-publish-" + runtime + "-input-" + randomName(8);
+        String outputTopicName = "test-publish-" + runtime + "-output-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+
+        String functionName = "test-publish-fn-" + randomName(8);
+        final int numMessages = 10;
+
+        // submit the exclamation function
+        switch (runtime) {
+            case JAVA:
+                submitFunction(
+                        runtime,
+                        inputTopicName,
+                        outputTopicName,
+                        functionName,
+                        null,
+                        PUBLISH_JAVA_CLASS,
+                        schema,
+                        Collections.singletonMap("publish-topic", outputTopicName),
+                        null, null, null, null, null, null);
+                break;
+            case PYTHON:
+                ConsumerConfig consumerConfig = new ConsumerConfig();
+                consumerConfig.setSchemaType("string");
+                Map<String, String> inputSpecs = new HashMap<>() {{
+                    put(inputTopicName, objectMapper.writeValueAsString(consumerConfig));
+                }};
+                submitFunction(
+                        runtime,
+                        inputTopicName,
+                        outputTopicName,
+                        functionName,
+                        PUBLISH_FUNCTION_PYTHON_FILE,
+                        PUBLISH_PYTHON_CLASS,
+                        schema,
+                        Collections.singletonMap("publish-topic", outputTopicName),
+                        objectMapper.writeValueAsString(inputSpecs), "string", null, null, null, null);
+                break;
+            case GO:
+                submitFunction(
+                        runtime,
+                        inputTopicName,
+                        outputTopicName,
+                        functionName,
+                        PUBLISH_FUNCTION_GO_FILE,
+                        null,
+                        schema,
+                        Collections.singletonMap("publish-topic", outputTopicName),
+                        null, null, null, null, null, null);
+        }
+
+        // get function info
+        getFunctionInfoSuccess(functionName);
+
+        // get function stats
+        getFunctionStatsEmpty(functionName);
+
+        // publish and consume result
+
+        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+            // java and python supports schema
+            publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
+        } else {
+            // Does Go support schema? Maybe we need a switch instead for the Go case.
+
+            @Cleanup PulsarClient client = PulsarClient.builder()
+                    .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                    .build();
+
+            @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
+                    .topic(outputTopicName)
+                    .subscriptionType(SubscriptionType.Exclusive)
+                    .subscriptionName("test-sub")
+                    .subscribe();
+
+            @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                producer.newMessage().key(String.valueOf(i)).property("count", String.valueOf(i))
+                        .value(("message-" + i).getBytes(UTF_8)).send();
+            }
+
+            Set<String> expectedMessages = new HashSet<>();
+            for (int i = 0; i < numMessages; i++) {
+                expectedMessages.add("message-" + i + "!");
+            }
+
+            for (int i = 0; i < numMessages; i++) {
+                Message<byte[]> msg = consumer.receive(30, TimeUnit.SECONDS);
+                String msgValue = new String(msg.getValue(), UTF_8);
+                log.info("Received: {}", msgValue);
+                assertEquals(msg.getKey(), String.valueOf(i));
+                assertEquals(msg.getProperties().get("count"), String.valueOf(i));
+                assertEquals(msg.getProperties().get("input_topic"), inputTopicName);
+                assertTrue(msg.getEventTime() > 0);
+                assertTrue(expectedMessages.contains(msgValue));
+                expectedMessages.remove(msgValue);
+            }
+        }
+
+        // get function status
+        getFunctionStatus(functionName, numMessages, true);
+
+        // get function stats
+        getFunctionStats(functionName, numMessages);
+
+        // delete function
+        deleteFunction(functionName);
+
+        // get function info
+        getFunctionInfoNotFound(functionName);
+
+        // make sure subscriptions are cleanup
+        checkSubscriptionsCleanup(inputTopicName);
+    }
+
+    protected void testExclamationFunction(Runtime runtime,
+                                           boolean isTopicPattern,
+                                           boolean pyZip,
+                                           boolean multipleInput,
+                                           boolean withExtraDeps) throws Exception {
+        testExclamationFunction(runtime, isTopicPattern, pyZip, multipleInput, withExtraDeps, null, null, null);
+    }
+
+    protected void testExclamationFunction(Runtime runtime,
+                                           boolean isTopicPattern,
+                                           boolean pyZip,
+                                           boolean multipleInput,
+                                           boolean withExtraDeps,
+                                           ConsumerConfig consumerConfig) throws Exception {
+        testExclamationFunction(runtime, isTopicPattern, pyZip, multipleInput, withExtraDeps, null, null, null);
+    }
+
+    protected void testExclamationFunction(Runtime runtime,
+                                           boolean isTopicPattern,
+                                           boolean pyZip,
+                                           boolean multipleInput,
+                                           boolean withExtraDeps,
+                                           ProducerConfig producerConfig) throws Exception {
+        testExclamationFunction(runtime, isTopicPattern, pyZip, multipleInput, withExtraDeps, null,
+                producerConfig, null);
+    }
+
+    protected void testExclamationFunction(Runtime runtime,
+                                           boolean isTopicPattern,
+                                           boolean pyZip,
+                                           boolean multipleInput,
+                                           boolean withExtraDeps,
+                                           ConsumerConfig consumerConfig,
+                                           ProducerConfig producerConfig,
+                                           java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
+            throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD && (runtime == Runtime.PYTHON || runtime == Runtime.GO)) {
+            // python&go can only run on process mode
+            return;
+        }
+
+
+        Schema<?> schema;
+        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+            schema = Schema.STRING;
+        } else {
+            schema = Schema.BYTES;
+        }
+
+        String inputTopicName = "persistent://public/default/test-exclamation-" + runtime + "-input-" + randomName(8);
+        String outputTopicName = "test-exclamation-" + runtime + "-output-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+        if (isTopicPattern) {
+            inputTopicName = inputTopicName + ".*";
+        } else if (multipleInput) {
+            inputTopicName = inputTopicName + "1," + inputTopicName + "2";
+        }
+        String functionName = "test-exclamation-fn-" + randomName(8);
+        final int numMessages = 10;
+
+        // submit the exclamation function
+        submitExclamationFunction(
+                runtime, inputTopicName, outputTopicName, functionName, pyZip, withExtraDeps, schema,
+                commandGeneratorConsumer);
+
+        // get function info
+        final String info = getFunctionInfoSuccess(functionName);
+        FunctionConfig config = ObjectMapperFactory.getMapper().getObjectMapper().readValue(info, FunctionConfig.class);
+
+        // get function stats
+        getFunctionStatsEmpty(functionName);
+
+        // publish and consume result
+        if (Runtime.JAVA == runtime || Runtime.PYTHON == runtime) {
+            // java supports schema
+            publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
+        } else {
+            // golang doesn't support schema
+            publishAndConsumeMessagesBytes(inputTopicName, outputTopicName, numMessages);
+        }
+
+        // check batching config
+        if (runtime == Runtime.JAVA) {
+            BatchingConfig batchingConfig = null;
+            if (producerConfig != null && producerConfig.getBatchingConfig() != null) {
+                batchingConfig = producerConfig.getBatchingConfig();
+            }
+            checkLogs(functionName, batchingConfig, consumerConfig, config, inputTopicName);
+        }
+
+        // get function status
+        getFunctionStatus(functionName, numMessages, true);
+
+        if (Runtime.GO != runtime) {
+            // TODO: Go runtime doesn't collect `process_latency_ms_1min` metric
+            // get function stats
+            getFunctionStats(functionName, numMessages);
+        }
+
+        // update parallelism
+        updateFunctionParallelism(functionName, 2);
+
+        //get function status
+        getFunctionStatus(functionName, 0, true, 2);
+
+        // update code file
+        switch (runtime) {
+            case JAVA:
+                updateFunctionCodeFile(functionName, Runtime.JAVA, "test");
+                break;
+            case PYTHON:
+                updateFunctionCodeFile(functionName, Runtime.PYTHON, EXCLAMATION_PYTHON_FILE);
+                break;
+            case GO:
+                updateFunctionCodeFile(functionName, Runtime.GO, EXCLAMATION_GO_FILE);
+                break;
+        }
+
+        // check subscription type
+        checkSubscriptionType(inputTopicName, config);
+
+        // delete function
+        deleteFunction(functionName);
+
+        // get function info
+        getFunctionInfoNotFound(functionName);
+
+        // make sure subscriptions are cleanup
+        checkSubscriptionsCleanup(inputTopicName);
+
+    }
+
+    private void checkSubscriptionType(String topic, FunctionConfig config) {
+        List<String> topics = new ArrayList<>();
+        if (topic.endsWith(".*")) {
+            topics.add(topic.substring(0, topic.length() - 2) + "1");
+            topics.add(topic.substring(0, topic.length() - 2) + "2");
+        } else if (topic.contains(",")) {
+            topics.addAll(Arrays.asList(topic.split(",")));
+        } else {
+            topics.add(topic);
+        }
+        topics.stream().forEach(t -> {
+            try {
+                ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
+                        PulsarCluster.ADMIN_SCRIPT,
+                        "topics",
+                        "stats",
+                        t);
+                TopicStats topicStats = ObjectMapperFactory.getMapper().reader()
+                        .readValue(result.getStdout(), TopicStats.class);
+                assertEquals(topicStats.getSubscriptions().size(), 1);
+                final SubscriptionStats sub = topicStats.getSubscriptions().values().iterator()
+                        .next();
+                if (config.getRetainOrdering()) {
+                    assertEquals(sub.getType(), "Failover");
+                } else if (config.getRetainKeyOrdering()) {
+                    assertEquals(sub.getType(), "Key_Shared");
+                } else {
+                    assertEquals(sub.getType(), "Shared");
+                }
+            } catch (Exception e) {
+                fail("Command should have exited with non-zero");
+            }
+        });
+    }
+
+    // checking batching config/consumer config, we can only check this by checking the logs for now
+    private void checkLogs(String functionName, BatchingConfig config, ConsumerConfig consumerConfig,
+                           FunctionConfig functionConfig, String topic) {
+        if (config != null) {
+            assertNotNull(functionConfig.getProducerConfig());
+            assertNotNull(functionConfig.getProducerConfig().getBatchingConfig());
+            assertEquals(config.toString(), functionConfig.getProducerConfig().getBatchingConfig().toString());
+        }
+
+        String functionLogs = pulsarCluster.getFunctionLogs(functionName);
+        if (config == null || config.isEnabled()) {
+            BatchingConfig finalConfig = config;
+            if (finalConfig == null) {
+                finalConfig = BatchingConfig.builder().build();
+            }
+            assertTrue(functionLogs.contains(finalConfig.toString()));
+
+            // THREAD runtime doesn't include producer&consumer related logs in the function logs
+            if (functionRuntimeType == FunctionRuntimeType.PROCESS) {
+                if (finalConfig.getBatchingMaxMessages() == null) {
+                    finalConfig.setBatchingMaxMessages(1000);
+                }
+                if (finalConfig.getBatchingMaxBytes() == null) {
+                    finalConfig.setBatchingMaxBytes(128 * 1024);
+                }
+                if (finalConfig.getBatchingMaxPublishDelayMs() == null) {
+                    finalConfig.setBatchingMaxPublishDelayMs(10);
+                }
+                if (finalConfig.getRoundRobinRouterBatchingPartitionSwitchFrequency() == null) {
+                    finalConfig.setRoundRobinRouterBatchingPartitionSwitchFrequency(10);
+                }
+                String producerSpec = String.format(
+                        "\"batchingMaxPublishDelayMicros\":%d,\"batchingPartitionSwitchFrequencyByPublishDelay\":%d,"
+                                + "\"batchingMaxMessages\":%d,\"batchingMaxBytes\":%d,\"batchingEnabled\":%s",
+                        finalConfig.getBatchingMaxPublishDelayMs() * 1000,
+                        finalConfig.getRoundRobinRouterBatchingPartitionSwitchFrequency(),
+                        finalConfig.getBatchingMaxMessages(),
+                        finalConfig.getBatchingMaxBytes(), finalConfig.isEnabled());
+                assertTrue(functionLogs.contains(producerSpec));
+            }
+        } else {
+            assertTrue(functionLogs.contains("BatchingConfig(enabled=false"));
+            // THREAD runtime doesn't include producer&consumer related logs in the function logs
+            if (functionRuntimeType == FunctionRuntimeType.PROCESS) {
+                assertTrue(functionLogs.contains("\"batchingEnabled\":false"));
+            }
+        }
+
+        if (consumerConfig != null && consumerConfig.getMessagePayloadProcessorConfig() != null) {
+            MessagePayloadProcessorConfig payloadProcessorConfig = consumerConfig.getMessagePayloadProcessorConfig();
+            assertNotNull(functionConfig.getInputSpecs().get(topic));
+            assertNotNull(functionConfig.getInputSpecs().get(topic).getMessagePayloadProcessorConfig());
+            assertEquals(payloadProcessorConfig.toString(),
+                    functionConfig.getInputSpecs().get(topic).getMessagePayloadProcessorConfig().toString());
+
+            // THREAD runtime doesn't include producer&consumer related logs in the function logs
+            if (functionRuntimeType == FunctionRuntimeType.PROCESS) {
+                assertTrue(functionLogs.contains("Processing message using TestPayloadProcessor"));
+            }
+            if (payloadProcessorConfig.getConfig() == null || payloadProcessorConfig.getConfig().isEmpty()) {
+                assertTrue(functionLogs.contains("TestPayloadProcessor constructor without configs"));
+            } else {
+                String configs = payloadProcessorConfig.getConfig().entrySet().stream()
+                        .map(entry -> entry.getKey() + "=" + entry.getValue())
+                        .collect(Collectors.joining(", "));
+                String expectedLogs = String.format("TestPayloadProcessor constructor with configs %s", configs);
+                assertTrue(functionLogs.contains(expectedLogs));
+            }
+        }
+    }
+
+    private void submitExclamationFunction(Runtime runtime,
+                                           String inputTopicName,
+                                           String outputTopicName,
+                                           String functionName,
+                                           boolean pyZip,
+                                           boolean withExtraDeps,
+                                           Schema<?> schema) throws Exception {
+        submitExclamationFunction(runtime, inputTopicName, outputTopicName, functionName, pyZip,
+                withExtraDeps, schema, null);
+    }
+
+    private void submitExclamationFunction(Runtime runtime,
+                                           String inputTopicName,
+                                           String outputTopicName,
+                                           String functionName,
+                                           boolean pyZip,
+                                           boolean withExtraDeps,
+                                           Schema<?> schema,
+                                           java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
+            throws Exception {
+        submitFunction(
+                runtime,
+                inputTopicName,
+                outputTopicName,
+                functionName,
+                pyZip,
+                withExtraDeps,
+                false,
+                getExclamationClass(runtime, pyZip, withExtraDeps),
+                schema,
+                commandGeneratorConsumer);
+    }
+
+    private <T> void submitFunction(Runtime runtime,
+                                    String inputTopicName,
+                                    String outputTopicName,
+                                    String functionName,
+                                    boolean pyZip,
+                                    boolean withExtraDeps,
+                                    boolean isPublishFunction,
+                                    String functionClass,
+                                    Schema<T> inputTopicSchema,
+                                    java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
+            throws Exception {
+
+        String file = null;
+        if (Runtime.JAVA == runtime) {
+            file = null;
+        } else if (Runtime.PYTHON == runtime) {
+            if (isPublishFunction) {
+                file = PUBLISH_FUNCTION_PYTHON_FILE;
+            } else if (pyZip) {
+                file = EXCLAMATION_PYTHON_ZIP_FILE;
+            } else if (withExtraDeps) {
+                file = EXCLAMATION_WITH_DEPS_PYTHON_FILE;
+            } else {
+                file = EXCLAMATION_PYTHON_FILE;
+            }
+        } else if (Runtime.GO == runtime) {
+            if (isPublishFunction) {
+                file = PUBLISH_FUNCTION_GO_FILE;
+            } else {
+                file = EXCLAMATION_GO_FILE;
+            }
+        }
+
+        submitFunction(runtime, inputTopicName, outputTopicName, functionName, file, functionClass, inputTopicSchema,
+                commandGeneratorConsumer);
+    }
+
+    private <T> void submitFunction(Runtime runtime,
+                                    String inputTopicName,
+                                    String outputTopicName,
+                                    String functionName,
+                                    String functionFile,
+                                    String functionClass,
+                                    Schema<T> inputTopicSchema,
+                                    java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
+            throws Exception {
+        submitFunction(runtime, inputTopicName, outputTopicName, functionName, functionFile, functionClass,
+                inputTopicSchema, null, null, null, null, null, null,
+                commandGeneratorConsumer);
+    }
+
+    private <T> void submitFunction(Runtime runtime,
+                                    String inputTopicName,
+                                    String outputTopicName,
+                                    String functionName,
+                                    String functionFile,
+                                    String functionClass,
+                                    Schema<T> inputTopicSchema,
+                                    Map<String, String> userConfigs,
+                                    String customSchemaInputs,
+                                    String outputSchemaType,
+                                    SubscriptionInitialPosition subscriptionInitialPosition,
+                                    String inputTypeClassName,
+                                    String outputTypeClassName,
+                                    java.util.function.Consumer<CommandGenerator> commandGeneratorConsumer)
+            throws Exception {
+
+        if (StringUtils.isNotEmpty(inputTopicName)) {
+            ensureSubscriptionCreated(
+                    inputTopicName, String.format("public/default/%s", functionName), inputTopicSchema);
+        }
+
+        CommandGenerator generator;
+        log.info("------- INPUT TOPIC: '{}', customSchemaInputs: {}", inputTopicName, customSchemaInputs);
+        if (inputTopicName.endsWith(".*")) {
+            log.info("----- CREATING TOPIC PATTERN FUNCTION --- ");
+            generator = CommandGenerator.createTopicPatternGenerator(inputTopicName, functionClass);
+        } else {
+            log.info("----- CREATING REGULAR FUNCTION --- ");
+            generator = CommandGenerator.createDefaultGenerator(inputTopicName, functionClass);
+        }
+        generator.setSinkTopic(outputTopicName);
+        generator.setFunctionName(functionName);
+        if (userConfigs != null) {
+            generator.setUserConfig(userConfigs);
+        }
+        if (customSchemaInputs != null) {
+            generator.setCustomSchemaInputs(customSchemaInputs);
+        }
+        if (outputSchemaType != null) {
+            generator.setSchemaType(outputSchemaType);
+        }
+        if (subscriptionInitialPosition != null) {
+            generator.setSubscriptionInitialPosition(subscriptionInitialPosition);
+        }
+        if (inputTypeClassName != null) {
+            generator.setInputTypeClassName(inputTypeClassName);
+        }
+        if (outputTypeClassName != null) {
+            generator.setOutputTypeClassName(outputTypeClassName);
+        }
+        if (commandGeneratorConsumer != null) {
+            commandGeneratorConsumer.accept(generator);
+        }
+        String command = "";
+
+        switch (runtime) {
+            case JAVA:
+                command = generator.generateCreateFunctionCommand();
+                break;
+            case PYTHON:
+            case GO:
+                generator.setRuntime(runtime);
+                command = generator.generateCreateFunctionCommand(functionFile);
+                break;
+            default:
+                throw new IllegalArgumentException("Unsupported runtime : " + runtime);
+        }
+
+        log.info("---------- Function command: {}", command);
+        String[] commands = {
+                "sh", "-c", command
+        };
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                commands);
+        log.info("---------- stdout is: {}", result.getStdout());
+        log.info("---------- stderr is: {}", result.getStderr());
+        assertTrue(result.getStdout().contains("Created successfully"));
+    }
+
+    private void updateFunctionParallelism(String functionName, int parallelism) throws Exception {
+
+        CommandGenerator generator = new CommandGenerator();
+        generator.setFunctionName(functionName);
+        generator.setParallelism(parallelism);
+        String command = generator.generateUpdateFunctionCommand();
+
+        log.info("---------- Function command: {}", command);
+        String[] commands = {
+                "sh", "-c", command
+        };
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                commands);
+        assertTrue(result.getStdout().contains("Updated successfully"));
+    }
+
+    private void updateFunctionCodeFile(String functionName, Runtime runtime, String codeFile) throws Exception {
+
+        CommandGenerator generator = new CommandGenerator();
+        generator.setFunctionName(functionName);
+        generator.setRuntime(runtime);
+        String command = generator.generateUpdateFunctionCommand(codeFile);
+
+        log.info("---------- Function command: {}", command);
+        String[] commands = {
+                "sh", "-c", command
+        };
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                commands);
+        assertTrue(result.getStdout().contains("Updated successfully"));
+    }
+
+    protected <T> void submitFunction(Runtime runtime,
+                                      String inputTopicName,
+                                      String outputTopicName,
+                                      String functionName,
+                                      String functionFile,
+                                      String functionClass,
+                                      Map<String, String> inputSerdeClassNames,
+                                      String outputSerdeClassName,
+                                      Map<String, String> userConfigs) throws Exception {
+
+        CommandGenerator generator;
+        log.info("------- INPUT TOPIC: '{}'", inputTopicName);
+        if (inputTopicName.endsWith(".*")) {
+            log.info("----- CREATING TOPIC PATTERN FUNCTION --- ");
+            generator = CommandGenerator.createTopicPatternGenerator(inputTopicName, functionClass);
+        } else {
+            log.info("----- CREATING REGULAR FUNCTION --- ");
+            generator = CommandGenerator.createDefaultGenerator(inputTopicName, functionClass);
+        }
+        generator.setSinkTopic(outputTopicName);
+        generator.setFunctionName(functionName);
+        generator.setCustomSerDeSourceTopics(inputSerdeClassNames);
+        generator.setOutputSerDe(outputSerdeClassName);
+        if (userConfigs != null) {
+            generator.setUserConfig(userConfigs);
+        }
+        String command;
+        if (Runtime.JAVA == runtime) {
+            command = generator.generateCreateFunctionCommand();
+        } else if (Runtime.PYTHON == runtime) {
+            generator.setRuntime(runtime);
+            command = generator.generateCreateFunctionCommand(functionFile);
+        } else {
+            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
+        }
+
+        log.info("---------- Function command: {}", command);
+        String[] commands = {
+                "sh", "-c", command
+        };
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                commands);
+        assertTrue(result.getStdout().contains("Created successfully"));
+    }
+
+    @SuppressWarnings("try")
+    private <T> void ensureSubscriptionCreated(String inputTopicName,
+                                               String subscriptionName,
+                                               Schema<T> inputTopicSchema)
+            throws Exception {
+        // ensure the function subscription exists before we start producing messages
+        try (PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build()) {
+            List<String> topics = new ArrayList<>();
+            if (inputTopicName.endsWith(".*")) {
+                topics.add(inputTopicName.substring(0, inputTopicName.length() - 2) + "1");
+                topics.add(inputTopicName.substring(0, inputTopicName.length() - 2) + "2");
+            } else if (inputTopicName.contains(",")) {
+                topics.addAll(Arrays.asList(inputTopicName.split(",")));
+            } else {
+                topics.add(inputTopicName);
+            }
+            try (Consumer<T> ignored = client.newConsumer(inputTopicSchema)
+                    .topic(topics.toArray(new String[0]))
+                    .subscriptionType(SubscriptionType.Shared)
+                    .subscriptionName(subscriptionName)
+                    .subscribe()) {
+            }
+        }
+    }
+
+    protected String getFunctionInfoSuccess(String functionName) throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        log.info("FUNCTION STATE: {}", result.getStdout());
+        assertTrue(result.getStdout().contains("\"name\": \"" + functionName + "\""));
+        return result.getStdout();
+    }
+
+
+    protected void getFunctionStatsEmpty(String functionName) throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "stats",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        log.info("FUNCTION STATS: {}", result.getStdout());
+        FunctionStatsImpl functionStats = FunctionStatsImpl.decode(result.getStdout());
+
+        assertEquals(functionStats.getReceivedTotal(), 0);
+        assertEquals(functionStats.getProcessedSuccessfullyTotal(), 0);
+        assertEquals(functionStats.getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.getUserExceptionsTotal(), 0);
+        assertEquals(functionStats.avgProcessLatency, null);
+        assertEquals(functionStats.oneMin.getReceivedTotal(), 0);
+        assertEquals(functionStats.oneMin.getProcessedSuccessfullyTotal(), 0);
+        assertEquals(functionStats.oneMin.getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.oneMin.getUserExceptionsTotal(), 0);
+        assertEquals(functionStats.oneMin.getAvgProcessLatency(), null);
+        assertEquals(functionStats.getAvgProcessLatency(), functionStats.oneMin.getAvgProcessLatency());
+        assertEquals(functionStats.getLastInvocation(), null);
+
+        assertEquals(functionStats.instances.size(), 1);
+        assertEquals(functionStats.instances.get(0).getInstanceId(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getReceivedTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getProcessedSuccessfullyTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getUserExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getAvgProcessLatency(), null);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getReceivedTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getProcessedSuccessfullyTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getUserExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getAvgProcessLatency(), null);
+    }
+
+    private void getFunctionStats(String functionName, int numMessages) throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "stats",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        log.info("FUNCTION STATS: {}", result.getStdout());
+
+        FunctionStatsImpl functionStats = FunctionStatsImpl.decode(result.getStdout());
+        assertEquals(functionStats.getReceivedTotal(), numMessages);
+        assertEquals(functionStats.getProcessedSuccessfullyTotal(), numMessages);
+        assertEquals(functionStats.getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.getUserExceptionsTotal(), 0);
+        assertTrue(functionStats.avgProcessLatency > 0);
+        assertEquals(functionStats.oneMin.getReceivedTotal(), numMessages);
+        assertEquals(functionStats.oneMin.getProcessedSuccessfullyTotal(), numMessages);
+        assertEquals(functionStats.oneMin.getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.oneMin.getUserExceptionsTotal(), 0);
+        assertTrue(functionStats.oneMin.getAvgProcessLatency() > 0);
+        assertEquals(functionStats.getAvgProcessLatency(), functionStats.oneMin.getAvgProcessLatency());
+        assertTrue(functionStats.getLastInvocation() > 0);
+
+        assertEquals(functionStats.instances.size(), 1);
+        assertEquals(functionStats.instances.get(0).getInstanceId(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getReceivedTotal(), numMessages);
+        assertEquals(functionStats.instances.get(0).getMetrics().getProcessedSuccessfullyTotal(), numMessages);
+        assertEquals(functionStats.instances.get(0).getMetrics().getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getUserExceptionsTotal(), 0);
+        assertTrue(functionStats.instances.get(0).getMetrics().getAvgProcessLatency() > 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getReceivedTotal(), numMessages);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getProcessedSuccessfullyTotal(),
+                numMessages);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getSystemExceptionsTotal(), 0);
+        assertEquals(functionStats.instances.get(0).getMetrics().getOneMin().getUserExceptionsTotal(), 0);
+        assertTrue(functionStats.instances.get(0).getMetrics().getOneMin().getAvgProcessLatency() > 0);
+    }
+
+    private void getFunctionInfoNotFound(String functionName) throws Exception {
+        retryStrategically(aVoid -> {
+            try {
+                pulsarCluster.getAnyWorker().execCmd(
+                        PulsarCluster.ADMIN_SCRIPT,
+                        "functions",
+                        "get",
+                        "--tenant", "public",
+                        "--namespace", "default",
+                        "--name", functionName);
+            } catch (ContainerExecException e) {
+                if (e.getResult().getStderr().contains("Reason: Function " + functionName + " doesn't exist")) {
+                    return true;
+                }
+
+            } catch (Exception e) {
+
+            }
+            return false;
+        }, 5, 100, true);
+    }
+
+    private void checkSubscriptionsCleanup(String topic) throws Exception {
+        List<String> topics = new ArrayList<>();
+        if (topic.endsWith(".*")) {
+            topics.add(topic.substring(0, topic.length() - 2) + "1");
+            topics.add(topic.substring(0, topic.length() - 2) + "2");
+        } else if (topic.contains(",")) {
+            topics.addAll(Arrays.asList(topic.split(",")));
+        } else {
+            topics.add(topic);
+        }
+        topics.stream().forEach(t -> {
+            try {
+                ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
+                        PulsarCluster.ADMIN_SCRIPT,
+                        "topics",
+                        "stats",
+                        t);
+                TopicStats topicStats = ObjectMapperFactory.getMapper().reader()
+                        .readValue(result.getStdout(), TopicStats.class);
+                assertEquals(topicStats.getSubscriptions().size(), 0);
+            } catch (Exception e) {
+                fail("Command should have exited with non-zero");
+            }
+        });
+    }
+
+    private void checkPublisherCleanup(String topic) throws Exception {
+        try {
+            ContainerExecResult result = pulsarCluster.getAnyBroker().execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "topics",
+                    "stats",
+                    topic);
+            TopicStats topicStats = ObjectMapperFactory.getMapper().reader()
+                    .readValue(result.getStdout(), TopicStats.class);
+            assertEquals(topicStats.getPublishers().size(), 0);
+
+        } catch (ContainerExecException e) {
+            fail("Command should have exited with non-zero");
+        }
+    }
+
+    private void getFunctionStatus(String functionName, int numMessages, boolean checkRestarts) throws Exception {
+        getFunctionStatus(functionName, numMessages, checkRestarts, 1);
+    }
+
+    private void getFunctionStatus(String functionName, int numMessages, boolean checkRestarts, int parallelism)
+            throws Exception {
+        Awaitility.await()
+                .pollInterval(Duration.ofSeconds(1))
+                .atMost(Duration.ofSeconds(15))
+                .ignoreExceptions()
+                .untilAsserted(() ->
+                        doGetFunctionStatus(functionName, numMessages, checkRestarts, parallelism));
+    }
+
+    private void doGetFunctionStatus(String functionName, int numMessages, boolean checkRestarts, int parallelism)
+            throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
+
+        assertEquals(functionStatus.getNumInstances(), parallelism);
+        assertEquals(functionStatus.getNumRunning(), parallelism);
+        assertEquals(functionStatus.getInstances().size(), parallelism);
+        boolean avgLatencyGreaterThanZero = false;
+        int totalMessagesProcessed = 0;
+        int totalMessagesSuccessfullyProcessed = 0;
+        boolean lastInvocationTimeGreaterThanZero = false;
+        for (int i = 0; i < parallelism; ++i) {
+            assertEquals(functionStatus.getInstances().get(i).getStatus().isRunning(), true);
+            assertTrue(functionStatus.getInstances().get(i).getInstanceId() >= 0);
+            assertTrue(functionStatus.getInstances().get(i).getInstanceId() < parallelism);
+            avgLatencyGreaterThanZero = avgLatencyGreaterThanZero
+                    || functionStatus.getInstances().get(i).getStatus().getAverageLatency() > 0.0;
+            lastInvocationTimeGreaterThanZero = lastInvocationTimeGreaterThanZero
+                    || functionStatus.getInstances().get(i).getStatus().getLastInvocationTime() > 0;
+            totalMessagesProcessed += functionStatus.getInstances().get(i).getStatus().getNumReceived();
+            totalMessagesSuccessfullyProcessed +=
+                    functionStatus.getInstances().get(i).getStatus().getNumSuccessfullyProcessed();
+            if (checkRestarts) {
+                assertEquals(functionStatus.getInstances().get(i).getStatus().getNumRestarts(), 0);
+            }
+            assertEquals(functionStatus.getInstances().get(i).getStatus().getLatestUserExceptions().size(), 0);
+            assertEquals(functionStatus.getInstances().get(i).getStatus().getLatestSystemExceptions().size(), 0);
+        }
+        if (numMessages > 0) {
+            assertTrue(avgLatencyGreaterThanZero);
+            assertTrue(lastInvocationTimeGreaterThanZero);
+        }
+        assertEquals(totalMessagesProcessed, numMessages);
+        assertEquals(totalMessagesSuccessfullyProcessed, numMessages);
+    }
+
+    private void publishAndConsumeMessages(String inputTopic,
+                                           String outputTopic,
+                                           int numMessages) throws Exception {
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(outputTopic)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-sub")
+                .subscribe();
+
+        if (inputTopic.endsWith(".*")) {
+            @Cleanup Producer<String> producer1 = client.newProducer(Schema.STRING)
+                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "1")
+                    .create();
+
+            @Cleanup Producer<String> producer2 = client.newProducer(Schema.STRING)
+                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "2")
+                    .create();
+
+            for (int i = 0; i < numMessages / 2; i++) {
+                producer1.send("message-" + i);
+            }
+
+            for (int i = numMessages / 2; i < numMessages; i++) {
+                producer2.send("message-" + i);
+            }
+        } else {
+            @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(inputTopic)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                producer.send("message-" + i);
+            }
+        }
+
+        Set<String> expectedMessages = new HashSet<>();
+        for (int i = 0; i < numMessages; i++) {
+            expectedMessages.add("message-" + i + "!");
+        }
+
+        for (int i = 0; i < numMessages; i++) {
+            log.info("Trying to receive message.. {}/{}", i, numMessages);
+            Message<String> msg = consumer.receive(30, TimeUnit.MINUTES);
+            log.info("Received: {}", msg.getValue());
+            assertTrue(expectedMessages.contains(msg.getValue()));
+            expectedMessages.remove(msg.getValue());
+        }
+    }
+
+    private void publishAndConsumeMessagesBytes(String inputTopic,
+                                                String outputTopic,
+                                                int numMessages) throws Exception {
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
+                .topic(outputTopic)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-sub")
+                .subscribe();
+
+        if (inputTopic.endsWith(".*")) {
+            @Cleanup Producer<byte[]> producer1 = client.newProducer(Schema.BYTES)
+                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "1")
+                    .create();
+
+            @Cleanup Producer<byte[]> producer2 = client.newProducer(Schema.BYTES)
+                    .topic(inputTopic.substring(0, inputTopic.length() - 2) + "2")
+                    .create();
+
+            for (int i = 0; i < numMessages / 2; i++) {
+                producer1.send(("message-" + i).getBytes(UTF_8));
+            }
+
+            for (int i = numMessages / 2; i < numMessages; i++) {
+                producer2.send(("message-" + i).getBytes(UTF_8));
+            }
+        } else if (inputTopic.contains(",")) {
+            String[] topics = inputTopic.split(",");
+            @Cleanup Producer<byte[]> producer1 = client.newProducer(Schema.BYTES)
+                    .topic(topics[0])
+                    .create();
+
+            @Cleanup Producer<byte[]> producer2 = client.newProducer(Schema.BYTES)
+                    .topic(topics[1])
+                    .create();
+
+            for (int i = 0; i < numMessages / 2; i++) {
+                producer1.send(("message-" + i).getBytes(UTF_8));
+            }
+
+            for (int i = numMessages / 2; i < numMessages; i++) {
+                producer2.send(("message-" + i).getBytes(UTF_8));
+            }
+        } else {
+            @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
+                    .topic(inputTopic)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                producer.send(("message-" + i).getBytes(UTF_8));
+            }
+        }
+
+        Set<String> expectedMessages = new HashSet<>();
+        for (int i = 0; i < numMessages; i++) {
+            expectedMessages.add("message-" + i + "!");
+        }
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<byte[]> msg = consumer.receive(30, TimeUnit.SECONDS);
+            String msgValue = new String(msg.getValue(), UTF_8);
+            log.info("Received: {}", msgValue);
+            assertTrue(expectedMessages.contains(msgValue));
+            expectedMessages.remove(msgValue);
+        }
+    }
+
+    private void deleteFunction(String functionName) throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+        assertTrue(result.getStdout().contains("Deleted successfully"));
+        result.assertNoStderr();
+    }
+
+    protected void testAutoSchemaFunction() throws Exception {
+        String inputTopicName = "test-autoschema-input-" + randomName(8);
+        String outputTopicName = "test-autoschema-output-" + randomName(8);
+        String functionName = "test-autoschema-fn-" + randomName(8);
+        final int numMessages = 10;
+
+
+        // submit the exclamation function
+        submitFunction(
+                Runtime.JAVA,
+                inputTopicName,
+                outputTopicName,
+                functionName,
+                false,
+                false,
+                false,
+                AutoSchemaFunction.class.getName(),
+                Schema.AVRO(CustomObject.class),
+                null);
+
+        // get function info
+        getFunctionInfoSuccess(functionName);
+
+        // publish and consume result
+        publishAndConsumeAvroMessages(inputTopicName, outputTopicName, numMessages);
+
+        // get function status. Note that this function might restart a few times until
+        // the producer above writes the messages.
+        getFunctionStatus(functionName, numMessages, false);
+
+        // delete function
+        deleteFunction(functionName);
+
+        // get function info
+        getFunctionInfoNotFound(functionName);
+    }
+
+    private void publishAndConsumeAvroMessages(String inputTopic,
+                                               String outputTopic,
+                                               int numMessages) throws Exception {
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(outputTopic)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-sub")
+                .subscribe();
+
+        @Cleanup Producer<CustomObject> producer = client.newProducer(Schema.AVRO(CustomObject.class))
+                .topic(inputTopic)
+                .create();
+
+        for (int i = 0; i < numMessages; i++) {
+            CustomObject co = new CustomObject(i);
+            producer.send(co);
+        }
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<String> msg = consumer.receive();
+            assertEquals("value-" + i, msg.getValue());
+        }
+    }
+
+    protected void testAvroSchemaFunction(Runtime runtime) throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD && runtime == Runtime.PYTHON) {
+            // python can only run on process mode
+            return;
+        }
+
+        log.info("testAvroSchemaFunction start ...");
+        final String inputTopic = "test-avroschema-input-" + randomName(8);
+        final String outputTopic = "test-avroschema-output-" + randomName(8);
+        final String functionName = "test-avroschema-fn-" + randomName(8);
+        final int numMessages = 10;
+
+        @Cleanup PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
+        log.info("pulsar client init - input: {}, output: {}", inputTopic, outputTopic);
+
+        @Cleanup Producer<AvroTestObject> producer = pulsarClient
+                .newProducer(Schema.AVRO(AvroTestObject.class))
+                .topic(inputTopic).create();
+        log.info("pulsar producer init - {}", inputTopic);
+
+        @Cleanup Consumer<AvroTestObject> consumer = pulsarClient
+                .newConsumer(Schema.AVRO(AvroTestObject.class))
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-avro-schema")
+                .topic(outputTopic)
+                .subscribe();
+        log.info("pulsar consumer init - {}", outputTopic);
+
+        CompletableFuture<Optional<SchemaInfo>> inputSchemaFuture =
+                ((PulsarClientImpl) pulsarClient).getSchema(inputTopic);
+        inputSchemaFuture.whenComplete((schemaInfo, throwable) -> {
+            if (schemaInfo.isPresent()) {
+                log.info("inputSchemaInfo: {}", schemaInfo.get().toString());
+            } else {
+                log.error("input schema is not present!");
+            }
+        });
+
+        CompletableFuture<Optional<SchemaInfo>> outputSchemaFuture =
+                ((PulsarClientImpl) pulsarClient).getSchema(outputTopic);
+        outputSchemaFuture.whenComplete((schemaInfo, throwable) -> {
+            if (throwable != null) {
+                log.error("get output schemaInfo error", throwable);
+                throwable.printStackTrace();
+                return;
+            }
+            if (schemaInfo.isPresent()) {
+                log.info("outputSchemaInfo: {}", schemaInfo.get().toString());
+            } else {
+                log.error("output schema is not present!");
+            }
+        });
+
+        if (runtime == Runtime.JAVA) {
+            submitFunction(
+                    Runtime.JAVA,
+                    inputTopic,
+                    outputTopic,
+                    functionName,
+                    null,
+                    AvroSchemaTestFunction.class.getName(),
+                    Schema.AVRO(AvroTestObject.class),
+                    null);
+        } else if (runtime == Runtime.PYTHON) {
+            ConsumerConfig consumerConfig = new ConsumerConfig();
+            consumerConfig.setSchemaType("avro");
+            Map<String, String> inputSpecs = new HashMap<>() {{
+                put(inputTopic, objectMapper.writeValueAsString(consumerConfig));
+            }};
+            submitFunction(
+                    Runtime.PYTHON,
+                    inputTopic,
+                    outputTopic,
+                    functionName,
+                    AVRO_SCHEMA_FUNCTION_PYTHON_FILE,
+                    AVRO_SCHEMA_PYTHON_CLASS,
+                    Schema.AVRO(AvroTestObject.class),
+                    null, objectMapper.writeValueAsString(inputSpecs), "avro", null,
+                    "avro_schema_test_function.AvroTestObject", "avro_schema_test_function.AvroTestObject",
+                    null);
+        }
+        log.info("pulsar submitFunction");
+
+        getFunctionInfoSuccess(functionName);
+
+        AvroSchemaTestFunction function = new AvroSchemaTestFunction();
+        Set<Object> expectedSet = new HashSet<>();
+
+        log.info("test-avro-schema producer connected: " + producer.isConnected());
+        for (int i = 0; i < numMessages; i++) {
+            AvroTestObject inputObject = new AvroTestObject();
+            inputObject.setBaseValue(i);
+            MessageId messageId = producer.send(inputObject);
+            log.info("test-avro-schema messageId: {}", messageId.toString());
+            expectedSet.add(function.process(inputObject, null));
+            log.info("test-avro-schema expectedSet size: {}", expectedSet.size());
+        }
+        getFunctionStatus(functionName, numMessages, false);
+        log.info("test-avro-schema producer send message finish");
+
+        CompletableFuture<Optional<SchemaInfo>> outputSchemaFuture2 =
+                ((PulsarClientImpl) pulsarClient).getSchema(outputTopic);
+        outputSchemaFuture2.whenComplete((schemaInfo, throwable) -> {
+            if (throwable != null) {
+                log.error("get output schemaInfo error", throwable);
+                throwable.printStackTrace();
+                return;
+            }
+            if (schemaInfo.isPresent()) {
+                log.info("outputSchemaInfo: {}", schemaInfo.get().toString());
+            } else {
+                log.error("output schema is not present!");
+            }
+        });
+
+        log.info("test-avro-schema consumer connected: " + consumer.isConnected());
+        for (int i = 0; i < numMessages; i++) {
+            log.info("test-avro-schema consumer receive [{}] start", i);
+            Message<AvroTestObject> message = consumer.receive();
+            log.info("test-avro-schema consumer receive [{}] over", i);
+            AvroTestObject outputObject = message.getValue();
+            assertTrue(expectedSet.contains(outputObject));
+            expectedSet.remove(outputObject);
+            consumer.acknowledge(message);
+        }
+        log.info("test-avro-schema consumer receive message finish");
+
+        assertEquals(expectedSet.size(), 0);
+
+        deleteFunction(functionName);
+
+        getFunctionInfoNotFound(functionName);
+    }
+
+
+    protected void testInitFunction(Runtime runtime) throws Exception {
+        if (runtime != Runtime.JAVA) {
+            // only java support init function
+            return;
+        }
+
+        Schema<?> schema = Schema.STRING;
+
+        String inputTopicName = "persistent://public/default/test-init-" + runtime + "-input-" + randomName(8);
+        String outputTopicName = "test-init-" + runtime + "-output-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+
+        String functionName = "test-init-fn-" + randomName(8);
+        final int numMessages = 10;
+
+        // submit the exclamation function
+        submitFunction(runtime, inputTopicName, outputTopicName, functionName, null,
+                InitializableFunction.class.getName(), schema,
+                Collections.singletonMap("publish-topic", outputTopicName), null, null, null, null, null, null);
+
+        // publish and consume result
+        publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
+
+        // delete function
+        deleteFunction(functionName);
+    }
+
+    protected void testLoggingFunction(Runtime runtime) throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD && runtime == Runtime.PYTHON) {
+            // python can only run on process mode
+            return;
+        }
+
+        if (functionRuntimeType == FunctionRuntimeType.THREAD && runtime == Runtime.GO) {
+            // go can only run on process mode
+            return;
+        }
+
+
+        Schema<?> schema;
+        if (Runtime.JAVA == runtime) {
+            schema = Schema.STRING;
+        } else {
+            schema = Schema.BYTES;
+        }
+
+        String inputTopicName = "persistent://public/default/test-log-" + runtime + "-input-" + randomName(8);
+        String logTopicName = "test-log-" + runtime + "-log-topic-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(logTopicName);
+        }
+
+        String functionName = "test-logging-fn-" + randomName(8);
+        final int numMessages = 10;
+
+        // submit the exclamation function
+        submitJavaLoggingFunction(
+                inputTopicName, logTopicName, functionName, schema);
+
+        // get function info
+        getFunctionInfoSuccess(functionName);
+
+        // get function stats
+        getFunctionStatsEmpty(functionName);
+
+        try {
+            // publish and consume result
+            publishAndConsumeMessages(inputTopicName, logTopicName, numMessages, "-log");
+        } finally {
+            // dump function logs so that it's easier to investigate failures
+            pulsarCluster.dumpFunctionLogs(functionName);
+        }
+
+        // get function status
+        getFunctionStatus(functionName, numMessages, true);
+
+        // get function stats
+        getFunctionStats(functionName, numMessages);
+
+        // delete function
+        deleteFunction(functionName);
+
+        // get function info
+        getFunctionInfoNotFound(functionName);
+
+        // make sure subscriptions are cleanup
+        checkSubscriptionsCleanup(inputTopicName);
+        checkPublisherCleanup(logTopicName);
+
+    }
+
+    private void submitJavaLoggingFunction(String inputTopicName,
+                                           String logTopicName,
+                                           String functionName,
+                                           Schema<?> schema) throws Exception {
+        ensureSubscriptionCreated(inputTopicName, String.format("public/default/%s", functionName), schema);
+
+        CommandGenerator generator;
+        log.info("------- INPUT TOPIC: '{}'", inputTopicName);
+        if (inputTopicName.endsWith(".*")) {
+            log.info("----- CREATING TOPIC PATTERN FUNCTION --- ");
+            generator = CommandGenerator.createTopicPatternGenerator(inputTopicName, LOGGING_JAVA_CLASS);
+        } else {
+            log.info("----- CREATING REGULAR FUNCTION --- ");
+            generator = CommandGenerator.createDefaultGenerator(inputTopicName, LOGGING_JAVA_CLASS);
+        }
+        generator.setLogTopic(logTopicName);
+        generator.setFunctionName(functionName);
+        String command = generator.generateCreateFunctionCommand();
+
+        log.info("---------- Function command: {}", command);
+        String[] commands = {
+                "sh", "-c", command
+        };
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                commands);
+        assertTrue(result.getStdout().contains("Created successfully"));
+    }
+
+    private void publishAndConsumeMessages(String inputTopic,
+                                           String outputTopic,
+                                           int numMessages,
+                                           String messagePostfix) throws Exception {
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup Consumer<byte[]> consumer = client.newConsumer()
+                .topic(outputTopic)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-sub")
+                .subscribe();
+
+        @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .create();
+
+        for (int i = 0; i < numMessages; i++) {
+            producer.send("message-" + i);
+        }
+
+        Set<String> expectedMessages = new HashSet<>();
+        for (int i = 0; i < numMessages; i++) {
+            expectedMessages.add("message-" + i + messagePostfix);
+        }
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<byte[]> msg = consumer.receive(30, TimeUnit.SECONDS);
+            if (msg == null) {
+                log.info("Input topic stats: {}",
+                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
+                                pulsarAdmin.topics().getStats(inputTopic, true)));
+                log.info("Output topic stats: {}",
+                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
+                                pulsarAdmin.topics().getStats(outputTopic, true)));
+                log.info("Input topic internal-stats: {}",
+                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
+                                pulsarAdmin.topics().getInternalStats(inputTopic, true)));
+                log.info("Output topic internal-stats: {}",
+                        objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
+                                pulsarAdmin.topics().getInternalStats(outputTopic, true)));
+            } else {
+                String logMsg = new String(msg.getValue(), UTF_8);
+                log.info("Received message: '{}'", logMsg);
+                assertTrue(expectedMessages.contains(logMsg), "Message '" + logMsg + "' not expected");
+                expectedMessages.remove(logMsg);
+            }
+        }
+
+        consumer.close();
+        producer.close();
+        client.close();
+    }
+
+
+    protected void testGenericObjectFunction(String function, boolean removeAgeField, boolean keyValue)
+            throws Exception {
+        log.info("start {} function test ...", function);
+
+        String ns = "public/ns-genericobject-" + randomName(8);
+        @Cleanup
+        PulsarAdmin pulsarAdmin = getPulsarAdmin();
+        pulsarAdmin.namespaces().createNamespace(ns);
+
+        @Cleanup
+        PulsarClient pulsarClient = getPulsarClient();
+
+        final int numMessages = 10;
+        final String inputTopic = ns + "/test-object-input-" + randomName(8);
+        final String outputTopic = ns + "/test-object-output" + randomName(8);
+        @Cleanup
+        Consumer<GenericRecord> consumer = pulsarClient
+                .newConsumer(Schema.AUTO_CONSUME())
+                .subscriptionName("test")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .topic(outputTopic)
+                .subscribe();
+
+        final String functionName = "test-generic-fn-" + randomName(8);
+        submitFunction(
+                Runtime.JAVA,
+                inputTopic,
+                outputTopic,
+                functionName,
+                null,
+                function,
+                Schema.AUTO_CONSUME(),
+                null,
+                null,
+                SchemaType.NONE.name(),
+                SubscriptionInitialPosition.Earliest, null, null, null);
+        try {
+            if (keyValue) {
+                @Cleanup
+                Producer<KeyValue<Users.UserV1, Users.UserV1>> producer = pulsarClient
+                        .newProducer(Schema.KeyValue(
+                                Schema.AVRO(Users.UserV1.class),
+                                Schema.AVRO(Users.UserV1.class), KeyValueEncodingType.SEPARATED))
+                        .topic(inputTopic)
+                        .create();
+                for (int i = 0; i < numMessages; i++) {
+                    producer.send(new KeyValue<>(new Users.UserV1("foo" + i, i),
+                            new Users.UserV1("bar" + i, i + 100)));
+                }
+            } else {
+                @Cleanup
+                Producer<Users.UserV1> producer = pulsarClient
+                        .newProducer(Schema.AVRO(Users.UserV1.class))
+                        .topic(inputTopic)
+                        .create();
+                for (int i = 0; i < numMessages; i++) {
+                    producer.send(new Users.UserV1("bar" + i, i + 100));
+                }
+            }
+
+            getFunctionInfoSuccess(functionName);
+
+            getFunctionStatus(functionName, numMessages, true);
+
+            int i = 0;
+            Message<GenericRecord> message;
+            do {
+                message = consumer.receive(30, TimeUnit.SECONDS);
+                if (message != null) {
+                    GenericRecord genericRecord = message.getValue();
+                    if (keyValue) {
+                        @SuppressWarnings("unchecked")
+                        KeyValue<GenericRecord, GenericRecord> keyValueObject =
+                                (KeyValue<GenericRecord, GenericRecord>) genericRecord.getNativeObject();
+                        GenericRecord key = keyValueObject.getKey();
+                        GenericRecord value = keyValueObject.getValue();
+                        key.getFields().forEach(f -> {
+                            log.info("key field {} value {}", f.getName(), key.getField(f.getName()));
+                        });
+                        value.getFields().forEach(f -> {
+                            log.info("value field {} value {}", f.getName(), value.getField(f.getName()));
+                        });
+                        assertEquals(i, key.getField("age"));
+                        assertEquals("foo" + i, key.getField("name"));
+
+                        if (removeAgeField) {
+                            // field "age" is removed from the schema
+                            assertFalse(value.getFields().stream().anyMatch(f -> f.getName().equals("age")));
+                        } else {
+                            assertEquals(i + 100, value.getField("age"));
+                        }
+                        assertEquals("bar" + i, value.getField("name"));
+                    } else {
+                        GenericRecord value = genericRecord;
+                        log.info("received value {}", value);
+                        value.getFields().forEach(f -> {
+                            log.info("value field {} value {}", f.getName(), value.getField(f.getName()));
+                        });
+
+                        if (removeAgeField) {
+                            // field "age" is removed from the schema
+                            assertFalse(value.getFields().stream().anyMatch(f -> f.getName().equals("age")));
+                        } else {
+                            assertEquals(i + 100, value.getField("age"));
+                        }
+                        assertEquals("bar" + i, value.getField("name"));
+                    }
+
+                    consumer.acknowledge(message);
+                    i++;
+                }
+            } while (message != null);
+        } finally {
+            pulsarCluster.dumpFunctionLogs(functionName);
+        }
+
+        deleteFunction(functionName);
+
+        getFunctionInfoNotFound(functionName);
+    }
+
+    protected void testRecordFunction() throws Exception {
+        log.info("start RecordFunction function test ...");
+
+        String ns = "public/ns-recordfunction-" + randomName(8);
+        @Cleanup
+        PulsarAdmin pulsarAdmin = getPulsarAdmin();
+        pulsarAdmin.namespaces().createNamespace(ns);
+
+        @Cleanup
+        PulsarClient pulsarClient = getPulsarClient();
+
+        final int numMessages = 10;
+        final String inputTopic = ns + "/test-string-input-" + randomName(8);
+        final String outputTopic = ns + "/test-string-output-" + randomName(8);
+        @Cleanup
+        Consumer<String> consumer = pulsarClient
+                .newConsumer(Schema.STRING)
+                .subscriptionName("test")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .topic("publishtopic")
+                .subscribe();
+
+        final String functionName = "test-record-fn-" + randomName(8);
+        submitFunction(
+                Runtime.JAVA,
+                inputTopic,
+                outputTopic,
+                functionName,
+                null,
+                RecordFunction.class.getName(),
+                Schema.AUTO_CONSUME(),
+                null);
+        try {
+            @Cleanup
+            Producer<String> producer = pulsarClient
+                    .newProducer(Schema.STRING)
+                    .topic(inputTopic)
+                    .create();
+            for (int i = 0; i < numMessages; i++) {
+                producer.send("message" + i);
+            }
+
+            getFunctionInfoSuccess(functionName);
+
+            getFunctionStatus(functionName, numMessages, true);
+
+            for (int i = 0; i < numMessages; i++) {
+                Message<String> msg = consumer.receive(30, TimeUnit.SECONDS);
+                log.info("Received: {}", msg.getValue());
+                assertEquals(msg.getValue(), "message" + i + "!");
+                assertEquals(msg.getProperty("input_topic"), "persistent://" + inputTopic);
+            }
+        } finally {
+            pulsarCluster.dumpFunctionLogs(functionName);
+        }
+
+        deleteFunction(functionName);
+
+        getFunctionInfoNotFound(functionName);
+    }
+
+    protected void testMergeFunction() throws Exception {
+        log.info("start merge function test ...");
+
+        String ns = "public/ns-merge-" + randomName(8);
+        @Cleanup
+        PulsarAdmin pulsarAdmin = getPulsarAdmin();
+        pulsarAdmin.namespaces().createNamespace(ns);
+        pulsarAdmin.namespaces().setSchemaCompatibilityStrategy(ns, SchemaCompatibilityStrategy.ALWAYS_COMPATIBLE);
+        SchemaCompatibilityStrategy strategy = pulsarAdmin.namespaces().getSchemaCompatibilityStrategy(ns);
+        log.info("namespace {} SchemaCompatibilityStrategy is {}", ns, strategy);
+
+        @Cleanup
+        PulsarClient pulsarClient = getPulsarClient();
+
+        ObjectNode inputSpecNode = objectMapper.createObjectNode();
+        Map<String, AtomicInteger> topicMsgCntMap = new ConcurrentHashMap<>();
+        int messagePerTopic = 10;
+        prepareDataForMergeFunction(ns, pulsarClient, inputSpecNode, messagePerTopic, topicMsgCntMap);
+
+        final String outputTopic = ns + "/test-merge-output";
+        @Cleanup
+        Consumer<GenericRecord> consumer = pulsarClient
+                .newConsumer(Schema.AUTO_CONSUME())
+                .subscriptionName("test-merge-fn")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .topic(outputTopic)
+                .subscribe();
+
+        final String functionName = "test-merge-fn-" + randomName(8);
+        submitFunction(
+                Runtime.JAVA,
+                "",
+                outputTopic,
+                functionName,
+                null,
+                MergeTopicFunction.class.getName(),
+                null,
+                null,
+                inputSpecNode.toString(),
+                SchemaType.AUTO_PUBLISH.name().toUpperCase(),
+                SubscriptionInitialPosition.Earliest, null, null, null);
+
+        getFunctionInfoSuccess(functionName);
+
+        getFunctionStatus(functionName, topicMsgCntMap.keySet().size() * messagePerTopic, true);
+
+        try {
+
+            Message<GenericRecord> message;
+            do {
+                message = consumer.receive(30, TimeUnit.SECONDS);
+                if (message != null) {
+                    String baseTopic = message.getProperty("baseTopic");
+                    GenericRecord genericRecord = message.getValue();
+                    log.info("receive msg baseTopic: {}, schemaType: {}, nativeClass: {}, nativeObject: {}",
+                            baseTopic,
+                            genericRecord.getSchemaType(),
+                            genericRecord.getNativeObject().getClass(),
+                            genericRecord.getNativeObject());
+                    checkSchemaForAutoSchema(message, baseTopic);
+                    topicMsgCntMap.get(baseTopic).decrementAndGet();
+                    consumer.acknowledge(message);
+                }
+            } while (message != null);
+
+            for (Map.Entry<String, AtomicInteger> entry : topicMsgCntMap.entrySet()) {
+                assertEquals(entry.getValue().get(), 0,
+                        "topic " + entry.getKey() + " left message cnt is not 0.");
+            }
+        } finally {
+            pulsarCluster.dumpFunctionLogs(functionName);
+        }
+
+        deleteFunction(functionName);
+
+        getFunctionInfoNotFound(functionName);
+        log.info("finish merge function test.");
+    }
+
+    private void prepareDataForMergeFunction(String ns,
+                                             PulsarClient pulsarClient,
+                                             ObjectNode inputSpecNode,
+                                             int messagePerTopic,
+                                             Map<String, AtomicInteger> topicMsgCntMap) throws PulsarClientException {
+        generateDataByDifferentSchema(ns, "merge-schema-bytes", pulsarClient,
+                Schema.BYTES, "bytes schema test".getBytes(), messagePerTopic, inputSpecNode, topicMsgCntMap);
+        generateDataByDifferentSchema(ns, "merge-schema-string", pulsarClient,
+                Schema.STRING, "string schema test", messagePerTopic, inputSpecNode, topicMsgCntMap);
+        generateDataByDifferentSchema(ns, "merge-schema-json-userv1", pulsarClient,
+                Schema.JSON(Users.UserV1.class), new Users.UserV1("ran", 33),
+                messagePerTopic, inputSpecNode, topicMsgCntMap);
+        generateDataByDifferentSchema(ns, "merge-schema-json-userv2", pulsarClient,
+                Schema.JSON(Users.UserV2.class), new Users.UserV2("tang", 18, "123123123"),
+                messagePerTopic, inputSpecNode, topicMsgCntMap);
+        generateDataByDifferentSchema(ns, "merge-schema-avro-userv2", pulsarClient,
+                Schema.AVRO(Users.UserV2.class), new Users.UserV2("tang", 20, "456456456"),
+                messagePerTopic, inputSpecNode, topicMsgCntMap);
+        generateDataByDifferentSchema(ns, "merge-schema-k-int-v-json-userv1-separate", pulsarClient,
+                Schema.KeyValue(Schema.INT32, Schema.JSON(Users.UserV1.class), KeyValueEncodingType.SEPARATED),
+                new KeyValue<>(100, new Users.UserV1("ran", 40)),
+                messagePerTopic, inputSpecNode, topicMsgCntMap);
+        generateDataByDifferentSchema(ns, "merge-schema-k-json-userv2-v-json-userv1-inline", pulsarClient,
+                Schema.KeyValue(Schema.JSON(Users.UserV2.class), Schema.JSON(Users.UserV1.class),
+                        KeyValueEncodingType.INLINE),
+                new KeyValue<>(new Users.UserV2("tang", 20, "789789789"),
+                        new Users.UserV1("ran", 40)),
+                messagePerTopic, inputSpecNode, topicMsgCntMap);
+    }
+
+    private <T> void generateDataByDifferentSchema(String ns,
+                                                   String baseTopic,
+                                                   PulsarClient pulsarClient,
+                                                   Schema<T> schema,
+                                                   T data,
+                                                   int messageCnt,
+                                                   ObjectNode inputSpecNode,
+                                                   Map<String, AtomicInteger> topicMsgCntMap)
+            throws PulsarClientException {
+        String topic = ns + "/" + baseTopic;
+        Producer<T> producer = pulsarClient.newProducer(schema)
+                .topic(topic)
+                .create();
+        for (int i = 0; i < messageCnt; i++) {
+            producer.newMessage().value(data).property("baseTopic", baseTopic).send();
+        }
+        ObjectNode confNode = objectMapper.createObjectNode();
+        confNode.put("schemaType", SchemaType.AUTO_CONSUME.name().toUpperCase());
+        inputSpecNode.put(topic, confNode.toString());
+        topicMsgCntMap.put(baseTopic, new AtomicInteger(messageCnt));
+        producer.close();
+        log.info("[merge-fn] generate {} messages for schema {}", messageCnt, schema.getSchemaInfo());
+    }
+
+    @SuppressWarnings("unchecked")
+    private void checkSchemaForAutoSchema(Message<GenericRecord> message, String baseTopic) {
+        if (message.getReaderSchema().isEmpty()) {
+            fail("Failed to get reader schema for auto consume multiple schema topic.");
+        }
+        Object nativeObject = message.getValue().getNativeObject();
+        JsonNode jsonNode;
+        KeyValue<?, ?> kv;
+        switch (baseTopic) {
+            case "merge-schema-bytes":
+                assertEquals(new String((byte[]) nativeObject), "bytes schema test");
+                break;
+            case "merge-schema-string":
+                assertEquals((String) nativeObject, "string schema test");
+                break;
+            case "merge-schema-json-userv1":
+                jsonNode = (JsonNode) nativeObject;
+                assertEquals(jsonNode.get("name").textValue(), "ran");
+                assertEquals(jsonNode.get("age").intValue(), 33);
+                break;
+            case "merge-schema-json-userv2":
+                jsonNode = (JsonNode) nativeObject;
+                assertEquals(jsonNode.get("name").textValue(), "tang");
+                assertEquals(jsonNode.get("age").intValue(), 18);
+                assertEquals(jsonNode.get("phone").textValue(), "123123123");
+                break;
+            case "merge-schema-avro-userv2":
+                org.apache.avro.generic.GenericRecord genericRecord =
+                        (org.apache.avro.generic.GenericRecord) nativeObject;
+                assertEquals(genericRecord.get("name").toString(), "tang");
+                assertEquals(genericRecord.get("age"), 20);
+                assertEquals(genericRecord.get("phone").toString(), "456456456");
+                break;
+            case "merge-schema-k-int-v-json-userv1-separate":
+                kv = (KeyValue<Integer, GenericRecord>) nativeObject;
+                assertEquals(kv.getKey(), 100);
+                jsonNode = ((GenericJsonRecord) kv.getValue()).getJsonNode();
+                assertEquals(jsonNode.get("name").textValue(), "ran");
+                assertEquals(jsonNode.get("age").intValue(), 40);
+                break;
+            case "merge-schema-k-json-userv2-v-json-userv1-inline":
+                kv = (KeyValue<GenericRecord, GenericRecord>) nativeObject;
+                jsonNode = ((GenericJsonRecord) kv.getKey()).getJsonNode();
+                assertEquals(jsonNode.get("name").textValue(), "tang");
+                assertEquals(jsonNode.get("age").intValue(), 20);
+                assertEquals(jsonNode.get("phone").textValue(), "789789789");
+                jsonNode = ((GenericJsonRecord) kv.getValue()).getJsonNode();
+                assertEquals(jsonNode.get("name").textValue(), "ran");
+                assertEquals(jsonNode.get("age").intValue(), 40);
+                break;
+            default:
+                // nothing to do
+        }
+    }
+
+    private PulsarClient getPulsarClient() throws PulsarClientException {
+        return PulsarClient.builder().serviceUrl(pulsarCluster.getPlainTextServiceUrl()).build();
+    }
+
+    private PulsarAdmin getPulsarAdmin() throws PulsarClientException {
+        return PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTestBase.java
index 288ced63ae..98db607644 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarFunctionsTestBase.java
@@ -1,160 +1,160 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testng.annotations.DataProvider;
-
-/**
- * A cluster to run pulsar functions for testing functions related features.
- */
-@Slf4j
-public abstract class PulsarFunctionsTestBase extends PulsarTestSuite {
-
-    //
-    // Common Variables used by functions test
-    //
-    public static final String EXCLAMATION_JAVA_CLASS =
-        "org.apache.pulsar.functions.api.examples.ExclamationFunction";
-
-    public static final String PUBLISH_JAVA_CLASS =
-            "org.apache.pulsar.functions.api.examples.TypedMessageBuilderPublish";
-
-    public static final String EXCEPTION_JAVA_CLASS =
-            "org.apache.pulsar.tests.integration.functions.ExceptionFunction";
-
-    public static final String GENERIC_OBJECT_FUNCTION_JAVA_CLASS =
-            "org.apache.pulsar.tests.integration.functions.GenericObjectFunction";
-
-    public static final String REMOVE_AVRO_FIELD_FUNCTION_JAVA_CLASS =
-            "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldFunction";
-
-    public static final String REMOVE_AVRO_FIELD_RECORD_FUNCTION_JAVA_CLASS =
-        "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldRecordFunction";
-
-    public static final String SERDE_JAVA_CLASS =
-            "org.apache.pulsar.functions.api.examples.CustomBaseToBaseFunction";
-
-    public static final String SERDE_CLASS =
-            "org.apache.pulsar.functions.api.examples.CustomBaseSerde";
-
-    public static final String EXCLAMATION_PYTHON_CLASS =
-        "exclamation_function.ExclamationFunction";
-
-    public static final String EXCLAMATION_WITH_DEPS_PYTHON_CLASS =
-        "exclamation_with_extra_deps.ExclamationFunction";
-
-    public static final String EXCLAMATION_PYTHON_ZIP_CLASS =
-            "exclamation";
-
-    public static final String PUBLISH_PYTHON_CLASS = "typed_message_builder_publish.TypedMessageBuilderPublish";
-    public static final String EXCEPTION_PYTHON_CLASS = "exception_function";
-    public static final String AVRO_SCHEMA_PYTHON_CLASS = "avro_schema_test_function.AvroSchemaTestFunction";
-    public static final String EXCLAMATION_PYTHON_FILE = "exclamation_function.py";
-    public static final String EXCLAMATION_WITH_DEPS_PYTHON_FILE = "exclamation_with_extra_deps.py";
-    public static final String EXCLAMATION_PYTHON_ZIP_FILE = "exclamation.zip";
-    public static final String PUBLISH_FUNCTION_PYTHON_FILE = "typed_message_builder_publish.py";
-    public static final String EXCEPTION_FUNCTION_PYTHON_FILE = "exception_function.py";
-    public static final String AVRO_SCHEMA_FUNCTION_PYTHON_FILE = "avro_schema_test_function.py";
-
-    public static final String EXCLAMATION_GO_FILE = "exclamationFunc";
-    public static final String PUBLISH_FUNCTION_GO_FILE = "exclamationFunc";
-
-    public static final String LOGGING_JAVA_CLASS =
-            "org.apache.pulsar.functions.api.examples.LoggingFunction";
-
-    @DataProvider(name = "FunctionRuntimeTypes")
-    public static Object[][] getData() {
-        return new Object[][] {
-            { FunctionRuntimeType.PROCESS },
-            { FunctionRuntimeType.THREAD }
-        };
-    }
-
-    @DataProvider(name = "FunctionRuntimes")
-    public static Object[][] functionRuntimes() {
-        return new Object[][] {
-            new Object[] { Runtime.JAVA },
-            new Object[] { Runtime.PYTHON },
-            new Object[] { Runtime.GO }
-        };
-    }
-
-    protected final FunctionRuntimeType functionRuntimeType;
-
-    public PulsarFunctionsTestBase() {
-        this(FunctionRuntimeType.PROCESS);
-    }
-
-    protected PulsarFunctionsTestBase(FunctionRuntimeType functionRuntimeType) {
-        this.functionRuntimeType = functionRuntimeType;
-    }
-
-    @Override
-    public void setupCluster() throws Exception {
-        super.setupCluster();
-        setupFunctionWorkers();
-    }
-
-    @Override
-    public void tearDownCluster() throws Exception {
-        try {
-            teardownFunctionWorkers();
-        } finally {
-            super.tearDownCluster();
-        }
-    }
-
-    protected void setupFunctionWorkers() {
-        final int numFunctionWorkers = 2;
-        log.info("Setting up {} function workers : function runtime type = {}",
-            numFunctionWorkers, functionRuntimeType);
-        pulsarCluster.setupFunctionWorkers(randomName(5), functionRuntimeType, numFunctionWorkers);
-        log.info("{} function workers has started", numFunctionWorkers);
-    }
-
-    protected void teardownFunctionWorkers() {
-        log.info("Tearing down function workers ...");
-        pulsarCluster.stopWorkers();
-        log.info("All functions workers are stopped.");
-    }
-
-    protected static String getExclamationClass(Runtime runtime,
-                                                boolean pyZip,
-                                                boolean extraDeps) {
-        if (Runtime.JAVA == runtime) {
-            return EXCLAMATION_JAVA_CLASS;
-        } else if (Runtime.PYTHON == runtime) {
-            if (pyZip) {
-                return EXCLAMATION_PYTHON_ZIP_CLASS;
-            } else if (extraDeps) {
-                return EXCLAMATION_WITH_DEPS_PYTHON_CLASS;
-            } else {
-                return EXCLAMATION_PYTHON_CLASS;
-            }
-        } else if (Runtime.GO == runtime) {
-            return null;
-        } else {
-            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testng.annotations.DataProvider;
+
+/**
+ * A cluster to run pulsar functions for testing functions related features.
+ */
+@Slf4j
+public abstract class PulsarFunctionsTestBase extends PulsarTestSuite {
+
+    //
+    // Common Variables used by functions test
+    //
+    public static final String EXCLAMATION_JAVA_CLASS =
+        "org.apache.pulsar.functions.api.examples.ExclamationFunction";
+
+    public static final String PUBLISH_JAVA_CLASS =
+            "org.apache.pulsar.functions.api.examples.TypedMessageBuilderPublish";
+
+    public static final String EXCEPTION_JAVA_CLASS =
+            "org.apache.pulsar.tests.integration.functions.ExceptionFunction";
+
+    public static final String GENERIC_OBJECT_FUNCTION_JAVA_CLASS =
+            "org.apache.pulsar.tests.integration.functions.GenericObjectFunction";
+
+    public static final String REMOVE_AVRO_FIELD_FUNCTION_JAVA_CLASS =
+            "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldFunction";
+
+    public static final String REMOVE_AVRO_FIELD_RECORD_FUNCTION_JAVA_CLASS =
+        "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldRecordFunction";
+
+    public static final String SERDE_JAVA_CLASS =
+            "org.apache.pulsar.functions.api.examples.CustomBaseToBaseFunction";
+
+    public static final String SERDE_CLASS =
+            "org.apache.pulsar.functions.api.examples.CustomBaseSerde";
+
+    public static final String EXCLAMATION_PYTHON_CLASS =
+        "exclamation_function.ExclamationFunction";
+
+    public static final String EXCLAMATION_WITH_DEPS_PYTHON_CLASS =
+        "exclamation_with_extra_deps.ExclamationFunction";
+
+    public static final String EXCLAMATION_PYTHON_ZIP_CLASS =
+            "exclamation";
+
+    public static final String PUBLISH_PYTHON_CLASS = "typed_message_builder_publish.TypedMessageBuilderPublish";
+    public static final String EXCEPTION_PYTHON_CLASS = "exception_function";
+    public static final String AVRO_SCHEMA_PYTHON_CLASS = "avro_schema_test_function.AvroSchemaTestFunction";
+    public static final String EXCLAMATION_PYTHON_FILE = "exclamation_function.py";
+    public static final String EXCLAMATION_WITH_DEPS_PYTHON_FILE = "exclamation_with_extra_deps.py";
+    public static final String EXCLAMATION_PYTHON_ZIP_FILE = "exclamation.zip";
+    public static final String PUBLISH_FUNCTION_PYTHON_FILE = "typed_message_builder_publish.py";
+    public static final String EXCEPTION_FUNCTION_PYTHON_FILE = "exception_function.py";
+    public static final String AVRO_SCHEMA_FUNCTION_PYTHON_FILE = "avro_schema_test_function.py";
+
+    public static final String EXCLAMATION_GO_FILE = "exclamationFunc";
+    public static final String PUBLISH_FUNCTION_GO_FILE = "exclamationFunc";
+
+    public static final String LOGGING_JAVA_CLASS =
+            "org.apache.pulsar.functions.api.examples.LoggingFunction";
+
+    @DataProvider(name = "FunctionRuntimeTypes")
+    public static Object[][] getData() {
+        return new Object[][] {
+            { FunctionRuntimeType.PROCESS },
+            { FunctionRuntimeType.THREAD }
+        };
+    }
+
+    @DataProvider(name = "FunctionRuntimes")
+    public static Object[][] functionRuntimes() {
+        return new Object[][] {
+            new Object[] { Runtime.JAVA },
+            new Object[] { Runtime.PYTHON },
+            new Object[] { Runtime.GO }
+        };
+    }
+
+    protected final FunctionRuntimeType functionRuntimeType;
+
+    public PulsarFunctionsTestBase() {
+        this(FunctionRuntimeType.PROCESS);
+    }
+
+    protected PulsarFunctionsTestBase(FunctionRuntimeType functionRuntimeType) {
+        this.functionRuntimeType = functionRuntimeType;
+    }
+
+    @Override
+    public void setupCluster() throws Exception {
+        super.setupCluster();
+        setupFunctionWorkers();
+    }
+
+    @Override
+    public void tearDownCluster() throws Exception {
+        try {
+            teardownFunctionWorkers();
+        } finally {
+            super.tearDownCluster();
+        }
+    }
+
+    protected void setupFunctionWorkers() {
+        final int numFunctionWorkers = 2;
+        log.info("Setting up {} function workers : function runtime type = {}",
+            numFunctionWorkers, functionRuntimeType);
+        pulsarCluster.setupFunctionWorkers(randomName(5), functionRuntimeType, numFunctionWorkers);
+        log.info("{} function workers has started", numFunctionWorkers);
+    }
+
+    protected void teardownFunctionWorkers() {
+        log.info("Tearing down function workers ...");
+        pulsarCluster.stopWorkers();
+        log.info("All functions workers are stopped.");
+    }
+
+    protected static String getExclamationClass(Runtime runtime,
+                                                boolean pyZip,
+                                                boolean extraDeps) {
+        if (Runtime.JAVA == runtime) {
+            return EXCLAMATION_JAVA_CLASS;
+        } else if (Runtime.PYTHON == runtime) {
+            if (pyZip) {
+                return EXCLAMATION_PYTHON_ZIP_CLASS;
+            } else if (extraDeps) {
+                return EXCLAMATION_WITH_DEPS_PYTHON_CLASS;
+            } else {
+                return EXCLAMATION_PYTHON_CLASS;
+            }
+        } else if (Runtime.GO == runtime) {
+            return null;
+        } else {
+            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarMetadataStateStoreTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarMetadataStateStoreTest.java
index cb74592891..a9265bd7e6 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarMetadataStateStoreTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarMetadataStateStoreTest.java
@@ -1,60 +1,60 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import static org.testng.Assert.assertEquals;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.functions.instance.state.PulsarMetadataStateStoreProviderImpl;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testcontainers.containers.Network;
-
-@Slf4j
-public class PulsarMetadataStateStoreTest extends PulsarStateTest {
-    protected PulsarMetadataStateStoreTest() {
-        super(PulsarMetadataStateStoreProviderImpl.class.getName());
-    }
-
-    public void setUpCluster() throws Exception {
-        incrementSetupNumber();
-        network = Network.newNetwork();
-        String clusterName = PulsarClusterTestBase.randomName(8);
-        container = new StandaloneContainer(clusterName, PulsarContainer.DEFAULT_IMAGE_NAME)
-                .withNetwork(network)
-                .withNetworkAliases(StandaloneContainer.NAME + "-" + clusterName)
-                .withEnv("PULSAR_STANDALONE_USE_ZOOKEEPER", "true")
-                .withEnv("PF_stateStorageProviderImplementation", PulsarMetadataStateStoreProviderImpl.class.getName())
-                .withEnv("PF_stateStorageServiceUrl", "zk:localhost:2181");
-        container.start();
-        log.info("Pulsar cluster {} is up running:", clusterName);
-        log.info("\tBinary Service Url : {}", container.getPlainTextServiceUrl());
-        log.info("\tHttp Service Url : {}", container.getHttpServiceUrl());
-
-        // add cluster to public tenant
-        ContainerExecResult result = container.execCmd(
-                "/pulsar/bin/pulsar-admin", "namespaces", "policies", "public/default");
-        assertEquals(0, result.getExitCode());
-        log.info("public/default namespace policies are {}", result.getStdout());
-    }
-
-
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import static org.testng.Assert.assertEquals;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.functions.instance.state.PulsarMetadataStateStoreProviderImpl;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testcontainers.containers.Network;
+
+@Slf4j
+public class PulsarMetadataStateStoreTest extends PulsarStateTest {
+    protected PulsarMetadataStateStoreTest() {
+        super(PulsarMetadataStateStoreProviderImpl.class.getName());
+    }
+
+    public void setUpCluster() throws Exception {
+        incrementSetupNumber();
+        network = Network.newNetwork();
+        String clusterName = PulsarClusterTestBase.randomName(8);
+        container = new StandaloneContainer(clusterName, PulsarContainer.DEFAULT_IMAGE_NAME)
+                .withNetwork(network)
+                .withNetworkAliases(StandaloneContainer.NAME + "-" + clusterName)
+                .withEnv("PULSAR_STANDALONE_USE_ZOOKEEPER", "true")
+                .withEnv("PF_stateStorageProviderImplementation", PulsarMetadataStateStoreProviderImpl.class.getName())
+                .withEnv("PF_stateStorageServiceUrl", "zk:localhost:2181");
+        container.start();
+        log.info("Pulsar cluster {} is up running:", clusterName);
+        log.info("\tBinary Service Url : {}", container.getPlainTextServiceUrl());
+        log.info("\tHttp Service Url : {}", container.getHttpServiceUrl());
+
+        // add cluster to public tenant
+        ContainerExecResult result = container.execCmd(
+                "/pulsar/bin/pulsar-admin", "namespaces", "policies", "public/default");
+        assertEquals(0, result.getExitCode());
+        log.info("public/default namespace policies are {}", result.getStdout());
+    }
+
+
+}
+
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarStateTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarStateTest.java
index 9d2510e610..9ddbb3340f 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarStateTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/PulsarStateTest.java
@@ -1,727 +1,727 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertNotEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.expectThrows;
-import static org.testng.Assert.fail;
-import com.google.common.base.Utf8;
-import com.google.gson.Gson;
-import java.util.Base64;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.common.functions.FunctionState;
-import org.apache.pulsar.common.policies.data.SinkStatus;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.functions.api.examples.WordCountFunction;
-import org.apache.pulsar.functions.instance.state.PulsarMetadataStateStoreProviderImpl;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.awaitility.Awaitility;
-import org.testng.annotations.Test;
-
-/**
- * State related test cases.
- */
-@Slf4j
-public abstract class PulsarStateTest extends PulsarStandaloneTestSuite {
-
-    protected String stateStoreProvider;
-
-    protected PulsarStateTest(String stateStoreProvider) {
-        super();
-        this.stateStoreProvider = stateStoreProvider;
-    }
-
-    public static final String WORDCOUNT_PYTHON_CLASS =
-            "wordcount_function.WordCountFunction";
-    public static final String WORDCOUNT_JAVA_CLASS = WordCountFunction.class.getName();
-
-    public static final String WORDCOUNT_PYTHON_FILE = "wordcount_function.py";
-
-    public static final String VALUE_BASE64 = "0a8001127e0a172e6576656e74732e437573746f6d65724372656174656412630a243"
-            + "2336366666263652d623038342d346631352d616565342d326330643135356131666"
-            + "36312026e311a3700000000000000000000000000000000000000000000000000000"
-            + "000000000000000000000000000000000000000000000000000000000";
-
-    private void doTestPythonWordCountFunction(String functionName) throws Exception {
-        String inputTopicName = "test-wordcount-py-input-" + randomName(8);
-        String outputTopicName = "test-wordcount-py-output-" + randomName(8);
-
-        // submit the word count function
-        submitWordCountFunction(
-                Runtime.PYTHON, inputTopicName, outputTopicName, functionName);
-        // run tests
-        doTestFunction(functionName, inputTopicName, outputTopicName);
-    }
-
-    private void doTestJavaWordCountFunction(String functionName) throws Exception {
-        String inputTopicName = "test-wordcount-java-input-" + randomName(8);
-
-        // submit the word count function
-        submitWordCountFunction(
-                Runtime.JAVA, inputTopicName, null, functionName);
-        // run tests
-        doTestFunction(functionName, inputTopicName, null);
-    }
-
-    private void doTestFunction(String functionName, String inputTopicName, String outputTopicName) throws Exception {
-        final int numMessages = 10;
-        // get function info
-        getFunctionInfoSuccess(functionName);
-
-        // publish and consume result
-        publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
-
-        // get function status
-        getFunctionStatus(functionName, numMessages);
-
-        // get state
-        queryState(functionName, "hello", numMessages, numMessages - 1);
-        queryState(functionName, "test", numMessages, numMessages - 1);
-        for (int i = 0; i < numMessages; i++) {
-            queryState(functionName, "message-" + i, 1, 0);
-        }
-
-        // test put state
-        String state = "{\"key\":\"test-string\",\"stringValue\":\"test value\"}";
-        String expect = "\"stringValue\": \"test value\"";
-        putAndQueryState(functionName, "test-string", state, expect);
-
-        String numberState = "{\"key\":\"test-number\",\"numberValue\":20}";
-        String expectNumber = "\"numberValue\": 20";
-        putAndQueryState(functionName, "test-number", numberState, expectNumber);
-
-        byte[] valueBytes = Base64.getDecoder().decode(VALUE_BASE64);
-        String bytesString = Base64.getEncoder().encodeToString(valueBytes);
-        String byteState = "{\"key\":\"test-bytes\",\"byteValue\":\"" + bytesString + "\"}";
-        putAndQueryStateByte(functionName, "test-bytes", byteState, valueBytes);
-
-        String valueStr = "hello pulsar";
-        byte[] valueStrBytes = valueStr.getBytes(UTF_8);
-        String bytesStrString = Base64.getEncoder().encodeToString(valueStrBytes);
-        String byteStrState = "{\"key\":\"test-str-bytes\",\"byteValue\":\"" + bytesStrString + "\"}";
-        putAndQueryState(functionName, "test-str-bytes", byteStrState, valueStr);
-
-        String byteStrStateWithEmptyValues = "{\"key\":\"test-str-bytes\",\"byteValue\":\"" + bytesStrString + "\","
-                + "\"stringValue\":\"\",\"numberValue\":0}";
-        putAndQueryState(functionName, "test-str-bytes", byteStrStateWithEmptyValues, valueStr);
-
-        // delete function
-        deleteFunction(functionName);
-
-        // get function info
-        getFunctionInfoNotFound(functionName);
-    }
-
-    @Test(groups = {"python_state", "state", "function", "python_function"})
-    public void testPythonWordCountFunction() throws Exception {
-        if (PulsarMetadataStateStoreProviderImpl.class.getName().equals(stateStoreProvider)) {
-            // python function doesn't support metadata state store yet
-            return;
-        }
-        String functionName = "test-wordcount-py-fn-" + randomName(8);
-        doTestPythonWordCountFunction(functionName);
-
-        // after a function is deleted, its state should be clean
-        // we just recreate and test the word count function again, and it should have same result
-        doTestPythonWordCountFunction(functionName);
-    }
-
-    @Test(groups = {"java_state", "state", "function", "java_function"})
-    public void testJavaWordCountFunction() throws Exception {
-        String functionName = "test-wordcount-java-fn-" + randomName(8);
-        doTestJavaWordCountFunction(functionName);
-
-        // after a function is deleted, its state should be clean
-        // we just recreate and test the word count function again, and it should have same result
-        doTestJavaWordCountFunction(functionName);
-    }
-
-
-    @Test(groups = {"java_state", "state", "function", "java_function"})
-    public void testSourceState() throws Exception {
-        String outputTopicName = "test-state-source-output-" + randomName(8);
-        String sourceName = "test-state-source-" + randomName(8);
-
-        submitSourceConnector(sourceName, outputTopicName, "org.apache.pulsar.tests.integration.io.TestStateSource",
-                JAVAJAR);
-
-        // get source info
-        getSourceInfoSuccess(sourceName);
-
-        // get source status
-        getSourceStatus(sourceName);
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWritten > 0);
-            });
-
-            {
-                FunctionState functionState =
-                        admin.functions().getFunctionState("public", "default", sourceName, "initial");
-                assertEquals(functionState.getStringValue(), "val1");
-            }
-
-            // query a non-exist key should get a 404 error
-            {
-                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
-                    admin.functions().getFunctionState("public", "default", sourceName, "non-exist");
-                });
-                assertEquals(e.getStatusCode(), 404);
-            }
-
-            // query a non-exist instance should get a 404 error
-            {
-                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
-                    admin.functions().getFunctionState("public", "default", "non-exist", "non-exist");
-                });
-                assertEquals(e.getStatusCode(), 404);
-            }
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                FunctionState functionState =
-                        admin.functions().getFunctionState("public", "default", sourceName, "now");
-                assertTrue(functionState.getStringValue().matches("val1-.*"));
-            });
-        }
-
-        // delete source
-        deleteSource(sourceName);
-
-        getSourceInfoNotFound(sourceName);
-    }
-
-    @Test(groups = {"java_state", "state", "function", "java_function"})
-    public void testSinkState() throws Exception {
-        String inputTopicName = "test-state-sink-input-" + randomName(8);
-        String sinkName = "test-state-sink-" + randomName(8);
-        int numMessages = 10;
-
-        submitSinkConnector(sinkName, inputTopicName, "org.apache.pulsar.tests.integration.io.TestStateSink", JAVAJAR);
-
-        // get sink info
-        getSinkInfoSuccess(sinkName);
-
-        // get sink status
-        getSinkStatus(sinkName);
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-            // java supports schema
-            @Cleanup PulsarClient client = PulsarClient.builder()
-                    .serviceUrl(container.getPlainTextServiceUrl())
-                    .build();
-            @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(inputTopicName)
-                    .create();
-
-            {
-                FunctionState functionState =
-                        admin.functions().getFunctionState("public", "default", sinkName, "initial");
-                assertEquals(functionState.getStringValue(), "val1");
-            }
-
-            // query a non-exist key should get a 404 error
-            {
-                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
-                    admin.functions().getFunctionState("public", "default", sinkName, "non-exist");
-                });
-                assertEquals(e.getStatusCode(), 404);
-            }
-
-            // query a non-exist instance should get a 404 error
-            {
-                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
-                    admin.functions().getFunctionState("public", "default", "non-exist", "non-exist");
-                });
-                assertEquals(e.getStatusCode(), 404);
-            }
-
-            for (int i = 0; i < numMessages; i++) {
-                producer.send("foo");
-            }
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWrittenToSink > 0);
-            });
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                FunctionState functionState = admin.functions().getFunctionState("public", "default", sinkName, "now");
-                assertEquals(functionState.getStringValue(), String.format("val1-%d", numMessages - 1));
-            });
-        }
-
-        // delete source
-        deleteSink(sinkName);
-
-        getSinkInfoNotFound(sinkName);
-    }
-
-    @Test(groups = {"python_state", "state", "function", "python_function"})
-    public void testNonExistFunction() throws Exception {
-        String functionName = "non-exist-function-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-            // query a non-exist instance should get a 404 error
-            {
-                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
-                    admin.functions().getFunctionState("public", "default", functionName, "non-exist");
-                });
-                assertEquals(e.getStatusCode(), 404);
-            }
-        }
-    }
-
-    @Test(groups = {"java_state", "state", "function", "java_function"})
-    public void testBytes2StringNotUTF8() {
-        byte[] valueBytes = Base64.getDecoder().decode(VALUE_BASE64);
-        assertFalse(Utf8.isWellFormed(valueBytes));
-        assertNotEquals(valueBytes, new String(valueBytes, UTF_8).getBytes(UTF_8));
-    }
-
-    @Test(groups = {"java_state", "state", "function", "java_function"})
-    public void testSourceByteState() throws Exception {
-        String outputTopicName = "test-state-source-output-" + randomName(8);
-        String sourceName = "test-state-source-" + randomName(8);
-
-        submitSourceConnector(sourceName, outputTopicName,
-                "org.apache.pulsar.tests.integration.io.TestByteStateSource", JAVAJAR);
-
-        // get source info
-        getSourceInfoSuccess(sourceName);
-
-        // get source status
-        getSourceStatus(sourceName);
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWritten > 0);
-            });
-
-            {
-                FunctionState functionState =
-                        admin.functions().getFunctionState("public", "default", sourceName, "initial");
-                assertNull(functionState.getStringValue());
-                assertEquals(functionState.getByteValue(), Base64.getDecoder().decode(VALUE_BASE64));
-            }
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                FunctionState functionState =
-                        admin.functions().getFunctionState("public", "default", sourceName, "now");
-                assertNull(functionState.getStringValue());
-                assertEquals(functionState.getByteValue(), Base64.getDecoder().decode(VALUE_BASE64));
-            });
-        }
-
-        // delete source
-        deleteSource(sourceName);
-
-        getSourceInfoNotFound(sourceName);
-    }
-
-    private void submitSourceConnector(String sourceName,
-                                       String outputTopicName,
-                                       String className,
-                                       String archive) throws Exception {
-        String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources", "create",
-                "--name", sourceName,
-                "--destinationTopicName", outputTopicName,
-                "--archive", archive,
-                "--classname", className
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    private void submitSinkConnector(String sinkName,
-                                     String inputTopicName,
-                                     String className,
-                                     String archive) throws Exception {
-        String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks", "create",
-                "--name", sinkName,
-                "--inputs", inputTopicName,
-                "--archive", archive,
-                "--classname", className
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    private void submitWordCountFunction(Runtime runtime,
-                                         String inputTopicName,
-                                         String outputTopicName,
-                                         String functionName) throws Exception {
-        submitFunction(
-                runtime,
-                inputTopicName,
-                outputTopicName,
-                functionName,
-                getWordCountClass(runtime),
-                Schema.BYTES);
-    }
-
-    protected static String getWordCountClass(Runtime runtime) {
-        if (Runtime.PYTHON == runtime) {
-            return WORDCOUNT_PYTHON_CLASS;
-        } else if (Runtime.JAVA == runtime) {
-            return WORDCOUNT_JAVA_CLASS;
-        } else {
-            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
-        }
-    }
-
-    private <T> void submitFunction(Runtime runtime,
-                                    String inputTopicName,
-                                    String outputTopicName,
-                                    String functionName,
-                                    String functionClass,
-                                    Schema<T> inputTopicSchema) throws Exception {
-        CommandGenerator generator;
-        generator = CommandGenerator.createDefaultGenerator(inputTopicName, functionClass);
-        generator.setSinkTopic(outputTopicName);
-        generator.setFunctionName(functionName);
-        String command;
-        if (Runtime.JAVA == runtime) {
-            command = generator.generateCreateFunctionCommand();
-        } else if (Runtime.PYTHON == runtime) {
-            generator.setRuntime(runtime);
-            command = generator.generateCreateFunctionCommand(WORDCOUNT_PYTHON_FILE);
-        } else {
-            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
-        }
-        String[] commands = {
-                "sh", "-c", command
-        };
-        ContainerExecResult result = container.execCmd(
-                commands);
-        assertTrue(result.getStdout().contains("Created successfully"));
-
-        ensureSubscriptionCreated(inputTopicName, String.format("public/default/%s", functionName), inputTopicSchema);
-    }
-
-    @SuppressWarnings("try")
-    private <T> void ensureSubscriptionCreated(String inputTopicName,
-                                               String subscriptionName,
-                                               Schema<T> inputTopicSchema)
-            throws Exception {
-        // ensure the function subscription exists before we start producing messages
-        try (PulsarClient client = PulsarClient.builder()
-                .serviceUrl(container.getPlainTextServiceUrl())
-                .build()) {
-            try (Consumer<T> ignored = client.newConsumer(inputTopicSchema)
-                    .topic(inputTopicName)
-                    .subscriptionType(SubscriptionType.Shared)
-                    .subscriptionName(subscriptionName)
-                    .subscribe()) {
-            }
-        }
-    }
-
-    private void getSinkInfoSuccess(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sinkName + "\""));
-    }
-
-    private void getSourceInfoSuccess(String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
-    }
-
-    private void getFunctionInfoSuccess(String functionName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + functionName + "\""));
-    }
-
-    private void getFunctionInfoNotFound(String functionName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "functions",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", functionName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Function " + functionName + " doesn't exist"));
-        }
-    }
-
-    private void getSinkStatus(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private void getSourceStatus(String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private void getFunctionStatus(String functionName, int numMessages) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "getstatus",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-        assertTrue(result.getStdout().contains("\"numSuccessfullyProcessed\" : " + numMessages));
-    }
-
-    private void queryState(String functionName, String key, int amount, long version)
-            throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "querystate",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName,
-                "--key", key
-        );
-        assertTrue(result.getStdout().contains("\"numberValue\": " + amount));
-        assertTrue(result.getStdout().contains("\"version\": " + version));
-        assertFalse(result.getStdout().contains("stringValue"));
-        assertFalse(result.getStdout().contains("byteValue"));
-    }
-
-    private void putAndQueryState(String functionName, String key, String state, String expect)
-            throws Exception {
-        container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "putstate",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName,
-                "--state", state
-        );
-
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "querystate",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName,
-                "--key", key
-        );
-        assertTrue(result.getStdout().contains(expect));
-    }
-
-    private void putAndQueryStateByte(String functionName, String key, String state, byte[] expect)
-            throws Exception {
-        container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "putstate",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName,
-                "--state", state
-        );
-
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "querystate",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName,
-                "--key", key
-        );
-
-        FunctionState byteState = new Gson().fromJson(result.getStdout(), FunctionState.class);
-        assertNull(byteState.getStringValue());
-        assertEquals(byteState.getByteValue(), expect);
-    }
-
-    private void publishAndConsumeMessages(String inputTopic,
-                                           String outputTopic,
-                                           int numMessages) throws Exception {
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(container.getPlainTextServiceUrl())
-                .build();
-        @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
-                .topic(inputTopic)
-                .create();
-
-        for (int i = 0; i < numMessages; i++) {
-            producer.send(("hello test message-" + i).getBytes(UTF_8));
-        }
-
-        if (outputTopic == null) {
-            return;
-        }
-        @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
-                .topic(outputTopic)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-sub")
-                .subscribe();
-        for (int i = 0; i < numMessages; i++) {
-            Message<byte[]> msg = consumer.receive();
-            assertEquals("hello test message-" + i + "!", new String(msg.getValue(), UTF_8));
-        }
-    }
-
-    private void deleteFunction(String functionName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-        assertTrue(result.getStdout().contains("Deleted successfully"));
-        result.assertNoStderr();
-    }
-
-    private void deleteSource(String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("Delete source successfully"));
-        result.assertNoStderr();
-    }
-
-    private void deleteSink(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("Deleted successfully"));
-        result.assertNoStderr();
-    }
-
-    private void getSourceInfoNotFound(String sourceName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sources",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", sourceName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-
-    private void getSinkInfoNotFound(String sinkName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sinks",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", sinkName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Sink " + sinkName + " doesn't exist"));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.expectThrows;
+import static org.testng.Assert.fail;
+import com.google.common.base.Utf8;
+import com.google.gson.Gson;
+import java.util.Base64;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.common.functions.FunctionState;
+import org.apache.pulsar.common.policies.data.SinkStatus;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.functions.api.examples.WordCountFunction;
+import org.apache.pulsar.functions.instance.state.PulsarMetadataStateStoreProviderImpl;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.awaitility.Awaitility;
+import org.testng.annotations.Test;
+
+/**
+ * State related test cases.
+ */
+@Slf4j
+public abstract class PulsarStateTest extends PulsarStandaloneTestSuite {
+
+    protected String stateStoreProvider;
+
+    protected PulsarStateTest(String stateStoreProvider) {
+        super();
+        this.stateStoreProvider = stateStoreProvider;
+    }
+
+    public static final String WORDCOUNT_PYTHON_CLASS =
+            "wordcount_function.WordCountFunction";
+    public static final String WORDCOUNT_JAVA_CLASS = WordCountFunction.class.getName();
+
+    public static final String WORDCOUNT_PYTHON_FILE = "wordcount_function.py";
+
+    public static final String VALUE_BASE64 = "0a8001127e0a172e6576656e74732e437573746f6d65724372656174656412630a243"
+            + "2336366666263652d623038342d346631352d616565342d326330643135356131666"
+            + "36312026e311a3700000000000000000000000000000000000000000000000000000"
+            + "000000000000000000000000000000000000000000000000000000000";
+
+    private void doTestPythonWordCountFunction(String functionName) throws Exception {
+        String inputTopicName = "test-wordcount-py-input-" + randomName(8);
+        String outputTopicName = "test-wordcount-py-output-" + randomName(8);
+
+        // submit the word count function
+        submitWordCountFunction(
+                Runtime.PYTHON, inputTopicName, outputTopicName, functionName);
+        // run tests
+        doTestFunction(functionName, inputTopicName, outputTopicName);
+    }
+
+    private void doTestJavaWordCountFunction(String functionName) throws Exception {
+        String inputTopicName = "test-wordcount-java-input-" + randomName(8);
+
+        // submit the word count function
+        submitWordCountFunction(
+                Runtime.JAVA, inputTopicName, null, functionName);
+        // run tests
+        doTestFunction(functionName, inputTopicName, null);
+    }
+
+    private void doTestFunction(String functionName, String inputTopicName, String outputTopicName) throws Exception {
+        final int numMessages = 10;
+        // get function info
+        getFunctionInfoSuccess(functionName);
+
+        // publish and consume result
+        publishAndConsumeMessages(inputTopicName, outputTopicName, numMessages);
+
+        // get function status
+        getFunctionStatus(functionName, numMessages);
+
+        // get state
+        queryState(functionName, "hello", numMessages, numMessages - 1);
+        queryState(functionName, "test", numMessages, numMessages - 1);
+        for (int i = 0; i < numMessages; i++) {
+            queryState(functionName, "message-" + i, 1, 0);
+        }
+
+        // test put state
+        String state = "{\"key\":\"test-string\",\"stringValue\":\"test value\"}";
+        String expect = "\"stringValue\": \"test value\"";
+        putAndQueryState(functionName, "test-string", state, expect);
+
+        String numberState = "{\"key\":\"test-number\",\"numberValue\":20}";
+        String expectNumber = "\"numberValue\": 20";
+        putAndQueryState(functionName, "test-number", numberState, expectNumber);
+
+        byte[] valueBytes = Base64.getDecoder().decode(VALUE_BASE64);
+        String bytesString = Base64.getEncoder().encodeToString(valueBytes);
+        String byteState = "{\"key\":\"test-bytes\",\"byteValue\":\"" + bytesString + "\"}";
+        putAndQueryStateByte(functionName, "test-bytes", byteState, valueBytes);
+
+        String valueStr = "hello pulsar";
+        byte[] valueStrBytes = valueStr.getBytes(UTF_8);
+        String bytesStrString = Base64.getEncoder().encodeToString(valueStrBytes);
+        String byteStrState = "{\"key\":\"test-str-bytes\",\"byteValue\":\"" + bytesStrString + "\"}";
+        putAndQueryState(functionName, "test-str-bytes", byteStrState, valueStr);
+
+        String byteStrStateWithEmptyValues = "{\"key\":\"test-str-bytes\",\"byteValue\":\"" + bytesStrString + "\","
+                + "\"stringValue\":\"\",\"numberValue\":0}";
+        putAndQueryState(functionName, "test-str-bytes", byteStrStateWithEmptyValues, valueStr);
+
+        // delete function
+        deleteFunction(functionName);
+
+        // get function info
+        getFunctionInfoNotFound(functionName);
+    }
+
+    @Test(groups = {"python_state", "state", "function", "python_function"})
+    public void testPythonWordCountFunction() throws Exception {
+        if (PulsarMetadataStateStoreProviderImpl.class.getName().equals(stateStoreProvider)) {
+            // python function doesn't support metadata state store yet
+            return;
+        }
+        String functionName = "test-wordcount-py-fn-" + randomName(8);
+        doTestPythonWordCountFunction(functionName);
+
+        // after a function is deleted, its state should be clean
+        // we just recreate and test the word count function again, and it should have same result
+        doTestPythonWordCountFunction(functionName);
+    }
+
+    @Test(groups = {"java_state", "state", "function", "java_function"})
+    public void testJavaWordCountFunction() throws Exception {
+        String functionName = "test-wordcount-java-fn-" + randomName(8);
+        doTestJavaWordCountFunction(functionName);
+
+        // after a function is deleted, its state should be clean
+        // we just recreate and test the word count function again, and it should have same result
+        doTestJavaWordCountFunction(functionName);
+    }
+
+
+    @Test(groups = {"java_state", "state", "function", "java_function"})
+    public void testSourceState() throws Exception {
+        String outputTopicName = "test-state-source-output-" + randomName(8);
+        String sourceName = "test-state-source-" + randomName(8);
+
+        submitSourceConnector(sourceName, outputTopicName, "org.apache.pulsar.tests.integration.io.TestStateSource",
+                JAVAJAR);
+
+        // get source info
+        getSourceInfoSuccess(sourceName);
+
+        // get source status
+        getSourceStatus(sourceName);
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWritten > 0);
+            });
+
+            {
+                FunctionState functionState =
+                        admin.functions().getFunctionState("public", "default", sourceName, "initial");
+                assertEquals(functionState.getStringValue(), "val1");
+            }
+
+            // query a non-exist key should get a 404 error
+            {
+                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
+                    admin.functions().getFunctionState("public", "default", sourceName, "non-exist");
+                });
+                assertEquals(e.getStatusCode(), 404);
+            }
+
+            // query a non-exist instance should get a 404 error
+            {
+                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
+                    admin.functions().getFunctionState("public", "default", "non-exist", "non-exist");
+                });
+                assertEquals(e.getStatusCode(), 404);
+            }
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                FunctionState functionState =
+                        admin.functions().getFunctionState("public", "default", sourceName, "now");
+                assertTrue(functionState.getStringValue().matches("val1-.*"));
+            });
+        }
+
+        // delete source
+        deleteSource(sourceName);
+
+        getSourceInfoNotFound(sourceName);
+    }
+
+    @Test(groups = {"java_state", "state", "function", "java_function"})
+    public void testSinkState() throws Exception {
+        String inputTopicName = "test-state-sink-input-" + randomName(8);
+        String sinkName = "test-state-sink-" + randomName(8);
+        int numMessages = 10;
+
+        submitSinkConnector(sinkName, inputTopicName, "org.apache.pulsar.tests.integration.io.TestStateSink", JAVAJAR);
+
+        // get sink info
+        getSinkInfoSuccess(sinkName);
+
+        // get sink status
+        getSinkStatus(sinkName);
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+            // java supports schema
+            @Cleanup PulsarClient client = PulsarClient.builder()
+                    .serviceUrl(container.getPlainTextServiceUrl())
+                    .build();
+            @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(inputTopicName)
+                    .create();
+
+            {
+                FunctionState functionState =
+                        admin.functions().getFunctionState("public", "default", sinkName, "initial");
+                assertEquals(functionState.getStringValue(), "val1");
+            }
+
+            // query a non-exist key should get a 404 error
+            {
+                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
+                    admin.functions().getFunctionState("public", "default", sinkName, "non-exist");
+                });
+                assertEquals(e.getStatusCode(), 404);
+            }
+
+            // query a non-exist instance should get a 404 error
+            {
+                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
+                    admin.functions().getFunctionState("public", "default", "non-exist", "non-exist");
+                });
+                assertEquals(e.getStatusCode(), 404);
+            }
+
+            for (int i = 0; i < numMessages; i++) {
+                producer.send("foo");
+            }
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWrittenToSink > 0);
+            });
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                FunctionState functionState = admin.functions().getFunctionState("public", "default", sinkName, "now");
+                assertEquals(functionState.getStringValue(), String.format("val1-%d", numMessages - 1));
+            });
+        }
+
+        // delete source
+        deleteSink(sinkName);
+
+        getSinkInfoNotFound(sinkName);
+    }
+
+    @Test(groups = {"python_state", "state", "function", "python_function"})
+    public void testNonExistFunction() throws Exception {
+        String functionName = "non-exist-function-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+            // query a non-exist instance should get a 404 error
+            {
+                PulsarAdminException e = expectThrows(PulsarAdminException.class, () -> {
+                    admin.functions().getFunctionState("public", "default", functionName, "non-exist");
+                });
+                assertEquals(e.getStatusCode(), 404);
+            }
+        }
+    }
+
+    @Test(groups = {"java_state", "state", "function", "java_function"})
+    public void testBytes2StringNotUTF8() {
+        byte[] valueBytes = Base64.getDecoder().decode(VALUE_BASE64);
+        assertFalse(Utf8.isWellFormed(valueBytes));
+        assertNotEquals(valueBytes, new String(valueBytes, UTF_8).getBytes(UTF_8));
+    }
+
+    @Test(groups = {"java_state", "state", "function", "java_function"})
+    public void testSourceByteState() throws Exception {
+        String outputTopicName = "test-state-source-output-" + randomName(8);
+        String sourceName = "test-state-source-" + randomName(8);
+
+        submitSourceConnector(sourceName, outputTopicName,
+                "org.apache.pulsar.tests.integration.io.TestByteStateSource", JAVAJAR);
+
+        // get source info
+        getSourceInfoSuccess(sourceName);
+
+        // get source status
+        getSourceStatus(sourceName);
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWritten > 0);
+            });
+
+            {
+                FunctionState functionState =
+                        admin.functions().getFunctionState("public", "default", sourceName, "initial");
+                assertNull(functionState.getStringValue());
+                assertEquals(functionState.getByteValue(), Base64.getDecoder().decode(VALUE_BASE64));
+            }
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                FunctionState functionState =
+                        admin.functions().getFunctionState("public", "default", sourceName, "now");
+                assertNull(functionState.getStringValue());
+                assertEquals(functionState.getByteValue(), Base64.getDecoder().decode(VALUE_BASE64));
+            });
+        }
+
+        // delete source
+        deleteSource(sourceName);
+
+        getSourceInfoNotFound(sourceName);
+    }
+
+    private void submitSourceConnector(String sourceName,
+                                       String outputTopicName,
+                                       String className,
+                                       String archive) throws Exception {
+        String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources", "create",
+                "--name", sourceName,
+                "--destinationTopicName", outputTopicName,
+                "--archive", archive,
+                "--classname", className
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    private void submitSinkConnector(String sinkName,
+                                     String inputTopicName,
+                                     String className,
+                                     String archive) throws Exception {
+        String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks", "create",
+                "--name", sinkName,
+                "--inputs", inputTopicName,
+                "--archive", archive,
+                "--classname", className
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    private void submitWordCountFunction(Runtime runtime,
+                                         String inputTopicName,
+                                         String outputTopicName,
+                                         String functionName) throws Exception {
+        submitFunction(
+                runtime,
+                inputTopicName,
+                outputTopicName,
+                functionName,
+                getWordCountClass(runtime),
+                Schema.BYTES);
+    }
+
+    protected static String getWordCountClass(Runtime runtime) {
+        if (Runtime.PYTHON == runtime) {
+            return WORDCOUNT_PYTHON_CLASS;
+        } else if (Runtime.JAVA == runtime) {
+            return WORDCOUNT_JAVA_CLASS;
+        } else {
+            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
+        }
+    }
+
+    private <T> void submitFunction(Runtime runtime,
+                                    String inputTopicName,
+                                    String outputTopicName,
+                                    String functionName,
+                                    String functionClass,
+                                    Schema<T> inputTopicSchema) throws Exception {
+        CommandGenerator generator;
+        generator = CommandGenerator.createDefaultGenerator(inputTopicName, functionClass);
+        generator.setSinkTopic(outputTopicName);
+        generator.setFunctionName(functionName);
+        String command;
+        if (Runtime.JAVA == runtime) {
+            command = generator.generateCreateFunctionCommand();
+        } else if (Runtime.PYTHON == runtime) {
+            generator.setRuntime(runtime);
+            command = generator.generateCreateFunctionCommand(WORDCOUNT_PYTHON_FILE);
+        } else {
+            throw new IllegalArgumentException("Unsupported runtime : " + runtime);
+        }
+        String[] commands = {
+                "sh", "-c", command
+        };
+        ContainerExecResult result = container.execCmd(
+                commands);
+        assertTrue(result.getStdout().contains("Created successfully"));
+
+        ensureSubscriptionCreated(inputTopicName, String.format("public/default/%s", functionName), inputTopicSchema);
+    }
+
+    @SuppressWarnings("try")
+    private <T> void ensureSubscriptionCreated(String inputTopicName,
+                                               String subscriptionName,
+                                               Schema<T> inputTopicSchema)
+            throws Exception {
+        // ensure the function subscription exists before we start producing messages
+        try (PulsarClient client = PulsarClient.builder()
+                .serviceUrl(container.getPlainTextServiceUrl())
+                .build()) {
+            try (Consumer<T> ignored = client.newConsumer(inputTopicSchema)
+                    .topic(inputTopicName)
+                    .subscriptionType(SubscriptionType.Shared)
+                    .subscriptionName(subscriptionName)
+                    .subscribe()) {
+            }
+        }
+    }
+
+    private void getSinkInfoSuccess(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sinkName + "\""));
+    }
+
+    private void getSourceInfoSuccess(String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
+    }
+
+    private void getFunctionInfoSuccess(String functionName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + functionName + "\""));
+    }
+
+    private void getFunctionInfoNotFound(String functionName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "functions",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", functionName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Function " + functionName + " doesn't exist"));
+        }
+    }
+
+    private void getSinkStatus(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private void getSourceStatus(String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private void getFunctionStatus(String functionName, int numMessages) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "getstatus",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+        assertTrue(result.getStdout().contains("\"numSuccessfullyProcessed\" : " + numMessages));
+    }
+
+    private void queryState(String functionName, String key, int amount, long version)
+            throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "querystate",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName,
+                "--key", key
+        );
+        assertTrue(result.getStdout().contains("\"numberValue\": " + amount));
+        assertTrue(result.getStdout().contains("\"version\": " + version));
+        assertFalse(result.getStdout().contains("stringValue"));
+        assertFalse(result.getStdout().contains("byteValue"));
+    }
+
+    private void putAndQueryState(String functionName, String key, String state, String expect)
+            throws Exception {
+        container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "putstate",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName,
+                "--state", state
+        );
+
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "querystate",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName,
+                "--key", key
+        );
+        assertTrue(result.getStdout().contains(expect));
+    }
+
+    private void putAndQueryStateByte(String functionName, String key, String state, byte[] expect)
+            throws Exception {
+        container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "putstate",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName,
+                "--state", state
+        );
+
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "querystate",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName,
+                "--key", key
+        );
+
+        FunctionState byteState = new Gson().fromJson(result.getStdout(), FunctionState.class);
+        assertNull(byteState.getStringValue());
+        assertEquals(byteState.getByteValue(), expect);
+    }
+
+    private void publishAndConsumeMessages(String inputTopic,
+                                           String outputTopic,
+                                           int numMessages) throws Exception {
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(container.getPlainTextServiceUrl())
+                .build();
+        @Cleanup Producer<byte[]> producer = client.newProducer(Schema.BYTES)
+                .topic(inputTopic)
+                .create();
+
+        for (int i = 0; i < numMessages; i++) {
+            producer.send(("hello test message-" + i).getBytes(UTF_8));
+        }
+
+        if (outputTopic == null) {
+            return;
+        }
+        @Cleanup Consumer<byte[]> consumer = client.newConsumer(Schema.BYTES)
+                .topic(outputTopic)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-sub")
+                .subscribe();
+        for (int i = 0; i < numMessages; i++) {
+            Message<byte[]> msg = consumer.receive();
+            assertEquals("hello test message-" + i + "!", new String(msg.getValue(), UTF_8));
+        }
+    }
+
+    private void deleteFunction(String functionName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+        assertTrue(result.getStdout().contains("Deleted successfully"));
+        result.assertNoStderr();
+    }
+
+    private void deleteSource(String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("Delete source successfully"));
+        result.assertNoStderr();
+    }
+
+    private void deleteSink(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("Deleted successfully"));
+        result.assertNoStderr();
+    }
+
+    private void getSourceInfoNotFound(String sourceName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sources",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", sourceName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+
+    private void getSinkInfoNotFound(String sinkName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sinks",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", sinkName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Sink " + sinkName + " doesn't exist"));
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoProcessTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoProcessTest.java
index 61e985ae99..790a154b86 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoProcessTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoProcessTest.java
@@ -1,29 +1,29 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.go;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarFunctionsGoProcessTest extends PulsarFunctionsGoTest {
-
-    PulsarFunctionsGoProcessTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.go;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarFunctionsGoProcessTest extends PulsarFunctionsGoTest {
+
+    PulsarFunctionsGoProcessTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoTest.java
index 0550fd94eb..f8222cb9dd 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoTest.java
@@ -1,42 +1,42 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.go;
-
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testng.annotations.Test;
-
-public abstract class PulsarFunctionsGoTest extends PulsarFunctionsTest {
-
-    PulsarFunctionsGoTest(FunctionRuntimeType functionRuntimeType) {
-        super(functionRuntimeType);
-    }
-
-    @Test(enabled = false, groups = {"go_function", "function"})
-    public void testGoFunctionLocalRun() throws Exception {
-        testFunctionLocalRun(Runtime.GO);
-    }
-
-    @Test(groups = {"go_function", "function"})
-    public void testGoExclamationMultiInputsFunction() throws Exception {
-        testExclamationFunction(Runtime.GO, false, false, true, false);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.go;
+
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testng.annotations.Test;
+
+public abstract class PulsarFunctionsGoTest extends PulsarFunctionsTest {
+
+    PulsarFunctionsGoTest(FunctionRuntimeType functionRuntimeType) {
+        super(functionRuntimeType);
+    }
+
+    @Test(enabled = false, groups = {"go_function", "function"})
+    public void testGoFunctionLocalRun() throws Exception {
+        testFunctionLocalRun(Runtime.GO);
+    }
+
+    @Test(groups = {"go_function", "function"})
+    public void testGoExclamationMultiInputsFunction() throws Exception {
+        testExclamationFunction(Runtime.GO, false, false, true, false);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoThreadTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoThreadTest.java
index 52c76bd659..9bc6ad1db6 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoThreadTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/go/PulsarFunctionsGoThreadTest.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.go;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarFunctionsGoThreadTest extends PulsarFunctionsGoTest {
-
-    PulsarFunctionsGoThreadTest() {
-        super(FunctionRuntimeType.THREAD);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.go;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarFunctionsGoThreadTest extends PulsarFunctionsGoTest {
+
+    PulsarFunctionsGoThreadTest() {
+        super(FunctionRuntimeType.THREAD);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaProcessTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaProcessTest.java
index 3acf5d0e44..fb12fa6a76 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaProcessTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaProcessTest.java
@@ -1,29 +1,29 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.java;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarFunctionsJavaProcessTest extends PulsarFunctionsJavaTest {
-
-    public PulsarFunctionsJavaProcessTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.java;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarFunctionsJavaProcessTest extends PulsarFunctionsJavaTest {
+
+    public PulsarFunctionsJavaProcessTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaTest.java
index 6610a35e11..ca2d70b838 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaTest.java
@@ -1,285 +1,285 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.java;
-
-import static org.testng.Assert.assertEquals;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import org.apache.commons.collections4.map.HashedMap;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.common.functions.BatchingConfig;
-import org.apache.pulsar.common.functions.ConsumerConfig;
-import org.apache.pulsar.common.functions.MessagePayloadProcessorConfig;
-import org.apache.pulsar.common.functions.ProducerConfig;
-import org.apache.pulsar.common.policies.data.FunctionStatus;
-import org.apache.pulsar.common.policies.data.FunctionStatusUtil;
-import org.apache.pulsar.functions.api.examples.TestPayloadProcessor;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.annotations.Test;
-
-public abstract class PulsarFunctionsJavaTest extends PulsarFunctionsTest {
-
-    PulsarFunctionsJavaTest(FunctionRuntimeType functionRuntimeType) {
-        super(functionRuntimeType);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaFunctionLocalRun() throws Exception {
-        testFunctionLocalRun(Runtime.JAVA);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaFunctionNegAck() throws Exception {
-        testFunctionNegAck(Runtime.JAVA);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaPublishFunction() throws Exception {
-        testPublishFunction(Runtime.JAVA);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testSerdeFunction() throws Exception {
-        testCustomSerdeFunction();
-    }
-
-    private void testCustomSerdeFunction() throws Exception {
-        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
-            return;
-        }
-
-        String inputTopicName = "persistent://public/default/test-serde-java-input-" + randomName(8);
-        String outputTopicName = "test-publish-serde-output-" + randomName(8);
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-
-        Map<String, String> inputTopicsSerde = new HashedMap<>();
-        inputTopicsSerde.put(inputTopicName, SERDE_CLASS);
-
-        String functionName = "test-serde-fn-" + randomName(8);
-        submitFunction(
-                Runtime.JAVA, inputTopicName, outputTopicName, functionName, null, SERDE_JAVA_CLASS, inputTopicsSerde,
-                SERDE_CLASS, Collections.singletonMap("serde-topic", outputTopicName)
-        );
-
-        // get function info
-        getFunctionInfoSuccess(functionName);
-        // get function stats
-        getFunctionStatsEmpty(functionName);
-
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", functionName
-        );
-
-        FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
-        assertEquals(functionStatus.getNumInstances(), 1);
-        assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
-    }
-
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaExclamationFunction() throws Exception {
-        testExclamationFunction(Runtime.JAVA, false, false, false, false);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaExclamationTopicPatternFunction() throws Exception {
-        testExclamationFunction(Runtime.JAVA, true, false, false, false);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaExclamationCustomBatchingFunction() throws Exception {
-        ProducerConfig producerConfig = new ProducerConfig();
-        producerConfig.setBatchingConfig(BatchingConfig.builder()
-                .enabled(true)
-                .batchingMaxPublishDelayMs(5)
-                .batchingMaxMessages(100)
-                .batchingMaxBytes(64 * 1024)
-                .roundRobinRouterBatchingPartitionSwitchFrequency(5)
-                .batchBuilder("KEY_BASED")
-                .build());
-        testExclamationFunction(Runtime.JAVA, false, false, false, false, null,
-                producerConfig, commandGenerator -> {
-                    commandGenerator.setProducerConfig(producerConfig);
-                });
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaExclamationDiableBatchingFunction() throws Exception {
-        ProducerConfig producerConfig = new ProducerConfig();
-        producerConfig.setBatchingConfig(BatchingConfig.builder()
-                .enabled(false)
-                .build());
-        testExclamationFunction(Runtime.JAVA, false, false, false, false, null,
-                producerConfig, commandGenerator -> {
-                    commandGenerator.setProducerConfig(producerConfig);
-                });
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaExclamationMessagePayloadProcessor() throws Exception {
-        ConsumerConfig consumerConfig = new ConsumerConfig();
-        consumerConfig.setMessagePayloadProcessorConfig(
-                new MessagePayloadProcessorConfig(
-                        TestPayloadProcessor.class.getName(),
-                        null
-                )
-        );
-        testExclamationFunction(Runtime.JAVA, false, false, false, false,
-                consumerConfig, null, commandGenerator -> {
-                    commandGenerator.setConsumerConfig(consumerConfig);
-                });
-    }
-
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaExclamationMessagePayloadProcessorWithConfigs() throws Exception {
-        ConsumerConfig consumerConfig = new ConsumerConfig();
-        consumerConfig.setMessagePayloadProcessorConfig(
-                new MessagePayloadProcessorConfig(
-                        TestPayloadProcessor.class.getName(),
-                        new HashMap<>(Map.of("key1", "value1", "key2", "value2"))
-                )
-        );
-        testExclamationFunction(Runtime.JAVA, false, false, false, false,
-                consumerConfig, null, commandGenerator -> {
-                    commandGenerator.setConsumerConfig(consumerConfig);
-                });
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testJavaLoggingFunction() throws Exception {
-        testLoggingFunction(Runtime.JAVA);
-    }
-
-
-    @Test(groups = {"java_function", "function"})
-    public void testInitFunction() throws Exception {
-        testInitFunction(Runtime.JAVA);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testTumblingCountWindowTest() throws Exception {
-        String[] expectedResults = {
-                "0,1,2,3,4,5,6,7,8,9",
-                "10,11,12,13,14,15,16,17,18,19",
-                "20,21,22,23,24,25,26,27,28,29",
-                "30,31,32,33,34,35,36,37,38,39",
-                "40,41,42,43,44,45,46,47,48,49",
-                "50,51,52,53,54,55,56,57,58,59",
-                "60,61,62,63,64,65,66,67,68,69",
-                "70,71,72,73,74,75,76,77,78,79",
-                "80,81,82,83,84,85,86,87,88,89",
-                "90,91,92,93,94,95,96,97,98,99",
-        };
-
-        testWindowFunction("tumbling", expectedResults);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testSlidingCountWindowTest() throws Exception {
-        String[] expectedResults = {
-                "0,1,2,3,4",
-                "0,1,2,3,4,5,6,7,8,9",
-                "5,6,7,8,9,10,11,12,13,14",
-                "10,11,12,13,14,15,16,17,18,19",
-                "15,16,17,18,19,20,21,22,23,24",
-                "20,21,22,23,24,25,26,27,28,29",
-                "25,26,27,28,29,30,31,32,33,34",
-                "30,31,32,33,34,35,36,37,38,39",
-                "35,36,37,38,39,40,41,42,43,44",
-                "40,41,42,43,44,45,46,47,48,49",
-                "45,46,47,48,49,50,51,52,53,54",
-                "50,51,52,53,54,55,56,57,58,59",
-                "55,56,57,58,59,60,61,62,63,64",
-                "60,61,62,63,64,65,66,67,68,69",
-                "65,66,67,68,69,70,71,72,73,74",
-                "70,71,72,73,74,75,76,77,78,79",
-                "75,76,77,78,79,80,81,82,83,84",
-                "80,81,82,83,84,85,86,87,88,89",
-                "85,86,87,88,89,90,91,92,93,94",
-                "90,91,92,93,94,95,96,97,98,99",
-        };
-
-        testWindowFunction("sliding", expectedResults);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testMergeFunctionTest() throws Exception {
-        testMergeFunction();
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testGenericObjectFunction() throws Exception {
-        testGenericObjectFunction(GENERIC_OBJECT_FUNCTION_JAVA_CLASS, false, false);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testGenericObjectRemoveFieldFunction() throws Exception {
-        testGenericObjectFunction(REMOVE_AVRO_FIELD_FUNCTION_JAVA_CLASS, true, false);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testGenericObjectRemoveFieldRecordFunction() throws Exception {
-        testGenericObjectFunction(REMOVE_AVRO_FIELD_RECORD_FUNCTION_JAVA_CLASS, true, false);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testGenericObjectFunctionKeyValue() throws Exception {
-        testGenericObjectFunction(GENERIC_OBJECT_FUNCTION_JAVA_CLASS, false, true);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testGenericObjectRemoveFieldFunctionKeyValue() throws Exception {
-        testGenericObjectFunction(REMOVE_AVRO_FIELD_FUNCTION_JAVA_CLASS, true, true);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testGenericObjectRemoveFieldRecordFunctionKeyValue() throws Exception {
-        testGenericObjectFunction(REMOVE_AVRO_FIELD_RECORD_FUNCTION_JAVA_CLASS, true, true);
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testRecordFunctionTest() throws Exception {
-        testRecordFunction();
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testAutoSchemaFunctionTest() throws Exception {
-        testAutoSchemaFunction();
-    }
-
-    @Test(groups = {"java_function", "function"})
-    public void testAvroSchemaFunctionTest() throws Exception {
-        testAvroSchemaFunction(Runtime.JAVA);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.java;
+
+import static org.testng.Assert.assertEquals;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.collections4.map.HashedMap;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.common.functions.BatchingConfig;
+import org.apache.pulsar.common.functions.ConsumerConfig;
+import org.apache.pulsar.common.functions.MessagePayloadProcessorConfig;
+import org.apache.pulsar.common.functions.ProducerConfig;
+import org.apache.pulsar.common.policies.data.FunctionStatus;
+import org.apache.pulsar.common.policies.data.FunctionStatusUtil;
+import org.apache.pulsar.functions.api.examples.TestPayloadProcessor;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.annotations.Test;
+
+public abstract class PulsarFunctionsJavaTest extends PulsarFunctionsTest {
+
+    PulsarFunctionsJavaTest(FunctionRuntimeType functionRuntimeType) {
+        super(functionRuntimeType);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaFunctionLocalRun() throws Exception {
+        testFunctionLocalRun(Runtime.JAVA);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaFunctionNegAck() throws Exception {
+        testFunctionNegAck(Runtime.JAVA);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaPublishFunction() throws Exception {
+        testPublishFunction(Runtime.JAVA);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testSerdeFunction() throws Exception {
+        testCustomSerdeFunction();
+    }
+
+    private void testCustomSerdeFunction() throws Exception {
+        if (functionRuntimeType == FunctionRuntimeType.THREAD) {
+            return;
+        }
+
+        String inputTopicName = "persistent://public/default/test-serde-java-input-" + randomName(8);
+        String outputTopicName = "test-publish-serde-output-" + randomName(8);
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+
+        Map<String, String> inputTopicsSerde = new HashedMap<>();
+        inputTopicsSerde.put(inputTopicName, SERDE_CLASS);
+
+        String functionName = "test-serde-fn-" + randomName(8);
+        submitFunction(
+                Runtime.JAVA, inputTopicName, outputTopicName, functionName, null, SERDE_JAVA_CLASS, inputTopicsSerde,
+                SERDE_CLASS, Collections.singletonMap("serde-topic", outputTopicName)
+        );
+
+        // get function info
+        getFunctionInfoSuccess(functionName);
+        // get function stats
+        getFunctionStatsEmpty(functionName);
+
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", functionName
+        );
+
+        FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
+        assertEquals(functionStatus.getNumInstances(), 1);
+        assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
+    }
+
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaExclamationFunction() throws Exception {
+        testExclamationFunction(Runtime.JAVA, false, false, false, false);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaExclamationTopicPatternFunction() throws Exception {
+        testExclamationFunction(Runtime.JAVA, true, false, false, false);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaExclamationCustomBatchingFunction() throws Exception {
+        ProducerConfig producerConfig = new ProducerConfig();
+        producerConfig.setBatchingConfig(BatchingConfig.builder()
+                .enabled(true)
+                .batchingMaxPublishDelayMs(5)
+                .batchingMaxMessages(100)
+                .batchingMaxBytes(64 * 1024)
+                .roundRobinRouterBatchingPartitionSwitchFrequency(5)
+                .batchBuilder("KEY_BASED")
+                .build());
+        testExclamationFunction(Runtime.JAVA, false, false, false, false, null,
+                producerConfig, commandGenerator -> {
+                    commandGenerator.setProducerConfig(producerConfig);
+                });
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaExclamationDiableBatchingFunction() throws Exception {
+        ProducerConfig producerConfig = new ProducerConfig();
+        producerConfig.setBatchingConfig(BatchingConfig.builder()
+                .enabled(false)
+                .build());
+        testExclamationFunction(Runtime.JAVA, false, false, false, false, null,
+                producerConfig, commandGenerator -> {
+                    commandGenerator.setProducerConfig(producerConfig);
+                });
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaExclamationMessagePayloadProcessor() throws Exception {
+        ConsumerConfig consumerConfig = new ConsumerConfig();
+        consumerConfig.setMessagePayloadProcessorConfig(
+                new MessagePayloadProcessorConfig(
+                        TestPayloadProcessor.class.getName(),
+                        null
+                )
+        );
+        testExclamationFunction(Runtime.JAVA, false, false, false, false,
+                consumerConfig, null, commandGenerator -> {
+                    commandGenerator.setConsumerConfig(consumerConfig);
+                });
+    }
+
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaExclamationMessagePayloadProcessorWithConfigs() throws Exception {
+        ConsumerConfig consumerConfig = new ConsumerConfig();
+        consumerConfig.setMessagePayloadProcessorConfig(
+                new MessagePayloadProcessorConfig(
+                        TestPayloadProcessor.class.getName(),
+                        new HashMap<>(Map.of("key1", "value1", "key2", "value2"))
+                )
+        );
+        testExclamationFunction(Runtime.JAVA, false, false, false, false,
+                consumerConfig, null, commandGenerator -> {
+                    commandGenerator.setConsumerConfig(consumerConfig);
+                });
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testJavaLoggingFunction() throws Exception {
+        testLoggingFunction(Runtime.JAVA);
+    }
+
+
+    @Test(groups = {"java_function", "function"})
+    public void testInitFunction() throws Exception {
+        testInitFunction(Runtime.JAVA);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testTumblingCountWindowTest() throws Exception {
+        String[] expectedResults = {
+                "0,1,2,3,4,5,6,7,8,9",
+                "10,11,12,13,14,15,16,17,18,19",
+                "20,21,22,23,24,25,26,27,28,29",
+                "30,31,32,33,34,35,36,37,38,39",
+                "40,41,42,43,44,45,46,47,48,49",
+                "50,51,52,53,54,55,56,57,58,59",
+                "60,61,62,63,64,65,66,67,68,69",
+                "70,71,72,73,74,75,76,77,78,79",
+                "80,81,82,83,84,85,86,87,88,89",
+                "90,91,92,93,94,95,96,97,98,99",
+        };
+
+        testWindowFunction("tumbling", expectedResults);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testSlidingCountWindowTest() throws Exception {
+        String[] expectedResults = {
+                "0,1,2,3,4",
+                "0,1,2,3,4,5,6,7,8,9",
+                "5,6,7,8,9,10,11,12,13,14",
+                "10,11,12,13,14,15,16,17,18,19",
+                "15,16,17,18,19,20,21,22,23,24",
+                "20,21,22,23,24,25,26,27,28,29",
+                "25,26,27,28,29,30,31,32,33,34",
+                "30,31,32,33,34,35,36,37,38,39",
+                "35,36,37,38,39,40,41,42,43,44",
+                "40,41,42,43,44,45,46,47,48,49",
+                "45,46,47,48,49,50,51,52,53,54",
+                "50,51,52,53,54,55,56,57,58,59",
+                "55,56,57,58,59,60,61,62,63,64",
+                "60,61,62,63,64,65,66,67,68,69",
+                "65,66,67,68,69,70,71,72,73,74",
+                "70,71,72,73,74,75,76,77,78,79",
+                "75,76,77,78,79,80,81,82,83,84",
+                "80,81,82,83,84,85,86,87,88,89",
+                "85,86,87,88,89,90,91,92,93,94",
+                "90,91,92,93,94,95,96,97,98,99",
+        };
+
+        testWindowFunction("sliding", expectedResults);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testMergeFunctionTest() throws Exception {
+        testMergeFunction();
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testGenericObjectFunction() throws Exception {
+        testGenericObjectFunction(GENERIC_OBJECT_FUNCTION_JAVA_CLASS, false, false);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testGenericObjectRemoveFieldFunction() throws Exception {
+        testGenericObjectFunction(REMOVE_AVRO_FIELD_FUNCTION_JAVA_CLASS, true, false);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testGenericObjectRemoveFieldRecordFunction() throws Exception {
+        testGenericObjectFunction(REMOVE_AVRO_FIELD_RECORD_FUNCTION_JAVA_CLASS, true, false);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testGenericObjectFunctionKeyValue() throws Exception {
+        testGenericObjectFunction(GENERIC_OBJECT_FUNCTION_JAVA_CLASS, false, true);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testGenericObjectRemoveFieldFunctionKeyValue() throws Exception {
+        testGenericObjectFunction(REMOVE_AVRO_FIELD_FUNCTION_JAVA_CLASS, true, true);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testGenericObjectRemoveFieldRecordFunctionKeyValue() throws Exception {
+        testGenericObjectFunction(REMOVE_AVRO_FIELD_RECORD_FUNCTION_JAVA_CLASS, true, true);
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testRecordFunctionTest() throws Exception {
+        testRecordFunction();
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testAutoSchemaFunctionTest() throws Exception {
+        testAutoSchemaFunction();
+    }
+
+    @Test(groups = {"java_function", "function"})
+    public void testAvroSchemaFunctionTest() throws Exception {
+        testAvroSchemaFunction(Runtime.JAVA);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaThreadTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaThreadTest.java
index faf6482f53..919779d7fb 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaThreadTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarFunctionsJavaThreadTest.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.java;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarFunctionsJavaThreadTest extends PulsarFunctionsJavaTest {
-
-    public PulsarFunctionsJavaThreadTest() {
-        super(FunctionRuntimeType.THREAD);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.java;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarFunctionsJavaThreadTest extends PulsarFunctionsJavaTest {
+
+    public PulsarFunctionsJavaThreadTest() {
+        super(FunctionRuntimeType.THREAD);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainProcessTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainProcessTest.java
index 11dec0b386..1e78471bd7 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainProcessTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainProcessTest.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.java;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarWorkerRebalanceDrainProcessTest extends PulsarWorkerRebalanceDrainTest {
-
-    public PulsarWorkerRebalanceDrainProcessTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.java;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarWorkerRebalanceDrainProcessTest extends PulsarWorkerRebalanceDrainTest {
+
+    public PulsarWorkerRebalanceDrainProcessTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainTest.java
index d15db61082..3010108fa4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainTest.java
@@ -1,399 +1,399 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.java;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import com.fasterxml.jackson.databind.MappingIterator;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import lombok.extern.slf4j.Slf4j;
-import lombok.val;
-import org.apache.commons.collections4.map.HashedMap;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.common.functions.WorkerInfo;
-import org.apache.pulsar.common.policies.data.FunctionStatus;
-import org.apache.pulsar.common.policies.data.FunctionStatusUtil;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.annotations.Test;
-
-@Slf4j
-public abstract class PulsarWorkerRebalanceDrainTest extends PulsarFunctionsTest {
-
-    final String urlProtocolPrefix = "http://";
-    final String workerRebalanceUrlSuffix = "/admin/v2/worker/rebalance";
-    final String workerDrainAtLeaderUrlSuffix = "/admin/v2/worker/leader/drain?workerId=";
-    final int numFunctionsAssignedOnEachWorker = 2;
-    final int numAdditionalWorkersAtSetup = 1;
-
-    PulsarWorkerRebalanceDrainTest(FunctionRuntimeType functionRuntimeType) {
-        super(functionRuntimeType);
-    }
-
-    @Override
-    public void setupCluster() throws Exception {
-        super.setupCluster();
-        pulsarCluster.setupFunctionWorkers(randomName(5), functionRuntimeType, numAdditionalWorkersAtSetup);
-        log.debug("PulsarWorkerRebalanceDrainTest: set up a total of {} function workers, of type {}",
-                pulsarCluster.getAlWorkers().size(), functionRuntimeType);
-    }
-
-    @Test(groups = {"java_function", "rebalance_drain", "rebalance"})
-    public void testRebalanceWorkers() throws Exception {
-        testRebalance();
-        log.info("Done with testRebalance");
-    }
-
-    @Test(groups = {"java_function", "rebalance_drain", "drain"})
-    public void testDrainWorkers() throws Exception {
-        testDrain();
-        log.info("Done with testDrain");
-    }
-
-    private List<WorkerInfo> workerInfoDecode(String json) throws IOException {
-        try (MappingIterator<WorkerInfo> it =
-                     ObjectMapperFactory.getMapper().getObjectMapper().readerFor(WorkerInfo.class)
-                .readValues(json)) {
-            return it.readAll();
-        }
-    }
-
-    // Parse a retrieved function-assignments list.
-    private List<Map<String, Collection<String>>> functionAssignmentsDecode(String json) throws IOException {
-        // Ad hoc parsing of the list of maps for function assignments.
-        // It is ad hoc because there doesn't appear to be any class exported from the function-worker code
-        // for this structure.
-        // The list is expected to be of the following form (this is from a real example):
-//           String json =
-//               "pulsar-functions-worker-process-hurkp-1    "
-//               + " [public/default/testDrainFunctionality-cipscktc:0, "
-//                       + "public/default/testDrainFunctionality-mzaudmyx:0] "
-//               + "pulsar-functions-worker-process-hurkp-0    "
-//               + " [public/default/testDrainFunctionality-morjleeh:0, "
-//                       + "public/default/testDrainFunctionality-owsxgiuo:0] "
-//               + "pulsar-functions-worker-process-qmcao-0    "
-//               + "[public/default/testDrainFunctionality-nsnqbnlc:0, "
-//                       + "public/default/testDrainFunctionality-tbakebis:0] ";
-
-        final int nextWorkerStart = 0;
-        String remainingJson = json;
-        String nextFunctionList;
-        String nextWorker;
-        boolean moreToParse = true;
-        List<Map<String, Collection<String>>> retVal = new ArrayList<>();
-
-        while (moreToParse) {
-            int nextFunctionListStart = remainingJson.indexOf("[");
-            int nextFunctionListEnd = remainingJson.indexOf("]");
-            nextWorker = remainingJson.substring(nextWorkerStart, nextFunctionListStart);
-            nextWorker = nextWorker.replaceAll("\\s+", "");
-            nextFunctionList = remainingJson.substring(nextFunctionListStart + 1, nextFunctionListEnd);
-            String[] funcAssignments = nextFunctionList.split(",");
-            Map<String, Collection<String>> curMap = new HashMap<>();
-            curMap.put(nextWorker, Arrays.asList(funcAssignments));
-            log.info("Found new entry: {}, {}", nextWorker, funcAssignments);
-            retVal.add(curMap);
-            log.info("retVal is {}", retVal);
-
-            // If we are already at the end, or if there are no more opening brackets
-            // (corresponding to function assignments), we are done.
-            try {
-                remainingJson = remainingJson.substring(nextFunctionListEnd + 1);
-            } catch (Throwable t) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Got exception {} while moving past function-list-end", t.getMessage());
-                }
-                moreToParse = false;
-            }
-            if (remainingJson.indexOf("[") < 0) {
-                moreToParse = false;
-            }
-        }
-        return retVal;
-    }
-
-    private List<WorkerInfo> getClusterStatus() throws Exception {
-        val result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions-worker",
-                "get-cluster"
-        );
-        log.debug("getClusterStatus result is: {}", result);
-        return workerInfoDecode(result.getStdout());
-    }
-
-    private WorkerInfo getClusterLeader() throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions-worker",
-                "get-cluster-leader"
-        );
-        List<WorkerInfo> winfos = workerInfoDecode(result.getStdout());
-        assertEquals(winfos.size(), 1);
-        return workerInfoDecode(result.getStdout()).get(0);
-    }
-
-    private List<Map<String, Collection<String>>> getFunctionAssignments() throws Exception {
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "functions-worker",
-                "get-function-assignments"
-        );
-        log.debug("getFunctionAssignments result is: {}", result);
-        return functionAssignmentsDecode(result.getStdout());
-    }
-
-    // Get the total number of functions assigned to all workers in the given function-info.
-    private int getFuncAssignmentsCount(List<Map<String, Collection<String>>> finfos) {
-        int funcCount = 0;
-        for (val l : finfos) {
-            for (val m : l.entrySet()) {
-                if (log.isDebugEnabled()) {
-                    log.debug("accumulating for key={}, value={} (size {})",
-                            m.getKey(), m.getValue(), m.getValue().size());
-                }
-                funcCount += m.getValue().size();
-            }
-        }
-        return funcCount;
-    }
-
-    // Get the min number of functions assigned to any worker in the given function-info.
-    private int getMinFuncAssignmentOnAnyWorker(List<Map<String, Collection<String>>> finfos) {
-        int minFuncCount = Integer.MAX_VALUE;
-        for (val l : finfos) {
-            for (val m : l.entrySet()) {
-                if (log.isDebugEnabled()) {
-                    log.debug("comparing current_min={} with key={}, value={} (size {})",
-                            minFuncCount, m.getKey(), m.getValue(), m.getValue().size());
-                }
-                minFuncCount = Math.min(minFuncCount, m.getValue().size());
-            }
-        }
-        return minFuncCount;
-    }
-
-    private void callRebalance() throws Exception {
-        val leader = getClusterLeader();
-        val worker = pulsarCluster.getWorker(leader.getWorkerId());
-        assertTrue(worker != null);
-
-        String rebalanceUrl = urlProtocolPrefix
-                + "localhost"
-                + ":"
-                + leader.getPort()
-                + workerRebalanceUrlSuffix;
-        ContainerExecResult result = worker.execCmd(
-                PulsarCluster.CURL,
-                "-X",
-                "PUT",
-                rebalanceUrl
-        );
-        if (log.isDebugEnabled()) {
-            log.debug("callRebalance: leader's rebalance url is: {}", rebalanceUrl);
-            log.debug("callRebalance: curl for rebalance: result is {}", result);
-        }
-    }
-
-    private void callDrain(final String workerToDrain) throws Exception {
-        val leader = getClusterLeader();
-        val worker = pulsarCluster.getWorker(leader.getWorkerId());
-        assertTrue(worker != null);
-
-        String drainUrl = urlProtocolPrefix
-                + "localhost"
-                + ":"
-                + leader.getPort()
-                + workerDrainAtLeaderUrlSuffix
-                + workerToDrain;
-        ContainerExecResult result = worker.execCmd(
-                PulsarCluster.CURL,
-                "-X",
-                "PUT",
-                drainUrl
-        );
-        if (log.isDebugEnabled()) {
-            log.debug("callDrain: leader's drain url is: {}", drainUrl);
-            log.debug("callDrain: curl for drain: result is {}", result);
-        }
-    }
-
-    private void createFunctionWorker(String functionName, String topicPrefix) throws Exception {
-        String suffix = functionName + randomName(8);
-        String inputTopicName = "persistent://public/default/" + topicPrefix + "-input-" + suffix;
-        String outputTopicName = topicPrefix + "-output-" + suffix;
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
-            admin.topics().createNonPartitionedTopic(inputTopicName);
-            admin.topics().createNonPartitionedTopic(outputTopicName);
-        }
-
-        Map<String, String> inputTopicsSerde = new HashedMap<>();
-        inputTopicsSerde.put(inputTopicName, SERDE_CLASS);
-
-        submitFunction(
-                Runtime.JAVA, inputTopicName, outputTopicName, functionName, null, SERDE_JAVA_CLASS, inputTopicsSerde,
-                SERDE_CLASS, Collections.singletonMap(topicPrefix, outputTopicName)
-        );
-    }
-
-    private void showWorkerStatus(String callerContext) throws Exception {
-        List<WorkerInfo> winfos = getClusterStatus();
-        assertEquals(winfos.size(), pulsarCluster.getAlWorkers().size());
-        log.info("{} get-cluster retrieved info about {} workers", callerContext, winfos.size());
-        winfos.forEach(w -> log.info("{} get-cluster worker-info: {}", callerContext, w));
-
-        val leaderInfo = getClusterLeader();
-        log.info("{} get-cluster-leader info: {}", callerContext, leaderInfo);
-
-        val finfos = getFunctionAssignments();
-        log.info("{} get-function-assignments retrieved info about {} workers with {} functions",
-                callerContext, finfos.size(), getFuncAssignmentsCount(finfos));
-        finfos.forEach(f -> log.info("{} get-function-assignments info: {}", callerContext, f));
-    }
-
-    private void allocateFunctions(String callingTest, String topicPrefix) throws  Exception {
-        // Allocate functions until there are NumFunctionsAssignedOnEachWorker on each worker, on the average.
-        ContainerExecResult result;
-        int numFunctions = pulsarCluster.getAlWorkers().size() * numFunctionsAssignedOnEachWorker;
-
-        for (int ix = 0; ix < numFunctions; ix++) {
-            String functionName = callingTest + "-" + randomName(8);
-            createFunctionWorker(functionName, topicPrefix);
-
-            result = pulsarCluster.getAnyWorker().execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "functions",
-                    "status",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", functionName
-            );
-
-            FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
-            log.debug("{}}: functionStatus is {}", callingTest, functionStatus);
-
-            assertEquals(functionStatus.getNumInstances(), 1);
-            assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
-        }
-    }
-
-    private void testRebalance() throws Exception {
-        // Add some workers; then call rebalance, and check that functions were assigned to all of the workers.
-        allocateFunctions("testRebalanceAddWorkers", "test-rebalance");
-
-        if (log.isDebugEnabled()) {
-            this.showWorkerStatus("testRebalanceAddWorkers after allocating functions");
-        }
-
-        WorkerInfo oldClusterLeaderInfo = getClusterLeader();
-        log.info("Cluster leader before adding more workers is: {}", oldClusterLeaderInfo);
-
-        List<Map<String, Collection<String>>> startFinfos = getFunctionAssignments();
-        int startFuncCount = getFuncAssignmentsCount(startFinfos);
-        log.info("testRebalanceAddWorkers: got info about {} workers with {} functions before creating new workers",
-                startFinfos.size(), startFuncCount);
-        // Check that there are NumFunctionsAssignedOnEachWorker functions assigned to each worker,
-        // since the assignment is round-robin by default.
-        assertEquals(getMinFuncAssignmentOnAnyWorker(startFinfos), numFunctionsAssignedOnEachWorker);
-
-        // Add a few more workers, to test rebalance
-        int initialNumWorkers = pulsarCluster.getAlWorkers().size();
-        final int numWorkersToAdd = 2;
-        log.info("testRebalanceAddWorkers: cluster has {} FunctionWorkers; going to set up {} more",
-                pulsarCluster.getAlWorkers().size(), numWorkersToAdd);
-        pulsarCluster.setupFunctionWorkers(randomName(5), functionRuntimeType, numWorkersToAdd);
-        assertEquals(pulsarCluster.getAlWorkers().size(), initialNumWorkers + numWorkersToAdd);
-        log.info("testRebalanceAddWorkers: got a total of {} function workers, of type {}",
-                pulsarCluster.getAlWorkers().size(), functionRuntimeType);
-
-        this.showWorkerStatus("testRebalanceAddWorkers status after adding more workers");
-
-        WorkerInfo newClusterLeaderInfo = getClusterLeader();
-        log.info("Cluster leader after adding {} workers is: {}", numWorkersToAdd, newClusterLeaderInfo);
-        // Leadership should not have changed.
-        assertTrue(oldClusterLeaderInfo.getWorkerId().compareTo(newClusterLeaderInfo.getWorkerId()) == 0);
-
-        this.showWorkerStatus("testRebalanceAddWorkers after adding more workers");
-
-        // Rebalance.
-        callRebalance();
-        this.showWorkerStatus("testRebalanceAddWorkers after rebalance");
-
-        List<Map<String, Collection<String>>> endFinfos = getFunctionAssignments();
-        int endFuncCount = getFuncAssignmentsCount(endFinfos);
-        log.info("testRebalanceAddWorkers: got info about {} workers with {} functions after rebalance",
-                endFinfos.size(), endFuncCount);
-
-        assertEquals(endFinfos.size() - startFinfos.size(), numWorkersToAdd);
-        assertEquals(startFuncCount, endFuncCount);
-        // Since scheduling is round-robin (default), we expect the minimum number of  function assignments
-        // on any worker to be the floor of the average number of functions per worker.
-        int minFuncsPerWorker = (int) Math.floor(endFuncCount / endFinfos.size());
-        assertEquals(getMinFuncAssignmentOnAnyWorker(endFinfos),  minFuncsPerWorker);
-
-        // Since we increased the number of workers, the minFuncsPerWorker should evaluate to some
-        // value less than the erstwhile NumFunctionsAssignedOnEachWorker.
-        assertTrue(minFuncsPerWorker < numFunctionsAssignedOnEachWorker);
-    }
-
-    private void testDrain() throws Exception {
-        allocateFunctions("testDrain", "test-drain");
-
-        val startFinfos = getFunctionAssignments();
-        int startFuncCount = getFuncAssignmentsCount(startFinfos);
-        log.info("testDrain: got info about {} workers with {} functions before drain",
-                startFinfos.size(), startFuncCount);
-
-        if (log.isDebugEnabled()) {
-            this.showWorkerStatus("testDrain after allocating functions");
-        }
-
-        WorkerInfo clusterLeaderInfo = getClusterLeader();
-
-        // Drain
-        callDrain(clusterLeaderInfo.getWorkerId());
-        if (log.isDebugEnabled()) {
-            this.showWorkerStatus("testDrain after drain");
-        }
-
-        val endFinfos = getFunctionAssignments();
-        int endFuncCount = getFuncAssignmentsCount(endFinfos);
-        log.info("testDrain: got info about {} workers with {} functions after drain",
-                endFinfos.size(), endFuncCount);
-
-        assertTrue(startFinfos.size() > endFinfos.size());
-        assertEquals(startFuncCount, endFuncCount);
-
-        // Since default scheduling is round-robin, we expect the minimum number of  function assignments
-        // on any worker to be the floor of the average number of functions per worker.
-        final int minFuncsPerWorker = (int) Math.floor(endFuncCount / endFinfos.size());
-        assertEquals(getMinFuncAssignmentOnAnyWorker(endFinfos), minFuncsPerWorker);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.java;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import com.fasterxml.jackson.databind.MappingIterator;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import lombok.val;
+import org.apache.commons.collections4.map.HashedMap;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.common.functions.WorkerInfo;
+import org.apache.pulsar.common.policies.data.FunctionStatus;
+import org.apache.pulsar.common.policies.data.FunctionStatusUtil;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.annotations.Test;
+
+@Slf4j
+public abstract class PulsarWorkerRebalanceDrainTest extends PulsarFunctionsTest {
+
+    final String urlProtocolPrefix = "http://";
+    final String workerRebalanceUrlSuffix = "/admin/v2/worker/rebalance";
+    final String workerDrainAtLeaderUrlSuffix = "/admin/v2/worker/leader/drain?workerId=";
+    final int numFunctionsAssignedOnEachWorker = 2;
+    final int numAdditionalWorkersAtSetup = 1;
+
+    PulsarWorkerRebalanceDrainTest(FunctionRuntimeType functionRuntimeType) {
+        super(functionRuntimeType);
+    }
+
+    @Override
+    public void setupCluster() throws Exception {
+        super.setupCluster();
+        pulsarCluster.setupFunctionWorkers(randomName(5), functionRuntimeType, numAdditionalWorkersAtSetup);
+        log.debug("PulsarWorkerRebalanceDrainTest: set up a total of {} function workers, of type {}",
+                pulsarCluster.getAlWorkers().size(), functionRuntimeType);
+    }
+
+    @Test(groups = {"java_function", "rebalance_drain", "rebalance"})
+    public void testRebalanceWorkers() throws Exception {
+        testRebalance();
+        log.info("Done with testRebalance");
+    }
+
+    @Test(groups = {"java_function", "rebalance_drain", "drain"})
+    public void testDrainWorkers() throws Exception {
+        testDrain();
+        log.info("Done with testDrain");
+    }
+
+    private List<WorkerInfo> workerInfoDecode(String json) throws IOException {
+        try (MappingIterator<WorkerInfo> it =
+                     ObjectMapperFactory.getMapper().getObjectMapper().readerFor(WorkerInfo.class)
+                .readValues(json)) {
+            return it.readAll();
+        }
+    }
+
+    // Parse a retrieved function-assignments list.
+    private List<Map<String, Collection<String>>> functionAssignmentsDecode(String json) throws IOException {
+        // Ad hoc parsing of the list of maps for function assignments.
+        // It is ad hoc because there doesn't appear to be any class exported from the function-worker code
+        // for this structure.
+        // The list is expected to be of the following form (this is from a real example):
+//           String json =
+//               "pulsar-functions-worker-process-hurkp-1    "
+//               + " [public/default/testDrainFunctionality-cipscktc:0, "
+//                       + "public/default/testDrainFunctionality-mzaudmyx:0] "
+//               + "pulsar-functions-worker-process-hurkp-0    "
+//               + " [public/default/testDrainFunctionality-morjleeh:0, "
+//                       + "public/default/testDrainFunctionality-owsxgiuo:0] "
+//               + "pulsar-functions-worker-process-qmcao-0    "
+//               + "[public/default/testDrainFunctionality-nsnqbnlc:0, "
+//                       + "public/default/testDrainFunctionality-tbakebis:0] ";
+
+        final int nextWorkerStart = 0;
+        String remainingJson = json;
+        String nextFunctionList;
+        String nextWorker;
+        boolean moreToParse = true;
+        List<Map<String, Collection<String>>> retVal = new ArrayList<>();
+
+        while (moreToParse) {
+            int nextFunctionListStart = remainingJson.indexOf("[");
+            int nextFunctionListEnd = remainingJson.indexOf("]");
+            nextWorker = remainingJson.substring(nextWorkerStart, nextFunctionListStart);
+            nextWorker = nextWorker.replaceAll("\\s+", "");
+            nextFunctionList = remainingJson.substring(nextFunctionListStart + 1, nextFunctionListEnd);
+            String[] funcAssignments = nextFunctionList.split(",");
+            Map<String, Collection<String>> curMap = new HashMap<>();
+            curMap.put(nextWorker, Arrays.asList(funcAssignments));
+            log.info("Found new entry: {}, {}", nextWorker, funcAssignments);
+            retVal.add(curMap);
+            log.info("retVal is {}", retVal);
+
+            // If we are already at the end, or if there are no more opening brackets
+            // (corresponding to function assignments), we are done.
+            try {
+                remainingJson = remainingJson.substring(nextFunctionListEnd + 1);
+            } catch (Throwable t) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Got exception {} while moving past function-list-end", t.getMessage());
+                }
+                moreToParse = false;
+            }
+            if (remainingJson.indexOf("[") < 0) {
+                moreToParse = false;
+            }
+        }
+        return retVal;
+    }
+
+    private List<WorkerInfo> getClusterStatus() throws Exception {
+        val result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions-worker",
+                "get-cluster"
+        );
+        log.debug("getClusterStatus result is: {}", result);
+        return workerInfoDecode(result.getStdout());
+    }
+
+    private WorkerInfo getClusterLeader() throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions-worker",
+                "get-cluster-leader"
+        );
+        List<WorkerInfo> winfos = workerInfoDecode(result.getStdout());
+        assertEquals(winfos.size(), 1);
+        return workerInfoDecode(result.getStdout()).get(0);
+    }
+
+    private List<Map<String, Collection<String>>> getFunctionAssignments() throws Exception {
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "functions-worker",
+                "get-function-assignments"
+        );
+        log.debug("getFunctionAssignments result is: {}", result);
+        return functionAssignmentsDecode(result.getStdout());
+    }
+
+    // Get the total number of functions assigned to all workers in the given function-info.
+    private int getFuncAssignmentsCount(List<Map<String, Collection<String>>> finfos) {
+        int funcCount = 0;
+        for (val l : finfos) {
+            for (val m : l.entrySet()) {
+                if (log.isDebugEnabled()) {
+                    log.debug("accumulating for key={}, value={} (size {})",
+                            m.getKey(), m.getValue(), m.getValue().size());
+                }
+                funcCount += m.getValue().size();
+            }
+        }
+        return funcCount;
+    }
+
+    // Get the min number of functions assigned to any worker in the given function-info.
+    private int getMinFuncAssignmentOnAnyWorker(List<Map<String, Collection<String>>> finfos) {
+        int minFuncCount = Integer.MAX_VALUE;
+        for (val l : finfos) {
+            for (val m : l.entrySet()) {
+                if (log.isDebugEnabled()) {
+                    log.debug("comparing current_min={} with key={}, value={} (size {})",
+                            minFuncCount, m.getKey(), m.getValue(), m.getValue().size());
+                }
+                minFuncCount = Math.min(minFuncCount, m.getValue().size());
+            }
+        }
+        return minFuncCount;
+    }
+
+    private void callRebalance() throws Exception {
+        val leader = getClusterLeader();
+        val worker = pulsarCluster.getWorker(leader.getWorkerId());
+        assertTrue(worker != null);
+
+        String rebalanceUrl = urlProtocolPrefix
+                + "localhost"
+                + ":"
+                + leader.getPort()
+                + workerRebalanceUrlSuffix;
+        ContainerExecResult result = worker.execCmd(
+                PulsarCluster.CURL,
+                "-X",
+                "PUT",
+                rebalanceUrl
+        );
+        if (log.isDebugEnabled()) {
+            log.debug("callRebalance: leader's rebalance url is: {}", rebalanceUrl);
+            log.debug("callRebalance: curl for rebalance: result is {}", result);
+        }
+    }
+
+    private void callDrain(final String workerToDrain) throws Exception {
+        val leader = getClusterLeader();
+        val worker = pulsarCluster.getWorker(leader.getWorkerId());
+        assertTrue(worker != null);
+
+        String drainUrl = urlProtocolPrefix
+                + "localhost"
+                + ":"
+                + leader.getPort()
+                + workerDrainAtLeaderUrlSuffix
+                + workerToDrain;
+        ContainerExecResult result = worker.execCmd(
+                PulsarCluster.CURL,
+                "-X",
+                "PUT",
+                drainUrl
+        );
+        if (log.isDebugEnabled()) {
+            log.debug("callDrain: leader's drain url is: {}", drainUrl);
+            log.debug("callDrain: curl for drain: result is {}", result);
+        }
+    }
+
+    private void createFunctionWorker(String functionName, String topicPrefix) throws Exception {
+        String suffix = functionName + randomName(8);
+        String inputTopicName = "persistent://public/default/" + topicPrefix + "-input-" + suffix;
+        String outputTopicName = topicPrefix + "-output-" + suffix;
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build()) {
+            admin.topics().createNonPartitionedTopic(inputTopicName);
+            admin.topics().createNonPartitionedTopic(outputTopicName);
+        }
+
+        Map<String, String> inputTopicsSerde = new HashedMap<>();
+        inputTopicsSerde.put(inputTopicName, SERDE_CLASS);
+
+        submitFunction(
+                Runtime.JAVA, inputTopicName, outputTopicName, functionName, null, SERDE_JAVA_CLASS, inputTopicsSerde,
+                SERDE_CLASS, Collections.singletonMap(topicPrefix, outputTopicName)
+        );
+    }
+
+    private void showWorkerStatus(String callerContext) throws Exception {
+        List<WorkerInfo> winfos = getClusterStatus();
+        assertEquals(winfos.size(), pulsarCluster.getAlWorkers().size());
+        log.info("{} get-cluster retrieved info about {} workers", callerContext, winfos.size());
+        winfos.forEach(w -> log.info("{} get-cluster worker-info: {}", callerContext, w));
+
+        val leaderInfo = getClusterLeader();
+        log.info("{} get-cluster-leader info: {}", callerContext, leaderInfo);
+
+        val finfos = getFunctionAssignments();
+        log.info("{} get-function-assignments retrieved info about {} workers with {} functions",
+                callerContext, finfos.size(), getFuncAssignmentsCount(finfos));
+        finfos.forEach(f -> log.info("{} get-function-assignments info: {}", callerContext, f));
+    }
+
+    private void allocateFunctions(String callingTest, String topicPrefix) throws  Exception {
+        // Allocate functions until there are NumFunctionsAssignedOnEachWorker on each worker, on the average.
+        ContainerExecResult result;
+        int numFunctions = pulsarCluster.getAlWorkers().size() * numFunctionsAssignedOnEachWorker;
+
+        for (int ix = 0; ix < numFunctions; ix++) {
+            String functionName = callingTest + "-" + randomName(8);
+            createFunctionWorker(functionName, topicPrefix);
+
+            result = pulsarCluster.getAnyWorker().execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "functions",
+                    "status",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", functionName
+            );
+
+            FunctionStatus functionStatus = FunctionStatusUtil.decode(result.getStdout());
+            log.debug("{}}: functionStatus is {}", callingTest, functionStatus);
+
+            assertEquals(functionStatus.getNumInstances(), 1);
+            assertEquals(functionStatus.getInstances().get(0).getStatus().isRunning(), true);
+        }
+    }
+
+    private void testRebalance() throws Exception {
+        // Add some workers; then call rebalance, and check that functions were assigned to all of the workers.
+        allocateFunctions("testRebalanceAddWorkers", "test-rebalance");
+
+        if (log.isDebugEnabled()) {
+            this.showWorkerStatus("testRebalanceAddWorkers after allocating functions");
+        }
+
+        WorkerInfo oldClusterLeaderInfo = getClusterLeader();
+        log.info("Cluster leader before adding more workers is: {}", oldClusterLeaderInfo);
+
+        List<Map<String, Collection<String>>> startFinfos = getFunctionAssignments();
+        int startFuncCount = getFuncAssignmentsCount(startFinfos);
+        log.info("testRebalanceAddWorkers: got info about {} workers with {} functions before creating new workers",
+                startFinfos.size(), startFuncCount);
+        // Check that there are NumFunctionsAssignedOnEachWorker functions assigned to each worker,
+        // since the assignment is round-robin by default.
+        assertEquals(getMinFuncAssignmentOnAnyWorker(startFinfos), numFunctionsAssignedOnEachWorker);
+
+        // Add a few more workers, to test rebalance
+        int initialNumWorkers = pulsarCluster.getAlWorkers().size();
+        final int numWorkersToAdd = 2;
+        log.info("testRebalanceAddWorkers: cluster has {} FunctionWorkers; going to set up {} more",
+                pulsarCluster.getAlWorkers().size(), numWorkersToAdd);
+        pulsarCluster.setupFunctionWorkers(randomName(5), functionRuntimeType, numWorkersToAdd);
+        assertEquals(pulsarCluster.getAlWorkers().size(), initialNumWorkers + numWorkersToAdd);
+        log.info("testRebalanceAddWorkers: got a total of {} function workers, of type {}",
+                pulsarCluster.getAlWorkers().size(), functionRuntimeType);
+
+        this.showWorkerStatus("testRebalanceAddWorkers status after adding more workers");
+
+        WorkerInfo newClusterLeaderInfo = getClusterLeader();
+        log.info("Cluster leader after adding {} workers is: {}", numWorkersToAdd, newClusterLeaderInfo);
+        // Leadership should not have changed.
+        assertTrue(oldClusterLeaderInfo.getWorkerId().compareTo(newClusterLeaderInfo.getWorkerId()) == 0);
+
+        this.showWorkerStatus("testRebalanceAddWorkers after adding more workers");
+
+        // Rebalance.
+        callRebalance();
+        this.showWorkerStatus("testRebalanceAddWorkers after rebalance");
+
+        List<Map<String, Collection<String>>> endFinfos = getFunctionAssignments();
+        int endFuncCount = getFuncAssignmentsCount(endFinfos);
+        log.info("testRebalanceAddWorkers: got info about {} workers with {} functions after rebalance",
+                endFinfos.size(), endFuncCount);
+
+        assertEquals(endFinfos.size() - startFinfos.size(), numWorkersToAdd);
+        assertEquals(startFuncCount, endFuncCount);
+        // Since scheduling is round-robin (default), we expect the minimum number of  function assignments
+        // on any worker to be the floor of the average number of functions per worker.
+        int minFuncsPerWorker = (int) Math.floor(endFuncCount / endFinfos.size());
+        assertEquals(getMinFuncAssignmentOnAnyWorker(endFinfos),  minFuncsPerWorker);
+
+        // Since we increased the number of workers, the minFuncsPerWorker should evaluate to some
+        // value less than the erstwhile NumFunctionsAssignedOnEachWorker.
+        assertTrue(minFuncsPerWorker < numFunctionsAssignedOnEachWorker);
+    }
+
+    private void testDrain() throws Exception {
+        allocateFunctions("testDrain", "test-drain");
+
+        val startFinfos = getFunctionAssignments();
+        int startFuncCount = getFuncAssignmentsCount(startFinfos);
+        log.info("testDrain: got info about {} workers with {} functions before drain",
+                startFinfos.size(), startFuncCount);
+
+        if (log.isDebugEnabled()) {
+            this.showWorkerStatus("testDrain after allocating functions");
+        }
+
+        WorkerInfo clusterLeaderInfo = getClusterLeader();
+
+        // Drain
+        callDrain(clusterLeaderInfo.getWorkerId());
+        if (log.isDebugEnabled()) {
+            this.showWorkerStatus("testDrain after drain");
+        }
+
+        val endFinfos = getFunctionAssignments();
+        int endFuncCount = getFuncAssignmentsCount(endFinfos);
+        log.info("testDrain: got info about {} workers with {} functions after drain",
+                endFinfos.size(), endFuncCount);
+
+        assertTrue(startFinfos.size() > endFinfos.size());
+        assertEquals(startFuncCount, endFuncCount);
+
+        // Since default scheduling is round-robin, we expect the minimum number of  function assignments
+        // on any worker to be the floor of the average number of functions per worker.
+        final int minFuncsPerWorker = (int) Math.floor(endFuncCount / endFinfos.size());
+        assertEquals(getMinFuncAssignmentOnAnyWorker(endFinfos), minFuncsPerWorker);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainThreadTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainThreadTest.java
index 7112f78c41..a89a116078 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainThreadTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/java/PulsarWorkerRebalanceDrainThreadTest.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.java;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarWorkerRebalanceDrainThreadTest extends PulsarWorkerRebalanceDrainTest {
-
-    public PulsarWorkerRebalanceDrainThreadTest() {
-        super(FunctionRuntimeType.THREAD);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.java;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarWorkerRebalanceDrainThreadTest extends PulsarWorkerRebalanceDrainTest {
+
+    public PulsarWorkerRebalanceDrainThreadTest() {
+        super(FunctionRuntimeType.THREAD);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/k8s/PulsarFunctionsK8STest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/k8s/PulsarFunctionsK8STest.java
new file mode 100644
index 0000000000..8f438f878e
--- /dev/null
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/k8s/PulsarFunctionsK8STest.java
@@ -0,0 +1,187 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.k8s;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
+import io.kubernetes.client.Exec;
+import io.kubernetes.client.openapi.ApiException;
+import io.kubernetes.client.openapi.apis.CoreV1Api;
+import io.kubernetes.client.openapi.models.V1Secret;
+import io.kubernetes.client.openapi.models.V1SecretBuilder;
+import java.io.IOException;
+import java.time.Duration;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.functions.FunctionConfig;
+import org.apache.pulsar.common.policies.data.FunctionStatus;
+import org.apache.pulsar.tests.integration.functions.java.PulsarFunctionsJavaTest;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator;
+import org.apache.pulsar.tests.integration.k8s.AbstractPulsarStandaloneK8STest;
+import org.awaitility.Awaitility;
+import org.testng.annotations.Test;
+
+/**
+ * This class is an integration test for Pulsar Functions running in Kubernetes.
+ * This tests {@link org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntimeFactory},
+ * {@link org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntime},
+ * and {@link org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator} classes
+ * in a lightweight Kubernetes cluster which is provided by a k3s container running in Docker with Testcontainers.
+ */
+@Slf4j
+public class PulsarFunctionsK8STest extends AbstractPulsarStandaloneK8STest {
+    @Test
+    public void testCreateFunctionInK8sWithSecrets()
+            throws PulsarAdminException, IOException, InterruptedException, ApiException {
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(getPulsarWebServiceUrl())
+                .build();
+
+        String randomPart = UUID.randomUUID().toString();
+        String inputTopicName =
+                "persistent://public/default/test-function-input-" + randomPart;
+        String outputTopicName = "persistent://public/default/test-function-output-" + randomPart;
+
+        // create a sample secret
+        try {
+            CoreV1Api api = new CoreV1Api(getApiClient());
+            V1Secret secret = new V1SecretBuilder()
+                    .withNewMetadata()
+                    .withName("mysecret")
+                    .endMetadata()
+                    .addToStringData("secret1", "value1")
+                    .addToStringData("secret2", "value2").build();
+            api.createNamespacedSecret(getNamespace(), secret).execute();
+        } catch (ApiException e) {
+            // ignore if the secret already exists since this could happen due to retries
+            if (e.getCode() != 409) {
+                throw e;
+            }
+        }
+
+        FunctionConfig functionConfig = new FunctionConfig();
+        String fnTenant = "public";
+        String fnNamespace = "default";
+        String fnName = "test-function";
+        functionConfig.setTenant(fnTenant);
+        functionConfig.setNamespace(fnNamespace);
+        functionConfig.setName(fnName);
+        functionConfig.setRuntime(FunctionConfig.Runtime.JAVA);
+        functionConfig.setClassName(PulsarFunctionsJavaTest.EXCLAMATION_JAVA_CLASS);
+        functionConfig.setJar(CommandGenerator.JAVAJAR);
+        functionConfig.setInputs(List.of(inputTopicName));
+        functionConfig.setOutput(outputTopicName);
+        // test referencing k8s secrets
+        functionConfig.setSecrets(
+                Map.of("secret1", Map.of(
+                                "path", "mysecret",
+                                "key", "secret1"),
+                        "secret2", Map.of(
+                                "path", "mysecret",
+                                "key", "secret2")));
+
+        log.info("Creating function");
+        admin.functions().createFunctionWithUrl(functionConfig, "file://" + CommandGenerator.JAVAJAR);
+
+        log.info("Waiting for function to be created");
+        Awaitility.await().ignoreExceptions().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(30))
+                .untilAsserted(() -> {
+            FunctionStatus functionStatus = admin.functions().getFunctionStatus(fnTenant, fnNamespace, fnName);
+            assertThat(functionStatus.getNumInstances()).isEqualTo(1);
+            assertThat(functionStatus.getNumRunning()).isEqualTo(1);
+        });
+        log.info("Function created successfully");
+
+        // Validate that k8s secrets were provided as environment variables to the function pod
+        String podName = "pf-%s-%s-%s-0".formatted(fnTenant, fnNamespace, fnName);
+        Exec exec = new Exec(getApiClient());
+        Process process = exec.newExecutionBuilder(getNamespace(), podName, new String[]{"sh", "-c",
+                        "echo \"secret1=$secret1,secret2=$secret2\""})
+                .setStdin(false).setStderr(false).setStdout(true).setTty(false).execute();
+        String response = process.inputReader().readLine();
+        assertThat(process.waitFor()).isEqualTo(0);
+        assertThat(response).isEqualTo("secret1=value1,secret2=value2");
+
+        log.info("Testing function");
+        @Cleanup
+        PulsarClient client = PulsarClient.builder().serviceUrl(getPulsarBrokerUrl())
+                .build();
+
+        @Cleanup
+        Consumer<String> consumer =
+                client.newConsumer(Schema.STRING).topic(outputTopicName).subscriptionName("sub").subscribe();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING).topic(inputTopicName).create();
+        producer.send("Hello");
+
+        Message<String> message = consumer.receive(5, TimeUnit.SECONDS);
+        assertThat(message).isNotNull();
+        assertThat(message.getValue()).isEqualTo("Hello!");
+
+
+        log.info("Stopping function");
+        admin.functions().stopFunction(fnTenant, fnNamespace, fnName);
+        Awaitility.await().ignoreExceptions().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(30))
+                .untilAsserted(() -> {
+                    FunctionStatus functionStatus = admin.functions().getFunctionStatus(fnTenant, fnNamespace, fnName);
+                    assertThat(functionStatus.getNumInstances()).isEqualTo(1);
+                    assertThat(functionStatus.getNumRunning()).isEqualTo(0);
+                });
+
+        log.info("Starting function");
+        // this seems to be flaky if the stopping of the function hasn't fully completed when it's started again.
+        // one way to reproduce is to remove the delay before starting the function and also removing the pollDelay
+        // from the await after stopFunction
+        Thread.sleep(2000);
+        admin.functions().startFunction(fnTenant, fnNamespace, fnName);
+        Awaitility.await().ignoreExceptions().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(30))
+                .untilAsserted(() -> {
+                    FunctionStatus functionStatus = admin.functions().getFunctionStatus(fnTenant, fnNamespace, fnName);
+                    assertThat(functionStatus.getNumInstances()).isEqualTo(1);
+                    assertThat(functionStatus.getNumRunning()).isEqualTo(1);
+                });
+
+        log.info("Waiting for function to be deleted");
+        admin.functions().deleteFunction(fnTenant, fnNamespace, fnName);
+        log.info("Function deleted successfully");
+
+        log.info("Waiting for function pod to be deleted");
+        CoreV1Api coreApi = new CoreV1Api(getApiClient());
+        Awaitility.await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofSeconds(30)).untilAsserted(() -> {
+            assertThatExceptionOfType(ApiException.class).isThrownBy(
+                    () -> coreApi.readNamespacedPod(getNamespace(), podName).execute())
+                    .satisfies(apiException -> {
+                assertThat(apiException.getCode()).isEqualTo(404);
+            });
+        });
+        log.info("Function pod deleted successfully");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonProcessTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonProcessTest.java
index 594d12222a..ce2c9ad030 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonProcessTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonProcessTest.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.python;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarFunctionsPythonProcessTest extends PulsarFunctionsPythonTest {
-
-    public PulsarFunctionsPythonProcessTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.python;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarFunctionsPythonProcessTest extends PulsarFunctionsPythonTest {
+
+    public PulsarFunctionsPythonProcessTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonTest.java
index 554a0f8822..d62b62ccd8 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonTest.java
@@ -1,89 +1,89 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.python;
-
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
-import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testng.annotations.Test;
-
-public abstract class PulsarFunctionsPythonTest extends PulsarFunctionsTest {
-
-    PulsarFunctionsPythonTest(FunctionRuntimeType functionRuntimeType) {
-        super(functionRuntimeType);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonFunctionLocalRun() throws Exception {
-        testFunctionLocalRun(Runtime.PYTHON);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonFunctionNegAck() throws Exception {
-        testFunctionNegAck(Runtime.PYTHON);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonPublishFunction() throws Exception {
-        testPublishFunction(Runtime.PYTHON);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonExclamationFunction() throws Exception {
-        testExclamationFunction(Runtime.PYTHON, false, false, false, false);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonExclamationFunctionWithExtraDeps() throws Exception {
-        testExclamationFunction(Runtime.PYTHON, false, false, false, true);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonExclamationZipFunction() throws Exception {
-        testExclamationFunction(Runtime.PYTHON, false, true, false, false);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testPythonExclamationTopicPatternFunction() throws Exception {
-        testExclamationFunction(Runtime.PYTHON, true, false, false, false);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testAvroSchemaFunctionTest() throws Exception {
-        testAvroSchemaFunction(Runtime.PYTHON);
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testRetainOrderingTest() throws Exception {
-        testExclamationFunction(Runtime.PYTHON, false, false, false,
-                false, null, null, generator -> {
-                    generator.setRetainOrdering(true);
-                });
-    }
-
-    @Test(groups = {"python_function", "function"})
-    public void testRetainKeyOrderingTest() throws Exception {
-        testExclamationFunction(Runtime.PYTHON, false, false, false,
-                false, null, null, generator -> {
-                    System.out.println("calling generator.setRetainKeyOrdering(true);");
-                    generator.setRetainKeyOrdering(true);
-                });
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.python;
+
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTest;
+import org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.Runtime;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testng.annotations.Test;
+
+public abstract class PulsarFunctionsPythonTest extends PulsarFunctionsTest {
+
+    PulsarFunctionsPythonTest(FunctionRuntimeType functionRuntimeType) {
+        super(functionRuntimeType);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonFunctionLocalRun() throws Exception {
+        testFunctionLocalRun(Runtime.PYTHON);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonFunctionNegAck() throws Exception {
+        testFunctionNegAck(Runtime.PYTHON);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonPublishFunction() throws Exception {
+        testPublishFunction(Runtime.PYTHON);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonExclamationFunction() throws Exception {
+        testExclamationFunction(Runtime.PYTHON, false, false, false, false);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonExclamationFunctionWithExtraDeps() throws Exception {
+        testExclamationFunction(Runtime.PYTHON, false, false, false, true);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonExclamationZipFunction() throws Exception {
+        testExclamationFunction(Runtime.PYTHON, false, true, false, false);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testPythonExclamationTopicPatternFunction() throws Exception {
+        testExclamationFunction(Runtime.PYTHON, true, false, false, false);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testAvroSchemaFunctionTest() throws Exception {
+        testAvroSchemaFunction(Runtime.PYTHON);
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testRetainOrderingTest() throws Exception {
+        testExclamationFunction(Runtime.PYTHON, false, false, false,
+                false, null, null, generator -> {
+                    generator.setRetainOrdering(true);
+                });
+    }
+
+    @Test(groups = {"python_function", "function"})
+    public void testRetainKeyOrderingTest() throws Exception {
+        testExclamationFunction(Runtime.PYTHON, false, false, false,
+                false, null, null, generator -> {
+                    System.out.println("calling generator.setRetainKeyOrdering(true);");
+                    generator.setRetainKeyOrdering(true);
+                });
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonThreadTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonThreadTest.java
index c41037a60a..cf4f349e89 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonThreadTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/python/PulsarFunctionsPythonThreadTest.java
@@ -1,28 +1,28 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.python;
-
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-
-public class PulsarFunctionsPythonThreadTest extends PulsarFunctionsPythonTest {
-
-    public PulsarFunctionsPythonThreadTest() {
-        super(FunctionRuntimeType.THREAD);
-  }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.python;
+
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+
+public class PulsarFunctionsPythonThreadTest extends PulsarFunctionsPythonTest {
+
+    public PulsarFunctionsPythonThreadTest() {
+        super(FunctionRuntimeType.THREAD);
+  }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/CommandGenerator.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/CommandGenerator.java
index cb9b87772e..992e9cd623 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/CommandGenerator.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/CommandGenerator.java
@@ -1,418 +1,418 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.utils;
-
-import com.google.gson.Gson;
-import java.util.HashMap;
-import java.util.Map;
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.common.functions.ConsumerConfig;
-import org.apache.pulsar.common.functions.ProducerConfig;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-@Getter
-@Setter
-@ToString
-public class CommandGenerator {
-    private static final long MB = 1048576L;
-    private static final long JAVA_RUNTIME_RAM_BYTES = 128 * MB;
-
-    public enum Runtime {
-        JAVA,
-        PYTHON,
-        GO,
-    };
-    private String functionName;
-    private String tenant = "public";
-    private String namespace = "default";
-    private String functionClassName;
-    private String sourceTopic;
-    private String sourceTopicPattern;
-    private Map<String, String> customSerDeSourceTopics;
-    private String sinkTopic;
-    private String logTopic;
-    private String outputSerDe;
-    private String processingGuarantees;
-    private Runtime runtime;
-    private Integer parallelism;
-    private String adminUrl;
-    private String batchBuilder;
-    private Integer windowLengthCount;
-    private Long windowLengthDurationMs;
-    private Integer slidingIntervalCount;
-    private Long slidingIntervalDurationMs;
-    private String customSchemaInputs;
-    private String inputTypeClassName;
-    private String outputTypeClassName;
-    private String schemaType;
-    private SubscriptionInitialPosition subscriptionInitialPosition;
-    private Boolean retainOrdering;
-    private Boolean retainKeyOrdering;
-    private ProducerConfig producerConfig;
-    private ConsumerConfig consumerConfig;
-
-    private Map<String, String> userConfig = new HashMap<>();
-    public static final String JAVAJAR = "/pulsar/examples/java-test-functions.jar";
-    public static final String PYTHONBASE = "/pulsar/examples/python-examples/";
-    public static final String GOBASE = "/pulsar/examples/go-examples/";
-
-    public static CommandGenerator createDefaultGenerator(String sourceTopic, String functionClassName) {
-        CommandGenerator generator = new CommandGenerator();
-        generator.setSourceTopic(sourceTopic);
-        generator.setFunctionClassName(functionClassName);
-        generator.setRuntime(Runtime.JAVA);
-        return generator;
-    }
-
-    public static CommandGenerator createTopicPatternGenerator(String sourceTopicPattern, String functionClassName) {
-        CommandGenerator generator = new CommandGenerator();
-        generator.setSourceTopicPattern(sourceTopicPattern);
-        generator.setFunctionClassName(functionClassName);
-        generator.setRuntime(Runtime.JAVA);
-        return generator;
-    }
-
-    public String generateLocalRunCommand(String codeFile) {
-        StringBuilder commandBuilder = new StringBuilder(PulsarCluster.ADMIN_SCRIPT);
-        commandBuilder.append(" functions localrun");
-        if (adminUrl != null) {
-            commandBuilder.append(" --broker-service-url " + adminUrl);
-        }
-        if (tenant != null) {
-            commandBuilder.append(" --tenant " + tenant);
-        }
-        if (namespace != null) {
-            commandBuilder.append(" --namespace " + namespace);
-        }
-        if (functionName != null) {
-            commandBuilder.append(" --name " + functionName);
-        }
-        if (runtime != Runtime.GO){
-            commandBuilder.append(" --className " + functionClassName);
-        }
-        if (StringUtils.isNotEmpty(sourceTopic)) {
-            commandBuilder.append(" --inputs " + sourceTopic);
-            if (consumerConfig != null) {
-                Map<String, ConsumerConfig> inputSpecs = new HashMap<>();
-                inputSpecs.put(sourceTopic, consumerConfig);
-                commandBuilder.append(" --input-specs \'" + new Gson().toJson(inputSpecs) + "\'");
-            }
-        }
-        if (sinkTopic != null) {
-            commandBuilder.append(" --output " + sinkTopic);
-        }
-        if (customSchemaInputs != null) {
-            commandBuilder.append(" --custom-schema-inputs \'" + customSchemaInputs + "\'");
-        }
-        if (inputTypeClassName != null) {
-            commandBuilder.append(" --input-type-class-name " + inputTypeClassName);
-        }
-        if (outputTypeClassName != null) {
-            commandBuilder.append(" --output-type-class-name " + outputTypeClassName);
-        }
-        if (schemaType != null) {
-            commandBuilder.append(" --schema-type " + schemaType);
-        }
-        if (subscriptionInitialPosition != null) {
-            commandBuilder.append(" --subs-position " + subscriptionInitialPosition.name());
-        }
-        switch (runtime){
-            case JAVA:
-                commandBuilder.append(" --jar " + JAVAJAR);
-                break;
-            case PYTHON:
-                if (codeFile != null) {
-                    commandBuilder.append(" --py " + PYTHONBASE + codeFile);
-                } else {
-                    commandBuilder.append(" --py " + PYTHONBASE);
-                }
-                break;
-            case GO:
-                if (codeFile != null) {
-                    commandBuilder.append(" --go " + GOBASE + codeFile);
-                } else {
-                    commandBuilder.append(" --go " + GOBASE);
-                }
-                break;
-        }
-        return commandBuilder.toString();
-    }
-
-    public String generateCreateFunctionCommand() {
-        return generateCreateFunctionCommand(null);
-    }
-
-    public String generateCreateFunctionCommand(String codeFile) {
-        StringBuilder commandBuilder = new StringBuilder(PulsarCluster.ADMIN_SCRIPT);
-        if (adminUrl != null) {
-            commandBuilder.append(" --admin-url ");
-            commandBuilder.append(adminUrl);
-        }
-        commandBuilder.append(" functions create");
-        if (tenant != null) {
-            commandBuilder.append(" --tenant " + tenant);
-        }
-        if (namespace != null) {
-            commandBuilder.append(" --namespace " + namespace);
-        }
-        if (functionName != null) {
-            commandBuilder.append(" --name " + functionName);
-        }
-        if (runtime != Runtime.GO){
-            commandBuilder.append(" --className " + functionClassName);
-        }
-        if (StringUtils.isNotEmpty(sourceTopic)) {
-            commandBuilder.append(" --inputs " + sourceTopic);
-            if (consumerConfig != null) {
-                Map<String, ConsumerConfig> inputSpecs = new HashMap<>();
-                inputSpecs.put(sourceTopic, consumerConfig);
-                commandBuilder.append(" --input-specs \'" + new Gson().toJson(inputSpecs) + "\'");
-            }
-        }
-        if (sourceTopicPattern != null) {
-            commandBuilder.append(" --topics-pattern " + sourceTopicPattern);
-        }
-        if (logTopic != null) {
-            commandBuilder.append(" --logTopic " + logTopic);
-        }
-        if (batchBuilder != null) {
-            commandBuilder.append("--batch-builder" + batchBuilder);
-        }
-        if (customSerDeSourceTopics != null && !customSerDeSourceTopics.isEmpty()) {
-            commandBuilder.append(" --customSerdeInputs \'" + new Gson().toJson(customSerDeSourceTopics) + "\'");
-        }
-        if (sinkTopic != null) {
-            commandBuilder.append(" --output " + sinkTopic);
-        }
-        if (outputSerDe != null) {
-            commandBuilder.append(" --outputSerdeClassName " + outputSerDe);
-        }
-        if (processingGuarantees != null) {
-            commandBuilder.append(" --processingGuarantees " + processingGuarantees);
-        }
-        if (!userConfig.isEmpty()) {
-            commandBuilder.append(" --userConfig \'" + new Gson().toJson(userConfig) + "\'");
-        }
-        if (parallelism != null) {
-            commandBuilder.append(" --parallelism " + parallelism);
-        }
-        if (windowLengthCount != null) {
-            commandBuilder.append(" --windowLengthCount " + windowLengthCount);
-        }
-        if (windowLengthDurationMs != null)  {
-            commandBuilder.append(" --windowLengthDurationMs " + windowLengthDurationMs);
-        }
-        if (slidingIntervalCount != null)  {
-            commandBuilder.append(" --slidingIntervalCount " + slidingIntervalCount);
-        }
-        if (slidingIntervalDurationMs != null)  {
-            commandBuilder.append(" --slidingIntervalDurationMs " + slidingIntervalDurationMs);
-        }
-        if (customSchemaInputs != null) {
-            commandBuilder.append(" --custom-schema-inputs \'" + customSchemaInputs + "\'");
-        }
-        if (inputTypeClassName != null) {
-            commandBuilder.append(" --input-type-class-name " + inputTypeClassName);
-        }
-        if (outputTypeClassName != null) {
-            commandBuilder.append(" --output-type-class-name " + outputTypeClassName);
-        }
-        if (schemaType != null) {
-            commandBuilder.append(" --schema-type " + schemaType);
-        }
-        if (subscriptionInitialPosition != null) {
-            commandBuilder.append(" --subs-position " + subscriptionInitialPosition.name());
-        }
-        if (retainOrdering != null) {
-            commandBuilder.append(" --retain-ordering ");
-        }
-        if (retainKeyOrdering != null) {
-            commandBuilder.append(" --retain-key-ordering ");
-        }
-
-        switch (runtime){
-            case JAVA:
-                commandBuilder.append(" --jar " + JAVAJAR);
-                commandBuilder.append(" --ram " + JAVA_RUNTIME_RAM_BYTES);
-                break;
-            case PYTHON:
-                if (codeFile != null) {
-                    commandBuilder.append(" --py " + PYTHONBASE + codeFile);
-                } else {
-                    commandBuilder.append(" --py " + PYTHONBASE);
-                }
-                break;
-            case GO:
-                if (codeFile != null) {
-                    commandBuilder.append(" --go " + GOBASE + codeFile);
-                } else {
-                    commandBuilder.append(" --go " + GOBASE);
-                }
-                break;
-        }
-        if (producerConfig != null) {
-            commandBuilder.append(" --producer-config \'" + new Gson().toJson(producerConfig) + "\'");
-        }
-        return commandBuilder.toString();
-    }
-
-    public String generateUpdateFunctionCommand() {
-        return generateUpdateFunctionCommand(null);
-    }
-
-    public String generateUpdateFunctionCommand(String codeFile) {
-        StringBuilder commandBuilder = new StringBuilder();
-        if (adminUrl == null) {
-            commandBuilder.append("/pulsar/bin/pulsar-admin functions update");
-        } else {
-            commandBuilder.append("/pulsar/bin/pulsar-admin");
-            commandBuilder.append(" --admin-url ");
-            commandBuilder.append(adminUrl);
-            commandBuilder.append(" functions update");
-        }
-        if (tenant != null) {
-            commandBuilder.append(" --tenant " + tenant);
-        }
-        if (namespace != null) {
-            commandBuilder.append(" --namespace " + namespace);
-        }
-        if (functionName != null) {
-            commandBuilder.append(" --name " + functionName);
-        }
-        if (functionClassName != null) {
-            commandBuilder.append(" --className " + functionClassName);
-        }
-        if (StringUtils.isNotEmpty(sourceTopic)) {
-            commandBuilder.append(" --inputs " + sourceTopic);
-            if (consumerConfig != null) {
-                Map<String, ConsumerConfig> inputSpecs = new HashMap<>();
-                inputSpecs.put(sourceTopic, consumerConfig);
-                commandBuilder.append(" --input-specs \'" + new Gson().toJson(inputSpecs) + "\'");
-            }
-        }
-        if (customSerDeSourceTopics != null && !customSerDeSourceTopics.isEmpty()) {
-            commandBuilder.append(" --customSerdeInputs \'" + new Gson().toJson(customSerDeSourceTopics) + "\'");
-        }
-        if (batchBuilder != null) {
-            commandBuilder.append("--batch-builder" + batchBuilder);
-        }
-        if (sinkTopic != null) {
-            commandBuilder.append(" --output " + sinkTopic);
-        }
-        if (logTopic != null) {
-            commandBuilder.append(" --logTopic " + logTopic);
-        }
-        if (outputSerDe != null) {
-            commandBuilder.append(" --outputSerdeClassName " + outputSerDe);
-        }
-        if (processingGuarantees != null) {
-            commandBuilder.append(" --processingGuarantees " + processingGuarantees);
-        }
-        if (!userConfig.isEmpty()) {
-            commandBuilder.append(" --userConfig \'" + new Gson().toJson(userConfig) + "\'");
-        }
-        if (parallelism != null) {
-            commandBuilder.append(" --parallelism " + parallelism);
-        }
-        if (windowLengthCount != null) {
-            commandBuilder.append(" --windowLengthCount " + windowLengthCount);
-        }
-        if (windowLengthDurationMs != null)  {
-            commandBuilder.append(" --windowLengthDurationMs " + windowLengthDurationMs);
-        }
-        if (slidingIntervalCount != null)  {
-            commandBuilder.append(" --slidingIntervalCount " + slidingIntervalCount);
-        }
-        if (slidingIntervalDurationMs != null)  {
-            commandBuilder.append(" --slidingIntervalDurationMs " + slidingIntervalDurationMs);
-        }
-        if (customSchemaInputs != null) {
-            commandBuilder.append(" --custom-schema-inputs \'" + customSchemaInputs + "\'");
-        }
-        if (inputTypeClassName != null) {
-            commandBuilder.append(" --input-type-class-name " + inputTypeClassName);
-        }
-        if (outputTypeClassName != null) {
-            commandBuilder.append(" --output-type-class-name " + outputTypeClassName);
-        }
-        if (schemaType != null) {
-            commandBuilder.append(" --schema-type " + schemaType);
-        }
-        if (subscriptionInitialPosition != null) {
-            commandBuilder.append(" --subs-position " + subscriptionInitialPosition.name());
-        }
-
-        if (codeFile != null) {
-            switch (runtime) {
-                case JAVA:
-                    commandBuilder.append(" --jar " + JAVAJAR);
-                    commandBuilder.append(" --ram " + JAVA_RUNTIME_RAM_BYTES);
-                    break;
-                case PYTHON:
-                    if (codeFile != null) {
-                        commandBuilder.append(" --py " + PYTHONBASE + codeFile);
-                    } else {
-                        commandBuilder.append(" --py " + PYTHONBASE);
-                    }
-                    break;
-                case GO:
-                    if (codeFile != null) {
-                        commandBuilder.append(" --go " + GOBASE + codeFile);
-                    } else {
-                        commandBuilder.append(" --go " + GOBASE);
-                    }
-                    break;
-            }
-        }
-        return commandBuilder.toString();
-    }
-
-    public String genereateDeleteFunctionCommand() {
-        StringBuilder commandBuilder = new StringBuilder("/pulsar/bin/pulsar-admin functions delete");
-        if (tenant != null) {
-            commandBuilder.append(" --tenant " + tenant);
-        }
-        if (namespace != null) {
-            commandBuilder.append(" --namespace " + namespace);
-        }
-        if (functionName != null) {
-            commandBuilder.append(" --name " + functionName);
-        }
-        return commandBuilder.toString();
-    }
-
-    public String generateTriggerFunctionCommand(String triggerValue) {
-        StringBuilder commandBuilder = new StringBuilder("/pulsar/bin/pulsar-admin functions trigger");
-        if (tenant != null) {
-            commandBuilder.append(" --tenant " + tenant);
-        }
-        if (namespace != null) {
-            commandBuilder.append(" --namespace " + namespace);
-        }
-        if (functionName != null) {
-            commandBuilder.append(" --name " + functionName);
-        }
-        commandBuilder.append(" --triggerValue " + triggerValue);
-        return commandBuilder.toString();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.utils;
+
+import com.google.gson.Gson;
+import java.util.HashMap;
+import java.util.Map;
+import lombok.Getter;
+import lombok.Setter;
+import lombok.ToString;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.common.functions.ConsumerConfig;
+import org.apache.pulsar.common.functions.ProducerConfig;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+@Getter
+@Setter
+@ToString
+public class CommandGenerator {
+    private static final long MB = 1048576L;
+    private static final long JAVA_RUNTIME_RAM_BYTES = 128 * MB;
+
+    public enum Runtime {
+        JAVA,
+        PYTHON,
+        GO,
+    };
+    private String functionName;
+    private String tenant = "public";
+    private String namespace = "default";
+    private String functionClassName;
+    private String sourceTopic;
+    private String sourceTopicPattern;
+    private Map<String, String> customSerDeSourceTopics;
+    private String sinkTopic;
+    private String logTopic;
+    private String outputSerDe;
+    private String processingGuarantees;
+    private Runtime runtime;
+    private Integer parallelism;
+    private String adminUrl;
+    private String batchBuilder;
+    private Integer windowLengthCount;
+    private Long windowLengthDurationMs;
+    private Integer slidingIntervalCount;
+    private Long slidingIntervalDurationMs;
+    private String customSchemaInputs;
+    private String inputTypeClassName;
+    private String outputTypeClassName;
+    private String schemaType;
+    private SubscriptionInitialPosition subscriptionInitialPosition;
+    private Boolean retainOrdering;
+    private Boolean retainKeyOrdering;
+    private ProducerConfig producerConfig;
+    private ConsumerConfig consumerConfig;
+
+    private Map<String, String> userConfig = new HashMap<>();
+    public static final String JAVAJAR = "/pulsar/examples/java-test-functions.jar";
+    public static final String PYTHONBASE = "/pulsar/examples/python-examples/";
+    public static final String GOBASE = "/pulsar/examples/go-examples/";
+
+    public static CommandGenerator createDefaultGenerator(String sourceTopic, String functionClassName) {
+        CommandGenerator generator = new CommandGenerator();
+        generator.setSourceTopic(sourceTopic);
+        generator.setFunctionClassName(functionClassName);
+        generator.setRuntime(Runtime.JAVA);
+        return generator;
+    }
+
+    public static CommandGenerator createTopicPatternGenerator(String sourceTopicPattern, String functionClassName) {
+        CommandGenerator generator = new CommandGenerator();
+        generator.setSourceTopicPattern(sourceTopicPattern);
+        generator.setFunctionClassName(functionClassName);
+        generator.setRuntime(Runtime.JAVA);
+        return generator;
+    }
+
+    public String generateLocalRunCommand(String codeFile) {
+        StringBuilder commandBuilder = new StringBuilder(PulsarCluster.ADMIN_SCRIPT);
+        commandBuilder.append(" functions localrun");
+        if (adminUrl != null) {
+            commandBuilder.append(" --broker-service-url " + adminUrl);
+        }
+        if (tenant != null) {
+            commandBuilder.append(" --tenant " + tenant);
+        }
+        if (namespace != null) {
+            commandBuilder.append(" --namespace " + namespace);
+        }
+        if (functionName != null) {
+            commandBuilder.append(" --name " + functionName);
+        }
+        if (runtime != Runtime.GO){
+            commandBuilder.append(" --className " + functionClassName);
+        }
+        if (StringUtils.isNotEmpty(sourceTopic)) {
+            commandBuilder.append(" --inputs " + sourceTopic);
+            if (consumerConfig != null) {
+                Map<String, ConsumerConfig> inputSpecs = new HashMap<>();
+                inputSpecs.put(sourceTopic, consumerConfig);
+                commandBuilder.append(" --input-specs \'" + new Gson().toJson(inputSpecs) + "\'");
+            }
+        }
+        if (sinkTopic != null) {
+            commandBuilder.append(" --output " + sinkTopic);
+        }
+        if (customSchemaInputs != null) {
+            commandBuilder.append(" --custom-schema-inputs \'" + customSchemaInputs + "\'");
+        }
+        if (inputTypeClassName != null) {
+            commandBuilder.append(" --input-type-class-name " + inputTypeClassName);
+        }
+        if (outputTypeClassName != null) {
+            commandBuilder.append(" --output-type-class-name " + outputTypeClassName);
+        }
+        if (schemaType != null) {
+            commandBuilder.append(" --schema-type " + schemaType);
+        }
+        if (subscriptionInitialPosition != null) {
+            commandBuilder.append(" --subs-position " + subscriptionInitialPosition.name());
+        }
+        switch (runtime){
+            case JAVA:
+                commandBuilder.append(" --jar " + JAVAJAR);
+                break;
+            case PYTHON:
+                if (codeFile != null) {
+                    commandBuilder.append(" --py " + PYTHONBASE + codeFile);
+                } else {
+                    commandBuilder.append(" --py " + PYTHONBASE);
+                }
+                break;
+            case GO:
+                if (codeFile != null) {
+                    commandBuilder.append(" --go " + GOBASE + codeFile);
+                } else {
+                    commandBuilder.append(" --go " + GOBASE);
+                }
+                break;
+        }
+        return commandBuilder.toString();
+    }
+
+    public String generateCreateFunctionCommand() {
+        return generateCreateFunctionCommand(null);
+    }
+
+    public String generateCreateFunctionCommand(String codeFile) {
+        StringBuilder commandBuilder = new StringBuilder(PulsarCluster.ADMIN_SCRIPT);
+        if (adminUrl != null) {
+            commandBuilder.append(" --admin-url ");
+            commandBuilder.append(adminUrl);
+        }
+        commandBuilder.append(" functions create");
+        if (tenant != null) {
+            commandBuilder.append(" --tenant " + tenant);
+        }
+        if (namespace != null) {
+            commandBuilder.append(" --namespace " + namespace);
+        }
+        if (functionName != null) {
+            commandBuilder.append(" --name " + functionName);
+        }
+        if (runtime != Runtime.GO){
+            commandBuilder.append(" --className " + functionClassName);
+        }
+        if (StringUtils.isNotEmpty(sourceTopic)) {
+            commandBuilder.append(" --inputs " + sourceTopic);
+            if (consumerConfig != null) {
+                Map<String, ConsumerConfig> inputSpecs = new HashMap<>();
+                inputSpecs.put(sourceTopic, consumerConfig);
+                commandBuilder.append(" --input-specs \'" + new Gson().toJson(inputSpecs) + "\'");
+            }
+        }
+        if (sourceTopicPattern != null) {
+            commandBuilder.append(" --topics-pattern " + sourceTopicPattern);
+        }
+        if (logTopic != null) {
+            commandBuilder.append(" --logTopic " + logTopic);
+        }
+        if (batchBuilder != null) {
+            commandBuilder.append("--batch-builder" + batchBuilder);
+        }
+        if (customSerDeSourceTopics != null && !customSerDeSourceTopics.isEmpty()) {
+            commandBuilder.append(" --customSerdeInputs \'" + new Gson().toJson(customSerDeSourceTopics) + "\'");
+        }
+        if (sinkTopic != null) {
+            commandBuilder.append(" --output " + sinkTopic);
+        }
+        if (outputSerDe != null) {
+            commandBuilder.append(" --outputSerdeClassName " + outputSerDe);
+        }
+        if (processingGuarantees != null) {
+            commandBuilder.append(" --processingGuarantees " + processingGuarantees);
+        }
+        if (!userConfig.isEmpty()) {
+            commandBuilder.append(" --userConfig \'" + new Gson().toJson(userConfig) + "\'");
+        }
+        if (parallelism != null) {
+            commandBuilder.append(" --parallelism " + parallelism);
+        }
+        if (windowLengthCount != null) {
+            commandBuilder.append(" --windowLengthCount " + windowLengthCount);
+        }
+        if (windowLengthDurationMs != null)  {
+            commandBuilder.append(" --windowLengthDurationMs " + windowLengthDurationMs);
+        }
+        if (slidingIntervalCount != null)  {
+            commandBuilder.append(" --slidingIntervalCount " + slidingIntervalCount);
+        }
+        if (slidingIntervalDurationMs != null)  {
+            commandBuilder.append(" --slidingIntervalDurationMs " + slidingIntervalDurationMs);
+        }
+        if (customSchemaInputs != null) {
+            commandBuilder.append(" --custom-schema-inputs \'" + customSchemaInputs + "\'");
+        }
+        if (inputTypeClassName != null) {
+            commandBuilder.append(" --input-type-class-name " + inputTypeClassName);
+        }
+        if (outputTypeClassName != null) {
+            commandBuilder.append(" --output-type-class-name " + outputTypeClassName);
+        }
+        if (schemaType != null) {
+            commandBuilder.append(" --schema-type " + schemaType);
+        }
+        if (subscriptionInitialPosition != null) {
+            commandBuilder.append(" --subs-position " + subscriptionInitialPosition.name());
+        }
+        if (retainOrdering != null) {
+            commandBuilder.append(" --retain-ordering ");
+        }
+        if (retainKeyOrdering != null) {
+            commandBuilder.append(" --retain-key-ordering ");
+        }
+
+        switch (runtime){
+            case JAVA:
+                commandBuilder.append(" --jar " + JAVAJAR);
+                commandBuilder.append(" --ram " + JAVA_RUNTIME_RAM_BYTES);
+                break;
+            case PYTHON:
+                if (codeFile != null) {
+                    commandBuilder.append(" --py " + PYTHONBASE + codeFile);
+                } else {
+                    commandBuilder.append(" --py " + PYTHONBASE);
+                }
+                break;
+            case GO:
+                if (codeFile != null) {
+                    commandBuilder.append(" --go " + GOBASE + codeFile);
+                } else {
+                    commandBuilder.append(" --go " + GOBASE);
+                }
+                break;
+        }
+        if (producerConfig != null) {
+            commandBuilder.append(" --producer-config \'" + new Gson().toJson(producerConfig) + "\'");
+        }
+        return commandBuilder.toString();
+    }
+
+    public String generateUpdateFunctionCommand() {
+        return generateUpdateFunctionCommand(null);
+    }
+
+    public String generateUpdateFunctionCommand(String codeFile) {
+        StringBuilder commandBuilder = new StringBuilder();
+        if (adminUrl == null) {
+            commandBuilder.append("/pulsar/bin/pulsar-admin functions update");
+        } else {
+            commandBuilder.append("/pulsar/bin/pulsar-admin");
+            commandBuilder.append(" --admin-url ");
+            commandBuilder.append(adminUrl);
+            commandBuilder.append(" functions update");
+        }
+        if (tenant != null) {
+            commandBuilder.append(" --tenant " + tenant);
+        }
+        if (namespace != null) {
+            commandBuilder.append(" --namespace " + namespace);
+        }
+        if (functionName != null) {
+            commandBuilder.append(" --name " + functionName);
+        }
+        if (functionClassName != null) {
+            commandBuilder.append(" --className " + functionClassName);
+        }
+        if (StringUtils.isNotEmpty(sourceTopic)) {
+            commandBuilder.append(" --inputs " + sourceTopic);
+            if (consumerConfig != null) {
+                Map<String, ConsumerConfig> inputSpecs = new HashMap<>();
+                inputSpecs.put(sourceTopic, consumerConfig);
+                commandBuilder.append(" --input-specs \'" + new Gson().toJson(inputSpecs) + "\'");
+            }
+        }
+        if (customSerDeSourceTopics != null && !customSerDeSourceTopics.isEmpty()) {
+            commandBuilder.append(" --customSerdeInputs \'" + new Gson().toJson(customSerDeSourceTopics) + "\'");
+        }
+        if (batchBuilder != null) {
+            commandBuilder.append("--batch-builder" + batchBuilder);
+        }
+        if (sinkTopic != null) {
+            commandBuilder.append(" --output " + sinkTopic);
+        }
+        if (logTopic != null) {
+            commandBuilder.append(" --logTopic " + logTopic);
+        }
+        if (outputSerDe != null) {
+            commandBuilder.append(" --outputSerdeClassName " + outputSerDe);
+        }
+        if (processingGuarantees != null) {
+            commandBuilder.append(" --processingGuarantees " + processingGuarantees);
+        }
+        if (!userConfig.isEmpty()) {
+            commandBuilder.append(" --userConfig \'" + new Gson().toJson(userConfig) + "\'");
+        }
+        if (parallelism != null) {
+            commandBuilder.append(" --parallelism " + parallelism);
+        }
+        if (windowLengthCount != null) {
+            commandBuilder.append(" --windowLengthCount " + windowLengthCount);
+        }
+        if (windowLengthDurationMs != null)  {
+            commandBuilder.append(" --windowLengthDurationMs " + windowLengthDurationMs);
+        }
+        if (slidingIntervalCount != null)  {
+            commandBuilder.append(" --slidingIntervalCount " + slidingIntervalCount);
+        }
+        if (slidingIntervalDurationMs != null)  {
+            commandBuilder.append(" --slidingIntervalDurationMs " + slidingIntervalDurationMs);
+        }
+        if (customSchemaInputs != null) {
+            commandBuilder.append(" --custom-schema-inputs \'" + customSchemaInputs + "\'");
+        }
+        if (inputTypeClassName != null) {
+            commandBuilder.append(" --input-type-class-name " + inputTypeClassName);
+        }
+        if (outputTypeClassName != null) {
+            commandBuilder.append(" --output-type-class-name " + outputTypeClassName);
+        }
+        if (schemaType != null) {
+            commandBuilder.append(" --schema-type " + schemaType);
+        }
+        if (subscriptionInitialPosition != null) {
+            commandBuilder.append(" --subs-position " + subscriptionInitialPosition.name());
+        }
+
+        if (codeFile != null) {
+            switch (runtime) {
+                case JAVA:
+                    commandBuilder.append(" --jar " + JAVAJAR);
+                    commandBuilder.append(" --ram " + JAVA_RUNTIME_RAM_BYTES);
+                    break;
+                case PYTHON:
+                    if (codeFile != null) {
+                        commandBuilder.append(" --py " + PYTHONBASE + codeFile);
+                    } else {
+                        commandBuilder.append(" --py " + PYTHONBASE);
+                    }
+                    break;
+                case GO:
+                    if (codeFile != null) {
+                        commandBuilder.append(" --go " + GOBASE + codeFile);
+                    } else {
+                        commandBuilder.append(" --go " + GOBASE);
+                    }
+                    break;
+            }
+        }
+        return commandBuilder.toString();
+    }
+
+    public String genereateDeleteFunctionCommand() {
+        StringBuilder commandBuilder = new StringBuilder("/pulsar/bin/pulsar-admin functions delete");
+        if (tenant != null) {
+            commandBuilder.append(" --tenant " + tenant);
+        }
+        if (namespace != null) {
+            commandBuilder.append(" --namespace " + namespace);
+        }
+        if (functionName != null) {
+            commandBuilder.append(" --name " + functionName);
+        }
+        return commandBuilder.toString();
+    }
+
+    public String generateTriggerFunctionCommand(String triggerValue) {
+        StringBuilder commandBuilder = new StringBuilder("/pulsar/bin/pulsar-admin functions trigger");
+        if (tenant != null) {
+            commandBuilder.append(" --tenant " + tenant);
+        }
+        if (namespace != null) {
+            commandBuilder.append(" --namespace " + namespace);
+        }
+        if (functionName != null) {
+            commandBuilder.append(" --name " + functionName);
+        }
+        commandBuilder.append(" --triggerValue " + triggerValue);
+        return commandBuilder.toString();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/UploadDownloadCommandGenerator.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/UploadDownloadCommandGenerator.java
index 225b4a4a74..603681fc91 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/UploadDownloadCommandGenerator.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/functions/utils/UploadDownloadCommandGenerator.java
@@ -1,74 +1,74 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.functions.utils;
-
-import lombok.Getter;
-import lombok.Setter;
-import lombok.ToString;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-@Getter
-@Setter
-@ToString
-public class UploadDownloadCommandGenerator {
-    public enum MODE {
-        UPLOAD,
-        DOWNLOAD,
-    };
-    private MODE mode;
-    private String bkPath;
-    private String localPath;
-    private String brokerUrl;
-
-    public static UploadDownloadCommandGenerator createUploader(String localPath, String bkPath) {
-        return new UploadDownloadCommandGenerator(MODE.UPLOAD, localPath, bkPath);
-    }
-
-    public static UploadDownloadCommandGenerator createDownloader(String localPath, String bkPath) {
-        return new UploadDownloadCommandGenerator(MODE.DOWNLOAD, localPath, bkPath);
-    }
-
-    public UploadDownloadCommandGenerator(MODE mode, String localPath, String bkPath) {
-        this.mode = mode;
-        this.localPath = localPath;
-        this.bkPath = bkPath;
-    }
-
-    public void createBrokerUrl(String host, int port) {
-        brokerUrl = "pulsar://" + host + ":" + port;
-    }
-
-    public String generateCommand() {
-        StringBuilder commandBuilder = new StringBuilder().append(PulsarCluster.ADMIN_SCRIPT).append(" functions ");
-        if (mode == MODE.UPLOAD) {
-            commandBuilder.append(" upload ");
-        } else {
-            commandBuilder.append(" download ");
-        }
-        commandBuilder.append(" --path ");
-        commandBuilder.append(bkPath);
-        if (mode == MODE.UPLOAD) {
-            commandBuilder.append(" --sourceFile ");
-        } else {
-            commandBuilder.append(" --destinationFile ");
-        }
-        commandBuilder.append(localPath);
-        return commandBuilder.toString();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.functions.utils;
+
+import lombok.Getter;
+import lombok.Setter;
+import lombok.ToString;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+@Getter
+@Setter
+@ToString
+public class UploadDownloadCommandGenerator {
+    public enum MODE {
+        UPLOAD,
+        DOWNLOAD,
+    };
+    private MODE mode;
+    private String bkPath;
+    private String localPath;
+    private String brokerUrl;
+
+    public static UploadDownloadCommandGenerator createUploader(String localPath, String bkPath) {
+        return new UploadDownloadCommandGenerator(MODE.UPLOAD, localPath, bkPath);
+    }
+
+    public static UploadDownloadCommandGenerator createDownloader(String localPath, String bkPath) {
+        return new UploadDownloadCommandGenerator(MODE.DOWNLOAD, localPath, bkPath);
+    }
+
+    public UploadDownloadCommandGenerator(MODE mode, String localPath, String bkPath) {
+        this.mode = mode;
+        this.localPath = localPath;
+        this.bkPath = bkPath;
+    }
+
+    public void createBrokerUrl(String host, int port) {
+        brokerUrl = "pulsar://" + host + ":" + port;
+    }
+
+    public String generateCommand() {
+        StringBuilder commandBuilder = new StringBuilder().append(PulsarCluster.ADMIN_SCRIPT).append(" functions ");
+        if (mode == MODE.UPLOAD) {
+            commandBuilder.append(" upload ");
+        } else {
+            commandBuilder.append(" download ");
+        }
+        commandBuilder.append(" --path ");
+        commandBuilder.append(bkPath);
+        if (mode == MODE.UPLOAD) {
+            commandBuilder.append(" --sourceFile ");
+        } else {
+            commandBuilder.append(" --destinationFile ");
+        }
+        commandBuilder.append(localPath);
+        return commandBuilder.toString();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarGenericObjectSinkTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarGenericObjectSinkTest.java
index 25f9aa8049..4bf0dc25c3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarGenericObjectSinkTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarGenericObjectSinkTest.java
@@ -1,337 +1,337 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.Arrays;
-import java.util.List;
-import java.util.stream.Collectors;
-import lombok.Builder;
-import lombok.Cleanup;
-import lombok.Data;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.policies.data.SinkStatus;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.annotations.Test;
-
-/**
- * Test behaviour of simple sinks.
- */
-@Slf4j
-public class PulsarGenericObjectSinkTest extends PulsarStandaloneTestSuite {
-
-    @Getter
-    private static final class SinkSpec<T> {
-        final String outputTopicName;
-        final Schema<T> schema;
-        final T testValue;
-
-        public SinkSpec(String outputTopicName, Schema<T> schema, T testValue) {
-            this.outputTopicName = outputTopicName;
-            this.schema = schema;
-            this.testValue = testValue;
-        }
-    }
-
-    @Data
-    @Builder
-    public static class Pojo {
-        private String field1;
-        private int field2;
-    }
-
-    @Data
-    @Builder
-    public static class PojoV2 {
-        private String field1;
-        private int field2;
-        private Double field3;
-    }
-
-    @Data
-    @Builder
-    public static final class PojoKey {
-        private String field1;
-    }
-
-    @Test(groups = {"sink"})
-    public void testGenericObjectSink() throws Exception {
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(container.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build();
-
-        // we are not using a parametrized test in order to save resources
-        // we create one sink that listens on multiple topics, send the records and verify the sink
-        List<SinkSpec<?>> specs = Arrays.asList(
-                new SinkSpec<>("test-kv-sink-input-string-" + randomName(8), Schema.STRING, "foo"),
-                new SinkSpec<>("test-kv-sink-input-avro-" + randomName(8), Schema.AVRO(Pojo.class),
-                        Pojo.builder().field1("a").field2(2).build()),
-                new SinkSpec<>("test-kv-sink-input-json-" + randomName(8), Schema.JSON(Pojo.class),
-                        Pojo.builder().field1("a").field2(2).build()),
-                new SinkSpec<>("test-kv-sink-input-kv-string-int-" + randomName(8),
-                        Schema.KeyValue(Schema.STRING, Schema.INT32), new KeyValue<>("foo", 123)),
-                new SinkSpec<>("test-kv-sink-input-kv-avro-json-inl-" + randomName(8),
-                        Schema.KeyValue(Schema.AVRO(PojoKey.class), Schema.JSON(Pojo.class),
-                                KeyValueEncodingType.INLINE), new KeyValue<>(PojoKey.builder().field1("a").build(),
-                        Pojo.builder().field1("a").field2(2).build())),
-                new SinkSpec("test-kv-sink-input-kv-avro-json-sep-" + randomName(8),
-                        Schema.KeyValue(Schema.AVRO(PojoKey.class), Schema.JSON(Pojo.class),
-                                KeyValueEncodingType.SEPARATED), new KeyValue<>(PojoKey.builder().field1("a").build(),
-                        Pojo.builder().field1("a").field2(2).build()))
-        );
-
-        final int numRecordsPerTopic = 2;
-
-        String sinkName = "genericobject-sink";
-        String topicNames = specs
-                .stream()
-                .map(SinkSpec::getOutputTopicName)
-                .collect(Collectors.joining(","));
-        submitSinkConnector(sinkName, topicNames, "org.apache.pulsar.tests.integration.io.TestGenericObjectSink",
-                JAVAJAR);
-        // get sink info
-        getSinkInfoSuccess(sinkName);
-        getSinkStatus(sinkName);
-
-
-        for (SinkSpec<?> spec : specs) {
-            sendMessages(client, numRecordsPerTopic, spec);
-        }
-
-        // wait that sink processed all records without errors
-
-        try {
-            log.info("waiting for sink {}", sinkName);
-
-            for (int i = 0; i < 120; i++) {
-                SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
-                log.info("sink {} status {}", sinkName, status);
-                assertEquals(status.getInstances().size(), 1);
-                SinkStatus.SinkInstanceStatus instance = status.getInstances().get(0);
-                if (instance.getStatus().numWrittenToSink >= numRecordsPerTopic * specs.size()
-                    || instance.getStatus().numSinkExceptions > 0
-                    || instance.getStatus().numSystemExceptions > 0
-                    || instance.getStatus().numRestarts > 0) {
-                    break;
-                }
-                Thread.sleep(1000);
-            }
-
-            SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
-            log.info("sink {} status {}", sinkName, status);
-            assertEquals(status.getInstances().size(), 1);
-            assertTrue(status.getInstances().get(0).getStatus().numWrittenToSink >= numRecordsPerTopic * specs.size());
-            assertTrue(status.getInstances().get(0).getStatus().numSinkExceptions == 0);
-            assertTrue(status.getInstances().get(0).getStatus().numSystemExceptions == 0);
-            log.info("sink {} is okay", sinkName);
-        } finally {
-            dumpFunctionLogs(sinkName);
-        }
-
-        deleteSink(sinkName);
-        getSinkInfoNotFound(sinkName);
-    }
-
-    private <T> void sendMessages(PulsarClient client, int numRecordsPerTopic, SinkSpec<T> spec)
-            throws PulsarClientException {
-        @Cleanup Producer<T> producer = client.newProducer(spec.schema)
-                .topic(spec.outputTopicName)
-                .create();
-        for (int i = 0; i < numRecordsPerTopic; i++) {
-            MessageId messageId = producer.newMessage()
-                    .value(spec.testValue)
-                    .property("expectedType", spec.schema.getSchemaInfo().getType().toString())
-                    .property("recordNumber", i + "")
-                    .send();
-            log.info("sent message {} {}  with ID {}", spec.testValue,
-                    spec.schema.getSchemaInfo().getType().toString(), messageId);
-        }
-    }
-
-    @Test(groups = {"sink"})
-    public void testGenericObjectSinkWithSchemaChange() throws Exception {
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(container.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build();
-
-
-        final int numRecords = 2;
-
-        String sinkName = "genericobject-sink";
-        String topicName = "test-genericobject-sink-schema-change";
-
-        submitSinkConnector(sinkName, topicName, "org.apache.pulsar.tests.integration.io.TestGenericObjectSink",
-                JAVAJAR);
-        // get sink info
-        getSinkInfoSuccess(sinkName);
-        getSinkStatus(sinkName);
-
-        @Cleanup Producer<byte[]> producer = client.newProducer()
-                    .topic(topicName)
-                    .create();
-        Schema<Pojo> schemav1 = Schema.AVRO(Pojo.class);
-        Pojo record1 = Pojo.builder().field1("foo").field2(23).build();
-        producer.newMessage(schemav1)
-                .value(record1)
-                .property("expectedType", schemav1.getSchemaInfo().getType().toString())
-                .property("expectedSchemaDefinition", schemav1.getSchemaInfo().getSchemaDefinition())
-                .property("recordNumber", "1")
-                .send();
-
-        Schema<PojoV2> schemav2 = Schema.AVRO(PojoV2.class);
-        PojoV2 record2 = PojoV2.builder().field1("foo").field2(23).field3(42.5).build();
-        producer.newMessage(schemav2)
-                .value(record2)
-                .property("expectedType", schemav2.getSchemaInfo().getType().toString())
-                .property("expectedSchemaDefinition", schemav2.getSchemaInfo().getSchemaDefinition())
-                .property("recordNumber", "2")
-                .send();
-
-        // wait that sink processed all records without errors
-
-        try {
-            log.info("waiting for sink {}", sinkName);
-
-            for (int i = 0; i < 120; i++) {
-                SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
-                log.info("sink {} status {}", sinkName, status);
-                assertEquals(status.getInstances().size(), 1);
-                SinkStatus.SinkInstanceStatus instance = status.getInstances().get(0);
-                if (instance.getStatus().numWrittenToSink >= numRecords
-                        || instance.getStatus().numSinkExceptions > 0
-                        || instance.getStatus().numSystemExceptions > 0
-                        || instance.getStatus().numRestarts > 0) {
-                    break;
-                }
-                Thread.sleep(1000);
-            }
-
-            SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
-            log.info("sink {} status {}", sinkName, status);
-            assertEquals(status.getInstances().size(), 1);
-            assertTrue(status.getInstances().get(0).getStatus().numWrittenToSink >= numRecords);
-            assertTrue(status.getInstances().get(0).getStatus().numSinkExceptions == 0);
-            assertTrue(status.getInstances().get(0).getStatus().numSystemExceptions == 0);
-            log.info("sink {} is okay", sinkName);
-        } finally {
-            dumpFunctionLogs(sinkName);
-        }
-
-        deleteSink(sinkName);
-        getSinkInfoNotFound(sinkName);
-    }
-
-    private void submitSinkConnector(String sinkName,
-                                     String inputTopicName,
-                                     String className,
-                                     String archive) throws Exception {
-        String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks", "create",
-                "--name", sinkName,
-                "-i", inputTopicName,
-                "--archive", archive,
-                "--classname", className
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    private void getSinkInfoSuccess(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sinkName + "\""));
-    }
-
-    private void getSinkStatus(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        log.info(result.getStdout());
-        log.info(result.getStderr());
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private void deleteSink(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("successfully"));
-        result.assertNoStderr();
-    }
-
-    private void getSinkInfoNotFound(String sinkName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sinks",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", sinkName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains(sinkName + " doesn't exist"));
-        }
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import lombok.Builder;
+import lombok.Cleanup;
+import lombok.Data;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.policies.data.SinkStatus;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.annotations.Test;
+
+/**
+ * Test behaviour of simple sinks.
+ */
+@Slf4j
+public class PulsarGenericObjectSinkTest extends PulsarStandaloneTestSuite {
+
+    @Getter
+    private static final class SinkSpec<T> {
+        final String outputTopicName;
+        final Schema<T> schema;
+        final T testValue;
+
+        public SinkSpec(String outputTopicName, Schema<T> schema, T testValue) {
+            this.outputTopicName = outputTopicName;
+            this.schema = schema;
+            this.testValue = testValue;
+        }
+    }
+
+    @Data
+    @Builder
+    public static class Pojo {
+        private String field1;
+        private int field2;
+    }
+
+    @Data
+    @Builder
+    public static class PojoV2 {
+        private String field1;
+        private int field2;
+        private Double field3;
+    }
+
+    @Data
+    @Builder
+    public static final class PojoKey {
+        private String field1;
+    }
+
+    @Test(groups = {"sink"})
+    public void testGenericObjectSink() throws Exception {
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(container.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build();
+
+        // we are not using a parametrized test in order to save resources
+        // we create one sink that listens on multiple topics, send the records and verify the sink
+        List<SinkSpec<?>> specs = Arrays.asList(
+                new SinkSpec<>("test-kv-sink-input-string-" + randomName(8), Schema.STRING, "foo"),
+                new SinkSpec<>("test-kv-sink-input-avro-" + randomName(8), Schema.AVRO(Pojo.class),
+                        Pojo.builder().field1("a").field2(2).build()),
+                new SinkSpec<>("test-kv-sink-input-json-" + randomName(8), Schema.JSON(Pojo.class),
+                        Pojo.builder().field1("a").field2(2).build()),
+                new SinkSpec<>("test-kv-sink-input-kv-string-int-" + randomName(8),
+                        Schema.KeyValue(Schema.STRING, Schema.INT32), new KeyValue<>("foo", 123)),
+                new SinkSpec<>("test-kv-sink-input-kv-avro-json-inl-" + randomName(8),
+                        Schema.KeyValue(Schema.AVRO(PojoKey.class), Schema.JSON(Pojo.class),
+                                KeyValueEncodingType.INLINE), new KeyValue<>(PojoKey.builder().field1("a").build(),
+                        Pojo.builder().field1("a").field2(2).build())),
+                new SinkSpec("test-kv-sink-input-kv-avro-json-sep-" + randomName(8),
+                        Schema.KeyValue(Schema.AVRO(PojoKey.class), Schema.JSON(Pojo.class),
+                                KeyValueEncodingType.SEPARATED), new KeyValue<>(PojoKey.builder().field1("a").build(),
+                        Pojo.builder().field1("a").field2(2).build()))
+        );
+
+        final int numRecordsPerTopic = 2;
+
+        String sinkName = "genericobject-sink";
+        String topicNames = specs
+                .stream()
+                .map(SinkSpec::getOutputTopicName)
+                .collect(Collectors.joining(","));
+        submitSinkConnector(sinkName, topicNames, "org.apache.pulsar.tests.integration.io.TestGenericObjectSink",
+                JAVAJAR);
+        // get sink info
+        getSinkInfoSuccess(sinkName);
+        getSinkStatus(sinkName);
+
+
+        for (SinkSpec<?> spec : specs) {
+            sendMessages(client, numRecordsPerTopic, spec);
+        }
+
+        // wait that sink processed all records without errors
+
+        try {
+            log.info("waiting for sink {}", sinkName);
+
+            for (int i = 0; i < 120; i++) {
+                SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
+                log.info("sink {} status {}", sinkName, status);
+                assertEquals(status.getInstances().size(), 1);
+                SinkStatus.SinkInstanceStatus instance = status.getInstances().get(0);
+                if (instance.getStatus().numWrittenToSink >= numRecordsPerTopic * specs.size()
+                    || instance.getStatus().numSinkExceptions > 0
+                    || instance.getStatus().numSystemExceptions > 0
+                    || instance.getStatus().numRestarts > 0) {
+                    break;
+                }
+                Thread.sleep(1000);
+            }
+
+            SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
+            log.info("sink {} status {}", sinkName, status);
+            assertEquals(status.getInstances().size(), 1);
+            assertTrue(status.getInstances().get(0).getStatus().numWrittenToSink >= numRecordsPerTopic * specs.size());
+            assertTrue(status.getInstances().get(0).getStatus().numSinkExceptions == 0);
+            assertTrue(status.getInstances().get(0).getStatus().numSystemExceptions == 0);
+            log.info("sink {} is okay", sinkName);
+        } finally {
+            dumpFunctionLogs(sinkName);
+        }
+
+        deleteSink(sinkName);
+        getSinkInfoNotFound(sinkName);
+    }
+
+    private <T> void sendMessages(PulsarClient client, int numRecordsPerTopic, SinkSpec<T> spec)
+            throws PulsarClientException {
+        @Cleanup Producer<T> producer = client.newProducer(spec.schema)
+                .topic(spec.outputTopicName)
+                .create();
+        for (int i = 0; i < numRecordsPerTopic; i++) {
+            MessageId messageId = producer.newMessage()
+                    .value(spec.testValue)
+                    .property("expectedType", spec.schema.getSchemaInfo().getType().toString())
+                    .property("recordNumber", i + "")
+                    .send();
+            log.info("sent message {} {}  with ID {}", spec.testValue,
+                    spec.schema.getSchemaInfo().getType().toString(), messageId);
+        }
+    }
+
+    @Test(groups = {"sink"})
+    public void testGenericObjectSinkWithSchemaChange() throws Exception {
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(container.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build();
+
+
+        final int numRecords = 2;
+
+        String sinkName = "genericobject-sink";
+        String topicName = "test-genericobject-sink-schema-change";
+
+        submitSinkConnector(sinkName, topicName, "org.apache.pulsar.tests.integration.io.TestGenericObjectSink",
+                JAVAJAR);
+        // get sink info
+        getSinkInfoSuccess(sinkName);
+        getSinkStatus(sinkName);
+
+        @Cleanup Producer<byte[]> producer = client.newProducer()
+                    .topic(topicName)
+                    .create();
+        Schema<Pojo> schemav1 = Schema.AVRO(Pojo.class);
+        Pojo record1 = Pojo.builder().field1("foo").field2(23).build();
+        producer.newMessage(schemav1)
+                .value(record1)
+                .property("expectedType", schemav1.getSchemaInfo().getType().toString())
+                .property("expectedSchemaDefinition", schemav1.getSchemaInfo().getSchemaDefinition())
+                .property("recordNumber", "1")
+                .send();
+
+        Schema<PojoV2> schemav2 = Schema.AVRO(PojoV2.class);
+        PojoV2 record2 = PojoV2.builder().field1("foo").field2(23).field3(42.5).build();
+        producer.newMessage(schemav2)
+                .value(record2)
+                .property("expectedType", schemav2.getSchemaInfo().getType().toString())
+                .property("expectedSchemaDefinition", schemav2.getSchemaInfo().getSchemaDefinition())
+                .property("recordNumber", "2")
+                .send();
+
+        // wait that sink processed all records without errors
+
+        try {
+            log.info("waiting for sink {}", sinkName);
+
+            for (int i = 0; i < 120; i++) {
+                SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
+                log.info("sink {} status {}", sinkName, status);
+                assertEquals(status.getInstances().size(), 1);
+                SinkStatus.SinkInstanceStatus instance = status.getInstances().get(0);
+                if (instance.getStatus().numWrittenToSink >= numRecords
+                        || instance.getStatus().numSinkExceptions > 0
+                        || instance.getStatus().numSystemExceptions > 0
+                        || instance.getStatus().numRestarts > 0) {
+                    break;
+                }
+                Thread.sleep(1000);
+            }
+
+            SinkStatus status = admin.sinks().getSinkStatus("public", "default", sinkName);
+            log.info("sink {} status {}", sinkName, status);
+            assertEquals(status.getInstances().size(), 1);
+            assertTrue(status.getInstances().get(0).getStatus().numWrittenToSink >= numRecords);
+            assertTrue(status.getInstances().get(0).getStatus().numSinkExceptions == 0);
+            assertTrue(status.getInstances().get(0).getStatus().numSystemExceptions == 0);
+            log.info("sink {} is okay", sinkName);
+        } finally {
+            dumpFunctionLogs(sinkName);
+        }
+
+        deleteSink(sinkName);
+        getSinkInfoNotFound(sinkName);
+    }
+
+    private void submitSinkConnector(String sinkName,
+                                     String inputTopicName,
+                                     String className,
+                                     String archive) throws Exception {
+        String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks", "create",
+                "--name", sinkName,
+                "-i", inputTopicName,
+                "--archive", archive,
+                "--classname", className
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    private void getSinkInfoSuccess(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sinkName + "\""));
+    }
+
+    private void getSinkStatus(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        log.info(result.getStdout());
+        log.info(result.getStderr());
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private void deleteSink(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("successfully"));
+        result.assertNoStderr();
+    }
+
+    private void getSinkInfoNotFound(String sinkName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sinks",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", sinkName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains(sinkName + " doesn't exist"));
+        }
+    }
+}
+
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestBase.java
index 92aa6fd013..3892b85a56 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestBase.java
@@ -1,75 +1,75 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTestBase;
-import org.apache.pulsar.tests.integration.io.sinks.PulsarIOSinkRunner;
-import org.apache.pulsar.tests.integration.io.sinks.SinkTester;
-import org.apache.pulsar.tests.integration.io.sources.PulsarIOSourceRunner;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testcontainers.containers.GenericContainer;
-
-public abstract class PulsarIOTestBase extends PulsarFunctionsTestBase {
-
-    public PulsarIOTestBase(FunctionRuntimeType functionRuntimeType) {
-        super(functionRuntimeType);
-    }
-
-    @SuppressWarnings({"unchecked", "rawtypes"})
-    protected void testSink(SinkTester tester, boolean builtin) throws Exception {
-        tester.startServiceContainer(pulsarCluster);
-        try {
-            PulsarIOSinkRunner runner = new PulsarIOSinkRunner(pulsarCluster, functionRuntimeType.toString());
-            runner.runSinkTester(tester, builtin);
-        } finally {
-            try {
-                tester.close();
-            } finally {
-                tester.stopServiceContainer();
-            }
-        }
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected <ServiceContainerT extends GenericContainer> void testSink(SinkTester<ServiceContainerT> sinkTester,
-                                                                         boolean builtinSink,
-                                                                         SourceTester<ServiceContainerT> sourceTester)
-            throws Exception {
-
-        ServiceContainerT serviceContainer = sinkTester.startServiceContainer(pulsarCluster);
-
-        try {
-            PulsarIOSinkRunner runner = new PulsarIOSinkRunner(pulsarCluster, functionRuntimeType.toString());
-            runner.runSinkTester(sinkTester, builtinSink);
-            if (null != sourceTester) {
-                PulsarIOSourceRunner sourceRunner =
-                        new PulsarIOSourceRunner(pulsarCluster, functionRuntimeType.toString());
-                sourceTester.setServiceContainer(serviceContainer);
-                sourceRunner.testSource(sourceTester);
-            }
-        } finally {
-            try {
-                sinkTester.close();
-            } finally {
-                sinkTester.stopServiceContainer();
-            }
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTestBase;
+import org.apache.pulsar.tests.integration.io.sinks.PulsarIOSinkRunner;
+import org.apache.pulsar.tests.integration.io.sinks.SinkTester;
+import org.apache.pulsar.tests.integration.io.sources.PulsarIOSourceRunner;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testcontainers.containers.GenericContainer;
+
+public abstract class PulsarIOTestBase extends PulsarFunctionsTestBase {
+
+    public PulsarIOTestBase(FunctionRuntimeType functionRuntimeType) {
+        super(functionRuntimeType);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    protected void testSink(SinkTester tester, boolean builtin) throws Exception {
+        tester.startServiceContainer(pulsarCluster);
+        try {
+            PulsarIOSinkRunner runner = new PulsarIOSinkRunner(pulsarCluster, functionRuntimeType.toString());
+            runner.runSinkTester(tester, builtin);
+        } finally {
+            try {
+                tester.close();
+            } finally {
+                tester.stopServiceContainer();
+            }
+        }
+    }
+
+    @SuppressWarnings("rawtypes")
+    protected <ServiceContainerT extends GenericContainer> void testSink(SinkTester<ServiceContainerT> sinkTester,
+                                                                         boolean builtinSink,
+                                                                         SourceTester<ServiceContainerT> sourceTester)
+            throws Exception {
+
+        ServiceContainerT serviceContainer = sinkTester.startServiceContainer(pulsarCluster);
+
+        try {
+            PulsarIOSinkRunner runner = new PulsarIOSinkRunner(pulsarCluster, functionRuntimeType.toString());
+            runner.runSinkTester(sinkTester, builtinSink);
+            if (null != sourceTester) {
+                PulsarIOSourceRunner sourceRunner =
+                        new PulsarIOSourceRunner(pulsarCluster, functionRuntimeType.toString());
+                sourceTester.setServiceContainer(serviceContainer);
+                sourceRunner.testSource(sourceTester);
+            }
+        } finally {
+            try {
+                sinkTester.close();
+            } finally {
+                sinkTester.stopServiceContainer();
+            }
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestRunner.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestRunner.java
index be6f699ea1..1873db6c61 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestRunner.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/PulsarIOTestRunner.java
@@ -1,94 +1,94 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import dev.failsafe.RetryPolicy;
-import java.time.Duration;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.impl.schema.KeyValueSchemaImpl;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.tests.integration.io.sinks.SinkTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-@Slf4j
-public abstract class PulsarIOTestRunner {
-    static final long MB = 1048576L;
-    public static final long RUNTIME_INSTANCE_RAM_BYTES = 128 * MB;
-    final Duration oneMinute = Duration.ofMinutes(1);
-    final Duration tenSeconds = Duration.ofSeconds(10);
-
-    protected final RetryPolicy<?> statusRetryPolicy = RetryPolicy.builder()
-            .withMaxDuration(oneMinute)
-            .withDelay(tenSeconds)
-            .onRetry(e -> log.error("Retry ... "))
-            .build();
-
-    protected PulsarCluster pulsarCluster;
-    protected String functionRuntimeType;
-
-    protected PulsarIOTestRunner(PulsarCluster cluster, String functionRuntimeType) {
-      this.pulsarCluster = cluster;
-      this.functionRuntimeType = functionRuntimeType;
-    }
-
-    protected Schema<?> getSchema(boolean jsonWithEnvelope) {
-        if (jsonWithEnvelope) {
-            return KeyValueSchemaImpl.kvBytes();
-        } else {
-            return KeyValueSchemaImpl.of(Schema.AUTO_CONSUME(), Schema.AUTO_CONSUME(), KeyValueEncodingType.SEPARATED);
-        }
-    }
-
-    @SuppressWarnings("try")
-    protected <T> void ensureSubscriptionCreated(String inputTopicName,
-                                                      String subscriptionName,
-                                                      Schema<T> inputTopicSchema)
-            throws Exception {
-        // ensure the function subscription exists before we start producing messages
-        try (PulsarClient client = PulsarClient.builder()
-            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-            .build()) {
-            try (Consumer<T> ignored = client.newConsumer(inputTopicSchema)
-                .topic(inputTopicName)
-                .subscriptionType(SubscriptionType.Shared)
-                .subscriptionName(subscriptionName)
-                .subscribe()) {
-            }
-        }
-    }
-
-    protected Map<String, String> produceMessagesToInputTopic(String inputTopicName,
-                                                              int numMessages, SinkTester<?> tester) throws Exception {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
-        tester.produceMessage(numMessages, client, inputTopicName, kvs);
-        return kvs;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import dev.failsafe.RetryPolicy;
+import java.time.Duration;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.impl.schema.KeyValueSchemaImpl;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.tests.integration.io.sinks.SinkTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+@Slf4j
+public abstract class PulsarIOTestRunner {
+    static final long MB = 1048576L;
+    public static final long RUNTIME_INSTANCE_RAM_BYTES = 128 * MB;
+    final Duration oneMinute = Duration.ofMinutes(1);
+    final Duration tenSeconds = Duration.ofSeconds(10);
+
+    protected final RetryPolicy<?> statusRetryPolicy = RetryPolicy.builder()
+            .withMaxDuration(oneMinute)
+            .withDelay(tenSeconds)
+            .onRetry(e -> log.error("Retry ... "))
+            .build();
+
+    protected PulsarCluster pulsarCluster;
+    protected String functionRuntimeType;
+
+    protected PulsarIOTestRunner(PulsarCluster cluster, String functionRuntimeType) {
+      this.pulsarCluster = cluster;
+      this.functionRuntimeType = functionRuntimeType;
+    }
+
+    protected Schema<?> getSchema(boolean jsonWithEnvelope) {
+        if (jsonWithEnvelope) {
+            return KeyValueSchemaImpl.kvBytes();
+        } else {
+            return KeyValueSchemaImpl.of(Schema.AUTO_CONSUME(), Schema.AUTO_CONSUME(), KeyValueEncodingType.SEPARATED);
+        }
+    }
+
+    @SuppressWarnings("try")
+    protected <T> void ensureSubscriptionCreated(String inputTopicName,
+                                                      String subscriptionName,
+                                                      Schema<T> inputTopicSchema)
+            throws Exception {
+        // ensure the function subscription exists before we start producing messages
+        try (PulsarClient client = PulsarClient.builder()
+            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+            .build()) {
+            try (Consumer<T> ignored = client.newConsumer(inputTopicSchema)
+                .topic(inputTopicName)
+                .subscriptionType(SubscriptionType.Shared)
+                .subscriptionName(subscriptionName)
+                .subscribe()) {
+            }
+        }
+    }
+
+    protected Map<String, String> produceMessagesToInputTopic(String inputTopicName,
+                                                              int numMessages, SinkTester<?> tester) throws Exception {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
+        tester.produceMessage(numMessages, client, inputTopicName, kvs);
+        return kvs;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSinkTester.java
index 3b0b5a231b..8234e5fe85 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSinkTester.java
@@ -1,113 +1,113 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.fail;
-import com.rabbitmq.client.AMQP;
-import com.rabbitmq.client.Channel;
-import com.rabbitmq.client.Connection;
-import com.rabbitmq.client.ConnectionFactory;
-import com.rabbitmq.client.DefaultConsumer;
-import com.rabbitmq.client.Envelope;
-import java.io.IOException;
-import java.util.Map;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeoutException;
-import lombok.Data;
-import org.apache.pulsar.tests.integration.containers.RabbitMQContainer;
-import org.apache.pulsar.tests.integration.io.sinks.SinkTester;
-import org.apache.pulsar.tests.integration.io.sinks.SinkTester.SinkType;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-public class RabbitMQSinkTester extends SinkTester<RabbitMQContainer> {
-    private final String exchangeName = "test-sink-exchange";
-    private final String queueName = "test-sink-queue";
-    private final String keyName = "test-key";
-
-    public RabbitMQSinkTester(String networkAlias) {
-        super(networkAlias, SinkType.RABBITMQ);
-
-        sinkConfig.put("connectionName", "test-sink-connection");
-        sinkConfig.put("host", networkAlias);
-        sinkConfig.put("port", RabbitMQContainer.PORTS[0]);
-        sinkConfig.put("queueName", queueName);
-        sinkConfig.put("exchangeName", exchangeName);
-        sinkConfig.put("routingKey", keyName);
-    }
-
-    @Override
-    protected RabbitMQContainer createSinkService(PulsarCluster cluster) {
-        return new RabbitMQContainer(cluster.getClusterName(), networkAlias);
-    }
-
-    @Override
-    public void prepareSink() throws Exception {
-    }
-
-    static ConnectionFactory createConnectionFactory(RabbitMQContainer container) {
-        ConnectionFactory connectionFactory = new ConnectionFactory();
-        connectionFactory.setHost(container.getHost());
-        connectionFactory.setPort(container.getMappedPort(RabbitMQContainer.PORTS[0]));
-
-        return connectionFactory;
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        ConnectionFactory connectionFactory = createConnectionFactory(serviceContainer);
-        try (Connection connection = connectionFactory.newConnection("rabbitmq-sink-tester");
-             Channel channel = connection.createChannel()) {
-            BlockingQueue<Record> records = new LinkedBlockingQueue<>();
-            channel.queueDeclare(queueName, true, false, false, null);
-            channel.basicConsume(queueName, new DefaultConsumer(channel) {
-                @Override
-                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,
-                                           byte[] body) throws IOException {
-                    records.add(new Record(envelope.getRoutingKey(), body));
-                    channel.basicAck(envelope.getDeliveryTag(), false);
-                }
-            });
-            // keys are discards when  into rabbitMQ
-            for (String value : kvs.values()) {
-                try {
-                    Record record = records.take();
-                    assertEquals(record.key, keyName);
-                    assertEquals(new String(record.body), value);
-                } catch (InterruptedException e) {
-                    break;
-                }
-            }
-        } catch (TimeoutException | IOException e) {
-            fail("RabbitMQ Sink test failed", e);
-        }
-    }
-
-    @Data
-    private static class Record {
-        private final String key;
-        private final byte[] body;
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+import com.rabbitmq.client.AMQP;
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.Connection;
+import com.rabbitmq.client.ConnectionFactory;
+import com.rabbitmq.client.DefaultConsumer;
+import com.rabbitmq.client.Envelope;
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeoutException;
+import lombok.Data;
+import org.apache.pulsar.tests.integration.containers.RabbitMQContainer;
+import org.apache.pulsar.tests.integration.io.sinks.SinkTester;
+import org.apache.pulsar.tests.integration.io.sinks.SinkTester.SinkType;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+public class RabbitMQSinkTester extends SinkTester<RabbitMQContainer> {
+    private final String exchangeName = "test-sink-exchange";
+    private final String queueName = "test-sink-queue";
+    private final String keyName = "test-key";
+
+    public RabbitMQSinkTester(String networkAlias) {
+        super(networkAlias, SinkType.RABBITMQ);
+
+        sinkConfig.put("connectionName", "test-sink-connection");
+        sinkConfig.put("host", networkAlias);
+        sinkConfig.put("port", RabbitMQContainer.PORTS[0]);
+        sinkConfig.put("queueName", queueName);
+        sinkConfig.put("exchangeName", exchangeName);
+        sinkConfig.put("routingKey", keyName);
+    }
+
+    @Override
+    protected RabbitMQContainer createSinkService(PulsarCluster cluster) {
+        return new RabbitMQContainer(cluster.getClusterName(), networkAlias);
+    }
+
+    @Override
+    public void prepareSink() throws Exception {
+    }
+
+    static ConnectionFactory createConnectionFactory(RabbitMQContainer container) {
+        ConnectionFactory connectionFactory = new ConnectionFactory();
+        connectionFactory.setHost(container.getHost());
+        connectionFactory.setPort(container.getMappedPort(RabbitMQContainer.PORTS[0]));
+
+        return connectionFactory;
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        ConnectionFactory connectionFactory = createConnectionFactory(serviceContainer);
+        try (Connection connection = connectionFactory.newConnection("rabbitmq-sink-tester");
+             Channel channel = connection.createChannel()) {
+            BlockingQueue<Record> records = new LinkedBlockingQueue<>();
+            channel.queueDeclare(queueName, true, false, false, null);
+            channel.basicConsume(queueName, new DefaultConsumer(channel) {
+                @Override
+                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,
+                                           byte[] body) throws IOException {
+                    records.add(new Record(envelope.getRoutingKey(), body));
+                    channel.basicAck(envelope.getDeliveryTag(), false);
+                }
+            });
+            // keys are discards when  into rabbitMQ
+            for (String value : kvs.values()) {
+                try {
+                    Record record = records.take();
+                    assertEquals(record.key, keyName);
+                    assertEquals(new String(record.body), value);
+                } catch (InterruptedException e) {
+                    break;
+                }
+            }
+        } catch (TimeoutException | IOException e) {
+            fail("RabbitMQ Sink test failed", e);
+        }
+    }
+
+    @Data
+    private static class Record {
+        private final String key;
+        private final byte[] body;
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSourceTester.java
index b616c8958d..97483ef793 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/RabbitMQSourceTester.java
@@ -1,95 +1,95 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import static org.apache.pulsar.tests.integration.io.RabbitMQSinkTester.createConnectionFactory;
-import com.rabbitmq.client.BuiltinExchangeType;
-import com.rabbitmq.client.Channel;
-import com.rabbitmq.client.Connection;
-import com.rabbitmq.client.ConnectionFactory;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import org.apache.pulsar.tests.integration.containers.RabbitMQContainer;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-
-public class RabbitMQSourceTester extends SourceTester<RabbitMQContainer> {
-    private RabbitMQContainer serviceContainer;
-    private final String exchangeName = "test-src-exchange";
-    private final String queueName = "test-src-queue";
-
-    public RabbitMQSourceTester(String networkAlias) {
-        super("rabbitmq");
-
-        sourceConfig.put("connectionName", "test-source-connection");
-        sourceConfig.put("host", networkAlias);
-        sourceConfig.put("port", RabbitMQContainer.PORTS[0]);
-        sourceConfig.put("queueName", queueName);
-    }
-
-    @Override
-    public void setServiceContainer(RabbitMQContainer serviceContainer) {
-        this.serviceContainer = serviceContainer;
-    }
-
-    @Override
-    public void prepareSource() throws Exception {
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        // pass
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        // pass
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        // pass
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
-        ConnectionFactory connectionFactory = createConnectionFactory(serviceContainer);
-        try (Connection connection = connectionFactory.newConnection("rabbitmq-source-tester");
-             Channel channel = connection.createChannel()) {
-            // the queue declaration has to be aligned with that in RabbitMQSource
-            channel.queueDeclare(queueName, false, false, false, null);
-            // use topic mode exchange in order to publish messages with any keys
-            channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC);
-            channel.queueBind(queueName, exchangeName, "#");
-
-            Map<String, String> values = new LinkedHashMap<>();
-            for (int i = 0; i < numMessages; i++) {
-                String key = "rb-key-" + i;
-                String value = "rb-value-" + i;
-                values.put(key, value);
-                channel.basicPublish(exchangeName, key, null, value.getBytes());
-            }
-            return values;
-        }
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import static org.apache.pulsar.tests.integration.io.RabbitMQSinkTester.createConnectionFactory;
+import com.rabbitmq.client.BuiltinExchangeType;
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.Connection;
+import com.rabbitmq.client.ConnectionFactory;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.apache.pulsar.tests.integration.containers.RabbitMQContainer;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+
+public class RabbitMQSourceTester extends SourceTester<RabbitMQContainer> {
+    private RabbitMQContainer serviceContainer;
+    private final String exchangeName = "test-src-exchange";
+    private final String queueName = "test-src-queue";
+
+    public RabbitMQSourceTester(String networkAlias) {
+        super("rabbitmq");
+
+        sourceConfig.put("connectionName", "test-source-connection");
+        sourceConfig.put("host", networkAlias);
+        sourceConfig.put("port", RabbitMQContainer.PORTS[0]);
+        sourceConfig.put("queueName", queueName);
+    }
+
+    @Override
+    public void setServiceContainer(RabbitMQContainer serviceContainer) {
+        this.serviceContainer = serviceContainer;
+    }
+
+    @Override
+    public void prepareSource() throws Exception {
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        // pass
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        // pass
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        // pass
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
+        ConnectionFactory connectionFactory = createConnectionFactory(serviceContainer);
+        try (Connection connection = connectionFactory.newConnection("rabbitmq-source-tester");
+             Channel channel = connection.createChannel()) {
+            // the queue declaration has to be aligned with that in RabbitMQSource
+            channel.queueDeclare(queueName, false, false, false, null);
+            // use topic mode exchange in order to publish messages with any keys
+            channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC);
+            channel.queueBind(queueName, exchangeName, "#");
+
+            Map<String, String> values = new LinkedHashMap<>();
+            for (int i = 0; i < numMessages; i++) {
+                String key = "rb-key-" + i;
+                String value = "rb-value-" + i;
+                values.put(key, value);
+                channel.basicPublish(exchangeName, key, null, value.getBytes());
+            }
+            return values;
+        }
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/SinkWithTransformFunctionTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/SinkWithTransformFunctionTest.java
index bed80a850d..8e14eab0eb 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/SinkWithTransformFunctionTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/SinkWithTransformFunctionTest.java
@@ -1,370 +1,370 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io;
-
-import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.functions.api.examples.pojo.Users;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testcontainers.containers.Network;
-import org.testng.annotations.Test;
-
-/**
- * Test behaviour of sinks with a transform function.
- */
-@Slf4j
-public class SinkWithTransformFunctionTest extends PulsarStandaloneTestSuite {
-
-    //Use PIP-117 new defaults so that the package management service is enabled.
-    @Override
-    public void setUpCluster() throws Exception {
-        incrementSetupNumber();
-        network = Network.newNetwork();
-        String clusterName = PulsarClusterTestBase.randomName(8);
-        container = new StandaloneContainer(clusterName, PulsarContainer.DEFAULT_IMAGE_NAME)
-                .withNetwork(network)
-                .withNetworkAliases(StandaloneContainer.NAME + "-" + clusterName)
-                .withEnv("PF_stateStorageServiceUrl", "bk://localhost:4181");
-        container.start();
-        log.info("Pulsar cluster {} is up running:", clusterName);
-        log.info("\tBinary Service Url : {}", container.getPlainTextServiceUrl());
-        log.info("\tHttp Service Url : {}", container.getHttpServiceUrl());
-
-        // add cluster to public tenant
-        ContainerExecResult result = container.execCmd(
-                "/pulsar/bin/pulsar-admin", "namespaces", "policies", "public/default");
-        assertEquals(0, result.getExitCode());
-        log.info("public/default namespace policies are {}", result.getStdout());
-    }
-
-    @Test(groups = {"sink"})
-    public void testSinkWithTransformFunction() throws Exception {
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(container.getPlainTextServiceUrl())
-                .build();
-
-        final int numRecords = 10;
-
-        String sinkName = "sink-with-function";
-        String topicName = "sink-with-function";
-        String logTopicName = "log-sink-with-function";
-        String packageName = "function://public/default/sink-with-function-function@1.0";
-
-        submitPackage(packageName, "package-function", JAVAJAR);
-
-        submitSinkConnector(
-                sinkName,
-                topicName,
-                "org.apache.pulsar.tests.integration.io.TestLoggingSink",
-                JAVAJAR,
-                "{\"log-topic\": \"" + logTopicName + "\"}",
-                packageName,
-                "org.apache.pulsar.functions.api.examples.RecordFunction");
-
-        getSinkInfoSuccess(sinkName);
-        getSinkStatus(sinkName);
-
-        @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(topicName)
-                    .create();
-
-        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(logTopicName)
-                .subscriptionName("sub")
-                .subscribe();
-
-        for (int i = 0; i < numRecords; i++) {
-            producer.send(i + "-test");
-        }
-
-        try {
-            log.info("waiting for sink {}", sinkName);
-
-            for (int i = 0; i < numRecords; i++) {
-                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
-                assertNotNull(receive);
-                assertEquals(receive.getValue(), "STRING - " + i + "-test!");
-            }
-        } finally {
-            dumpFunctionLogs(sinkName);
-        }
-
-        deleteSink(sinkName);
-        getSinkInfoNotFound(sinkName);
-    }
-
-    @Test(groups = {"sink"})
-    public void testGenericObjectSinkWithTransformFunction() throws Exception {
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-            .serviceUrl(container.getPlainTextServiceUrl())
-            .build();
-
-        final int numRecords = 10;
-
-        String sinkName = "sink-with-genericobject-function";
-        String topicName = "sink-with-genericobject-function";
-        String logTopicName = "log-sink-with-genericobject-function";
-        String packageName = "function://public/default/sink-with-genericobject-function-function@1.0";
-
-        submitPackage(packageName, "package-function", JAVAJAR);
-
-        submitSinkConnector(
-            sinkName,
-            topicName,
-            "org.apache.pulsar.tests.integration.io.TestLoggingSink",
-            JAVAJAR,
-            "{\"log-topic\": \"" + logTopicName + "\"}",
-            packageName,
-            "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldRecordFunction");
-
-        getSinkInfoSuccess(sinkName);
-        getSinkStatus(sinkName);
-
-        try {
-            @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(logTopicName)
-                .subscriptionName("sub")
-                .subscribe();
-
-            @Cleanup Producer<Users.UserV1> producer1 = client.newProducer(Schema.AVRO(Users.UserV1.class))
-                .topic(topicName)
-                .create();
-
-            for (int i = 0; i < numRecords; i++) {
-                producer1.send(new Users.UserV1("foo" + i, i));
-            }
-
-            for (int i = 0; i < numRecords; i++) {
-                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
-                assertNotNull(receive);
-                assertEquals(receive.getValue(), "AVRO - {\"name\": \"foo" + i + "\"}");
-            }
-
-            // Test with schema evolution
-            @Cleanup Producer<Users.UserV2> producer2 = client.newProducer(Schema.AVRO(Users.UserV2.class))
-                .topic(topicName)
-                .create();
-
-            for (int i = 0; i < numRecords; i++) {
-                producer2.send(new Users.UserV2("foo" + i, i, "bar" + i));
-            }
-
-            for (int i = 0; i < numRecords; i++) {
-                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
-                assertNotNull(receive);
-                assertEquals(receive.getValue(), "AVRO - {\"name\": \"foo" + i + "\", \"phone\": \"bar" + i + "\"}");
-            }
-
-            for (int i = 0; i < numRecords; i++) {
-                producer1.send(new Users.UserV1("foo" + i, i));
-            }
-
-            for (int i = 0; i < numRecords; i++) {
-                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
-                assertNotNull(receive);
-                assertEquals(receive.getValue(), "AVRO - {\"name\": \"foo" + i + "\"}");
-            }
-        } finally {
-            dumpFunctionLogs(sinkName);
-        }
-
-        deleteSink(sinkName);
-        getSinkInfoNotFound(sinkName);
-    }
-
-    @Test(groups = {"sink"})
-    public void testKeyValueSinkWithTransformFunction() throws Exception {
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-            .serviceUrl(container.getPlainTextServiceUrl())
-            .build();
-
-        final int numRecords = 10;
-
-        String sinkName = "sink-with-kv-function";
-        String topicName = "sink-with-kv-function";
-        String logTopicName = "log-sink-with-kv-function";
-        String packageName = "function://public/default/sink-with-kv-function-function@1.0";
-
-        submitPackage(packageName, "package-function", JAVAJAR);
-
-        submitSinkConnector(
-            sinkName,
-            topicName,
-            "org.apache.pulsar.tests.integration.io.TestLoggingSink",
-            JAVAJAR,
-            "{\"log-topic\": \"" + logTopicName + "\"}",
-            packageName,
-            "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldRecordFunction");
-
-        getSinkInfoSuccess(sinkName);
-        getSinkStatus(sinkName);
-
-        try {
-            @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(logTopicName)
-                .subscriptionName("sub")
-                .subscribe();
-
-            @Cleanup Producer<KeyValue<Users.UserV1, Users.UserV1>> producer = client
-                .newProducer(Schema.KeyValue(
-                    Schema.AVRO(Users.UserV1.class),
-                    Schema.AVRO(Users.UserV1.class), KeyValueEncodingType.SEPARATED))
-                .topic(topicName)
-                .create();
-
-            for (int i = 0; i < numRecords; i++) {
-                producer.send(new KeyValue<>(new Users.UserV1("foo" + i, i),
-                    new Users.UserV1("bar" + i, i + 100)));
-            }
-
-            for (int i = 0; i < numRecords; i++) {
-                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
-                assertNotNull(receive);
-                assertEquals(receive.getValue(), "KEY_VALUE - (key = {\"age\": " + i
-                    + ", \"name\": \"foo" + i + "\"}, value = "
-                    + "{\"name\": \"bar" + i + "\"})");
-            }
-        } finally {
-            dumpFunctionLogs(sinkName);
-        }
-
-        deleteSink(sinkName);
-        getSinkInfoNotFound(sinkName);
-    }
-
-
-    private void submitPackage(String packageName, String description, String packagePath) throws Exception {
-        String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "packages", "upload",
-                packageName,
-                "--description", description,
-                "--path", packagePath
-
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("successfully"),
-                result.getStdout());
-    }
-
-    private void submitSinkConnector(String sinkName,
-                                     String inputTopicName,
-                                     String className,
-                                     String archive,
-                                     String configs,
-                                     String transformFunction,
-                                     String transformFunctionClassName) throws Exception {
-        String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks", "create",
-                "--name", sinkName,
-                "-i", inputTopicName,
-                "--archive", archive,
-                "--classname", className,
-                "--sink-config", configs,
-                "--transform-function", transformFunction,
-                "--transform-function-classname", transformFunctionClassName
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    private void getSinkInfoSuccess(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sinkName + "\""));
-    }
-
-    private void getSinkStatus(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        log.info(result.getStdout());
-        log.info(result.getStderr());
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private void deleteSink(String sinkName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sinks",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sinkName
-        );
-        assertTrue(result.getStdout().contains("successfully"));
-        result.assertNoStderr();
-    }
-
-    private void getSinkInfoNotFound(String sinkName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sinks",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", sinkName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains(sinkName + " doesn't exist"));
-        }
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io;
+
+import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.functions.api.examples.pojo.Users;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testcontainers.containers.Network;
+import org.testng.annotations.Test;
+
+/**
+ * Test behaviour of sinks with a transform function.
+ */
+@Slf4j
+public class SinkWithTransformFunctionTest extends PulsarStandaloneTestSuite {
+
+    //Use PIP-117 new defaults so that the package management service is enabled.
+    @Override
+    public void setUpCluster() throws Exception {
+        incrementSetupNumber();
+        network = Network.newNetwork();
+        String clusterName = PulsarClusterTestBase.randomName(8);
+        container = new StandaloneContainer(clusterName, PulsarContainer.DEFAULT_IMAGE_NAME)
+                .withNetwork(network)
+                .withNetworkAliases(StandaloneContainer.NAME + "-" + clusterName)
+                .withEnv("PF_stateStorageServiceUrl", "bk://localhost:4181");
+        container.start();
+        log.info("Pulsar cluster {} is up running:", clusterName);
+        log.info("\tBinary Service Url : {}", container.getPlainTextServiceUrl());
+        log.info("\tHttp Service Url : {}", container.getHttpServiceUrl());
+
+        // add cluster to public tenant
+        ContainerExecResult result = container.execCmd(
+                "/pulsar/bin/pulsar-admin", "namespaces", "policies", "public/default");
+        assertEquals(0, result.getExitCode());
+        log.info("public/default namespace policies are {}", result.getStdout());
+    }
+
+    @Test(groups = {"sink"})
+    public void testSinkWithTransformFunction() throws Exception {
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(container.getPlainTextServiceUrl())
+                .build();
+
+        final int numRecords = 10;
+
+        String sinkName = "sink-with-function";
+        String topicName = "sink-with-function";
+        String logTopicName = "log-sink-with-function";
+        String packageName = "function://public/default/sink-with-function-function@1.0";
+
+        submitPackage(packageName, "package-function", JAVAJAR);
+
+        submitSinkConnector(
+                sinkName,
+                topicName,
+                "org.apache.pulsar.tests.integration.io.TestLoggingSink",
+                JAVAJAR,
+                "{\"log-topic\": \"" + logTopicName + "\"}",
+                packageName,
+                "org.apache.pulsar.functions.api.examples.RecordFunction");
+
+        getSinkInfoSuccess(sinkName);
+        getSinkStatus(sinkName);
+
+        @Cleanup Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(topicName)
+                    .create();
+
+        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(logTopicName)
+                .subscriptionName("sub")
+                .subscribe();
+
+        for (int i = 0; i < numRecords; i++) {
+            producer.send(i + "-test");
+        }
+
+        try {
+            log.info("waiting for sink {}", sinkName);
+
+            for (int i = 0; i < numRecords; i++) {
+                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
+                assertNotNull(receive);
+                assertEquals(receive.getValue(), "STRING - " + i + "-test!");
+            }
+        } finally {
+            dumpFunctionLogs(sinkName);
+        }
+
+        deleteSink(sinkName);
+        getSinkInfoNotFound(sinkName);
+    }
+
+    @Test(groups = {"sink"})
+    public void testGenericObjectSinkWithTransformFunction() throws Exception {
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+            .serviceUrl(container.getPlainTextServiceUrl())
+            .build();
+
+        final int numRecords = 10;
+
+        String sinkName = "sink-with-genericobject-function";
+        String topicName = "sink-with-genericobject-function";
+        String logTopicName = "log-sink-with-genericobject-function";
+        String packageName = "function://public/default/sink-with-genericobject-function-function@1.0";
+
+        submitPackage(packageName, "package-function", JAVAJAR);
+
+        submitSinkConnector(
+            sinkName,
+            topicName,
+            "org.apache.pulsar.tests.integration.io.TestLoggingSink",
+            JAVAJAR,
+            "{\"log-topic\": \"" + logTopicName + "\"}",
+            packageName,
+            "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldRecordFunction");
+
+        getSinkInfoSuccess(sinkName);
+        getSinkStatus(sinkName);
+
+        try {
+            @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(logTopicName)
+                .subscriptionName("sub")
+                .subscribe();
+
+            @Cleanup Producer<Users.UserV1> producer1 = client.newProducer(Schema.AVRO(Users.UserV1.class))
+                .topic(topicName)
+                .create();
+
+            for (int i = 0; i < numRecords; i++) {
+                producer1.send(new Users.UserV1("foo" + i, i));
+            }
+
+            for (int i = 0; i < numRecords; i++) {
+                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
+                assertNotNull(receive);
+                assertEquals(receive.getValue(), "AVRO - {\"name\": \"foo" + i + "\"}");
+            }
+
+            // Test with schema evolution
+            @Cleanup Producer<Users.UserV2> producer2 = client.newProducer(Schema.AVRO(Users.UserV2.class))
+                .topic(topicName)
+                .create();
+
+            for (int i = 0; i < numRecords; i++) {
+                producer2.send(new Users.UserV2("foo" + i, i, "bar" + i));
+            }
+
+            for (int i = 0; i < numRecords; i++) {
+                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
+                assertNotNull(receive);
+                assertEquals(receive.getValue(), "AVRO - {\"name\": \"foo" + i + "\", \"phone\": \"bar" + i + "\"}");
+            }
+
+            for (int i = 0; i < numRecords; i++) {
+                producer1.send(new Users.UserV1("foo" + i, i));
+            }
+
+            for (int i = 0; i < numRecords; i++) {
+                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
+                assertNotNull(receive);
+                assertEquals(receive.getValue(), "AVRO - {\"name\": \"foo" + i + "\"}");
+            }
+        } finally {
+            dumpFunctionLogs(sinkName);
+        }
+
+        deleteSink(sinkName);
+        getSinkInfoNotFound(sinkName);
+    }
+
+    @Test(groups = {"sink"})
+    public void testKeyValueSinkWithTransformFunction() throws Exception {
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+            .serviceUrl(container.getPlainTextServiceUrl())
+            .build();
+
+        final int numRecords = 10;
+
+        String sinkName = "sink-with-kv-function";
+        String topicName = "sink-with-kv-function";
+        String logTopicName = "log-sink-with-kv-function";
+        String packageName = "function://public/default/sink-with-kv-function-function@1.0";
+
+        submitPackage(packageName, "package-function", JAVAJAR);
+
+        submitSinkConnector(
+            sinkName,
+            topicName,
+            "org.apache.pulsar.tests.integration.io.TestLoggingSink",
+            JAVAJAR,
+            "{\"log-topic\": \"" + logTopicName + "\"}",
+            packageName,
+            "org.apache.pulsar.tests.integration.functions.RemoveAvroFieldRecordFunction");
+
+        getSinkInfoSuccess(sinkName);
+        getSinkStatus(sinkName);
+
+        try {
+            @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(logTopicName)
+                .subscriptionName("sub")
+                .subscribe();
+
+            @Cleanup Producer<KeyValue<Users.UserV1, Users.UserV1>> producer = client
+                .newProducer(Schema.KeyValue(
+                    Schema.AVRO(Users.UserV1.class),
+                    Schema.AVRO(Users.UserV1.class), KeyValueEncodingType.SEPARATED))
+                .topic(topicName)
+                .create();
+
+            for (int i = 0; i < numRecords; i++) {
+                producer.send(new KeyValue<>(new Users.UserV1("foo" + i, i),
+                    new Users.UserV1("bar" + i, i + 100)));
+            }
+
+            for (int i = 0; i < numRecords; i++) {
+                Message<String> receive = consumer.receive(5, TimeUnit.SECONDS);
+                assertNotNull(receive);
+                assertEquals(receive.getValue(), "KEY_VALUE - (key = {\"age\": " + i
+                    + ", \"name\": \"foo" + i + "\"}, value = "
+                    + "{\"name\": \"bar" + i + "\"})");
+            }
+        } finally {
+            dumpFunctionLogs(sinkName);
+        }
+
+        deleteSink(sinkName);
+        getSinkInfoNotFound(sinkName);
+    }
+
+
+    private void submitPackage(String packageName, String description, String packagePath) throws Exception {
+        String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "packages", "upload",
+                packageName,
+                "--description", description,
+                "--path", packagePath
+
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("successfully"),
+                result.getStdout());
+    }
+
+    private void submitSinkConnector(String sinkName,
+                                     String inputTopicName,
+                                     String className,
+                                     String archive,
+                                     String configs,
+                                     String transformFunction,
+                                     String transformFunctionClassName) throws Exception {
+        String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks", "create",
+                "--name", sinkName,
+                "-i", inputTopicName,
+                "--archive", archive,
+                "--classname", className,
+                "--sink-config", configs,
+                "--transform-function", transformFunction,
+                "--transform-function-classname", transformFunctionClassName
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    private void getSinkInfoSuccess(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sinkName + "\""));
+    }
+
+    private void getSinkStatus(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        log.info(result.getStdout());
+        log.info(result.getStderr());
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private void deleteSink(String sinkName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sinks",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sinkName
+        );
+        assertTrue(result.getStdout().contains("successfully"));
+        result.assertNoStderr();
+    }
+
+    private void getSinkInfoNotFound(String sinkName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sinks",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", sinkName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains(sinkName + " doesn't exist"));
+        }
+    }
+}
+
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/CassandraSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/CassandraSinkTester.java
index e7fb69f85f..3ff6af433d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/CassandraSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/CassandraSinkTester.java
@@ -1,150 +1,150 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase.randomName;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import com.datastax.driver.core.Cluster;
-import com.datastax.driver.core.ResultSet;
-import com.datastax.driver.core.Row;
-import com.datastax.driver.core.Session;
-import java.util.List;
-import java.util.Map;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.PulsarVersion;
-import org.apache.pulsar.tests.integration.containers.CassandraContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-/**
- * A tester for testing cassandra sink.
- */
-@Slf4j
-public class CassandraSinkTester extends SinkTester<CassandraContainer> {
-
-    public static CassandraSinkTester createTester(boolean builtin) {
-        if (builtin) {
-            return new CassandraSinkTester(builtin);
-        } else {
-            return new CassandraSinkTester();
-        }
-    }
-
-    private static final String NAME = "cassandra";
-
-    private static final String ROOTS = "cassandra";
-    private static final String KEY = "key";
-    private static final String COLUMN = "col";
-    private static final String ARCHIVE = "/pulsar/connectors/pulsar-io-cassandra-"
-            + PulsarVersion.getVersion() + ".nar";
-
-    private final String keySpace;
-    private final String tableName;
-
-    private Cluster cluster;
-    private Session session;
-
-    private CassandraSinkTester() {
-        super(NAME, ARCHIVE, "org.apache.pulsar.io.cassandra.CassandraStringSink");
-
-        String suffix = randomName(8) + "_" + System.currentTimeMillis();
-        this.keySpace = "keySpace_" + suffix;
-        this.tableName = "tableName_" + suffix;
-
-        sinkConfig.put("roots", ROOTS);
-        sinkConfig.put("keyspace", keySpace);
-        sinkConfig.put("columnFamily", tableName);
-        sinkConfig.put("keyname", KEY);
-        sinkConfig.put("columnName", COLUMN);
-    }
-
-    private CassandraSinkTester(boolean builtin) {
-        super(NAME, SinkType.CASSANDRA);
-
-        String suffix = randomName(8) + "_" + System.currentTimeMillis();
-        this.keySpace = "keySpace_" + suffix;
-        this.tableName = "tableName_" + suffix;
-
-        sinkConfig.put("roots", ROOTS);
-        sinkConfig.put("keyspace", keySpace);
-        sinkConfig.put("columnFamily", tableName);
-        sinkConfig.put("keyname", KEY);
-        sinkConfig.put("columnName", COLUMN);
-    }
-
-    @Override
-    protected CassandraContainer createSinkService(PulsarCluster cluster) {
-        return new CassandraContainer(cluster.getClusterName());
-    }
-
-    @Override
-    public void prepareSink() {
-        // build the sink
-        cluster = Cluster.builder()
-                .addContactPoint("localhost")
-                .withPort(serviceContainer.getCassandraPort())
-                .withoutJMXReporting()
-                .build();
-
-        // connect to the cluster
-        session = cluster.connect();
-        log.info("Connecting to cassandra cluster at localhost:{}", serviceContainer.getCassandraPort());
-
-        String createKeySpace =
-                "CREATE KEYSPACE " + keySpace
-                        + " WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}; ";
-        log.info(createKeySpace);
-        session.execute(createKeySpace);
-        session.execute("USE " + keySpace);
-
-        String createTable = "CREATE TABLE " + tableName
-                + "(" + KEY + " text PRIMARY KEY, "
-                + COLUMN + " text);";
-        log.info(createTable);
-        session.execute(createTable);
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        String query = "SELECT * FROM " + tableName + ";";
-        ResultSet result = session.execute(query);
-        List<Row> rows = result.all();
-        assertEquals(kvs.size(), rows.size());
-        for (Row row : rows) {
-            String key = row.getString(KEY);
-            String value = row.getString(COLUMN);
-
-            String expectedValue = kvs.get(key);
-            assertNotNull(expectedValue);
-            assertEquals(expectedValue, value);
-        }
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (session != null) {
-            session.close();
-            session = null;
-        }
-        if (cluster != null) {
-            cluster.close();
-            cluster = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase.randomName;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import com.datastax.driver.core.Cluster;
+import com.datastax.driver.core.ResultSet;
+import com.datastax.driver.core.Row;
+import com.datastax.driver.core.Session;
+import java.util.List;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.PulsarVersion;
+import org.apache.pulsar.tests.integration.containers.CassandraContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+/**
+ * A tester for testing cassandra sink.
+ */
+@Slf4j
+public class CassandraSinkTester extends SinkTester<CassandraContainer> {
+
+    public static CassandraSinkTester createTester(boolean builtin) {
+        if (builtin) {
+            return new CassandraSinkTester(builtin);
+        } else {
+            return new CassandraSinkTester();
+        }
+    }
+
+    private static final String NAME = "cassandra";
+
+    private static final String ROOTS = "cassandra";
+    private static final String KEY = "key";
+    private static final String COLUMN = "col";
+    private static final String ARCHIVE = "/pulsar/connectors/pulsar-io-cassandra-"
+            + PulsarVersion.getVersion() + ".nar";
+
+    private final String keySpace;
+    private final String tableName;
+
+    private Cluster cluster;
+    private Session session;
+
+    private CassandraSinkTester() {
+        super(NAME, ARCHIVE, "org.apache.pulsar.io.cassandra.CassandraStringSink");
+
+        String suffix = randomName(8) + "_" + System.currentTimeMillis();
+        this.keySpace = "keySpace_" + suffix;
+        this.tableName = "tableName_" + suffix;
+
+        sinkConfig.put("roots", ROOTS);
+        sinkConfig.put("keyspace", keySpace);
+        sinkConfig.put("columnFamily", tableName);
+        sinkConfig.put("keyname", KEY);
+        sinkConfig.put("columnName", COLUMN);
+    }
+
+    private CassandraSinkTester(boolean builtin) {
+        super(NAME, SinkType.CASSANDRA);
+
+        String suffix = randomName(8) + "_" + System.currentTimeMillis();
+        this.keySpace = "keySpace_" + suffix;
+        this.tableName = "tableName_" + suffix;
+
+        sinkConfig.put("roots", ROOTS);
+        sinkConfig.put("keyspace", keySpace);
+        sinkConfig.put("columnFamily", tableName);
+        sinkConfig.put("keyname", KEY);
+        sinkConfig.put("columnName", COLUMN);
+    }
+
+    @Override
+    protected CassandraContainer createSinkService(PulsarCluster cluster) {
+        return new CassandraContainer(cluster.getClusterName());
+    }
+
+    @Override
+    public void prepareSink() {
+        // build the sink
+        cluster = Cluster.builder()
+                .addContactPoint("localhost")
+                .withPort(serviceContainer.getCassandraPort())
+                .withoutJMXReporting()
+                .build();
+
+        // connect to the cluster
+        session = cluster.connect();
+        log.info("Connecting to cassandra cluster at localhost:{}", serviceContainer.getCassandraPort());
+
+        String createKeySpace =
+                "CREATE KEYSPACE " + keySpace
+                        + " WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}; ";
+        log.info(createKeySpace);
+        session.execute(createKeySpace);
+        session.execute("USE " + keySpace);
+
+        String createTable = "CREATE TABLE " + tableName
+                + "(" + KEY + " text PRIMARY KEY, "
+                + COLUMN + " text);";
+        log.info(createTable);
+        session.execute(createTable);
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        String query = "SELECT * FROM " + tableName + ";";
+        ResultSet result = session.execute(query);
+        List<Row> rows = result.all();
+        assertEquals(kvs.size(), rows.size());
+        for (Row row : rows) {
+            String key = row.getString(KEY);
+            String value = row.getString(COLUMN);
+
+            String expectedValue = kvs.get(key);
+            assertNotNull(expectedValue);
+            assertEquals(expectedValue, value);
+        }
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (session != null) {
+            session.close();
+            session = null;
+        }
+        if (cluster != null) {
+            cluster.close();
+            cluster = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch7SinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch7SinkTester.java
index d99fcad252..1d17c23296 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch7SinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch7SinkTester.java
@@ -1,41 +1,41 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import java.util.Optional;
-import org.testcontainers.elasticsearch.ElasticsearchContainer;
-
-public class ElasticSearch7SinkTester extends ElasticSearchSinkTester {
-
-    public static final String ELASTICSEARCH_7 = Optional.ofNullable(System.getenv("ELASTICSEARCH_IMAGE_V7"))
-            .orElse("docker.elastic.co/elasticsearch/elasticsearch:7.17.7");
-
-
-    public ElasticSearch7SinkTester(boolean schemaEnable) {
-        super(schemaEnable);
-    }
-
-
-    @Override
-    protected ElasticsearchContainer createElasticContainer() {
-        return new ElasticsearchContainer(ELASTICSEARCH_7)
-                .withEnv("ES_JAVA_OPTS", "-Xms128m -Xmx256m");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import java.util.Optional;
+import org.testcontainers.elasticsearch.ElasticsearchContainer;
+
+public class ElasticSearch7SinkTester extends ElasticSearchSinkTester {
+
+    public static final String ELASTICSEARCH_7 = Optional.ofNullable(System.getenv("ELASTICSEARCH_IMAGE_V7"))
+            .orElse("docker.elastic.co/elasticsearch/elasticsearch:7.17.7");
+
+
+    public ElasticSearch7SinkTester(boolean schemaEnable) {
+        super(schemaEnable);
+    }
+
+
+    @Override
+    protected ElasticsearchContainer createElasticContainer() {
+        return new ElasticsearchContainer(ELASTICSEARCH_7)
+                .withEnv("ES_JAVA_OPTS", "-Xms128m -Xmx256m");
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch8SinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch8SinkTester.java
index 8e7617a82a..e055c4fd57 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch8SinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearch8SinkTester.java
@@ -1,42 +1,42 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import java.util.Optional;
-import org.testcontainers.elasticsearch.ElasticsearchContainer;
-
-public class ElasticSearch8SinkTester extends ElasticSearchSinkTester {
-
-    public static final String ELASTICSEARCH_8 = Optional.ofNullable(System.getenv("ELASTICSEARCH_IMAGE_V8"))
-            .orElse("docker.elastic.co/elasticsearch/elasticsearch:8.5.3");
-
-
-    public ElasticSearch8SinkTester(boolean schemaEnable) {
-        super(schemaEnable);
-    }
-
-    @Override
-    protected ElasticsearchContainer createElasticContainer() {
-        return new ElasticsearchContainer(ELASTICSEARCH_8)
-                .withEnv("ES_JAVA_OPTS", "-Xms128m -Xmx256m")
-                .withEnv("xpack.security.enabled", "false")
-                .withEnv("xpack.security.http.ssl.enabled", "false");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import java.util.Optional;
+import org.testcontainers.elasticsearch.ElasticsearchContainer;
+
+public class ElasticSearch8SinkTester extends ElasticSearchSinkTester {
+
+    public static final String ELASTICSEARCH_8 = Optional.ofNullable(System.getenv("ELASTICSEARCH_IMAGE_V8"))
+            .orElse("docker.elastic.co/elasticsearch/elasticsearch:8.5.3");
+
+
+    public ElasticSearch8SinkTester(boolean schemaEnable) {
+        super(schemaEnable);
+    }
+
+    @Override
+    protected ElasticsearchContainer createElasticContainer() {
+        return new ElasticsearchContainer(ELASTICSEARCH_8)
+                .withEnv("ES_JAVA_OPTS", "-Xms128m -Xmx256m")
+                .withEnv("xpack.security.enabled", "false")
+                .withEnv("xpack.security.http.ssl.enabled", "false");
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearchSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearchSinkTester.java
index 8b43621e92..8703c34c9b 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearchSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ElasticSearchSinkTester.java
@@ -1,208 +1,208 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.testng.Assert.assertTrue;
-import co.elastic.clients.elasticsearch.ElasticsearchClient;
-import co.elastic.clients.elasticsearch.core.SearchRequest;
-import co.elastic.clients.elasticsearch.core.SearchResponse;
-import co.elastic.clients.json.jackson.JacksonJsonpMapper;
-import co.elastic.clients.transport.ElasticsearchTransport;
-import co.elastic.clients.transport.rest_client.RestClientTransport;
-import com.google.common.collect.ImmutableMap;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import lombok.AllArgsConstructor;
-import lombok.Cleanup;
-import lombok.Data;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.http.HttpHost;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.awaitility.Awaitility;
-import org.elasticsearch.client.RestClient;
-import org.elasticsearch.client.RestClientBuilder;
-import org.testcontainers.elasticsearch.ElasticsearchContainer;
-
-@Slf4j
-public abstract class ElasticSearchSinkTester extends SinkTester<ElasticsearchContainer> {
-
-    private static final String NAME = "elastic-search";
-
-    private ElasticsearchClient elasticClient;
-    private boolean schemaEnable;
-    private final Schema<KeyValue<SimplePojo, SimplePojo>> kvSchema;
-
-    @Data
-    @AllArgsConstructor
-    public static final class SimplePojo {
-        private String field1;
-        private String field2;
-        private List<Integer> list1;
-        private Set<Long> set1;
-        private Map<String, String> map1;
-    }
-
-    /**
-     * This method is used to pre create the subscription for the Sink.
-     * @return the schema for the subscription
-     */
-    public Schema<?> getInputTopicSchema() {
-        if (schemaEnable) {
-            // we do not want to enforce a Schema
-            // at the beginning of the test
-            return Schema.AUTO_CONSUME();
-        } else {
-            return Schema.STRING;
-        }
-    }
-
-    public ElasticSearchSinkTester(boolean schemaEnable) {
-        super(NAME, SinkType.ELASTIC_SEARCH);
-
-        sinkConfig.put("elasticSearchUrl", "http://" + NAME + ":9200");
-        sinkConfig.put("indexName", "test-index");
-        this.schemaEnable = schemaEnable;
-        if (schemaEnable) {
-            sinkConfig.put("schemaEnable", "true");
-            kvSchema = Schema.KeyValue(Schema.JSON(SimplePojo.class),
-                    Schema.AVRO(SimplePojo.class), KeyValueEncodingType.SEPARATED);
-        } else {
-            // default behaviour, it must be enabled the default, in order to preserve compatibility with Pulsar 2.8.x
-            kvSchema = null;
-        }
-    }
-
-    @Override
-    protected final ElasticsearchContainer createSinkService(PulsarCluster cluster) {
-        ElasticsearchContainer elasticContainer = createElasticContainer();
-        configureElasticContainer(elasticContainer);
-        return elasticContainer;
-    }
-
-    protected void configureElasticContainer(ElasticsearchContainer elasticContainer) {
-        if (!isOpenSearch()) {
-            elasticContainer.withEnv("ingest.geoip.downloader.enabled", "false");
-        }
-
-        // allow disk to fill up beyond default 90% threshold
-        elasticContainer.withEnv("cluster.routing.allocation.disk.threshold_enabled", "false");
-
-        elasticContainer.withLogConsumer(o -> log.info("elastic> {}", o.getUtf8String()));
-    }
-
-    protected boolean isOpenSearch() {
-        return false;
-    }
-
-    protected abstract ElasticsearchContainer createElasticContainer();
-
-    @Override
-    public void prepareSink() throws Exception {
-        RestClientBuilder builder = RestClient.builder(
-            new HttpHost(
-                "localhost",
-                serviceContainer.getMappedPort(9200),
-                "http"));
-        ElasticsearchTransport transport = new RestClientTransport(builder.build(),
-                new JacksonJsonpMapper());
-        elasticClient = new ElasticsearchClient(transport);
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        Awaitility.await().untilAsserted(() -> {
-            SearchResponse<?> searchResult = elasticClient.search(new SearchRequest.Builder().index("test-index")
-                    .q("*:*")
-                    .build(), Map.class);
-            assertTrue(searchResult.hits().total().value() > 0, searchResult.toString());
-        });
-    }
-
-    @Override
-    public void produceMessage(int numMessages, PulsarClient client,
-                               String inputTopicName, LinkedHashMap<String, String> kvs) throws Exception {
-        if (schemaEnable) {
-
-            @Cleanup
-            Producer<KeyValue<SimplePojo, SimplePojo>> producer = client.newProducer(kvSchema)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                String key = "key-" + i;
-                kvs.put(key, key);
-                final SimplePojo keyPojo = new SimplePojo(
-                        "f1_" + i,
-                        "f2_" + i,
-                        Arrays.asList(i, i + 1),
-                        new HashSet<>(Arrays.asList((long) i)),
-                        ImmutableMap.of("map1_k_" + i, "map1_kv_" + i));
-                final SimplePojo valuePojo = new SimplePojo(
-                        "f1_" + i,
-                        "f2_" + i,
-                        Arrays.asList(i, i + 1),
-                        new HashSet<>(Arrays.asList((long) i)),
-                        ImmutableMap.of("map1_v_" + i, "map1_vv_" + i));
-                producer.newMessage()
-                        .value(new KeyValue<>(keyPojo, valuePojo))
-                        .send();
-            }
-
-        } else {
-
-            @Cleanup
-            Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                String key = "key-" + i;
-                // this is a JSON document, written to ElasticSearch
-                Map<String, String> valueMap = new HashMap<>();
-                valueMap.put("key" + i, "value" + i);
-                String value = ObjectMapperFactory.getMapper().getObjectMapper().writeValueAsString(valueMap);
-                kvs.put(key, value);
-                producer.newMessage()
-                        .key(key)
-                        .value(value)
-                        .send();
-            }
-
-        }
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (elasticClient != null) {
-            elasticClient._transport().close();
-            elasticClient = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.testng.Assert.assertTrue;
+import co.elastic.clients.elasticsearch.ElasticsearchClient;
+import co.elastic.clients.elasticsearch.core.SearchRequest;
+import co.elastic.clients.elasticsearch.core.SearchResponse;
+import co.elastic.clients.json.jackson.JacksonJsonpMapper;
+import co.elastic.clients.transport.ElasticsearchTransport;
+import co.elastic.clients.transport.rest_client.RestClientTransport;
+import com.google.common.collect.ImmutableMap;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import lombok.AllArgsConstructor;
+import lombok.Cleanup;
+import lombok.Data;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.http.HttpHost;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.awaitility.Awaitility;
+import org.elasticsearch.client.RestClient;
+import org.elasticsearch.client.RestClientBuilder;
+import org.testcontainers.elasticsearch.ElasticsearchContainer;
+
+@Slf4j
+public abstract class ElasticSearchSinkTester extends SinkTester<ElasticsearchContainer> {
+
+    private static final String NAME = "elastic-search";
+
+    private ElasticsearchClient elasticClient;
+    private boolean schemaEnable;
+    private final Schema<KeyValue<SimplePojo, SimplePojo>> kvSchema;
+
+    @Data
+    @AllArgsConstructor
+    public static final class SimplePojo {
+        private String field1;
+        private String field2;
+        private List<Integer> list1;
+        private Set<Long> set1;
+        private Map<String, String> map1;
+    }
+
+    /**
+     * This method is used to pre create the subscription for the Sink.
+     * @return the schema for the subscription
+     */
+    public Schema<?> getInputTopicSchema() {
+        if (schemaEnable) {
+            // we do not want to enforce a Schema
+            // at the beginning of the test
+            return Schema.AUTO_CONSUME();
+        } else {
+            return Schema.STRING;
+        }
+    }
+
+    public ElasticSearchSinkTester(boolean schemaEnable) {
+        super(NAME, SinkType.ELASTIC_SEARCH);
+
+        sinkConfig.put("elasticSearchUrl", "http://" + NAME + ":9200");
+        sinkConfig.put("indexName", "test-index");
+        this.schemaEnable = schemaEnable;
+        if (schemaEnable) {
+            sinkConfig.put("schemaEnable", "true");
+            kvSchema = Schema.KeyValue(Schema.JSON(SimplePojo.class),
+                    Schema.AVRO(SimplePojo.class), KeyValueEncodingType.SEPARATED);
+        } else {
+            // default behaviour, it must be enabled the default, in order to preserve compatibility with Pulsar 2.8.x
+            kvSchema = null;
+        }
+    }
+
+    @Override
+    protected final ElasticsearchContainer createSinkService(PulsarCluster cluster) {
+        ElasticsearchContainer elasticContainer = createElasticContainer();
+        configureElasticContainer(elasticContainer);
+        return elasticContainer;
+    }
+
+    protected void configureElasticContainer(ElasticsearchContainer elasticContainer) {
+        if (!isOpenSearch()) {
+            elasticContainer.withEnv("ingest.geoip.downloader.enabled", "false");
+        }
+
+        // allow disk to fill up beyond default 90% threshold
+        elasticContainer.withEnv("cluster.routing.allocation.disk.threshold_enabled", "false");
+
+        elasticContainer.withLogConsumer(o -> log.info("elastic> {}", o.getUtf8String()));
+    }
+
+    protected boolean isOpenSearch() {
+        return false;
+    }
+
+    protected abstract ElasticsearchContainer createElasticContainer();
+
+    @Override
+    public void prepareSink() throws Exception {
+        RestClientBuilder builder = RestClient.builder(
+            new HttpHost(
+                "localhost",
+                serviceContainer.getMappedPort(9200),
+                "http"));
+        ElasticsearchTransport transport = new RestClientTransport(builder.build(),
+                new JacksonJsonpMapper());
+        elasticClient = new ElasticsearchClient(transport);
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        Awaitility.await().untilAsserted(() -> {
+            SearchResponse<?> searchResult = elasticClient.search(new SearchRequest.Builder().index("test-index")
+                    .q("*:*")
+                    .build(), Map.class);
+            assertTrue(searchResult.hits().total().value() > 0, searchResult.toString());
+        });
+    }
+
+    @Override
+    public void produceMessage(int numMessages, PulsarClient client,
+                               String inputTopicName, LinkedHashMap<String, String> kvs) throws Exception {
+        if (schemaEnable) {
+
+            @Cleanup
+            Producer<KeyValue<SimplePojo, SimplePojo>> producer = client.newProducer(kvSchema)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                String key = "key-" + i;
+                kvs.put(key, key);
+                final SimplePojo keyPojo = new SimplePojo(
+                        "f1_" + i,
+                        "f2_" + i,
+                        Arrays.asList(i, i + 1),
+                        new HashSet<>(Arrays.asList((long) i)),
+                        ImmutableMap.of("map1_k_" + i, "map1_kv_" + i));
+                final SimplePojo valuePojo = new SimplePojo(
+                        "f1_" + i,
+                        "f2_" + i,
+                        Arrays.asList(i, i + 1),
+                        new HashSet<>(Arrays.asList((long) i)),
+                        ImmutableMap.of("map1_v_" + i, "map1_vv_" + i));
+                producer.newMessage()
+                        .value(new KeyValue<>(keyPojo, valuePojo))
+                        .send();
+            }
+
+        } else {
+
+            @Cleanup
+            Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                String key = "key-" + i;
+                // this is a JSON document, written to ElasticSearch
+                Map<String, String> valueMap = new HashMap<>();
+                valueMap.put("key" + i, "value" + i);
+                String value = ObjectMapperFactory.getMapper().getObjectMapper().writeValueAsString(valueMap);
+                kvs.put(key, value);
+                producer.newMessage()
+                        .key(key)
+                        .value(value)
+                        .send();
+            }
+
+        }
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (elasticClient != null) {
+            elasticClient._transport().close();
+            elasticClient = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/HdfsSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/HdfsSinkTester.java
index 4b172f9560..8b8127da9b 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/HdfsSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/HdfsSinkTester.java
@@ -1,62 +1,62 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import java.util.Map;
-import org.apache.pulsar.tests.integration.containers.HdfsContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-public class HdfsSinkTester extends SinkTester<HdfsContainer> {
-
-    private static final String NAME = "HDFS";
-
-    public HdfsSinkTester() {
-        super(NAME, SinkType.HDFS);
-
-        // TODO How do I get the core-site.xml, and hdfs-site.xml files from the container?
-        sinkConfig.put("hdfsConfigResources", "");
-        sinkConfig.put("directory", "/testing/test");
-    }
-
-    @Override
-    protected HdfsContainer createSinkService(PulsarCluster cluster) {
-        return new HdfsContainer(cluster.getClusterName());
-    }
-
-    @Override
-    public void prepareSink() throws Exception {
-        // Create the test directory
-        serviceContainer.execInContainer("/hadoop/bin/hdfs", "dfs", "-mkdir", "/tmp/testing");
-        serviceContainer.execInContainer("/hadoop/bin/hdfs", "-chown", "tester:testing", "/tmp/testing");
-
-        // Execute all future commands as the "tester" user
-        serviceContainer.execInContainer("export HADOOP_USER_NAME=tester");
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        // TODO Auto-generated method stub
-
-    }
-
-    @Override
-    public void close() throws Exception {
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import java.util.Map;
+import org.apache.pulsar.tests.integration.containers.HdfsContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+public class HdfsSinkTester extends SinkTester<HdfsContainer> {
+
+    private static final String NAME = "HDFS";
+
+    public HdfsSinkTester() {
+        super(NAME, SinkType.HDFS);
+
+        // TODO How do I get the core-site.xml, and hdfs-site.xml files from the container?
+        sinkConfig.put("hdfsConfigResources", "");
+        sinkConfig.put("directory", "/testing/test");
+    }
+
+    @Override
+    protected HdfsContainer createSinkService(PulsarCluster cluster) {
+        return new HdfsContainer(cluster.getClusterName());
+    }
+
+    @Override
+    public void prepareSink() throws Exception {
+        // Create the test directory
+        serviceContainer.execInContainer("/hadoop/bin/hdfs", "dfs", "-mkdir", "/tmp/testing");
+        serviceContainer.execInContainer("/hadoop/bin/hdfs", "-chown", "tester:testing", "/tmp/testing");
+
+        // Execute all future commands as the "tester" user
+        serviceContainer.execInContainer("export HADOOP_USER_NAME=tester");
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        // TODO Auto-generated method stub
+
+    }
+
+    @Override
+    public void close() throws Exception {
+
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/JdbcPostgresSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/JdbcPostgresSinkTester.java
index 4a7baf27ba..e1bdcece27 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/JdbcPostgresSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/JdbcPostgresSinkTester.java
@@ -1,201 +1,201 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.fail;
-import java.sql.Connection;
-import java.sql.DriverManager;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import lombok.AllArgsConstructor;
-import lombok.Cleanup;
-import lombok.Data;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.SchemaDefinition;
-import org.apache.pulsar.client.impl.schema.AvroSchema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testcontainers.containers.PostgreSQLContainer;
-
-/**
- * A tester for testing jdbc sink.
- * This will use Postgres as DB server
- */
-@Slf4j
-public class JdbcPostgresSinkTester extends SinkTester<PostgreSQLContainer> {
-
-    @Data
-    public static class Foo {
-        private String field1;
-        private String field2;
-        private int field3;
-    }
-
-    @Data
-    @AllArgsConstructor
-    public static class KVSchemaKey {
-        private int field3;
-    }
-
-    @Data
-    @AllArgsConstructor
-    public static class KVSchemaValue {
-        private String field1;
-        private String field2;
-    }
-
-    private static final String NAME = "jdbc-postgres";
-    private static final String POSTGRES = "postgres";
-
-    private final AvroSchema<Foo> schema = AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
-    private final String tableName = "test";
-    private Connection connection;
-    private boolean keyValueSchema;
-
-    public JdbcPostgresSinkTester(boolean keyValueSchema) {
-        super(NAME, SinkType.JDBC_POSTGRES);
-        this.keyValueSchema = keyValueSchema;
-
-        // container default value is test
-        sinkConfig.put("userName", "test");
-        sinkConfig.put("password", "test");
-        sinkConfig.put("nonKey", "field2,field3");
-        sinkConfig.put("key", "field1");
-        sinkConfig.put("tableName", tableName);
-        sinkConfig.put("batchSize", 1);
-    }
-
-    @Override
-    public Schema<?> getInputTopicSchema() {
-        if (keyValueSchema) {
-            return Schema.AUTO_CONSUME();
-        } else {
-            return schema;
-        }
-    }
-
-    @Override
-    protected PostgreSQLContainer createSinkService(PulsarCluster cluster) {
-        return (PostgreSQLContainer) new PostgreSQLContainer("postgres:14.3")
-            .withNetworkAliases(POSTGRES);
-    }
-
-    @Override
-    public void prepareSink() throws Exception {
-        String jdbcUrl = serviceContainer.getJdbcUrl();
-        // we need set postgres server address in cluster network.
-        sinkConfig.put("jdbcUrl", "jdbc:postgresql://" + POSTGRES + ":5432/test");
-        String driver = serviceContainer.getDriverClassName();
-        Class.forName(driver);
-
-        connection = DriverManager.getConnection(jdbcUrl, "test", "test");
-        log.info("getConnection: {}, jdbcurl: {}", connection, jdbcUrl);
-
-        // create table
-        String createTable = "CREATE TABLE " + tableName
-            + " (field1 TEXT, field2 TEXT, field3 INTEGER, PRIMARY KEY (field3))";
-        int ret = connection.createStatement().executeUpdate(createTable);
-        log.info("created table in jdbc: {}, return value: {}", createTable, ret);
-    }
-
-    @Override
-    public void produceMessage(int numMessages, PulsarClient client, String inputTopicName, LinkedHashMap<String,
-            String> kvs) throws Exception {
-        if (!keyValueSchema) {
-            super.produceMessage(numMessages, client, inputTopicName, kvs);
-            return;
-        }
-
-        @Cleanup
-        Producer<KeyValue<KVSchemaKey, KVSchemaValue>> producer =
-                client.newProducer(Schema.KeyValue(Schema.JSON(KVSchemaKey.class), Schema.AVRO(KVSchemaValue.class),
-                                KeyValueEncodingType.SEPARATED)).topic(inputTopicName).create();
-
-        for (int i = 0; i < numMessages; i++) {
-            String key = "key-" + i;
-            kvs.put(key, key);
-            producer.newMessage()
-                    .value(new KeyValue<>(new KVSchemaKey(i), new KVSchemaValue("f1_" + i, "f2_" + i)))
-                    .send();
-        }
-
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        log.info("Query table content from postgres server: {}", tableName);
-        String querySql = "SELECT * FROM " + tableName + " ORDER BY field3";
-        ResultSet rs;
-        try {
-            // backend flush may not complete.
-            Thread.sleep(1000);
-
-            PreparedStatement statement = connection.prepareStatement(querySql,
-                ResultSet.TYPE_SCROLL_INSENSITIVE,
-                ResultSet.CONCUR_UPDATABLE);
-            rs = statement.executeQuery();
-
-            if (!keyValueSchema && kvs.get("ACTION").equals("DELETE")) {
-                assertFalse(rs.first());
-                return;
-            }
-            int index = 0;
-            while (rs.next()) {
-                String field1 = rs.getString(1);
-                String field2 = rs.getString(2);
-                int field3 = rs.getInt(3);
-                if (keyValueSchema) {
-                    assertEquals(field1, "f1_" + index);
-                    assertEquals(field2, "f2_" + index);
-                    assertEquals(field3, index);
-                } else {
-                    String value = kvs.get("key-" + field3);
-                    Foo obj = schema.decode(value.getBytes());
-                    assertEquals(obj.field1, field1);
-                    assertEquals(obj.field2, field2);
-                    assertEquals(obj.field3, field3);
-                }
-                index++;
-            }
-        } catch (Exception e) {
-            log.error("Got exception: ", e);
-            fail("Got exception when op sql: " + e);
-        }
-    }
-
-    public boolean isKeyValueSchema() {
-        return keyValueSchema;
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (connection != null) {
-            connection.close();
-            connection = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.fail;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import lombok.AllArgsConstructor;
+import lombok.Cleanup;
+import lombok.Data;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.SchemaDefinition;
+import org.apache.pulsar.client.impl.schema.AvroSchema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testcontainers.containers.PostgreSQLContainer;
+
+/**
+ * A tester for testing jdbc sink.
+ * This will use Postgres as DB server
+ */
+@Slf4j
+public class JdbcPostgresSinkTester extends SinkTester<PostgreSQLContainer> {
+
+    @Data
+    public static class Foo {
+        private String field1;
+        private String field2;
+        private int field3;
+    }
+
+    @Data
+    @AllArgsConstructor
+    public static class KVSchemaKey {
+        private int field3;
+    }
+
+    @Data
+    @AllArgsConstructor
+    public static class KVSchemaValue {
+        private String field1;
+        private String field2;
+    }
+
+    private static final String NAME = "jdbc-postgres";
+    private static final String POSTGRES = "postgres";
+
+    private final AvroSchema<Foo> schema = AvroSchema.of(SchemaDefinition.<Foo>builder().withPojo(Foo.class).build());
+    private final String tableName = "test";
+    private Connection connection;
+    private boolean keyValueSchema;
+
+    public JdbcPostgresSinkTester(boolean keyValueSchema) {
+        super(NAME, SinkType.JDBC_POSTGRES);
+        this.keyValueSchema = keyValueSchema;
+
+        // container default value is test
+        sinkConfig.put("userName", "test");
+        sinkConfig.put("password", "test");
+        sinkConfig.put("nonKey", "field2,field3");
+        sinkConfig.put("key", "field1");
+        sinkConfig.put("tableName", tableName);
+        sinkConfig.put("batchSize", 1);
+    }
+
+    @Override
+    public Schema<?> getInputTopicSchema() {
+        if (keyValueSchema) {
+            return Schema.AUTO_CONSUME();
+        } else {
+            return schema;
+        }
+    }
+
+    @Override
+    protected PostgreSQLContainer createSinkService(PulsarCluster cluster) {
+        return (PostgreSQLContainer) new PostgreSQLContainer("postgres:14.3")
+            .withNetworkAliases(POSTGRES);
+    }
+
+    @Override
+    public void prepareSink() throws Exception {
+        String jdbcUrl = serviceContainer.getJdbcUrl();
+        // we need set postgres server address in cluster network.
+        sinkConfig.put("jdbcUrl", "jdbc:postgresql://" + POSTGRES + ":5432/test");
+        String driver = serviceContainer.getDriverClassName();
+        Class.forName(driver);
+
+        connection = DriverManager.getConnection(jdbcUrl, "test", "test");
+        log.info("getConnection: {}, jdbcurl: {}", connection, jdbcUrl);
+
+        // create table
+        String createTable = "CREATE TABLE " + tableName
+            + " (field1 TEXT, field2 TEXT, field3 INTEGER, PRIMARY KEY (field3))";
+        int ret = connection.createStatement().executeUpdate(createTable);
+        log.info("created table in jdbc: {}, return value: {}", createTable, ret);
+    }
+
+    @Override
+    public void produceMessage(int numMessages, PulsarClient client, String inputTopicName, LinkedHashMap<String,
+            String> kvs) throws Exception {
+        if (!keyValueSchema) {
+            super.produceMessage(numMessages, client, inputTopicName, kvs);
+            return;
+        }
+
+        @Cleanup
+        Producer<KeyValue<KVSchemaKey, KVSchemaValue>> producer =
+                client.newProducer(Schema.KeyValue(Schema.JSON(KVSchemaKey.class), Schema.AVRO(KVSchemaValue.class),
+                                KeyValueEncodingType.SEPARATED)).topic(inputTopicName).create();
+
+        for (int i = 0; i < numMessages; i++) {
+            String key = "key-" + i;
+            kvs.put(key, key);
+            producer.newMessage()
+                    .value(new KeyValue<>(new KVSchemaKey(i), new KVSchemaValue("f1_" + i, "f2_" + i)))
+                    .send();
+        }
+
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        log.info("Query table content from postgres server: {}", tableName);
+        String querySql = "SELECT * FROM " + tableName + " ORDER BY field3";
+        ResultSet rs;
+        try {
+            // backend flush may not complete.
+            Thread.sleep(1000);
+
+            PreparedStatement statement = connection.prepareStatement(querySql,
+                ResultSet.TYPE_SCROLL_INSENSITIVE,
+                ResultSet.CONCUR_UPDATABLE);
+            rs = statement.executeQuery();
+
+            if (!keyValueSchema && kvs.get("ACTION").equals("DELETE")) {
+                assertFalse(rs.first());
+                return;
+            }
+            int index = 0;
+            while (rs.next()) {
+                String field1 = rs.getString(1);
+                String field2 = rs.getString(2);
+                int field3 = rs.getInt(3);
+                if (keyValueSchema) {
+                    assertEquals(field1, "f1_" + index);
+                    assertEquals(field2, "f2_" + index);
+                    assertEquals(field3, index);
+                } else {
+                    String value = kvs.get("key-" + field3);
+                    Foo obj = schema.decode(value.getBytes());
+                    assertEquals(obj.field1, field1);
+                    assertEquals(obj.field2, field2);
+                    assertEquals(obj.field3, field3);
+                }
+                index++;
+            }
+        } catch (Exception e) {
+            log.error("Got exception: ", e);
+            fail("Got exception when op sql: " + e);
+        }
+    }
+
+    public boolean isKeyValueSchema() {
+        return keyValueSchema;
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (connection != null) {
+            connection.close();
+            connection = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KafkaSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KafkaSinkTester.java
index dbcb1639c1..b5559938e4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KafkaSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KafkaSinkTester.java
@@ -1,134 +1,134 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.apache.pulsar.tests.integration.topologies.PulsarTestBase.randomName;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import com.google.common.collect.ImmutableMap;
-import java.time.Duration;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.Map;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.kafka.clients.consumer.ConsumerConfig;
-import org.apache.kafka.clients.consumer.ConsumerRecord;
-import org.apache.kafka.clients.consumer.ConsumerRecords;
-import org.apache.kafka.clients.consumer.KafkaConsumer;
-import org.apache.kafka.common.serialization.StringDeserializer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testcontainers.containers.Container.ExecResult;
-import org.testcontainers.containers.KafkaContainer;
-import org.testcontainers.utility.DockerImageName;
-
-/**
- * A tester for testing kafka sink.
- */
-@Slf4j
-public class KafkaSinkTester extends SinkTester<KafkaContainer> {
-    public static final String CONFLUENT_PLATFORM_VERSION = System.getProperty("confluent.version", "7.8.2");
-
-    private final String kafkaTopicName;
-    private KafkaConsumer<String, String> kafkaConsumer;
-
-    private final String containerName;
-
-    public KafkaSinkTester(String containerName) {
-        super(containerName, SinkType.KAFKA);
-        this.containerName = containerName;
-        String suffix = randomName(8) + "_" + System.currentTimeMillis();
-        this.kafkaTopicName = "kafka_sink_topic_" + suffix;
-
-        sinkConfig.put("bootstrapServers", networkAlias + ":9092");
-        sinkConfig.put("acks", "all");
-        sinkConfig.put("batchSize", 1L);
-        sinkConfig.put("maxRequestSize", 1048576L);
-        sinkConfig.put("topic", kafkaTopicName);
-    }
-
-    @SuppressWarnings("deprecation")
-    @Override
-    protected KafkaContainer createSinkService(PulsarCluster cluster) {
-        return new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
-                .withEmbeddedZookeeper()
-                .withNetworkAliases(containerName)
-                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd
-                        .withName(containerName)
-                        .withHostName(cluster.getClusterName() + "-" + containerName));
-    }
-
-    @Override
-    public void prepareSink() throws Exception {
-        ExecResult execResult = serviceContainer.execInContainer(
-                "/usr/bin/kafka-topics",
-                "--create",
-                "--bootstrap-server",
-                "localhost:9092",
-                "--partitions",
-                "1",
-                "--replication-factor",
-                "1",
-                "--topic",
-                kafkaTopicName);
-        assertTrue(
-                execResult.getStdout().contains("Created topic"),
-                execResult.getStdout());
-
-        kafkaConsumer = new KafkaConsumer<>(
-                ImmutableMap.of(
-                        ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, serviceContainer.getBootstrapServers(),
-                        ConsumerConfig.GROUP_ID_CONFIG, "sink-test-" + randomName(8),
-                        ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"
-                ),
-                new StringDeserializer(),
-                new StringDeserializer()
-        );
-        kafkaConsumer.subscribe(Arrays.asList(kafkaTopicName));
-        log.info("Successfully subscribe to kafka topic {}", kafkaTopicName);
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        Iterator<Map.Entry<String, String>> kvIter = kvs.entrySet().iterator();
-        while (kvIter.hasNext()) {
-            ConsumerRecords<String, String> records = kafkaConsumer.poll(Duration.ofSeconds(1L));
-            log.info("Received {} records from kafka topic {}",
-                    records.count(), kafkaTopicName);
-            if (records.isEmpty()) {
-                continue;
-            }
-
-            Iterator<ConsumerRecord<String, String>> recordsIter = records.iterator();
-            while (recordsIter.hasNext() && kvIter.hasNext()) {
-                ConsumerRecord<String, String> consumerRecord = recordsIter.next();
-                Map.Entry<String, String> expectedRecord = kvIter.next();
-                assertEquals(expectedRecord.getKey(), consumerRecord.key());
-                assertEquals(expectedRecord.getValue(), consumerRecord.value());
-            }
-        }
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (kafkaConsumer != null) {
-            kafkaConsumer.close();
-            kafkaConsumer = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.apache.pulsar.tests.integration.topologies.PulsarTestBase.randomName;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import com.google.common.collect.ImmutableMap;
+import java.time.Duration;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testcontainers.containers.Container.ExecResult;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.utility.DockerImageName;
+
+/**
+ * A tester for testing kafka sink.
+ */
+@Slf4j
+public class KafkaSinkTester extends SinkTester<KafkaContainer> {
+    public static final String CONFLUENT_PLATFORM_VERSION = System.getProperty("confluent.version", "7.8.2");
+
+    private final String kafkaTopicName;
+    private KafkaConsumer<String, String> kafkaConsumer;
+
+    private final String containerName;
+
+    public KafkaSinkTester(String containerName) {
+        super(containerName, SinkType.KAFKA);
+        this.containerName = containerName;
+        String suffix = randomName(8) + "_" + System.currentTimeMillis();
+        this.kafkaTopicName = "kafka_sink_topic_" + suffix;
+
+        sinkConfig.put("bootstrapServers", networkAlias + ":9092");
+        sinkConfig.put("acks", "all");
+        sinkConfig.put("batchSize", 1L);
+        sinkConfig.put("maxRequestSize", 1048576L);
+        sinkConfig.put("topic", kafkaTopicName);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    protected KafkaContainer createSinkService(PulsarCluster cluster) {
+        return new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
+                .withEmbeddedZookeeper()
+                .withNetworkAliases(containerName)
+                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd
+                        .withName(containerName)
+                        .withHostName(cluster.getClusterName() + "-" + containerName));
+    }
+
+    @Override
+    public void prepareSink() throws Exception {
+        ExecResult execResult = serviceContainer.execInContainer(
+                "/usr/bin/kafka-topics",
+                "--create",
+                "--bootstrap-server",
+                "localhost:9092",
+                "--partitions",
+                "1",
+                "--replication-factor",
+                "1",
+                "--topic",
+                kafkaTopicName);
+        assertTrue(
+                execResult.getStdout().contains("Created topic"),
+                execResult.getStdout());
+
+        kafkaConsumer = new KafkaConsumer<>(
+                ImmutableMap.of(
+                        ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, serviceContainer.getBootstrapServers(),
+                        ConsumerConfig.GROUP_ID_CONFIG, "sink-test-" + randomName(8),
+                        ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"
+                ),
+                new StringDeserializer(),
+                new StringDeserializer()
+        );
+        kafkaConsumer.subscribe(Arrays.asList(kafkaTopicName));
+        log.info("Successfully subscribe to kafka topic {}", kafkaTopicName);
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        Iterator<Map.Entry<String, String>> kvIter = kvs.entrySet().iterator();
+        while (kvIter.hasNext()) {
+            ConsumerRecords<String, String> records = kafkaConsumer.poll(Duration.ofSeconds(1L));
+            log.info("Received {} records from kafka topic {}",
+                    records.count(), kafkaTopicName);
+            if (records.isEmpty()) {
+                continue;
+            }
+
+            Iterator<ConsumerRecord<String, String>> recordsIter = records.iterator();
+            while (recordsIter.hasNext() && kvIter.hasNext()) {
+                ConsumerRecord<String, String> consumerRecord = recordsIter.next();
+                Map.Entry<String, String> expectedRecord = kvIter.next();
+                assertEquals(expectedRecord.getKey(), consumerRecord.key());
+                assertEquals(expectedRecord.getValue(), consumerRecord.value());
+            }
+        }
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (kafkaConsumer != null) {
+            kafkaConsumer.close();
+            kafkaConsumer = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KinesisSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KinesisSinkTester.java
index 41228f1465..8121cdb408 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KinesisSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/KinesisSinkTester.java
@@ -1,290 +1,290 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.testng.Assert.assertEquals;
-import com.fasterxml.jackson.databind.JsonNode;
-import com.fasterxml.jackson.databind.ObjectReader;
-import com.google.common.collect.ImmutableMap;
-import java.io.UncheckedIOException;
-import java.net.URI;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import lombok.AllArgsConstructor;
-import lombok.Cleanup;
-import lombok.Data;
-import lombok.SneakyThrows;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.apache.pulsar.common.schema.KeyValueEncodingType;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.awaitility.Awaitility;
-import org.testcontainers.containers.localstack.LocalStackContainer;
-import org.testcontainers.utility.DockerImageName;
-import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
-import software.amazon.awssdk.regions.Region;
-import software.amazon.awssdk.services.kinesis.KinesisAsyncClient;
-import software.amazon.awssdk.services.kinesis.model.CreateStreamRequest;
-import software.amazon.awssdk.services.kinesis.model.GetRecordsRequest;
-import software.amazon.awssdk.services.kinesis.model.GetRecordsResponse;
-import software.amazon.awssdk.services.kinesis.model.GetShardIteratorRequest;
-import software.amazon.awssdk.services.kinesis.model.ListShardsRequest;
-import software.amazon.awssdk.services.kinesis.model.Record;
-import software.amazon.awssdk.services.kinesis.model.ShardIteratorType;
-import software.amazon.kinesis.retrieval.AggregatorUtil;
-import software.amazon.kinesis.retrieval.KinesisClientRecord;
-
-@Slf4j
-public class KinesisSinkTester extends SinkTester<LocalStackContainer> {
-
-    private static final String NAME = "kinesis";
-    private static final int LOCALSTACK_SERVICE_PORT = 4566;
-    public static final String STREAM_NAME = "my-stream-1";
-    public static final ObjectReader READER = ObjectMapperFactory.getMapper().reader();
-    private final boolean withSchema;
-    private KinesisAsyncClient client;
-
-    public KinesisSinkTester(boolean withSchema) {
-        super(NAME, SinkType.KINESIS);
-        this.withSchema = withSchema;
-
-        sinkConfig.put("awsKinesisStreamName", STREAM_NAME);
-        sinkConfig.put("awsRegion", "us-east-1");
-        sinkConfig.put("awsCredentialPluginParam", "{\"accessKey\":\"access\",\"secretKey\":\"secret\"}");
-        sinkConfig.put("awsEndpoint", NAME);
-        sinkConfig.put("awsEndpointPort", LOCALSTACK_SERVICE_PORT);
-        sinkConfig.put("awsStsEndpoint", NAME);
-        sinkConfig.put("awsStsPort", LOCALSTACK_SERVICE_PORT);
-        sinkConfig.put("skipCertificateValidation", true);
-        if (withSchema) {
-            sinkConfig.put("messageFormat", "FULL_MESSAGE_IN_JSON_EXPAND_VALUE");
-        }
-    }
-
-    @Override
-    public Schema<?> getInputTopicSchema() {
-        if (withSchema) {
-            // we do not want to enforce a Schema
-            // at the beginning of the test
-            return Schema.AUTO_CONSUME();
-        } else {
-            return Schema.STRING;
-        }
-    }
-
-
-    @Override
-    public void prepareSink() throws Exception {
-        final LocalStackContainer localStackContainer = getServiceContainer();
-        final URI endpointOverride = localStackContainer.getEndpointOverride(LocalStackContainer.Service.KINESIS);
-        client = KinesisAsyncClient.builder().credentialsProvider(() -> AwsBasicCredentials.create(
-                "access",
-                "secret"))
-                .region(Region.US_EAST_1)
-                .endpointOverride(endpointOverride)
-                .build();
-        log.info("prepareSink for kinesis: creating stream {}, endpoint {}", STREAM_NAME, endpointOverride);
-        client.createStream(CreateStreamRequest.builder()
-                .streamName(STREAM_NAME)
-                .shardCount(1)
-                .build())
-                .get();
-        log.info("prepareSink for kinesis: created stream {}", STREAM_NAME);
-    }
-
-    @Override
-    public void stopServiceContainer() {
-        if (client != null) {
-            client.close();
-        }
-        super.stopServiceContainer();
-    }
-
-    @Override
-    protected LocalStackContainer createSinkService(PulsarCluster cluster) {
-        return new LocalStackContainer(DockerImageName.parse("localstack/localstack:4.0.3"))
-                .withServices(LocalStackContainer.Service.KINESIS, LocalStackContainer.Service.STS)
-                .withEnv("KINESIS_PROVIDER", "kinesalite");
-    }
-
-    @Override
-    public void produceMessage(int numMessages, PulsarClient client,
-                               String inputTopicName, LinkedHashMap<String, String> kvs) throws Exception {
-        if (withSchema) {
-            Schema<KeyValue<SimplePojo, SimplePojo>> kvSchema =
-                    Schema.KeyValue(Schema.JSON(SimplePojo.class),
-                            Schema.AVRO(SimplePojo.class), KeyValueEncodingType.SEPARATED);
-
-            @Cleanup
-            Producer<KeyValue<SimplePojo, SimplePojo>> producer = client.newProducer(kvSchema)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                String key = String.valueOf(i);
-                kvs.put(key, key);
-                final SimplePojo keyPojo = new SimplePojo(
-                        "f1_" + i,
-                        "f2_" + i,
-                        Arrays.asList(i, i + 1),
-                        new HashSet<>(Arrays.asList((long) i)),
-                        ImmutableMap.of("map1_k_" + i, "map1_kv_" + i),
-                        ("key_bytes_" + i).getBytes(StandardCharsets.UTF_8));
-                final SimplePojo valuePojo = new SimplePojo(
-                        String.valueOf(i),
-                        "v2_" + i,
-                        Arrays.asList(i, i + 1),
-                        new HashSet<>(Arrays.asList((long) i)),
-                        ImmutableMap.of("map1_v_" + i, "map1_vv_" + i),
-                        ("value_bytes_" + i).getBytes(StandardCharsets.UTF_8));
-                producer.newMessage()
-                        .value(new KeyValue<>(keyPojo, valuePojo))
-                        .send();
-            }
-        } else {
-            @Cleanup
-            Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(inputTopicName)
-                    .create();
-
-            for (int i = 0; i < numMessages; i++) {
-                String key = "key-" + i;
-                String value = "value-" + i;
-                kvs.put(key, value);
-                producer.newMessage()
-                        .key(key)
-                        .value(value)
-                        .send();
-            }
-        }
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        Awaitility.await().untilAsserted(() -> internalValidateSinkResult(kvs));
-    }
-
-    @SneakyThrows
-    private void internalValidateSinkResult(Map<String, String> kvs) {
-        final String shardId = client.listShards(
-                ListShardsRequest.builder()
-                        .streamName(STREAM_NAME)
-                        .build()
-        ).get()
-                .shards()
-                .get(0)
-                .shardId();
-
-        final String iterator = client.getShardIterator(GetShardIteratorRequest.builder()
-                .streamName(STREAM_NAME)
-                .shardId(shardId)
-                .shardIteratorType(ShardIteratorType.TRIM_HORIZON)
-                .build())
-                .get()
-                .shardIterator();
-
-        Map<String, String> actualKvs = new LinkedHashMap<>();
-
-        addMoreRecords(actualKvs, iterator);
-
-        assertEquals(actualKvs, kvs);
-    }
-
-    @SneakyThrows
-    private void parseRecordData(Map<String, String> actualKvs, String data, String partitionKey) {
-        if (withSchema) {
-            JsonNode payload = READER.readTree(data).at("/payload");
-            String i = payload.at("/value/field1").asText();
-            assertEquals(payload.at("/value/field2").asText(), "v2_" + i);
-            assertEquals(payload.at("/value/bytes").asText(),
-                    Base64.getEncoder().encodeToString(("value_bytes_" + i).getBytes(StandardCharsets.UTF_8)));
-            assertEquals(payload.at("/key/field1").asText(), "f1_" + i);
-            assertEquals(payload.at("/key/field2").asText(), "f2_" + i);
-            assertEquals(payload.at("/key/bytes").asText(),
-                    Base64.getEncoder().encodeToString(("key_bytes_" + i).getBytes(StandardCharsets.UTF_8)));
-            actualKvs.put(i, i);
-        } else {
-            actualKvs.put(partitionKey, data);
-        }
-    }
-
-    @SneakyThrows
-    private void addMoreRecords(Map<String, String> actualKvs, String iterator) {
-        GetRecordsResponse response;
-        List<KinesisClientRecord> aggRecords = new ArrayList<>();
-        do {
-            GetRecordsRequest request = GetRecordsRequest.builder().shardIterator(iterator).build();
-            response = client.getRecords(request).get();
-            if (response.hasRecords()) {
-                for (Record record : response.records()) {
-                    // KinesisSink uses KPL with aggregation enabled (by default).
-                    // However, due to the async state initialization of the KPL internal ShardMap,
-                    // the first sinked records might not be aggregated in Kinesis.
-                    // ref: https://github.com/awslabs/amazon-kinesis-producer/issues/131
-                    try {
-                        String data = record.data().asString(StandardCharsets.UTF_8);
-                        parseRecordData(actualKvs, data, record.partitionKey());
-                    } catch (UncheckedIOException e) {
-                        aggRecords.add(KinesisClientRecord.fromRecord(record));
-                    }
-                }
-            }
-            iterator = response.nextShardIterator();
-            // millisBehindLatest equals zero when record processing is caught up,
-            // and there are no new records to process at this moment.
-            // See https://docs.aws.amazon.com/kinesis/latest/APIReference/
-            // API_GetRecords.html#Streams-GetRecords-response-MillisBehindLatest
-        } while (response.millisBehindLatest() != 0);
-
-        for (KinesisClientRecord record : new AggregatorUtil().deaggregate(aggRecords)) {
-            String data = new String(record.data().array(), StandardCharsets.UTF_8);
-            parseRecordData(actualKvs, data, record.partitionKey());
-        }
-    }
-
-    @Data
-    @AllArgsConstructor
-    public static final class SimplePojo {
-        private String field1;
-        private String field2;
-        private List<Integer> list1;
-        private Set<Long> set1;
-        private Map<String, String> map1;
-        private byte[] bytes;
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (client != null) {
-            client.close();
-            client = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.testng.Assert.assertEquals;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.google.common.collect.ImmutableMap;
+import java.io.UncheckedIOException;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import lombok.AllArgsConstructor;
+import lombok.Cleanup;
+import lombok.Data;
+import lombok.SneakyThrows;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.apache.pulsar.common.schema.KeyValueEncodingType;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.awaitility.Awaitility;
+import org.testcontainers.containers.localstack.LocalStackContainer;
+import org.testcontainers.utility.DockerImageName;
+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
+import software.amazon.awssdk.regions.Region;
+import software.amazon.awssdk.services.kinesis.KinesisAsyncClient;
+import software.amazon.awssdk.services.kinesis.model.CreateStreamRequest;
+import software.amazon.awssdk.services.kinesis.model.GetRecordsRequest;
+import software.amazon.awssdk.services.kinesis.model.GetRecordsResponse;
+import software.amazon.awssdk.services.kinesis.model.GetShardIteratorRequest;
+import software.amazon.awssdk.services.kinesis.model.ListShardsRequest;
+import software.amazon.awssdk.services.kinesis.model.Record;
+import software.amazon.awssdk.services.kinesis.model.ShardIteratorType;
+import software.amazon.kinesis.retrieval.AggregatorUtil;
+import software.amazon.kinesis.retrieval.KinesisClientRecord;
+
+@Slf4j
+public class KinesisSinkTester extends SinkTester<LocalStackContainer> {
+
+    private static final String NAME = "kinesis";
+    private static final int LOCALSTACK_SERVICE_PORT = 4566;
+    public static final String STREAM_NAME = "my-stream-1";
+    public static final ObjectReader READER = ObjectMapperFactory.getMapper().reader();
+    private final boolean withSchema;
+    private KinesisAsyncClient client;
+
+    public KinesisSinkTester(boolean withSchema) {
+        super(NAME, SinkType.KINESIS);
+        this.withSchema = withSchema;
+
+        sinkConfig.put("awsKinesisStreamName", STREAM_NAME);
+        sinkConfig.put("awsRegion", "us-east-1");
+        sinkConfig.put("awsCredentialPluginParam", "{\"accessKey\":\"access\",\"secretKey\":\"secret\"}");
+        sinkConfig.put("awsEndpoint", NAME);
+        sinkConfig.put("awsEndpointPort", LOCALSTACK_SERVICE_PORT);
+        sinkConfig.put("awsStsEndpoint", NAME);
+        sinkConfig.put("awsStsPort", LOCALSTACK_SERVICE_PORT);
+        sinkConfig.put("skipCertificateValidation", true);
+        if (withSchema) {
+            sinkConfig.put("messageFormat", "FULL_MESSAGE_IN_JSON_EXPAND_VALUE");
+        }
+    }
+
+    @Override
+    public Schema<?> getInputTopicSchema() {
+        if (withSchema) {
+            // we do not want to enforce a Schema
+            // at the beginning of the test
+            return Schema.AUTO_CONSUME();
+        } else {
+            return Schema.STRING;
+        }
+    }
+
+
+    @Override
+    public void prepareSink() throws Exception {
+        final LocalStackContainer localStackContainer = getServiceContainer();
+        final URI endpointOverride = localStackContainer.getEndpointOverride(LocalStackContainer.Service.KINESIS);
+        client = KinesisAsyncClient.builder().credentialsProvider(() -> AwsBasicCredentials.create(
+                "access",
+                "secret"))
+                .region(Region.US_EAST_1)
+                .endpointOverride(endpointOverride)
+                .build();
+        log.info("prepareSink for kinesis: creating stream {}, endpoint {}", STREAM_NAME, endpointOverride);
+        client.createStream(CreateStreamRequest.builder()
+                .streamName(STREAM_NAME)
+                .shardCount(1)
+                .build())
+                .get();
+        log.info("prepareSink for kinesis: created stream {}", STREAM_NAME);
+    }
+
+    @Override
+    public void stopServiceContainer() {
+        if (client != null) {
+            client.close();
+        }
+        super.stopServiceContainer();
+    }
+
+    @Override
+    protected LocalStackContainer createSinkService(PulsarCluster cluster) {
+        return new LocalStackContainer(DockerImageName.parse("localstack/localstack:4.0.3"))
+                .withServices(LocalStackContainer.Service.KINESIS, LocalStackContainer.Service.STS)
+                .withEnv("KINESIS_PROVIDER", "kinesalite");
+    }
+
+    @Override
+    public void produceMessage(int numMessages, PulsarClient client,
+                               String inputTopicName, LinkedHashMap<String, String> kvs) throws Exception {
+        if (withSchema) {
+            Schema<KeyValue<SimplePojo, SimplePojo>> kvSchema =
+                    Schema.KeyValue(Schema.JSON(SimplePojo.class),
+                            Schema.AVRO(SimplePojo.class), KeyValueEncodingType.SEPARATED);
+
+            @Cleanup
+            Producer<KeyValue<SimplePojo, SimplePojo>> producer = client.newProducer(kvSchema)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                String key = String.valueOf(i);
+                kvs.put(key, key);
+                final SimplePojo keyPojo = new SimplePojo(
+                        "f1_" + i,
+                        "f2_" + i,
+                        Arrays.asList(i, i + 1),
+                        new HashSet<>(Arrays.asList((long) i)),
+                        ImmutableMap.of("map1_k_" + i, "map1_kv_" + i),
+                        ("key_bytes_" + i).getBytes(StandardCharsets.UTF_8));
+                final SimplePojo valuePojo = new SimplePojo(
+                        String.valueOf(i),
+                        "v2_" + i,
+                        Arrays.asList(i, i + 1),
+                        new HashSet<>(Arrays.asList((long) i)),
+                        ImmutableMap.of("map1_v_" + i, "map1_vv_" + i),
+                        ("value_bytes_" + i).getBytes(StandardCharsets.UTF_8));
+                producer.newMessage()
+                        .value(new KeyValue<>(keyPojo, valuePojo))
+                        .send();
+            }
+        } else {
+            @Cleanup
+            Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(inputTopicName)
+                    .create();
+
+            for (int i = 0; i < numMessages; i++) {
+                String key = "key-" + i;
+                String value = "value-" + i;
+                kvs.put(key, value);
+                producer.newMessage()
+                        .key(key)
+                        .value(value)
+                        .send();
+            }
+        }
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        Awaitility.await().untilAsserted(() -> internalValidateSinkResult(kvs));
+    }
+
+    @SneakyThrows
+    private void internalValidateSinkResult(Map<String, String> kvs) {
+        final String shardId = client.listShards(
+                ListShardsRequest.builder()
+                        .streamName(STREAM_NAME)
+                        .build()
+        ).get()
+                .shards()
+                .get(0)
+                .shardId();
+
+        final String iterator = client.getShardIterator(GetShardIteratorRequest.builder()
+                .streamName(STREAM_NAME)
+                .shardId(shardId)
+                .shardIteratorType(ShardIteratorType.TRIM_HORIZON)
+                .build())
+                .get()
+                .shardIterator();
+
+        Map<String, String> actualKvs = new LinkedHashMap<>();
+
+        addMoreRecords(actualKvs, iterator);
+
+        assertEquals(actualKvs, kvs);
+    }
+
+    @SneakyThrows
+    private void parseRecordData(Map<String, String> actualKvs, String data, String partitionKey) {
+        if (withSchema) {
+            JsonNode payload = READER.readTree(data).at("/payload");
+            String i = payload.at("/value/field1").asText();
+            assertEquals(payload.at("/value/field2").asText(), "v2_" + i);
+            assertEquals(payload.at("/value/bytes").asText(),
+                    Base64.getEncoder().encodeToString(("value_bytes_" + i).getBytes(StandardCharsets.UTF_8)));
+            assertEquals(payload.at("/key/field1").asText(), "f1_" + i);
+            assertEquals(payload.at("/key/field2").asText(), "f2_" + i);
+            assertEquals(payload.at("/key/bytes").asText(),
+                    Base64.getEncoder().encodeToString(("key_bytes_" + i).getBytes(StandardCharsets.UTF_8)));
+            actualKvs.put(i, i);
+        } else {
+            actualKvs.put(partitionKey, data);
+        }
+    }
+
+    @SneakyThrows
+    private void addMoreRecords(Map<String, String> actualKvs, String iterator) {
+        GetRecordsResponse response;
+        List<KinesisClientRecord> aggRecords = new ArrayList<>();
+        do {
+            GetRecordsRequest request = GetRecordsRequest.builder().shardIterator(iterator).build();
+            response = client.getRecords(request).get();
+            if (response.hasRecords()) {
+                for (Record record : response.records()) {
+                    // KinesisSink uses KPL with aggregation enabled (by default).
+                    // However, due to the async state initialization of the KPL internal ShardMap,
+                    // the first sinked records might not be aggregated in Kinesis.
+                    // ref: https://github.com/awslabs/amazon-kinesis-producer/issues/131
+                    try {
+                        String data = record.data().asString(StandardCharsets.UTF_8);
+                        parseRecordData(actualKvs, data, record.partitionKey());
+                    } catch (UncheckedIOException e) {
+                        aggRecords.add(KinesisClientRecord.fromRecord(record));
+                    }
+                }
+            }
+            iterator = response.nextShardIterator();
+            // millisBehindLatest equals zero when record processing is caught up,
+            // and there are no new records to process at this moment.
+            // See https://docs.aws.amazon.com/kinesis/latest/APIReference/
+            // API_GetRecords.html#Streams-GetRecords-response-MillisBehindLatest
+        } while (response.millisBehindLatest() != 0);
+
+        for (KinesisClientRecord record : new AggregatorUtil().deaggregate(aggRecords)) {
+            String data = new String(record.data().array(), StandardCharsets.UTF_8);
+            parseRecordData(actualKvs, data, record.partitionKey());
+        }
+    }
+
+    @Data
+    @AllArgsConstructor
+    public static final class SimplePojo {
+        private String field1;
+        private String field2;
+        private List<Integer> list1;
+        private Set<Long> set1;
+        private Map<String, String> map1;
+        private byte[] bytes;
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (client != null) {
+            client.close();
+            client = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/OpenSearchSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/OpenSearchSinkTester.java
index 8daed8d5c0..bbfabd89d5 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/OpenSearchSinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/OpenSearchSinkTester.java
@@ -1,90 +1,90 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.testng.Assert.assertTrue;
-import java.util.Map;
-import java.util.Optional;
-import org.apache.http.HttpHost;
-import org.awaitility.Awaitility;
-import org.opensearch.action.search.SearchRequest;
-import org.opensearch.action.search.SearchResponse;
-import org.opensearch.client.RequestOptions;
-import org.opensearch.client.RestClient;
-import org.opensearch.client.RestClientBuilder;
-import org.opensearch.client.RestHighLevelClient;
-import org.testcontainers.elasticsearch.ElasticsearchContainer;
-import org.testcontainers.utility.DockerImageName;
-
-public class OpenSearchSinkTester extends ElasticSearchSinkTester {
-
-    public static final String OPENSEARCH = Optional.ofNullable(System.getenv("OPENSEARCH_IMAGE"))
-            .orElse("opensearchproject/opensearch:2.16.0");
-
-    private RestHighLevelClient elasticClient;
-
-
-    public OpenSearchSinkTester(boolean schemaEnable) {
-        super(schemaEnable);
-    }
-
-    @Override
-    protected ElasticsearchContainer createElasticContainer() {
-        DockerImageName dockerImageName = DockerImageName.parse(OPENSEARCH)
-                .asCompatibleSubstituteFor("docker.elastic.co/elasticsearch/elasticsearch");
-        return new ElasticsearchContainer(dockerImageName)
-                .withEnv("OPENSEARCH_INITIAL_ADMIN_PASSWORD", "0pEn7earch!")
-                .withEnv("OPENSEARCH_JAVA_OPTS", "-Xms128m -Xmx256m")
-                .withEnv("bootstrap.memory_lock", "true")
-                .withEnv("plugins.security.disabled", "true");
-    }
-
-    protected boolean isOpenSearch() {
-        return true;
-    }
-
-    @Override
-    public void prepareSink() throws Exception {
-        RestClientBuilder builder = RestClient.builder(
-                new HttpHost(
-                        "localhost",
-                        serviceContainer.getMappedPort(9200),
-                        "http"));
-        elasticClient = new RestHighLevelClient(builder);
-    }
-
-    @Override
-    public void validateSinkResult(Map<String, String> kvs) {
-        org.opensearch.action.search.SearchRequest searchRequest = new SearchRequest("test-index");
-
-        Awaitility.await().untilAsserted(() -> {
-            SearchResponse searchResult = elasticClient.search(searchRequest, RequestOptions.DEFAULT);
-            assertTrue(searchResult.getHits().getTotalHits().value > 0, searchResult.toString());
-        });
-    }
-
-    @Override
-    public void close() throws Exception {
-        super.close();
-        if (elasticClient != null) {
-            elasticClient.close();
-            elasticClient = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.testng.Assert.assertTrue;
+import java.util.Map;
+import java.util.Optional;
+import org.apache.http.HttpHost;
+import org.awaitility.Awaitility;
+import org.opensearch.action.search.SearchRequest;
+import org.opensearch.action.search.SearchResponse;
+import org.opensearch.client.RequestOptions;
+import org.opensearch.client.RestClient;
+import org.opensearch.client.RestClientBuilder;
+import org.opensearch.client.RestHighLevelClient;
+import org.testcontainers.elasticsearch.ElasticsearchContainer;
+import org.testcontainers.utility.DockerImageName;
+
+public class OpenSearchSinkTester extends ElasticSearchSinkTester {
+
+    public static final String OPENSEARCH = Optional.ofNullable(System.getenv("OPENSEARCH_IMAGE"))
+            .orElse("opensearchproject/opensearch:2.16.0");
+
+    private RestHighLevelClient elasticClient;
+
+
+    public OpenSearchSinkTester(boolean schemaEnable) {
+        super(schemaEnable);
+    }
+
+    @Override
+    protected ElasticsearchContainer createElasticContainer() {
+        DockerImageName dockerImageName = DockerImageName.parse(OPENSEARCH)
+                .asCompatibleSubstituteFor("docker.elastic.co/elasticsearch/elasticsearch");
+        return new ElasticsearchContainer(dockerImageName)
+                .withEnv("OPENSEARCH_INITIAL_ADMIN_PASSWORD", "0pEn7earch!")
+                .withEnv("OPENSEARCH_JAVA_OPTS", "-Xms128m -Xmx256m")
+                .withEnv("bootstrap.memory_lock", "true")
+                .withEnv("plugins.security.disabled", "true");
+    }
+
+    protected boolean isOpenSearch() {
+        return true;
+    }
+
+    @Override
+    public void prepareSink() throws Exception {
+        RestClientBuilder builder = RestClient.builder(
+                new HttpHost(
+                        "localhost",
+                        serviceContainer.getMappedPort(9200),
+                        "http"));
+        elasticClient = new RestHighLevelClient(builder);
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        org.opensearch.action.search.SearchRequest searchRequest = new SearchRequest("test-index");
+
+        Awaitility.await().untilAsserted(() -> {
+            SearchResponse searchResult = elasticClient.search(searchRequest, RequestOptions.DEFAULT);
+            assertTrue(searchResult.getHits().getTotalHits().value > 0, searchResult.toString());
+        });
+    }
+
+    @Override
+    public void close() throws Exception {
+        super.close();
+        if (elasticClient != null) {
+            elasticClient.close();
+            elasticClient = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarIOSinkRunner.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarIOSinkRunner.java
index 6643999d58..170c0b6529 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarIOSinkRunner.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarIOSinkRunner.java
@@ -1,458 +1,458 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import com.google.gson.Gson;
-import dev.failsafe.Failsafe;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.impl.schema.AvroSchema;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.common.policies.data.SinkStatus;
-import org.apache.pulsar.common.policies.data.SinkStatusUtil;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.io.PulsarIOTestRunner;
-import org.apache.pulsar.tests.integration.io.sinks.JdbcPostgresSinkTester.Foo;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarTestBase;
-import org.testcontainers.containers.GenericContainer;
-import org.testng.collections.Maps;
-
-@Slf4j
-public class PulsarIOSinkRunner extends PulsarIOTestRunner {
-
-    public PulsarIOSinkRunner(PulsarCluster cluster, String functionRuntimeType) {
-        super(cluster, functionRuntimeType);
-    }
-
-    @SuppressWarnings({ "rawtypes" })
-    public <T extends GenericContainer> void runSinkTester(SinkTester<T> tester, boolean builtin) throws Exception {
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String inputTopicName = "test-sink-connector-"
-            + tester.getSinkType() + "-" + functionRuntimeType + "-input-topic-" + PulsarTestBase.randomName(8);
-        final String sinkName = "test-sink-connector-"
-            + tester.getSinkType().name().toLowerCase() + "-" + functionRuntimeType + "-name-"
-                + PulsarTestBase.randomName(8);
-        final int numMessages = 20;
-
-        // prepare the testing environment for sink
-        prepareSink(tester);
-
-        ensureSubscriptionCreated(
-            inputTopicName,
-            String.format("public/default/%s", sinkName),
-            tester.getInputTopicSchema());
-
-        // submit the sink connector
-        submitSinkConnector(tester, tenant, namespace, sinkName, inputTopicName);
-
-        // get sink info
-        getSinkInfoSuccess(tester, tenant, namespace, sinkName, builtin);
-        try {
-
-            // get sink status
-            Failsafe.with(statusRetryPolicy).run(() -> getSinkStatus(tenant, namespace, sinkName));
-
-            // produce messages
-            Map<String, String> kvs;
-            if (tester instanceof JdbcPostgresSinkTester && !((JdbcPostgresSinkTester) tester).isKeyValueSchema()) {
-                kvs = produceSchemaInsertMessagesToInputTopic(inputTopicName, numMessages,
-                        AvroSchema.of(JdbcPostgresSinkTester.Foo.class));
-                // wait for sink to process messages
-                Failsafe.with(statusRetryPolicy).run(() ->
-                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages));
-
-                // validate the sink result
-                tester.validateSinkResult(kvs);
-
-                kvs = produceSchemaUpdateMessagesToInputTopic(inputTopicName, numMessages,
-                        AvroSchema.of(JdbcPostgresSinkTester.Foo.class));
-
-                // wait for sink to process messages
-                Failsafe.with(statusRetryPolicy).run(() ->
-                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages + 20));
-
-                // validate the sink result
-                tester.validateSinkResult(kvs);
-
-                kvs = produceSchemaDeleteMessagesToInputTopic(inputTopicName, numMessages,
-                        AvroSchema.of(JdbcPostgresSinkTester.Foo.class));
-
-                // wait for sink to process messages
-                Failsafe.with(statusRetryPolicy).run(() ->
-                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages + 20 + 20));
-
-                // validate the sink result
-                tester.validateSinkResult(kvs);
-
-            } else {
-                kvs = produceMessagesToInputTopic(inputTopicName, numMessages, tester);
-                // wait for sink to process messages
-                Failsafe.with(statusRetryPolicy).run(() ->
-                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages));
-                // validate the sink result
-                tester.validateSinkResult(kvs);
-            }
-        } finally {
-            // always print the content of the logs, in order to ease debugging
-            pulsarCluster.dumpFunctionLogs(sinkName);
-        }
-
-        // update the sink
-        updateSinkConnector(tester, tenant, namespace, sinkName, inputTopicName);
-
-        // delete the sink
-        deleteSink(tenant, namespace, sinkName);
-
-        // get sink info (sink should be deleted)
-        getSinkInfoNotFound(tenant, namespace, sinkName);
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected void prepareSink(SinkTester tester) throws Exception {
-        tester.prepareSink();
-    }
-
-    protected void submitSinkConnector(@SuppressWarnings("rawtypes") SinkTester tester,
-                                       String tenant,
-                                       String namespace,
-                                       String sinkName,
-                                       String inputTopicName) throws Exception {
-        String[] commands;
-        if (tester.getSinkType() != SinkTester.SinkType.UNDEFINED) {
-            commands = new String[] {
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sink", "create",
-                    "--tenant", tenant,
-                    "--namespace", namespace,
-                    "--name", sinkName,
-                    "--sink-type", tester.sinkType().getValue().toLowerCase(),
-                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
-                    "--inputs", inputTopicName,
-                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
-            };
-        } else {
-            commands = new String[] {
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sink", "create",
-                    "--tenant", tenant,
-                    "--namespace", namespace,
-                    "--name", sinkName,
-                    "--archive", tester.getSinkArchive(),
-                    "--classname", tester.getSinkClassName(),
-                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
-                    "--inputs", inputTopicName,
-                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
-            };
-        }
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-            result.getStdout().contains("Created successfully"),
-            result.getStdout());
-    }
-
-    protected void updateSinkConnector(@SuppressWarnings("rawtypes") SinkTester tester,
-                                       String tenant,
-                                       String namespace,
-                                       String sinkName,
-                                       String inputTopicName) throws Exception {
-        String[] commands;
-        if (tester.getSinkType() != SinkTester.SinkType.UNDEFINED) {
-            commands = new String[] {
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sink", "update",
-                    "--tenant", tenant,
-                    "--namespace", namespace,
-                    "--name", sinkName,
-                    "--sink-type", tester.sinkType().getValue().toLowerCase(),
-                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
-                    "--inputs", inputTopicName,
-                    "--parallelism", "2",
-                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
-            };
-        } else {
-            commands = new String[] {
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sink", "update",
-                    "--tenant", tenant,
-                    "--namespace", namespace,
-                    "--name", sinkName,
-                    "--archive", tester.getSinkArchive(),
-                    "--classname", tester.getSinkClassName(),
-                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
-                    "--inputs", inputTopicName,
-                    "--parallelism", "2",
-                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
-            };
-        }
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Updated successfully"),
-                result.getStdout());
-    }
-
-    protected void getSinkInfoSuccess(@SuppressWarnings("rawtypes") SinkTester tester,
-                                      String tenant,
-                                      String namespace,
-                                      String sinkName,
-                                      boolean builtin) throws Exception {
-        String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "sink",
-            "get",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sinkName
-        };
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get sink info : {}", result.getStdout());
-        if (builtin) {
-            assertTrue(
-                    result.getStdout().contains("\"archive\": \"builtin://"
-                            + tester.getSinkType().getValue().toLowerCase() + "\""),
-                    result.getStdout()
-            );
-        } else {
-            assertTrue(
-                    result.getStdout().contains("\"className\": \"" + tester.getSinkClassName() + "\""),
-                    result.getStdout()
-            );
-        }
-    }
-
-    protected void getSinkStatus(String tenant, String namespace, String sinkName) throws Exception {
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "sink",
-            "status",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sinkName
-        };
-
-        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get sink status : {}", result.getStdout());
-
-        assertEquals(result.getExitCode(), 0);
-
-        SinkStatus sinkStatus = SinkStatusUtil.decode(result.getStdout());
-
-        assertEquals(sinkStatus.getNumInstances(), 1);
-        assertEquals(sinkStatus.getNumRunning(), 1);
-        assertEquals(sinkStatus.getInstances().size(), 1);
-        assertEquals(sinkStatus.getInstances().get(0).getInstanceId(), 0);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-    }
-
-    protected void deleteSink(String tenant, String namespace, String sinkName) throws Exception {
-
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "sink",
-            "delete",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sinkName
-        };
-
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-            result.getStdout().contains("Deleted successfully"),
-            result.getStdout()
-        );
-        result.assertNoStderr();
-    }
-
-    protected void getSinkInfoNotFound(String tenant, String namespace, String sinkName) throws Exception {
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "sink",
-            "get",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sinkName
-        };
-        try {
-            pulsarCluster.getAnyWorker().execCmd(commands);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Sink " + sinkName + " doesn't exist"));
-        }
-    }
-
-    protected void waitForProcessingSinkMessages(String tenant,
-                                                 String namespace,
-                                                 String sinkName,
-                                                 int numMessages) throws Exception {
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "sink",
-                "status",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sinkName
-        };
-
-        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get sink status : {}", result.getStdout());
-
-        assertEquals(result.getExitCode(), 0);
-
-        final SinkStatus sinkStatus = SinkStatusUtil.decode(result.getStdout());
-
-        assertEquals(sinkStatus.getNumInstances(), 1);
-        assertEquals(sinkStatus.getNumRunning(), 1);
-        assertEquals(sinkStatus.getInstances().size(), 1);
-        assertEquals(sinkStatus.getInstances().get(0).getInstanceId(), 0);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertTrue(sinkStatus.getInstances().get(0).getStatus().getLastReceivedTime() > 0);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumReadFromPulsar(), numMessages);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumWrittenToSink(), numMessages);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(sinkStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-    }
-
-    // This for JdbcPostgresSinkTester
-    protected Map<String, String> produceSchemaInsertMessagesToInputTopic(String inputTopicName,
-                                                                          int numMessages,
-                                                                          Schema<Foo> schema) throws Exception {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-            .build();
-
-        @Cleanup
-        Producer<Foo> producer = client.newProducer(schema)
-            .topic(inputTopicName)
-            .create();
-
-        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
-        for (int i = 0; i < numMessages; i++) {
-            String key = "key-" + i;
-
-            JdbcPostgresSinkTester.Foo obj = new JdbcPostgresSinkTester.Foo();
-            obj.setField1("field1_insert_" + i);
-            obj.setField2("field2_insert_" + i);
-            obj.setField3(i);
-            String value = new String(schema.encode(obj));
-            Map<String, String> properties = Maps.newHashMap();
-            properties.put("ACTION", "INSERT");
-
-            kvs.put(key, value);
-            kvs.put("ACTION", "INSERT");
-            producer.newMessage()
-                    .properties(properties)
-                    .key(key)
-                    .value(obj)
-                    .send();
-        }
-        return kvs;
-    }
-
-    // This for JdbcPostgresSinkTester
-    protected Map<String, String> produceSchemaUpdateMessagesToInputTopic(String inputTopicName,
-                                                                          int numMessages,
-                                                                          Schema<Foo> schema) throws Exception {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        Producer<Foo> producer = client.newProducer(schema)
-                .topic(inputTopicName)
-                .create();
-
-        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
-        log.info("update start");
-        for (int i = 0; i < numMessages; i++) {
-            String key = "key-" + i;
-
-            JdbcPostgresSinkTester.Foo obj = new JdbcPostgresSinkTester.Foo();
-            obj.setField1("field1_insert_" + i);
-            obj.setField2("field2_update_" + i);
-            obj.setField3(i);
-            String value = new String(schema.encode(obj));
-            Map<String, String> properties = Maps.newHashMap();
-            properties.put("ACTION", "UPDATE");
-
-            kvs.put(key, value);
-            kvs.put("ACTION", "UPDATE");
-            producer.newMessage()
-                    .properties(properties)
-                    .key(key)
-                    .value(obj)
-                    .send();
-        }
-        log.info("update end");
-        return kvs;
-    }
-
-    // This for JdbcPostgresSinkTester
-    protected Map<String, String> produceSchemaDeleteMessagesToInputTopic(String inputTopicName,
-                                                                          int numMessages,
-                                                                          Schema<Foo> schema) throws Exception {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        Producer<Foo> producer = client.newProducer(schema)
-                .topic(inputTopicName)
-                .create();
-
-        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
-        for (int i = 0; i < numMessages; i++) {
-            String key = "key-" + i;
-
-            JdbcPostgresSinkTester.Foo obj = new JdbcPostgresSinkTester.Foo();
-            obj.setField1("field1_insert_" + i);
-            obj.setField2("field2_update_" + i);
-            obj.setField3(i);
-            String value = new String(schema.encode(obj));
-            Map<String, String> properties = Maps.newHashMap();
-            properties.put("ACTION", "DELETE");
-
-            kvs.put(key, value);
-            kvs.put("ACTION", "DELETE");
-            producer.newMessage()
-                    .properties(properties)
-                    .key(key)
-                    .value(obj)
-                    .send();
-        }
-        return kvs;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import com.google.gson.Gson;
+import dev.failsafe.Failsafe;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.impl.schema.AvroSchema;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.common.policies.data.SinkStatus;
+import org.apache.pulsar.common.policies.data.SinkStatusUtil;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.io.PulsarIOTestRunner;
+import org.apache.pulsar.tests.integration.io.sinks.JdbcPostgresSinkTester.Foo;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarTestBase;
+import org.testcontainers.containers.GenericContainer;
+import org.testng.collections.Maps;
+
+@Slf4j
+public class PulsarIOSinkRunner extends PulsarIOTestRunner {
+
+    public PulsarIOSinkRunner(PulsarCluster cluster, String functionRuntimeType) {
+        super(cluster, functionRuntimeType);
+    }
+
+    @SuppressWarnings({ "rawtypes" })
+    public <T extends GenericContainer> void runSinkTester(SinkTester<T> tester, boolean builtin) throws Exception {
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String inputTopicName = "test-sink-connector-"
+            + tester.getSinkType() + "-" + functionRuntimeType + "-input-topic-" + PulsarTestBase.randomName(8);
+        final String sinkName = "test-sink-connector-"
+            + tester.getSinkType().name().toLowerCase() + "-" + functionRuntimeType + "-name-"
+                + PulsarTestBase.randomName(8);
+        final int numMessages = 20;
+
+        // prepare the testing environment for sink
+        prepareSink(tester);
+
+        ensureSubscriptionCreated(
+            inputTopicName,
+            String.format("public/default/%s", sinkName),
+            tester.getInputTopicSchema());
+
+        // submit the sink connector
+        submitSinkConnector(tester, tenant, namespace, sinkName, inputTopicName);
+
+        // get sink info
+        getSinkInfoSuccess(tester, tenant, namespace, sinkName, builtin);
+        try {
+
+            // get sink status
+            Failsafe.with(statusRetryPolicy).run(() -> getSinkStatus(tenant, namespace, sinkName));
+
+            // produce messages
+            Map<String, String> kvs;
+            if (tester instanceof JdbcPostgresSinkTester && !((JdbcPostgresSinkTester) tester).isKeyValueSchema()) {
+                kvs = produceSchemaInsertMessagesToInputTopic(inputTopicName, numMessages,
+                        AvroSchema.of(JdbcPostgresSinkTester.Foo.class));
+                // wait for sink to process messages
+                Failsafe.with(statusRetryPolicy).run(() ->
+                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages));
+
+                // validate the sink result
+                tester.validateSinkResult(kvs);
+
+                kvs = produceSchemaUpdateMessagesToInputTopic(inputTopicName, numMessages,
+                        AvroSchema.of(JdbcPostgresSinkTester.Foo.class));
+
+                // wait for sink to process messages
+                Failsafe.with(statusRetryPolicy).run(() ->
+                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages + 20));
+
+                // validate the sink result
+                tester.validateSinkResult(kvs);
+
+                kvs = produceSchemaDeleteMessagesToInputTopic(inputTopicName, numMessages,
+                        AvroSchema.of(JdbcPostgresSinkTester.Foo.class));
+
+                // wait for sink to process messages
+                Failsafe.with(statusRetryPolicy).run(() ->
+                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages + 20 + 20));
+
+                // validate the sink result
+                tester.validateSinkResult(kvs);
+
+            } else {
+                kvs = produceMessagesToInputTopic(inputTopicName, numMessages, tester);
+                // wait for sink to process messages
+                Failsafe.with(statusRetryPolicy).run(() ->
+                        waitForProcessingSinkMessages(tenant, namespace, sinkName, numMessages));
+                // validate the sink result
+                tester.validateSinkResult(kvs);
+            }
+        } finally {
+            // always print the content of the logs, in order to ease debugging
+            pulsarCluster.dumpFunctionLogs(sinkName);
+        }
+
+        // update the sink
+        updateSinkConnector(tester, tenant, namespace, sinkName, inputTopicName);
+
+        // delete the sink
+        deleteSink(tenant, namespace, sinkName);
+
+        // get sink info (sink should be deleted)
+        getSinkInfoNotFound(tenant, namespace, sinkName);
+    }
+
+    @SuppressWarnings("rawtypes")
+    protected void prepareSink(SinkTester tester) throws Exception {
+        tester.prepareSink();
+    }
+
+    protected void submitSinkConnector(@SuppressWarnings("rawtypes") SinkTester tester,
+                                       String tenant,
+                                       String namespace,
+                                       String sinkName,
+                                       String inputTopicName) throws Exception {
+        String[] commands;
+        if (tester.getSinkType() != SinkTester.SinkType.UNDEFINED) {
+            commands = new String[] {
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sink", "create",
+                    "--tenant", tenant,
+                    "--namespace", namespace,
+                    "--name", sinkName,
+                    "--sink-type", tester.sinkType().getValue().toLowerCase(),
+                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
+                    "--inputs", inputTopicName,
+                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
+            };
+        } else {
+            commands = new String[] {
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sink", "create",
+                    "--tenant", tenant,
+                    "--namespace", namespace,
+                    "--name", sinkName,
+                    "--archive", tester.getSinkArchive(),
+                    "--classname", tester.getSinkClassName(),
+                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
+                    "--inputs", inputTopicName,
+                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
+            };
+        }
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+            result.getStdout().contains("Created successfully"),
+            result.getStdout());
+    }
+
+    protected void updateSinkConnector(@SuppressWarnings("rawtypes") SinkTester tester,
+                                       String tenant,
+                                       String namespace,
+                                       String sinkName,
+                                       String inputTopicName) throws Exception {
+        String[] commands;
+        if (tester.getSinkType() != SinkTester.SinkType.UNDEFINED) {
+            commands = new String[] {
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sink", "update",
+                    "--tenant", tenant,
+                    "--namespace", namespace,
+                    "--name", sinkName,
+                    "--sink-type", tester.sinkType().getValue().toLowerCase(),
+                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
+                    "--inputs", inputTopicName,
+                    "--parallelism", "2",
+                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
+            };
+        } else {
+            commands = new String[] {
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sink", "update",
+                    "--tenant", tenant,
+                    "--namespace", namespace,
+                    "--name", sinkName,
+                    "--archive", tester.getSinkArchive(),
+                    "--classname", tester.getSinkClassName(),
+                    "--sinkConfig", new Gson().toJson(tester.sinkConfig()),
+                    "--inputs", inputTopicName,
+                    "--parallelism", "2",
+                    "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
+            };
+        }
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Updated successfully"),
+                result.getStdout());
+    }
+
+    protected void getSinkInfoSuccess(@SuppressWarnings("rawtypes") SinkTester tester,
+                                      String tenant,
+                                      String namespace,
+                                      String sinkName,
+                                      boolean builtin) throws Exception {
+        String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "sink",
+            "get",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sinkName
+        };
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get sink info : {}", result.getStdout());
+        if (builtin) {
+            assertTrue(
+                    result.getStdout().contains("\"archive\": \"builtin://"
+                            + tester.getSinkType().getValue().toLowerCase() + "\""),
+                    result.getStdout()
+            );
+        } else {
+            assertTrue(
+                    result.getStdout().contains("\"className\": \"" + tester.getSinkClassName() + "\""),
+                    result.getStdout()
+            );
+        }
+    }
+
+    protected void getSinkStatus(String tenant, String namespace, String sinkName) throws Exception {
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "sink",
+            "status",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sinkName
+        };
+
+        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get sink status : {}", result.getStdout());
+
+        assertEquals(result.getExitCode(), 0);
+
+        SinkStatus sinkStatus = SinkStatusUtil.decode(result.getStdout());
+
+        assertEquals(sinkStatus.getNumInstances(), 1);
+        assertEquals(sinkStatus.getNumRunning(), 1);
+        assertEquals(sinkStatus.getInstances().size(), 1);
+        assertEquals(sinkStatus.getInstances().get(0).getInstanceId(), 0);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+    }
+
+    protected void deleteSink(String tenant, String namespace, String sinkName) throws Exception {
+
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "sink",
+            "delete",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sinkName
+        };
+
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+            result.getStdout().contains("Deleted successfully"),
+            result.getStdout()
+        );
+        result.assertNoStderr();
+    }
+
+    protected void getSinkInfoNotFound(String tenant, String namespace, String sinkName) throws Exception {
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "sink",
+            "get",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sinkName
+        };
+        try {
+            pulsarCluster.getAnyWorker().execCmd(commands);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Sink " + sinkName + " doesn't exist"));
+        }
+    }
+
+    protected void waitForProcessingSinkMessages(String tenant,
+                                                 String namespace,
+                                                 String sinkName,
+                                                 int numMessages) throws Exception {
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "sink",
+                "status",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sinkName
+        };
+
+        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get sink status : {}", result.getStdout());
+
+        assertEquals(result.getExitCode(), 0);
+
+        final SinkStatus sinkStatus = SinkStatusUtil.decode(result.getStdout());
+
+        assertEquals(sinkStatus.getNumInstances(), 1);
+        assertEquals(sinkStatus.getNumRunning(), 1);
+        assertEquals(sinkStatus.getInstances().size(), 1);
+        assertEquals(sinkStatus.getInstances().get(0).getInstanceId(), 0);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertTrue(sinkStatus.getInstances().get(0).getStatus().getLastReceivedTime() > 0);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumReadFromPulsar(), numMessages);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumWrittenToSink(), numMessages);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(sinkStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+    }
+
+    // This for JdbcPostgresSinkTester
+    protected Map<String, String> produceSchemaInsertMessagesToInputTopic(String inputTopicName,
+                                                                          int numMessages,
+                                                                          Schema<Foo> schema) throws Exception {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+            .build();
+
+        @Cleanup
+        Producer<Foo> producer = client.newProducer(schema)
+            .topic(inputTopicName)
+            .create();
+
+        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
+        for (int i = 0; i < numMessages; i++) {
+            String key = "key-" + i;
+
+            JdbcPostgresSinkTester.Foo obj = new JdbcPostgresSinkTester.Foo();
+            obj.setField1("field1_insert_" + i);
+            obj.setField2("field2_insert_" + i);
+            obj.setField3(i);
+            String value = new String(schema.encode(obj));
+            Map<String, String> properties = Maps.newHashMap();
+            properties.put("ACTION", "INSERT");
+
+            kvs.put(key, value);
+            kvs.put("ACTION", "INSERT");
+            producer.newMessage()
+                    .properties(properties)
+                    .key(key)
+                    .value(obj)
+                    .send();
+        }
+        return kvs;
+    }
+
+    // This for JdbcPostgresSinkTester
+    protected Map<String, String> produceSchemaUpdateMessagesToInputTopic(String inputTopicName,
+                                                                          int numMessages,
+                                                                          Schema<Foo> schema) throws Exception {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        Producer<Foo> producer = client.newProducer(schema)
+                .topic(inputTopicName)
+                .create();
+
+        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
+        log.info("update start");
+        for (int i = 0; i < numMessages; i++) {
+            String key = "key-" + i;
+
+            JdbcPostgresSinkTester.Foo obj = new JdbcPostgresSinkTester.Foo();
+            obj.setField1("field1_insert_" + i);
+            obj.setField2("field2_update_" + i);
+            obj.setField3(i);
+            String value = new String(schema.encode(obj));
+            Map<String, String> properties = Maps.newHashMap();
+            properties.put("ACTION", "UPDATE");
+
+            kvs.put(key, value);
+            kvs.put("ACTION", "UPDATE");
+            producer.newMessage()
+                    .properties(properties)
+                    .key(key)
+                    .value(obj)
+                    .send();
+        }
+        log.info("update end");
+        return kvs;
+    }
+
+    // This for JdbcPostgresSinkTester
+    protected Map<String, String> produceSchemaDeleteMessagesToInputTopic(String inputTopicName,
+                                                                          int numMessages,
+                                                                          Schema<Foo> schema) throws Exception {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        Producer<Foo> producer = client.newProducer(schema)
+                .topic(inputTopicName)
+                .create();
+
+        LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
+        for (int i = 0; i < numMessages; i++) {
+            String key = "key-" + i;
+
+            JdbcPostgresSinkTester.Foo obj = new JdbcPostgresSinkTester.Foo();
+            obj.setField1("field1_insert_" + i);
+            obj.setField2("field2_update_" + i);
+            obj.setField3(i);
+            String value = new String(schema.encode(obj));
+            Map<String, String> properties = Maps.newHashMap();
+            properties.put("ACTION", "DELETE");
+
+            kvs.put(key, value);
+            kvs.put("ACTION", "DELETE");
+            producer.newMessage()
+                    .properties(properties)
+                    .key(key)
+                    .value(obj)
+                    .send();
+        }
+        return kvs;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarSinksTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarSinksTest.java
index 0663b4d44f..26ad584c1c 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarSinksTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/PulsarSinksTest.java
@@ -1,94 +1,94 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-
-import org.apache.pulsar.tests.integration.io.PulsarIOTestBase;
-import org.apache.pulsar.tests.integration.io.RabbitMQSinkTester;
-import org.apache.pulsar.tests.integration.io.RabbitMQSourceTester;
-import org.apache.pulsar.tests.integration.io.sources.KafkaSourceTester;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-
-public class PulsarSinksTest extends PulsarIOTestBase {
-
-    public PulsarSinksTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-
-    @DataProvider(name = "withSchema")
-    public Object[][] withSchema() {
-        return new Object[][]{{Boolean.TRUE}, {Boolean.FALSE}};
-    }
-
-    @Test(groups = "sink")
-    public void testKafkaSink() throws Exception {
-        final String kafkaContainerName = "kafka-" + randomName(8);
-        testSink(new KafkaSinkTester(kafkaContainerName), true, new KafkaSourceTester(kafkaContainerName));
-    }
-
-    @Test(groups = "sink")
-    public void testCassandraSink() throws Exception {
-        testSink(CassandraSinkTester.createTester(true), true);
-    }
-
-    @Test(groups = "sink")
-    public void testCassandraArchiveSink() throws Exception {
-        testSink(CassandraSinkTester.createTester(false), false);
-    }
-
-    @Test(enabled = false, groups = "sink")
-    public void testHdfsSink() throws Exception {
-        testSink(new HdfsSinkTester(), false);
-    }
-
-    @Test(groups = "sink", dataProvider = "withSchema")
-    public void testJdbcSink(boolean kvSchema) throws Exception {
-        testSink(new JdbcPostgresSinkTester(kvSchema), true);
-    }
-
-    @Test(groups = "sink", dataProvider = "withSchema")
-    public void testElasticSearch7Sink(boolean withSchema) throws Exception {
-        testSink(new ElasticSearch7SinkTester(withSchema), true);
-    }
-
-    @Test(groups = "sink", dataProvider = "withSchema")
-    public void testElasticSearch8Sink(boolean withSchema) throws Exception {
-        testSink(new ElasticSearch8SinkTester(withSchema), true);
-    }
-
-    @Test(groups = "sink", dataProvider = "withSchema")
-    public void testOpenSearchSinkRawData(boolean withSchema) throws Exception {
-        testSink(new OpenSearchSinkTester(withSchema), true);
-    }
-
-    @Test(groups = "sink")
-    public void testRabbitMQSink() throws Exception {
-        final String containerName = "rabbitmq-" + randomName(8);
-        testSink(new RabbitMQSinkTester(containerName), true, new RabbitMQSourceTester(containerName));
-    }
-
-    @Test(groups = "sink", dataProvider = "withSchema")
-    public void testKinesis(boolean withSchema) throws Exception {
-        testSink(new KinesisSinkTester(withSchema), true);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+
+import org.apache.pulsar.tests.integration.io.PulsarIOTestBase;
+import org.apache.pulsar.tests.integration.io.RabbitMQSinkTester;
+import org.apache.pulsar.tests.integration.io.RabbitMQSourceTester;
+import org.apache.pulsar.tests.integration.io.sources.KafkaSourceTester;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+
+public class PulsarSinksTest extends PulsarIOTestBase {
+
+    public PulsarSinksTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+
+    @DataProvider(name = "withSchema")
+    public Object[][] withSchema() {
+        return new Object[][]{{Boolean.TRUE}, {Boolean.FALSE}};
+    }
+
+    @Test(groups = "sink")
+    public void testKafkaSink() throws Exception {
+        final String kafkaContainerName = "kafka-" + randomName(8);
+        testSink(new KafkaSinkTester(kafkaContainerName), true, new KafkaSourceTester(kafkaContainerName));
+    }
+
+    @Test(groups = "sink")
+    public void testCassandraSink() throws Exception {
+        testSink(CassandraSinkTester.createTester(true), true);
+    }
+
+    @Test(groups = "sink")
+    public void testCassandraArchiveSink() throws Exception {
+        testSink(CassandraSinkTester.createTester(false), false);
+    }
+
+    @Test(enabled = false, groups = "sink")
+    public void testHdfsSink() throws Exception {
+        testSink(new HdfsSinkTester(), false);
+    }
+
+    @Test(groups = "sink", dataProvider = "withSchema")
+    public void testJdbcSink(boolean kvSchema) throws Exception {
+        testSink(new JdbcPostgresSinkTester(kvSchema), true);
+    }
+
+    @Test(groups = "sink", dataProvider = "withSchema")
+    public void testElasticSearch7Sink(boolean withSchema) throws Exception {
+        testSink(new ElasticSearch7SinkTester(withSchema), true);
+    }
+
+    @Test(groups = "sink", dataProvider = "withSchema")
+    public void testElasticSearch8Sink(boolean withSchema) throws Exception {
+        testSink(new ElasticSearch8SinkTester(withSchema), true);
+    }
+
+    @Test(groups = "sink", dataProvider = "withSchema")
+    public void testOpenSearchSinkRawData(boolean withSchema) throws Exception {
+        testSink(new OpenSearchSinkTester(withSchema), true);
+    }
+
+    @Test(groups = "sink")
+    public void testRabbitMQSink() throws Exception {
+        final String containerName = "rabbitmq-" + randomName(8);
+        testSink(new RabbitMQSinkTester(containerName), true, new RabbitMQSourceTester(containerName));
+    }
+
+    @Test(groups = "sink", dataProvider = "withSchema")
+    public void testKinesis(boolean withSchema) throws Exception {
+        testSink(new KinesisSinkTester(withSchema), true);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ScyllaDBSinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ScyllaDBSinkTester.java
new file mode 100644
index 0000000000..850546ed37
--- /dev/null
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/ScyllaDBSinkTester.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import static org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase.randomName;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import com.datastax.driver.core.Cluster;
+import com.datastax.driver.core.ResultSet;
+import com.datastax.driver.core.Row;
+import com.datastax.driver.core.Session;
+import java.util.List;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.PulsarVersion;
+import org.apache.pulsar.tests.integration.containers.ScyllaDBContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+/**
+ * A tester for testing ScyllaDB sink.
+ *
+ * This class demonstrates ScyllaDB's drop-in compatibility with Apache Cassandra
+ * by reusing the existing Cassandra sink connector (pulsar-io-cassandra) without
+ * any modifications. ScyllaDB is protocol-compatible with Cassandra and works
+ * seamlessly with the DataStax Cassandra driver.
+ *
+ * The test validates that:
+ * - The Cassandra sink connector works identically with ScyllaDB
+ * - No production code changes are needed
+ * - The same CQL commands and data validation logic work
+ * - ScyllaDB is truly a drop-in replacement for Cassandra in Pulsar
+ */
+@Slf4j
+public class ScyllaDBSinkTester extends SinkTester<ScyllaDBContainer> {
+
+    public static ScyllaDBSinkTester createTester(boolean builtin) {
+        if (builtin) {
+            return new ScyllaDBSinkTester(builtin);
+        } else {
+            return new ScyllaDBSinkTester();
+        }
+    }
+
+    private static final String NAME = "scylladb";
+
+    // Network alias matches the ScyllaDBContainer NAME
+    private static final String ROOTS = "scylladb";
+    private static final String KEY = "key";
+    private static final String COLUMN = "col";
+
+    // We use the SAME Cassandra connector archive
+    private static final String ARCHIVE = "/pulsar/connectors/pulsar-io-cassandra-"
+            + PulsarVersion.getVersion() + ".nar";
+
+    private final String keySpace;
+    private final String tableName;
+
+    private Cluster cluster;
+    private Session session;
+
+    private ScyllaDBSinkTester() {
+        // Use the SAME Cassandra sink class - key to drop-in compatibility
+        super(NAME, ARCHIVE, "org.apache.pulsar.io.cassandra.CassandraStringSink");
+
+        String suffix = randomName(8) + "_" + System.currentTimeMillis();
+        this.keySpace = "keySpace_" + suffix;
+        this.tableName = "tableName_" + suffix;
+
+        // Configuration is identical to Cassandra, only the network alias differs
+        sinkConfig.put("roots", ROOTS);
+        sinkConfig.put("keyspace", keySpace);
+        sinkConfig.put("columnFamily", tableName);
+        sinkConfig.put("keyname", KEY);
+        sinkConfig.put("columnName", COLUMN);
+    }
+
+    private ScyllaDBSinkTester(boolean builtin) {
+        // Using SinkType.CASSANDRA because ScyllaDB is Cassandra-compatible
+        super(NAME, SinkType.CASSANDRA);
+
+        String suffix = randomName(8) + "_" + System.currentTimeMillis();
+        this.keySpace = "keySpace_" + suffix;
+        this.tableName = "tableName_" + suffix;
+
+        sinkConfig.put("roots", ROOTS);
+        sinkConfig.put("keyspace", keySpace);
+        sinkConfig.put("columnFamily", tableName);
+        sinkConfig.put("keyname", KEY);
+        sinkConfig.put("columnName", COLUMN);
+    }
+
+    @Override
+    protected ScyllaDBContainer createSinkService(PulsarCluster cluster) {
+        return new ScyllaDBContainer(cluster.getClusterName());
+    }
+
+    @Override
+    public void prepareSink() {
+        // Build cluster connection using DataStax Cassandra driver
+        cluster = Cluster.builder()
+                .addContactPoint("localhost")
+                .withPort(serviceContainer.getScyllaDBPort())
+                .withoutJMXReporting()
+                .build();
+
+        session = cluster.connect();
+        log.info("Connecting to ScyllaDB cluster at localhost:{}", serviceContainer.getScyllaDBPort());
+
+        String createKeySpace =
+                "CREATE KEYSPACE " + keySpace
+                        + " WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}; ";
+        log.info(createKeySpace);
+        session.execute(createKeySpace);
+        session.execute("USE " + keySpace);
+
+        String createTable = "CREATE TABLE " + tableName
+                + "(" + KEY + " text PRIMARY KEY, "
+                + COLUMN + " text);";
+        log.info(createTable);
+        session.execute(createTable);
+    }
+
+    @Override
+    public void validateSinkResult(Map<String, String> kvs) {
+        // Same CQL as Cassandra tests
+        String query = "SELECT * FROM " + tableName + ";";
+        ResultSet result = session.execute(query);
+        List<Row> rows = result.all();
+
+        assertEquals(kvs.size(), rows.size());
+        for (Row row : rows) {
+            String key = row.getString(KEY);
+            String value = row.getString(COLUMN);
+
+            String expectedValue = kvs.get(key);
+            assertNotNull(expectedValue);
+            assertEquals(expectedValue, value);
+        }
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (session != null) {
+            session.close();
+            session = null;
+        }
+        if (cluster != null) {
+            cluster.close();
+            cluster = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/SinkTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/SinkTester.java
index 5ae947892e..02ca8c616e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/SinkTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sinks/SinkTester.java
@@ -1,129 +1,129 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sinks;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-import lombok.Cleanup;
-import lombok.Getter;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testcontainers.containers.GenericContainer;
-import org.testng.collections.Maps;
-
-/**
- * A tester used for testing a specific sink.
- */
-@Getter
-public abstract class SinkTester<ServiceContainerT extends GenericContainer> implements AutoCloseable {
-
-    @Getter
-    public enum SinkType {
-        UNDEFINED("undefined"),
-        CASSANDRA("cassandra"),
-        KAFKA("kafka"),
-        KINESIS("kinesis"),
-        JDBC_POSTGRES("jdbc-postgres"),
-        HDFS("hdfs"),
-        ELASTIC_SEARCH("elastic_search"),
-        RABBITMQ("rabbitmq");
-
-        private final String value;
-
-        SinkType(String value) {
-            this.value = value;
-        }
-    }
-
-    protected final String networkAlias;
-    protected final SinkType sinkType;
-    protected final String sinkArchive;
-    protected final String sinkClassName;
-    protected final Map<String, Object> sinkConfig;
-    protected ServiceContainerT serviceContainer;
-
-    public SinkTester(String networkAlias, SinkType sinkType) {
-        this.networkAlias = networkAlias;
-        this.sinkType = sinkType;
-        this.sinkArchive = null;
-        this.sinkClassName = null;
-        this.sinkConfig = Maps.newHashMap();
-    }
-
-    public SinkTester(String networkAlias, String sinkArchive, String sinkClassName) {
-        this.networkAlias = networkAlias;
-        this.sinkType = SinkType.UNDEFINED;
-        this.sinkArchive = sinkArchive;
-        this.sinkClassName = sinkClassName;
-        this.sinkConfig = Maps.newHashMap();
-    }
-
-    public Schema<?> getInputTopicSchema() {
-        return Schema.STRING;
-    }
-
-    protected abstract ServiceContainerT createSinkService(PulsarCluster cluster);
-
-    public ServiceContainerT startServiceContainer(PulsarCluster cluster) {
-        this.serviceContainer = createSinkService(cluster);
-        cluster.startService(networkAlias, serviceContainer);
-        return serviceContainer;
-    }
-
-    public void stopServiceContainer() {
-        if (null != serviceContainer) {
-            PulsarCluster.stopService(networkAlias, serviceContainer);
-        }
-    }
-
-    public SinkType sinkType() {
-        return sinkType;
-    }
-
-    public Map<String, Object> sinkConfig() {
-        return sinkConfig;
-    }
-
-    public abstract void prepareSink() throws Exception;
-
-    public abstract void validateSinkResult(Map<String, String> kvs);
-
-    public void produceMessage(int numMessages,
-                               PulsarClient client,
-                               String inputTopicName,
-                               LinkedHashMap<String, String> kvs) throws Exception {
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopicName)
-                .create();
-
-        for (int i = 0; i < numMessages; i++) {
-            String key = "key-" + i;
-            String value = "value-" + i;
-            kvs.put(key, value);
-            producer.newMessage()
-                    .key(key)
-                    .value(value)
-                    .send();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sinks;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import lombok.Cleanup;
+import lombok.Getter;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testcontainers.containers.GenericContainer;
+import org.testng.collections.Maps;
+
+/**
+ * A tester used for testing a specific sink.
+ */
+@Getter
+public abstract class SinkTester<ServiceContainerT extends GenericContainer> implements AutoCloseable {
+
+    @Getter
+    public enum SinkType {
+        UNDEFINED("undefined"),
+        CASSANDRA("cassandra"),
+        KAFKA("kafka"),
+        KINESIS("kinesis"),
+        JDBC_POSTGRES("jdbc-postgres"),
+        HDFS("hdfs"),
+        ELASTIC_SEARCH("elastic_search"),
+        RABBITMQ("rabbitmq");
+
+        private final String value;
+
+        SinkType(String value) {
+            this.value = value;
+        }
+    }
+
+    protected final String networkAlias;
+    protected final SinkType sinkType;
+    protected final String sinkArchive;
+    protected final String sinkClassName;
+    protected final Map<String, Object> sinkConfig;
+    protected ServiceContainerT serviceContainer;
+
+    public SinkTester(String networkAlias, SinkType sinkType) {
+        this.networkAlias = networkAlias;
+        this.sinkType = sinkType;
+        this.sinkArchive = null;
+        this.sinkClassName = null;
+        this.sinkConfig = Maps.newHashMap();
+    }
+
+    public SinkTester(String networkAlias, String sinkArchive, String sinkClassName) {
+        this.networkAlias = networkAlias;
+        this.sinkType = SinkType.UNDEFINED;
+        this.sinkArchive = sinkArchive;
+        this.sinkClassName = sinkClassName;
+        this.sinkConfig = Maps.newHashMap();
+    }
+
+    public Schema<?> getInputTopicSchema() {
+        return Schema.STRING;
+    }
+
+    protected abstract ServiceContainerT createSinkService(PulsarCluster cluster);
+
+    public ServiceContainerT startServiceContainer(PulsarCluster cluster) {
+        this.serviceContainer = createSinkService(cluster);
+        cluster.startService(networkAlias, serviceContainer);
+        return serviceContainer;
+    }
+
+    public void stopServiceContainer() {
+        if (null != serviceContainer) {
+            PulsarCluster.stopService(networkAlias, serviceContainer);
+        }
+    }
+
+    public SinkType sinkType() {
+        return sinkType;
+    }
+
+    public Map<String, Object> sinkConfig() {
+        return sinkConfig;
+    }
+
+    public abstract void prepareSink() throws Exception;
+
+    public abstract void validateSinkResult(Map<String, String> kvs);
+
+    public void produceMessage(int numMessages,
+                               PulsarClient client,
+                               String inputTopicName,
+                               LinkedHashMap<String, String> kvs) throws Exception {
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopicName)
+                .create();
+
+        for (int i = 0; i < numMessages; i++) {
+            String key = "key-" + i;
+            String value = "value-" + i;
+            kvs.put(key, value);
+            producer.newMessage()
+                    .key(key)
+                    .value(value)
+                    .send();
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/AvroKafkaSourceTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/AvroKafkaSourceTest.java
index 771bb5b539..7c9db7e5ff 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/AvroKafkaSourceTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/AvroKafkaSourceTest.java
@@ -1,515 +1,515 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import com.google.common.collect.ImmutableMap;
-import com.google.gson.Gson;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import lombok.Data;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.avro.io.DatumWriter;
-import org.apache.avro.io.EncoderFactory;
-import org.apache.avro.io.JsonEncoder;
-import org.apache.avro.reflect.ReflectData;
-import org.apache.avro.reflect.ReflectDatumWriter;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.Field;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.common.policies.data.SourceStatusUtil;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTestBase;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.awaitility.Awaitility;
-import org.testcontainers.containers.Container.ExecResult;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.KafkaContainer;
-import org.testcontainers.containers.wait.strategy.Wait;
-import org.testcontainers.images.builder.Transferable;
-import org.testcontainers.utility.DockerImageName;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * A tester for testing kafka source with Avro Messages.
- * This test starts a PulsarCluster, a container with a Kafka Broker
- * and a container with the SchemaRegistry.
- * It populates a Kafka topic with Avro encoded messages with schema
- * and then it verifies that the records are correclty received
- * but a Pulsar Consumer
- */
-@Slf4j
-public class AvroKafkaSourceTest extends PulsarFunctionsTestBase {
-    public static final String CONFLUENT_PLATFORM_VERSION = System.getProperty("confluent.version", "7.8.2");
-
-    private static final String SOURCE_TYPE = "kafka";
-
-    private final String kafkaTopicName = "kafkasourcetopic";
-
-    private EnhancedKafkaContainer kafkaContainer;
-    private SchemaRegistryContainer schemaRegistryContainer;
-
-    protected final Map<String, Object> sourceConfig;
-    protected final String kafkaContainerName = "kafkacontainer";
-    protected final String schemaRegistryContainerName = "schemaregistry";
-
-    public AvroKafkaSourceTest() {
-        sourceConfig = new HashMap<>();
-    }
-
-    @Test(groups = "source")
-    public void test() throws Exception {
-        startKafkaContainers(pulsarCluster);
-        try {
-            testSource();
-        } finally {
-            stopKafkaContainers();
-        }
-    }
-
-    private String getBootstrapServersOnDockerNetwork() {
-        return kafkaContainerName + ":9093";
-    }
-
-
-    public void startKafkaContainers(PulsarCluster cluster) throws Exception {
-        this.kafkaContainer = createKafkaContainer(cluster);
-        cluster.startService(kafkaContainerName, kafkaContainer);
-        log.info("creating schema registry kafka {}",  getBootstrapServersOnDockerNetwork());
-        this.schemaRegistryContainer = new SchemaRegistryContainer(getBootstrapServersOnDockerNetwork());
-        cluster.startService(schemaRegistryContainerName, schemaRegistryContainer);
-        sourceConfig.put("bootstrapServers", getBootstrapServersOnDockerNetwork());
-        sourceConfig.put("groupId", "test-source-group");
-        sourceConfig.put("fetchMinBytes", 1L);
-        sourceConfig.put("autoCommitIntervalMs", 10L);
-        sourceConfig.put("sessionTimeoutMs", 10000L);
-        sourceConfig.put("heartbeatIntervalMs", 5000L);
-        sourceConfig.put("topic", kafkaTopicName);
-        sourceConfig.put("valueDeserializationClass", "io.confluent.kafka.serializers.KafkaAvroDeserializer");
-        sourceConfig.put("consumerConfigProperties",
-                ImmutableMap.of("schema.registry.url", getRegistryAddressInDockerNetwork())
-        );
-    }
-
-    private class EnhancedKafkaContainer extends KafkaContainer {
-
-        public EnhancedKafkaContainer(DockerImageName dockerImageName) {
-            super(dockerImageName);
-        }
-
-        @Override
-        public String getBootstrapServers() {
-            // we have to override this function
-            // because we want the Kafka Broker to advertise itself
-            // with the docker network address
-            // otherwise the Kafka Schema Registry won't work
-            return "PLAINTEXT://" + kafkaContainerName + ":9093";
-        }
-
-    }
-
-    protected EnhancedKafkaContainer createKafkaContainer(PulsarCluster cluster) {
-        return (EnhancedKafkaContainer) new EnhancedKafkaContainer(
-                DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
-                .withEmbeddedZookeeper()
-                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd
-                        .withName(kafkaContainerName)
-                );
-    }
-
-    public void stopKafkaContainers() {
-        if (null != schemaRegistryContainer) {
-            PulsarCluster.stopService(schemaRegistryContainerName, schemaRegistryContainer);
-        }
-        if (null != kafkaContainer) {
-            PulsarCluster.stopService(kafkaContainerName, kafkaContainer);
-        }
-    }
-
-    public void prepareSource() throws Exception {
-        log.info("creating topic");
-        ExecResult execResult = kafkaContainer.execInContainer(
-            "/usr/bin/kafka-topics",
-            "--create",
-            "--bootstrap-server",
-            getBootstrapServersOnDockerNetwork(),
-            "--partitions",
-            "1",
-            "--replication-factor",
-            "1",
-            "--topic",
-            kafkaTopicName);
-        assertTrue(
-            execResult.getStdout().contains("Created topic"),
-            execResult.getStdout());
-
-    }
-
-    private String getZooKeeperAddressInDockerNetwork() {
-        return kafkaContainerName + ":2181";
-    }
-
-    private void testSource()  throws Exception {
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "test-source-connector-"
-                + functionRuntimeType + "-output-topic-" + randomName(8);
-        final String sourceName = "test-source-connector-"
-                + functionRuntimeType + "-name-" + randomName(8);
-        final int numMessages = 10;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        Consumer<GenericRecord> consumer = client.newConsumer(Schema.AUTO_CONSUME())
-                .topic(outputTopicName)
-                .subscriptionName("sourcetester")
-                .subscribe();
-
-        // prepare the testing environment for source
-        prepareSource();
-
-        // submit the source connector
-        submitSourceConnector(tenant, namespace, sourceName, outputTopicName);
-
-        // get source info
-        getSourceInfoSuccess(tenant, namespace, sourceName);
-
-        // get source status
-        Awaitility.with()
-                .timeout(Duration.ofMinutes(1))
-                .pollInterval(Duration.ofSeconds(10))
-                .until(() -> {
-                    try {
-                        getSourceStatus(tenant, namespace, sourceName);
-                        return true;
-                    } catch (Throwable ex) {
-                        log.error("Error while getting source status, will retry", ex);
-                        return false;
-                    }
-                });
-        // produce messages
-        List<MyBean> messages = produceSourceMessages(numMessages);
-
-        // wait for source to process messages
-        Awaitility.with()
-                .timeout(Duration.ofMinutes(1))
-                .pollInterval(Duration.ofSeconds(10))
-                .until(() -> {
-                    try {
-                        waitForProcessingSourceMessages(tenant, namespace, sourceName, numMessages);
-                        return true;
-                    } catch (Throwable ex) {
-                        log.error("Error while processing source messages, will retry", ex);
-                        return false;
-                    }
-                });
-
-        // validate the source result
-       validateSourceResultAvro(consumer, messages);
-
-        // delete the source
-        deleteSource(tenant, namespace, sourceName);
-
-        // get source info (source should be deleted)
-        getSourceInfoNotFound(tenant, namespace, sourceName);
-    }
-
-    public void validateSourceResultAvro(Consumer<GenericRecord> consumer,
-                                         List<MyBean> beans) throws Exception {
-        int recordsNumber = 0;
-        Message<GenericRecord> msg = consumer.receive(10, TimeUnit.SECONDS);
-        while (msg != null) {
-            GenericRecord valueRecord = msg.getValue();
-            Assert.assertNotNull(valueRecord.getFields());
-            Assert.assertTrue(valueRecord.getFields().size() > 0);
-            for (Field field : valueRecord.getFields()) {
-                log.info("field {} value {}", field, valueRecord.getField(field));
-            }
-            assertEquals(beans.get(recordsNumber).field, valueRecord.getField("field"));
-            consumer.acknowledge(msg);
-            recordsNumber++;
-            msg = consumer.receive(10, TimeUnit.SECONDS);
-        }
-
-        Assert.assertEquals(recordsNumber, beans.size());
-        log.info("Stop {} server container. topic: {} has {} records.", kafkaContainerName, consumer.getTopic(),
-                recordsNumber);
-    }
-
-    protected void getSourceInfoSuccess(String tenant,
-                                        String namespace,
-                                        String sourceName) throws Exception {
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source",
-                "get",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName
-        };
-
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get source info : {}", result.getStdout());
-        assertTrue(
-                result.getStdout().contains("\"archive\": \"builtin://" + SOURCE_TYPE + "\""),
-                result.getStdout()
-        );
-    }
-
-    protected void getSourceStatus(String tenant, String namespace, String sourceName) throws Exception {
-
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source",
-                "status",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName
-        };
-
-        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get source status : {}", result.getStdout());
-
-        assertEquals(result.getExitCode(), 0);
-
-        final SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
-
-        assertEquals(sourceStatus.getNumInstances(), 1);
-        assertEquals(sourceStatus.getNumRunning(), 1);
-        assertEquals(sourceStatus.getInstances().size(), 1);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-
-    }
-
-    protected void submitSourceConnector(String tenant,
-                                         String namespace,
-                                         String sourceName,
-                                         String outputTopicName) throws Exception {
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source", "create",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName,
-                "--source-type", SOURCE_TYPE,
-                "--sourceConfig", new Gson().toJson(sourceConfig),
-                "--destinationTopicName", outputTopicName
-        };
-
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    @Data
-    public static final class MyBean {
-        private String field;
-    }
-
-    public List<MyBean> produceSourceMessages(int numMessages) throws Exception{
-        org.apache.avro.Schema schema = ReflectData.get().getSchema(MyBean.class);
-        String schemaDef = schema.toString(false);
-        log.info("schema {}", schemaDef);
-
-        List<MyBean> written = new ArrayList<>();
-        StringBuilder payload = new StringBuilder();
-        for (int i = 0; i < numMessages; i++) {
-            MyBean bean = new MyBean();
-            bean.setField("value" + i);
-            String serialized = serializeBeanUsingAvro(schema, bean);
-            payload.append(serialized);
-            if (i != numMessages - 1) {
-                // do not add a newline in the end of the file
-                payload.append("\n");
-            }
-            written.add(bean);
-        }
-
-        // write messages to Kafka using kafka-avro-console-producer
-        // we are writing the serialized values to the stdin of kafka-avro-console-producer
-        // the only way to do it with TestContainers is actually to create a bash script
-        // and execute it
-        String bashFileTemplate = "echo '" + payload + "' "
-                + "| /usr/bin/kafka-avro-console-producer "
-                + "--broker-list " + getBootstrapServersOnDockerNetwork() + " "
-                + "--property 'value.schema=" + schemaDef + "' "
-                + "--property schema.registry.url=" + getRegistryAddressInDockerNetwork() + " "
-                + "--topic " + kafkaTopicName;
-        String file = "/home/appuser/produceRecords.sh";
-
-        schemaRegistryContainer.copyFileToContainer(Transferable
-                        .of(bashFileTemplate.getBytes(StandardCharsets.UTF_8), 0777), file);
-
-        ExecResult cat = schemaRegistryContainer.execInContainer("cat", file);
-        log.info("cat results: " + cat.getStdout());
-        log.info("cat stderr: " + cat.getStderr());
-
-        ExecResult execResult = schemaRegistryContainer.execInContainer("/bin/bash", file);
-
-        log.info("script results: " + execResult.getStdout());
-        log.info("script stderr: " + execResult.getStderr());
-        assertTrue(execResult.getStdout().contains("Closing the Kafka producer"),
-                execResult.getStdout() + " " + execResult.getStderr());
-        // filter out the SLF4J warnings
-        String stderrFiltered = execResult.getStderr()
-                .replaceAll("(?m)^SLF4J: .*?[\\r\\n]+", "")
-                .trim();
-        assertTrue(stderrFiltered.isEmpty(), stderrFiltered);
-
-        log.info("Successfully produced {} messages to kafka topic {}", numMessages, kafkaTopicName);
-        return written;
-    }
-
-    private static String serializeBeanUsingAvro(org.apache.avro.Schema schema, MyBean bean) throws IOException {
-        DatumWriter<MyBean> userDatumWriter = new ReflectDatumWriter<>(schema);
-        ByteArrayOutputStream stream = new ByteArrayOutputStream();
-        JsonEncoder encoder = EncoderFactory.get().jsonEncoder(schema, stream);
-        userDatumWriter.write(bean, encoder);
-        encoder.flush();
-        String serialized = new String(stream.toByteArray(), StandardCharsets.UTF_8);
-        return serialized;
-    }
-
-    protected void waitForProcessingSourceMessages(String tenant,
-                                                   String namespace,
-                                                   String sourceName,
-                                                   int numMessages) throws Exception {
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source",
-                "status",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName
-        };
-
-        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get source status : {}", result.getStdout());
-
-        assertEquals(result.getExitCode(), 0);
-
-        SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
-        assertEquals(sourceStatus.getNumInstances(), 1);
-        assertEquals(sourceStatus.getNumRunning(), 1);
-        assertEquals(sourceStatus.getInstances().size(), 1);
-        assertEquals(sourceStatus.getInstances().get(0).getInstanceId(), 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertTrue(sourceStatus.getInstances().get(0).getStatus().getLastReceivedTime() > 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumReceivedFromSource(), numMessages);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumWritten(), numMessages);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-    }
-
-    protected void deleteSource(String tenant, String namespace, String sourceName) throws Exception {
-
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source",
-                "delete",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName
-        };
-
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Delete source successfully"),
-                result.getStdout()
-        );
-        assertTrue(
-                result.getStderr().isEmpty(),
-                result.getStderr()
-        );
-    }
-
-    protected void getSourceInfoNotFound(String tenant, String namespace, String sourceName) throws Exception {
-
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source",
-                "get",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName
-        };
-
-        try {
-            pulsarCluster.getAnyWorker().execCmd(commands);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-
-    public class SchemaRegistryContainer extends GenericContainer<SchemaRegistryContainer> {
-        private static final int SCHEMA_REGISTRY_INTERNAL_PORT = 8081;
-
-        public SchemaRegistryContainer(String boostrapServers) throws Exception {
-            super("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION);
-
-            addEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", boostrapServers);
-            addEnv("SCHEMA_REGISTRY_HOST_NAME", schemaRegistryContainerName);
-
-            withExposedPorts(SCHEMA_REGISTRY_INTERNAL_PORT);
-            withLogConsumer(o -> {
-                log.info("schemaregistry> {}", o.getUtf8String());
-            });
-            waitingFor(Wait.forHttp("/subjects"));
-        }
-    }
-
-    private String getRegistryAddressInDockerNetwork() {
-        return "http://" + schemaRegistryContainerName + ":8081";
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import com.google.common.collect.ImmutableMap;
+import com.google.gson.Gson;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import lombok.Data;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.avro.io.DatumWriter;
+import org.apache.avro.io.EncoderFactory;
+import org.apache.avro.io.JsonEncoder;
+import org.apache.avro.reflect.ReflectData;
+import org.apache.avro.reflect.ReflectDatumWriter;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.Field;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.common.policies.data.SourceStatusUtil;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.functions.PulsarFunctionsTestBase;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.awaitility.Awaitility;
+import org.testcontainers.containers.Container.ExecResult;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.wait.strategy.Wait;
+import org.testcontainers.images.builder.Transferable;
+import org.testcontainers.utility.DockerImageName;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * A tester for testing kafka source with Avro Messages.
+ * This test starts a PulsarCluster, a container with a Kafka Broker
+ * and a container with the SchemaRegistry.
+ * It populates a Kafka topic with Avro encoded messages with schema
+ * and then it verifies that the records are correclty received
+ * but a Pulsar Consumer
+ */
+@Slf4j
+public class AvroKafkaSourceTest extends PulsarFunctionsTestBase {
+    public static final String CONFLUENT_PLATFORM_VERSION = System.getProperty("confluent.version", "7.8.2");
+
+    private static final String SOURCE_TYPE = "kafka";
+
+    private final String kafkaTopicName = "kafkasourcetopic";
+
+    private EnhancedKafkaContainer kafkaContainer;
+    private SchemaRegistryContainer schemaRegistryContainer;
+
+    protected final Map<String, Object> sourceConfig;
+    protected final String kafkaContainerName = "kafkacontainer";
+    protected final String schemaRegistryContainerName = "schemaregistry";
+
+    public AvroKafkaSourceTest() {
+        sourceConfig = new HashMap<>();
+    }
+
+    @Test(groups = "source")
+    public void test() throws Exception {
+        startKafkaContainers(pulsarCluster);
+        try {
+            testSource();
+        } finally {
+            stopKafkaContainers();
+        }
+    }
+
+    private String getBootstrapServersOnDockerNetwork() {
+        return kafkaContainerName + ":9093";
+    }
+
+
+    public void startKafkaContainers(PulsarCluster cluster) throws Exception {
+        this.kafkaContainer = createKafkaContainer(cluster);
+        cluster.startService(kafkaContainerName, kafkaContainer);
+        log.info("creating schema registry kafka {}",  getBootstrapServersOnDockerNetwork());
+        this.schemaRegistryContainer = new SchemaRegistryContainer(getBootstrapServersOnDockerNetwork());
+        cluster.startService(schemaRegistryContainerName, schemaRegistryContainer);
+        sourceConfig.put("bootstrapServers", getBootstrapServersOnDockerNetwork());
+        sourceConfig.put("groupId", "test-source-group");
+        sourceConfig.put("fetchMinBytes", 1L);
+        sourceConfig.put("autoCommitIntervalMs", 10L);
+        sourceConfig.put("sessionTimeoutMs", 10000L);
+        sourceConfig.put("heartbeatIntervalMs", 5000L);
+        sourceConfig.put("topic", kafkaTopicName);
+        sourceConfig.put("valueDeserializationClass", "io.confluent.kafka.serializers.KafkaAvroDeserializer");
+        sourceConfig.put("consumerConfigProperties",
+                ImmutableMap.of("schema.registry.url", getRegistryAddressInDockerNetwork())
+        );
+    }
+
+    private class EnhancedKafkaContainer extends KafkaContainer {
+
+        public EnhancedKafkaContainer(DockerImageName dockerImageName) {
+            super(dockerImageName);
+        }
+
+        @Override
+        public String getBootstrapServers() {
+            // we have to override this function
+            // because we want the Kafka Broker to advertise itself
+            // with the docker network address
+            // otherwise the Kafka Schema Registry won't work
+            return "PLAINTEXT://" + kafkaContainerName + ":9093";
+        }
+
+    }
+
+    protected EnhancedKafkaContainer createKafkaContainer(PulsarCluster cluster) {
+        return (EnhancedKafkaContainer) new EnhancedKafkaContainer(
+                DockerImageName.parse("confluentinc/cp-kafka:" + CONFLUENT_PLATFORM_VERSION))
+                .withEmbeddedZookeeper()
+                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd
+                        .withName(kafkaContainerName)
+                );
+    }
+
+    public void stopKafkaContainers() {
+        if (null != schemaRegistryContainer) {
+            PulsarCluster.stopService(schemaRegistryContainerName, schemaRegistryContainer);
+        }
+        if (null != kafkaContainer) {
+            PulsarCluster.stopService(kafkaContainerName, kafkaContainer);
+        }
+    }
+
+    public void prepareSource() throws Exception {
+        log.info("creating topic");
+        ExecResult execResult = kafkaContainer.execInContainer(
+            "/usr/bin/kafka-topics",
+            "--create",
+            "--bootstrap-server",
+            getBootstrapServersOnDockerNetwork(),
+            "--partitions",
+            "1",
+            "--replication-factor",
+            "1",
+            "--topic",
+            kafkaTopicName);
+        assertTrue(
+            execResult.getStdout().contains("Created topic"),
+            execResult.getStdout());
+
+    }
+
+    private String getZooKeeperAddressInDockerNetwork() {
+        return kafkaContainerName + ":2181";
+    }
+
+    private void testSource()  throws Exception {
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "test-source-connector-"
+                + functionRuntimeType + "-output-topic-" + randomName(8);
+        final String sourceName = "test-source-connector-"
+                + functionRuntimeType + "-name-" + randomName(8);
+        final int numMessages = 10;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        Consumer<GenericRecord> consumer = client.newConsumer(Schema.AUTO_CONSUME())
+                .topic(outputTopicName)
+                .subscriptionName("sourcetester")
+                .subscribe();
+
+        // prepare the testing environment for source
+        prepareSource();
+
+        // submit the source connector
+        submitSourceConnector(tenant, namespace, sourceName, outputTopicName);
+
+        // get source info
+        getSourceInfoSuccess(tenant, namespace, sourceName);
+
+        // get source status
+        Awaitility.with()
+                .timeout(Duration.ofMinutes(1))
+                .pollInterval(Duration.ofSeconds(10))
+                .until(() -> {
+                    try {
+                        getSourceStatus(tenant, namespace, sourceName);
+                        return true;
+                    } catch (Throwable ex) {
+                        log.error("Error while getting source status, will retry", ex);
+                        return false;
+                    }
+                });
+        // produce messages
+        List<MyBean> messages = produceSourceMessages(numMessages);
+
+        // wait for source to process messages
+        Awaitility.with()
+                .timeout(Duration.ofMinutes(1))
+                .pollInterval(Duration.ofSeconds(10))
+                .until(() -> {
+                    try {
+                        waitForProcessingSourceMessages(tenant, namespace, sourceName, numMessages);
+                        return true;
+                    } catch (Throwable ex) {
+                        log.error("Error while processing source messages, will retry", ex);
+                        return false;
+                    }
+                });
+
+        // validate the source result
+       validateSourceResultAvro(consumer, messages);
+
+        // delete the source
+        deleteSource(tenant, namespace, sourceName);
+
+        // get source info (source should be deleted)
+        getSourceInfoNotFound(tenant, namespace, sourceName);
+    }
+
+    public void validateSourceResultAvro(Consumer<GenericRecord> consumer,
+                                         List<MyBean> beans) throws Exception {
+        int recordsNumber = 0;
+        Message<GenericRecord> msg = consumer.receive(10, TimeUnit.SECONDS);
+        while (msg != null) {
+            GenericRecord valueRecord = msg.getValue();
+            Assert.assertNotNull(valueRecord.getFields());
+            Assert.assertTrue(valueRecord.getFields().size() > 0);
+            for (Field field : valueRecord.getFields()) {
+                log.info("field {} value {}", field, valueRecord.getField(field));
+            }
+            assertEquals(beans.get(recordsNumber).field, valueRecord.getField("field"));
+            consumer.acknowledge(msg);
+            recordsNumber++;
+            msg = consumer.receive(10, TimeUnit.SECONDS);
+        }
+
+        Assert.assertEquals(recordsNumber, beans.size());
+        log.info("Stop {} server container. topic: {} has {} records.", kafkaContainerName, consumer.getTopic(),
+                recordsNumber);
+    }
+
+    protected void getSourceInfoSuccess(String tenant,
+                                        String namespace,
+                                        String sourceName) throws Exception {
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source",
+                "get",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName
+        };
+
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get source info : {}", result.getStdout());
+        assertTrue(
+                result.getStdout().contains("\"archive\": \"builtin://" + SOURCE_TYPE + "\""),
+                result.getStdout()
+        );
+    }
+
+    protected void getSourceStatus(String tenant, String namespace, String sourceName) throws Exception {
+
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source",
+                "status",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName
+        };
+
+        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get source status : {}", result.getStdout());
+
+        assertEquals(result.getExitCode(), 0);
+
+        final SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
+
+        assertEquals(sourceStatus.getNumInstances(), 1);
+        assertEquals(sourceStatus.getNumRunning(), 1);
+        assertEquals(sourceStatus.getInstances().size(), 1);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+
+    }
+
+    protected void submitSourceConnector(String tenant,
+                                         String namespace,
+                                         String sourceName,
+                                         String outputTopicName) throws Exception {
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source", "create",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName,
+                "--source-type", SOURCE_TYPE,
+                "--sourceConfig", new Gson().toJson(sourceConfig),
+                "--destinationTopicName", outputTopicName
+        };
+
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    @Data
+    public static final class MyBean {
+        private String field;
+    }
+
+    public List<MyBean> produceSourceMessages(int numMessages) throws Exception{
+        org.apache.avro.Schema schema = ReflectData.get().getSchema(MyBean.class);
+        String schemaDef = schema.toString(false);
+        log.info("schema {}", schemaDef);
+
+        List<MyBean> written = new ArrayList<>();
+        StringBuilder payload = new StringBuilder();
+        for (int i = 0; i < numMessages; i++) {
+            MyBean bean = new MyBean();
+            bean.setField("value" + i);
+            String serialized = serializeBeanUsingAvro(schema, bean);
+            payload.append(serialized);
+            if (i != numMessages - 1) {
+                // do not add a newline in the end of the file
+                payload.append("\n");
+            }
+            written.add(bean);
+        }
+
+        // write messages to Kafka using kafka-avro-console-producer
+        // we are writing the serialized values to the stdin of kafka-avro-console-producer
+        // the only way to do it with TestContainers is actually to create a bash script
+        // and execute it
+        String bashFileTemplate = "echo '" + payload + "' "
+                + "| /usr/bin/kafka-avro-console-producer "
+                + "--broker-list " + getBootstrapServersOnDockerNetwork() + " "
+                + "--property 'value.schema=" + schemaDef + "' "
+                + "--property schema.registry.url=" + getRegistryAddressInDockerNetwork() + " "
+                + "--topic " + kafkaTopicName;
+        String file = "/home/appuser/produceRecords.sh";
+
+        schemaRegistryContainer.copyFileToContainer(Transferable
+                        .of(bashFileTemplate.getBytes(StandardCharsets.UTF_8), 0777), file);
+
+        ExecResult cat = schemaRegistryContainer.execInContainer("cat", file);
+        log.info("cat results: " + cat.getStdout());
+        log.info("cat stderr: " + cat.getStderr());
+
+        ExecResult execResult = schemaRegistryContainer.execInContainer("/bin/bash", file);
+
+        log.info("script results: " + execResult.getStdout());
+        log.info("script stderr: " + execResult.getStderr());
+        assertTrue(execResult.getStdout().contains("Closing the Kafka producer"),
+                execResult.getStdout() + " " + execResult.getStderr());
+        // filter out the SLF4J warnings
+        String stderrFiltered = execResult.getStderr()
+                .replaceAll("(?m)^SLF4J: .*?[\\r\\n]+", "")
+                .trim();
+        assertTrue(stderrFiltered.isEmpty(), stderrFiltered);
+
+        log.info("Successfully produced {} messages to kafka topic {}", numMessages, kafkaTopicName);
+        return written;
+    }
+
+    private static String serializeBeanUsingAvro(org.apache.avro.Schema schema, MyBean bean) throws IOException {
+        DatumWriter<MyBean> userDatumWriter = new ReflectDatumWriter<>(schema);
+        ByteArrayOutputStream stream = new ByteArrayOutputStream();
+        JsonEncoder encoder = EncoderFactory.get().jsonEncoder(schema, stream);
+        userDatumWriter.write(bean, encoder);
+        encoder.flush();
+        String serialized = new String(stream.toByteArray(), StandardCharsets.UTF_8);
+        return serialized;
+    }
+
+    protected void waitForProcessingSourceMessages(String tenant,
+                                                   String namespace,
+                                                   String sourceName,
+                                                   int numMessages) throws Exception {
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source",
+                "status",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName
+        };
+
+        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get source status : {}", result.getStdout());
+
+        assertEquals(result.getExitCode(), 0);
+
+        SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
+        assertEquals(sourceStatus.getNumInstances(), 1);
+        assertEquals(sourceStatus.getNumRunning(), 1);
+        assertEquals(sourceStatus.getInstances().size(), 1);
+        assertEquals(sourceStatus.getInstances().get(0).getInstanceId(), 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertTrue(sourceStatus.getInstances().get(0).getStatus().getLastReceivedTime() > 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumReceivedFromSource(), numMessages);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumWritten(), numMessages);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+    }
+
+    protected void deleteSource(String tenant, String namespace, String sourceName) throws Exception {
+
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source",
+                "delete",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName
+        };
+
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Delete source successfully"),
+                result.getStdout()
+        );
+        assertTrue(
+                result.getStderr().isEmpty(),
+                result.getStderr()
+        );
+    }
+
+    protected void getSourceInfoNotFound(String tenant, String namespace, String sourceName) throws Exception {
+
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source",
+                "get",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName
+        };
+
+        try {
+            pulsarCluster.getAnyWorker().execCmd(commands);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+
+    public class SchemaRegistryContainer extends GenericContainer<SchemaRegistryContainer> {
+        private static final int SCHEMA_REGISTRY_INTERNAL_PORT = 8081;
+
+        public SchemaRegistryContainer(String boostrapServers) throws Exception {
+            super("confluentinc/cp-schema-registry:" + CONFLUENT_PLATFORM_VERSION);
+
+            addEnv("SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS", boostrapServers);
+            addEnv("SCHEMA_REGISTRY_HOST_NAME", schemaRegistryContainerName);
+
+            withExposedPorts(SCHEMA_REGISTRY_INTERNAL_PORT);
+            withLogConsumer(o -> {
+                log.info("schemaregistry> {}", o.getUtf8String());
+            });
+            waitingFor(Wait.forHttp("/subjects"));
+        }
+    }
+
+    private String getRegistryAddressInDockerNetwork() {
+        return "http://" + schemaRegistryContainerName + ":8081";
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/BatchSourceTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/BatchSourceTest.java
index b3e225c375..96d5e8ba66 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/BatchSourceTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/BatchSourceTest.java
@@ -1,222 +1,222 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.apache.pulsar.tests.integration.suites.PulsarTestSuite.retryStrategically;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * This tests verifies that a batch source can be successfully submitted and run via the pulsar-admin CLI.
- */
-@Slf4j
-public class BatchSourceTest extends PulsarStandaloneTestSuite {
-
-    private static final String BATCH_CONFIG = "{\"discoveryTriggererConfig\": {\"__CRON__\": \"* * * * * *\"}, "
-            + "\"discoveryTriggererClassName\": \"org.apache.pulsar.io.batchdiscovery.CronTriggerer\"}";
-
-    @Test(groups = {"source"})
-    public void testGenericRecordSource() throws Exception {
-        String outputTopicName = "test-state-source-output-" + randomName(8);
-        String sourceName = "test-state-source-" + randomName(8);
-        int numMessages = 10;
-        try {
-            submitSourceConnector(
-                    sourceName,
-                    outputTopicName,
-                    "builtin://batch-data-generator");
-
-            // get source info
-            getSourceInfoSuccess(container, sourceName);
-
-            // get source status
-            getSourceStatus(container, sourceName);
-
-            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-                retryStrategically((test) -> {
-                    try {
-                        SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                        return status.getInstances().size() > 0
-                                && status.getInstances().get(0).getStatus().numWritten >= 10;
-                    } catch (PulsarAdminException e) {
-                        return false;
-                    }
-                }, 10, 200);
-
-                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWritten >= 10);
-            }
-
-            consumeMessages(container, outputTopicName, numMessages);
-
-            // delete source
-            deleteSource(container, sourceName);
-
-            getSourceInfoNotFound(container, sourceName);
-        } finally {
-            dumpFunctionLogs(sourceName);
-        }
-
-    }
-
-    private void submitSourceConnector(String sourceName,
-                                       String outputTopicName,
-                                       String archive) throws Exception {
-        String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "sources", "create",
-            "--name", sourceName,
-            "--destinationTopicName", outputTopicName,
-            "--archive", archive,
-            "--batch-source-config", BATCH_CONFIG
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-            result.getStdout().contains("Created successfully"),
-            result.getStdout());
-    }
-
-    private static void getSourceInfoSuccess(StandaloneContainer container, String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "sources",
-            "get",
-            "--tenant", "public",
-            "--namespace", "default",
-            "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
-    }
-
-    private static void getSourceStatus(StandaloneContainer container, String sourceName) throws Exception {
-        retryStrategically((test) -> {
-                    try {
-                        ContainerExecResult result = container.execCmd(
-                                PulsarCluster.ADMIN_SCRIPT,
-                                "sources",
-                                "status",
-                                "--tenant", "public",
-                                "--namespace", "default",
-                                "--name", sourceName);
-
-                        if (result.getStdout().contains("\"running\" : true")) {
-                            return true;
-                        }
-                        return false;
-                    } catch (Exception e) {
-                        log.error("Encountered error when getting source status", e);
-                        return false;
-                    }
-                }, 10, 200);
-
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName);
-
-        Assert.assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private static void consumeMessages(StandaloneContainer container, String outputTopic,
-                                        int numMessages) throws Exception {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(container.getPlainTextServiceUrl())
-            .build();
-
-        // read using Pulsar GenericRecord abstraction
-        @Cleanup
-        Consumer<GenericRecord> consumer = client.newConsumer(Schema.AUTO_CONSUME())
-            .topic(outputTopic)
-            .subscriptionType(SubscriptionType.Exclusive)
-            .subscriptionName("test-sub")
-            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-            .startMessageIdInclusive()
-            .subscribe();
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<GenericRecord> msg = consumer.receive(10, TimeUnit.SECONDS);
-            if (msg == null) {
-                fail("message " + i + " not received in time");
-                return;
-            }
-            log.info("received {}", msg.getValue());
-            msg.getValue().getFields().forEach(f -> {
-                log.info("field {} {}", f, msg.getValue().getField(f));
-            });
-        }
-    }
-
-    private static void deleteSource(StandaloneContainer container, String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "sources",
-            "delete",
-            "--tenant", "public",
-            "--namespace", "default",
-            "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("Delete source successfully"));
-        assertTrue(result.getStderr().isEmpty());
-    }
-
-    private static void getSourceInfoNotFound(StandaloneContainer container, String sourceName) throws Exception {
-        try {
-            container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.apache.pulsar.tests.integration.suites.PulsarTestSuite.retryStrategically;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * This tests verifies that a batch source can be successfully submitted and run via the pulsar-admin CLI.
+ */
+@Slf4j
+public class BatchSourceTest extends PulsarStandaloneTestSuite {
+
+    private static final String BATCH_CONFIG = "{\"discoveryTriggererConfig\": {\"__CRON__\": \"* * * * * *\"}, "
+            + "\"discoveryTriggererClassName\": \"org.apache.pulsar.io.batchdiscovery.CronTriggerer\"}";
+
+    @Test(groups = {"source"})
+    public void testGenericRecordSource() throws Exception {
+        String outputTopicName = "test-state-source-output-" + randomName(8);
+        String sourceName = "test-state-source-" + randomName(8);
+        int numMessages = 10;
+        try {
+            submitSourceConnector(
+                    sourceName,
+                    outputTopicName,
+                    "builtin://batch-data-generator");
+
+            // get source info
+            getSourceInfoSuccess(container, sourceName);
+
+            // get source status
+            getSourceStatus(container, sourceName);
+
+            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+                retryStrategically((test) -> {
+                    try {
+                        SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                        return status.getInstances().size() > 0
+                                && status.getInstances().get(0).getStatus().numWritten >= 10;
+                    } catch (PulsarAdminException e) {
+                        return false;
+                    }
+                }, 10, 200);
+
+                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWritten >= 10);
+            }
+
+            consumeMessages(container, outputTopicName, numMessages);
+
+            // delete source
+            deleteSource(container, sourceName);
+
+            getSourceInfoNotFound(container, sourceName);
+        } finally {
+            dumpFunctionLogs(sourceName);
+        }
+
+    }
+
+    private void submitSourceConnector(String sourceName,
+                                       String outputTopicName,
+                                       String archive) throws Exception {
+        String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "sources", "create",
+            "--name", sourceName,
+            "--destinationTopicName", outputTopicName,
+            "--archive", archive,
+            "--batch-source-config", BATCH_CONFIG
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+            result.getStdout().contains("Created successfully"),
+            result.getStdout());
+    }
+
+    private static void getSourceInfoSuccess(StandaloneContainer container, String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "sources",
+            "get",
+            "--tenant", "public",
+            "--namespace", "default",
+            "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
+    }
+
+    private static void getSourceStatus(StandaloneContainer container, String sourceName) throws Exception {
+        retryStrategically((test) -> {
+                    try {
+                        ContainerExecResult result = container.execCmd(
+                                PulsarCluster.ADMIN_SCRIPT,
+                                "sources",
+                                "status",
+                                "--tenant", "public",
+                                "--namespace", "default",
+                                "--name", sourceName);
+
+                        if (result.getStdout().contains("\"running\" : true")) {
+                            return true;
+                        }
+                        return false;
+                    } catch (Exception e) {
+                        log.error("Encountered error when getting source status", e);
+                        return false;
+                    }
+                }, 10, 200);
+
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName);
+
+        Assert.assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private static void consumeMessages(StandaloneContainer container, String outputTopic,
+                                        int numMessages) throws Exception {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(container.getPlainTextServiceUrl())
+            .build();
+
+        // read using Pulsar GenericRecord abstraction
+        @Cleanup
+        Consumer<GenericRecord> consumer = client.newConsumer(Schema.AUTO_CONSUME())
+            .topic(outputTopic)
+            .subscriptionType(SubscriptionType.Exclusive)
+            .subscriptionName("test-sub")
+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+            .startMessageIdInclusive()
+            .subscribe();
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<GenericRecord> msg = consumer.receive(10, TimeUnit.SECONDS);
+            if (msg == null) {
+                fail("message " + i + " not received in time");
+                return;
+            }
+            log.info("received {}", msg.getValue());
+            msg.getValue().getFields().forEach(f -> {
+                log.info("field {} {}", f, msg.getValue().getField(f));
+            });
+        }
+    }
+
+    private static void deleteSource(StandaloneContainer container, String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "sources",
+            "delete",
+            "--tenant", "public",
+            "--namespace", "default",
+            "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("Delete source successfully"));
+        assertTrue(result.getStderr().isEmpty());
+    }
+
+    private static void getSourceInfoNotFound(StandaloneContainer container, String sourceName) throws Exception {
+        try {
+            container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/DataGeneratorSourceTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/DataGeneratorSourceTest.java
index 10b8e3cbd2..2c74d4a0ed 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/DataGeneratorSourceTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/DataGeneratorSourceTest.java
@@ -1,246 +1,246 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.apache.pulsar.tests.integration.suites.PulsarTestSuite.retryStrategically;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import com.google.gson.Gson;
-import java.util.ArrayList;
-import java.util.List;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.common.functions.BatchingConfig;
-import org.apache.pulsar.common.functions.ProducerConfig;
-import org.apache.pulsar.common.io.SourceConfig;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * This tests verifies that a batch source can be successfully submitted and run via the pulsar-admin CLI.
- */
-@Slf4j
-public class DataGeneratorSourceTest extends PulsarStandaloneTestSuite {
-
-    @Test(groups = {"source"})
-    public void testSource() throws Exception {
-        testGenericRecordSource(null);
-    }
-
-    @Test(groups = {"source"})
-    public void testSourceCustomBatching() throws Exception {
-        BatchingConfig config = BatchingConfig.builder()
-                .enabled(true)
-                .batchingMaxPublishDelayMs(5)
-                .roundRobinRouterBatchingPartitionSwitchFrequency(10)
-                .batchingMaxMessages(10)
-                .batchingMaxBytes(32 * 1024)
-                .batchBuilder("KEY_BASED")
-                .build();
-        testGenericRecordSource(config);
-    }
-
-    @Test(groups = {"source"})
-    public void testSourceDisableBatching() throws Exception {
-        BatchingConfig config = BatchingConfig.builder()
-                .enabled(false)
-                .build();
-        testGenericRecordSource(config);
-    }
-
-    public void testGenericRecordSource(BatchingConfig config) throws Exception {
-        String outputTopicName = "test-state-source-output-" + randomName(8);
-        String sourceName = "test-state-source-" + randomName(8);
-        int numMessages = 10;
-        try {
-            ProducerConfig producerConfig = null;
-            if (config != null) {
-                producerConfig = ProducerConfig.builder()
-                        .batchingConfig(config)
-                        .build();
-            }
-            submitSourceConnector(
-                    sourceName,
-                    outputTopicName,
-                    "builtin://data-generator",
-                    producerConfig);
-
-            // get source info
-            String info = getSourceInfoSuccess(container, sourceName);
-            SourceConfig sourceConfig =
-                    ObjectMapperFactory.getMapper().getObjectMapper().readValue(info, SourceConfig.class);
-            // checking batching config is applied
-            checkBatchingConfig(sourceName, config, sourceConfig);
-
-            // get source status
-            getSourceStatus(container, sourceName);
-
-            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-                retryStrategically((test) -> {
-                    try {
-                        SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                        return status.getInstances().size() > 0
-                                && status.getInstances().get(0).getStatus().numWritten >= 10;
-                    } catch (PulsarAdminException e) {
-                        return false;
-                    }
-                }, 10, 200);
-
-                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWritten >= 10);
-            }
-
-            // delete source
-            deleteSource(container, sourceName);
-
-            getSourceInfoNotFound(container, sourceName);
-        } finally {
-            dumpFunctionLogs(sourceName);
-        }
-    }
-
-    private void submitSourceConnector(String sourceName,
-                                       String outputTopicName,
-                                       String archive,
-                                       ProducerConfig producerConfig) throws Exception {
-        List<String> commands = new ArrayList<>(List.of(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources", "create",
-                "--name", sourceName,
-                "--destinationTopicName", outputTopicName,
-                "--archive", archive
-        ));
-        if (producerConfig != null) {
-            commands.add("--producer-config");
-            commands.add(new Gson().toJson(producerConfig));
-        }
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands.toArray(new String[0]));
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    private static String getSourceInfoSuccess(StandaloneContainer container, String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
-        return result.getStdout();
-    }
-
-    private static void getSourceStatus(StandaloneContainer container, String sourceName) throws Exception {
-        retryStrategically((test) -> {
-            try {
-                ContainerExecResult result = container.execCmd(
-                        PulsarCluster.ADMIN_SCRIPT,
-                        "sources",
-                        "status",
-                        "--tenant", "public",
-                        "--namespace", "default",
-                        "--name", sourceName);
-
-                if (result.getStdout().contains("\"running\" : true")) {
-                    return true;
-                }
-                return false;
-            } catch (Exception e) {
-                log.error("Encountered error when getting source status", e);
-                return false;
-            }
-        }, 10, 200);
-
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName);
-
-        Assert.assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    // checking batching config, we can only check this by checking the logs for now
-    private void checkBatchingConfig(String functionName, BatchingConfig config, SourceConfig sourceConfig) {
-        if (config != null) {
-            assertNotNull(sourceConfig.getProducerConfig());
-            assertNotNull(sourceConfig.getProducerConfig().getBatchingConfig());
-            assertEquals(config.toString(), sourceConfig.getProducerConfig().getBatchingConfig().toString());
-        }
-
-        String functionLogs = getFunctionLogs(functionName);
-        if (config == null || config.isEnabled()) {
-            BatchingConfig finalConfig = config;
-            if (finalConfig == null) {
-                finalConfig = BatchingConfig.builder().build();
-            }
-            assertTrue(functionLogs.contains(finalConfig.toString()));
-        } else {
-            assertTrue(functionLogs.contains("BatchingConfig(enabled=false"));
-        }
-    }
-
-    private static void deleteSource(StandaloneContainer container, String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("Delete source successfully"));
-        assertTrue(result.getStderr().isEmpty());
-    }
-
-    private static void getSourceInfoNotFound(StandaloneContainer container, String sourceName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sources",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", sourceName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.apache.pulsar.tests.integration.suites.PulsarTestSuite.retryStrategically;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import com.google.gson.Gson;
+import java.util.ArrayList;
+import java.util.List;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.common.functions.BatchingConfig;
+import org.apache.pulsar.common.functions.ProducerConfig;
+import org.apache.pulsar.common.io.SourceConfig;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * This tests verifies that a batch source can be successfully submitted and run via the pulsar-admin CLI.
+ */
+@Slf4j
+public class DataGeneratorSourceTest extends PulsarStandaloneTestSuite {
+
+    @Test(groups = {"source"})
+    public void testSource() throws Exception {
+        testGenericRecordSource(null);
+    }
+
+    @Test(groups = {"source"})
+    public void testSourceCustomBatching() throws Exception {
+        BatchingConfig config = BatchingConfig.builder()
+                .enabled(true)
+                .batchingMaxPublishDelayMs(5)
+                .roundRobinRouterBatchingPartitionSwitchFrequency(10)
+                .batchingMaxMessages(10)
+                .batchingMaxBytes(32 * 1024)
+                .batchBuilder("KEY_BASED")
+                .build();
+        testGenericRecordSource(config);
+    }
+
+    @Test(groups = {"source"})
+    public void testSourceDisableBatching() throws Exception {
+        BatchingConfig config = BatchingConfig.builder()
+                .enabled(false)
+                .build();
+        testGenericRecordSource(config);
+    }
+
+    public void testGenericRecordSource(BatchingConfig config) throws Exception {
+        String outputTopicName = "test-state-source-output-" + randomName(8);
+        String sourceName = "test-state-source-" + randomName(8);
+        int numMessages = 10;
+        try {
+            ProducerConfig producerConfig = null;
+            if (config != null) {
+                producerConfig = ProducerConfig.builder()
+                        .batchingConfig(config)
+                        .build();
+            }
+            submitSourceConnector(
+                    sourceName,
+                    outputTopicName,
+                    "builtin://data-generator",
+                    producerConfig);
+
+            // get source info
+            String info = getSourceInfoSuccess(container, sourceName);
+            SourceConfig sourceConfig =
+                    ObjectMapperFactory.getMapper().getObjectMapper().readValue(info, SourceConfig.class);
+            // checking batching config is applied
+            checkBatchingConfig(sourceName, config, sourceConfig);
+
+            // get source status
+            getSourceStatus(container, sourceName);
+
+            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+                retryStrategically((test) -> {
+                    try {
+                        SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                        return status.getInstances().size() > 0
+                                && status.getInstances().get(0).getStatus().numWritten >= 10;
+                    } catch (PulsarAdminException e) {
+                        return false;
+                    }
+                }, 10, 200);
+
+                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWritten >= 10);
+            }
+
+            // delete source
+            deleteSource(container, sourceName);
+
+            getSourceInfoNotFound(container, sourceName);
+        } finally {
+            dumpFunctionLogs(sourceName);
+        }
+    }
+
+    private void submitSourceConnector(String sourceName,
+                                       String outputTopicName,
+                                       String archive,
+                                       ProducerConfig producerConfig) throws Exception {
+        List<String> commands = new ArrayList<>(List.of(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources", "create",
+                "--name", sourceName,
+                "--destinationTopicName", outputTopicName,
+                "--archive", archive
+        ));
+        if (producerConfig != null) {
+            commands.add("--producer-config");
+            commands.add(new Gson().toJson(producerConfig));
+        }
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands.toArray(new String[0]));
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    private static String getSourceInfoSuccess(StandaloneContainer container, String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
+        return result.getStdout();
+    }
+
+    private static void getSourceStatus(StandaloneContainer container, String sourceName) throws Exception {
+        retryStrategically((test) -> {
+            try {
+                ContainerExecResult result = container.execCmd(
+                        PulsarCluster.ADMIN_SCRIPT,
+                        "sources",
+                        "status",
+                        "--tenant", "public",
+                        "--namespace", "default",
+                        "--name", sourceName);
+
+                if (result.getStdout().contains("\"running\" : true")) {
+                    return true;
+                }
+                return false;
+            } catch (Exception e) {
+                log.error("Encountered error when getting source status", e);
+                return false;
+            }
+        }, 10, 200);
+
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName);
+
+        Assert.assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    // checking batching config, we can only check this by checking the logs for now
+    private void checkBatchingConfig(String functionName, BatchingConfig config, SourceConfig sourceConfig) {
+        if (config != null) {
+            assertNotNull(sourceConfig.getProducerConfig());
+            assertNotNull(sourceConfig.getProducerConfig().getBatchingConfig());
+            assertEquals(config.toString(), sourceConfig.getProducerConfig().getBatchingConfig().toString());
+        }
+
+        String functionLogs = getFunctionLogs(functionName);
+        if (config == null || config.isEnabled()) {
+            BatchingConfig finalConfig = config;
+            if (finalConfig == null) {
+                finalConfig = BatchingConfig.builder().build();
+            }
+            assertTrue(functionLogs.contains(finalConfig.toString()));
+        } else {
+            assertTrue(functionLogs.contains("BatchingConfig(enabled=false"));
+        }
+    }
+
+    private static void deleteSource(StandaloneContainer container, String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("Delete source successfully"));
+        assertTrue(result.getStderr().isEmpty());
+    }
+
+    private static void getSourceInfoNotFound(StandaloneContainer container, String sourceName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sources",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", sourceName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/GenericRecordSourceTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/GenericRecordSourceTest.java
index a920e8fa93..eb06ad2c4a 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/GenericRecordSourceTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/GenericRecordSourceTest.java
@@ -1,257 +1,257 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
-import static org.apache.pulsar.tests.integration.suites.PulsarTestSuite.retryStrategically;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import lombok.Data;
-import lombok.ToString;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * This tests demonstrates how a Source can create messages using GenericRecord API
- * and the consumer is able to consume it as AVRO messages, with GenericRecord and with Java Model.
- */
-@Slf4j
-public class GenericRecordSourceTest extends PulsarStandaloneTestSuite {
-
-    @Test(groups = {"source"})
-    public void testGenericRecordSource() throws Exception {
-        String outputTopicName = "test-state-source-output-" + randomName(8);
-        String sourceName = "test-state-source-" + randomName(8);
-        int numMessages = 10;
-        try {
-            submitSourceConnector(
-                    sourceName,
-                    outputTopicName,
-                    "org.apache.pulsar.tests.integration.io.GenericRecordSource", JAVAJAR);
-
-            // get source info
-            getSourceInfoSuccess(container, sourceName);
-
-            // get source status
-            getSourceStatus(container, sourceName);
-
-            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-                retryStrategically((test) -> {
-                    try {
-                        SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                        return status.getInstances().size() > 0
-                                && status.getInstances().get(0).getStatus().numWritten >= 10;
-                    } catch (PulsarAdminException e) {
-                        return false;
-                    }
-                }, 10, 200);
-
-                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWritten >= 10);
-            }
-
-            consumeMessages(container, outputTopicName, numMessages);
-
-            // delete source
-            deleteSource(container, sourceName);
-
-            getSourceInfoNotFound(container, sourceName);
-        } finally {
-            dumpFunctionLogs(sourceName);
-        }
-
-    }
-
-    private void submitSourceConnector(String sourceName,
-                                       String outputTopicName,
-                                       String className,
-                                       String archive) throws Exception {
-        String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "sources", "create",
-            "--name", sourceName,
-            "--destinationTopicName", outputTopicName,
-            "--archive", archive,
-            "--classname", className
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-            result.getStdout().contains("Created successfully"),
-            result.getStdout());
-    }
-
-    private static void getSourceInfoSuccess(StandaloneContainer container, String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "sources",
-            "get",
-            "--tenant", "public",
-            "--namespace", "default",
-            "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
-    }
-
-    private static void getSourceStatus(StandaloneContainer container, String sourceName) throws Exception {
-        retryStrategically((test) -> {
-                    try {
-                        ContainerExecResult result = container.execCmd(
-                                PulsarCluster.ADMIN_SCRIPT,
-                                "sources",
-                                "status",
-                                "--tenant", "public",
-                                "--namespace", "default",
-                                "--name", sourceName);
-
-                        if (result.getStdout().contains("\"running\" : true")) {
-                            return true;
-                        }
-                        return false;
-                    } catch (Exception e) {
-                        log.error("Encountered error when getting source status", e);
-                        return false;
-                    }
-                }, 10, 200);
-
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName);
-
-        Assert.assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private static void consumeMessages(StandaloneContainer container, String outputTopic,
-                                        int numMessages) throws Exception {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(container.getPlainTextServiceUrl())
-            .build();
-
-        // read using Pulsar GenericRecord abstraction
-        @Cleanup
-        Consumer<GenericRecord> consumer = client.newConsumer(Schema.AUTO_CONSUME())
-            .topic(outputTopic)
-            .subscriptionType(SubscriptionType.Exclusive)
-            .subscriptionName("test-sub")
-            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-            .startMessageIdInclusive()
-            .subscribe();
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<GenericRecord> msg = consumer.receive(10, TimeUnit.SECONDS);
-            if (msg == null) {
-                fail("message " + i + " not received in time");
-                return;
-            }
-            log.info("received {}", msg.getValue());
-            msg.getValue().getFields().forEach(f -> {
-                log.info("field {} {}", f, msg.getValue().getField(f));
-            });
-            String text = (String) msg.getValue().getField("text");
-            int number = (Integer) msg.getValue().getField("number");
-
-            assertEquals(text, "value-" + number);
-        }
-
-        @Cleanup
-        Consumer<MyBean> typedConsumer = client.newConsumer(Schema.AVRO(MyBean.class))
-            .topic(outputTopic)
-            .subscriptionType(SubscriptionType.Exclusive)
-            .subscriptionName("test-sub-typed")
-            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-            .startMessageIdInclusive()
-            .subscribe();
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<MyBean> msg = typedConsumer.receive(10, TimeUnit.SECONDS);
-            if (msg == null) {
-                fail("message " + i + " not received in time");
-                return;
-            }
-            log.info("received {}", msg.getValue());
-            String text = msg.getValue().getText();
-            int number = msg.getValue().getNumber();
-            assertEquals(text, "value-" + number);
-        }
-
-    }
-
-    @Data
-    @ToString
-    public static class MyBean {
-        String text;
-        int number;
-    }
-
-    private static void deleteSource(StandaloneContainer container, String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-            PulsarCluster.ADMIN_SCRIPT,
-            "sources",
-            "delete",
-            "--tenant", "public",
-            "--namespace", "default",
-            "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("Delete source successfully"));
-        assertTrue(result.getStderr().isEmpty());
-    }
-
-    private static void getSourceInfoNotFound(StandaloneContainer container, String sourceName) throws Exception {
-        try {
-            container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
+import static org.apache.pulsar.tests.integration.suites.PulsarTestSuite.retryStrategically;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import lombok.Data;
+import lombok.ToString;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * This tests demonstrates how a Source can create messages using GenericRecord API
+ * and the consumer is able to consume it as AVRO messages, with GenericRecord and with Java Model.
+ */
+@Slf4j
+public class GenericRecordSourceTest extends PulsarStandaloneTestSuite {
+
+    @Test(groups = {"source"})
+    public void testGenericRecordSource() throws Exception {
+        String outputTopicName = "test-state-source-output-" + randomName(8);
+        String sourceName = "test-state-source-" + randomName(8);
+        int numMessages = 10;
+        try {
+            submitSourceConnector(
+                    sourceName,
+                    outputTopicName,
+                    "org.apache.pulsar.tests.integration.io.GenericRecordSource", JAVAJAR);
+
+            // get source info
+            getSourceInfoSuccess(container, sourceName);
+
+            // get source status
+            getSourceStatus(container, sourceName);
+
+            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+                retryStrategically((test) -> {
+                    try {
+                        SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                        return status.getInstances().size() > 0
+                                && status.getInstances().get(0).getStatus().numWritten >= 10;
+                    } catch (PulsarAdminException e) {
+                        return false;
+                    }
+                }, 10, 200);
+
+                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWritten >= 10);
+            }
+
+            consumeMessages(container, outputTopicName, numMessages);
+
+            // delete source
+            deleteSource(container, sourceName);
+
+            getSourceInfoNotFound(container, sourceName);
+        } finally {
+            dumpFunctionLogs(sourceName);
+        }
+
+    }
+
+    private void submitSourceConnector(String sourceName,
+                                       String outputTopicName,
+                                       String className,
+                                       String archive) throws Exception {
+        String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "sources", "create",
+            "--name", sourceName,
+            "--destinationTopicName", outputTopicName,
+            "--archive", archive,
+            "--classname", className
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+            result.getStdout().contains("Created successfully"),
+            result.getStdout());
+    }
+
+    private static void getSourceInfoSuccess(StandaloneContainer container, String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "sources",
+            "get",
+            "--tenant", "public",
+            "--namespace", "default",
+            "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
+    }
+
+    private static void getSourceStatus(StandaloneContainer container, String sourceName) throws Exception {
+        retryStrategically((test) -> {
+                    try {
+                        ContainerExecResult result = container.execCmd(
+                                PulsarCluster.ADMIN_SCRIPT,
+                                "sources",
+                                "status",
+                                "--tenant", "public",
+                                "--namespace", "default",
+                                "--name", sourceName);
+
+                        if (result.getStdout().contains("\"running\" : true")) {
+                            return true;
+                        }
+                        return false;
+                    } catch (Exception e) {
+                        log.error("Encountered error when getting source status", e);
+                        return false;
+                    }
+                }, 10, 200);
+
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName);
+
+        Assert.assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private static void consumeMessages(StandaloneContainer container, String outputTopic,
+                                        int numMessages) throws Exception {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(container.getPlainTextServiceUrl())
+            .build();
+
+        // read using Pulsar GenericRecord abstraction
+        @Cleanup
+        Consumer<GenericRecord> consumer = client.newConsumer(Schema.AUTO_CONSUME())
+            .topic(outputTopic)
+            .subscriptionType(SubscriptionType.Exclusive)
+            .subscriptionName("test-sub")
+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+            .startMessageIdInclusive()
+            .subscribe();
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<GenericRecord> msg = consumer.receive(10, TimeUnit.SECONDS);
+            if (msg == null) {
+                fail("message " + i + " not received in time");
+                return;
+            }
+            log.info("received {}", msg.getValue());
+            msg.getValue().getFields().forEach(f -> {
+                log.info("field {} {}", f, msg.getValue().getField(f));
+            });
+            String text = (String) msg.getValue().getField("text");
+            int number = (Integer) msg.getValue().getField("number");
+
+            assertEquals(text, "value-" + number);
+        }
+
+        @Cleanup
+        Consumer<MyBean> typedConsumer = client.newConsumer(Schema.AVRO(MyBean.class))
+            .topic(outputTopic)
+            .subscriptionType(SubscriptionType.Exclusive)
+            .subscriptionName("test-sub-typed")
+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+            .startMessageIdInclusive()
+            .subscribe();
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<MyBean> msg = typedConsumer.receive(10, TimeUnit.SECONDS);
+            if (msg == null) {
+                fail("message " + i + " not received in time");
+                return;
+            }
+            log.info("received {}", msg.getValue());
+            String text = msg.getValue().getText();
+            int number = msg.getValue().getNumber();
+            assertEquals(text, "value-" + number);
+        }
+
+    }
+
+    @Data
+    @ToString
+    public static class MyBean {
+        String text;
+        int number;
+    }
+
+    private static void deleteSource(StandaloneContainer container, String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+            PulsarCluster.ADMIN_SCRIPT,
+            "sources",
+            "delete",
+            "--tenant", "public",
+            "--namespace", "default",
+            "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("Delete source successfully"));
+        assertTrue(result.getStderr().isEmpty());
+    }
+
+    private static void getSourceInfoNotFound(StandaloneContainer container, String sourceName) throws Exception {
+        try {
+            container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/KafkaSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/KafkaSourceTester.java
index e3fe0f9a5b..a3bfd1cd83 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/KafkaSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/KafkaSourceTester.java
@@ -1,153 +1,153 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase.randomName;
-import static org.testng.Assert.assertTrue;
-import com.google.common.collect.ImmutableMap;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.UUID;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.kafka.clients.consumer.ConsumerConfig;
-import org.apache.kafka.clients.consumer.KafkaConsumer;
-import org.apache.kafka.clients.producer.KafkaProducer;
-import org.apache.kafka.clients.producer.ProducerConfig;
-import org.apache.kafka.clients.producer.ProducerRecord;
-import org.apache.kafka.common.serialization.StringDeserializer;
-import org.apache.kafka.common.serialization.StringSerializer;
-import org.testcontainers.containers.Container.ExecResult;
-import org.testcontainers.containers.KafkaContainer;
-
-/**
- * A tester for testing kafka source.
- */
-@Slf4j
-public class KafkaSourceTester extends SourceTester<KafkaContainer> {
-
-    private static final String SOURCE_TYPE = "kafka";
-
-    private final String kafkaTopicName;
-
-    private KafkaContainer kafkaContainer;
-
-    private KafkaConsumer<String, String> kafkaConsumer;
-
-    public KafkaSourceTester(String containerName) {
-        super(SOURCE_TYPE);
-        String suffix = randomName(8) + "_" + System.currentTimeMillis();
-        this.kafkaTopicName = "kafka_source_topic_" + suffix;
-
-        sourceConfig.put("bootstrapServers", containerName + ":9092");
-        sourceConfig.put("groupId", "test-source-group");
-        sourceConfig.put("fetchMinBytes", 1L);
-        sourceConfig.put("autoCommitIntervalMs", 10L);
-        sourceConfig.put("sessionTimeoutMs", 10000L);
-        sourceConfig.put("heartbeatIntervalMs", 5000L);
-        sourceConfig.put("topic", kafkaTopicName);
-        sourceConfig.put("valueDeserializationClass", "org.apache.kafka.common.serialization.ByteArrayDeserializer");
-    }
-
-    @Override
-    public void setServiceContainer(KafkaContainer container) {
-        this.kafkaContainer = container;
-    }
-
-    @Override
-    public void prepareSource() throws Exception {
-        ExecResult execResult = kafkaContainer.execInContainer(
-            "/usr/bin/kafka-topics",
-            "--create",
-            "--bootstrap-server",
-            "localhost:9092",
-            "--partitions",
-            "1",
-            "--replication-factor",
-            "1",
-            "--topic",
-            kafkaTopicName);
-        assertTrue(
-            execResult.getStdout().contains("Created topic"),
-            execResult.getStdout());
-
-        kafkaConsumer = new KafkaConsumer<>(
-            ImmutableMap.of(
-                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers(),
-                ConsumerConfig.GROUP_ID_CONFIG, "source-test-" + randomName(8),
-                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"
-            ),
-            new StringDeserializer(),
-            new StringDeserializer()
-        );
-        kafkaConsumer.subscribe(Arrays.asList(kafkaTopicName));
-        log.info("Successfully subscribe to kafka topic {}", kafkaTopicName);
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        // pass
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        // pass
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        // pass
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) throws Exception{
-        try (KafkaProducer<String, String> producer = new KafkaProducer<>(
-                ImmutableMap.of(
-                        ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers(),
-                        ProducerConfig.CLIENT_ID_CONFIG, UUID.randomUUID().toString()
-                ),
-                new StringSerializer(),
-                new StringSerializer()
-        )) {
-            LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
-            for (int i = 0; i < numMessages; i++) {
-                String key = "key-" + i;
-                String value = "value-" + i;
-                ProducerRecord<String, String> record = new ProducerRecord<>(
-                        kafkaTopicName,
-                        key,
-                        value
-                );
-                kvs.put(key, value);
-                producer.send(record).get();
-            }
-
-            log.info("Successfully produced {} messages to kafka topic {}", numMessages, kafkaTopicName);
-            return kvs;
-        }
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (kafkaConsumer != null) {
-            kafkaConsumer.close();
-            kafkaConsumer = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase.randomName;
+import static org.testng.Assert.assertTrue;
+import com.google.common.collect.ImmutableMap;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.UUID;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.testcontainers.containers.Container.ExecResult;
+import org.testcontainers.containers.KafkaContainer;
+
+/**
+ * A tester for testing kafka source.
+ */
+@Slf4j
+public class KafkaSourceTester extends SourceTester<KafkaContainer> {
+
+    private static final String SOURCE_TYPE = "kafka";
+
+    private final String kafkaTopicName;
+
+    private KafkaContainer kafkaContainer;
+
+    private KafkaConsumer<String, String> kafkaConsumer;
+
+    public KafkaSourceTester(String containerName) {
+        super(SOURCE_TYPE);
+        String suffix = randomName(8) + "_" + System.currentTimeMillis();
+        this.kafkaTopicName = "kafka_source_topic_" + suffix;
+
+        sourceConfig.put("bootstrapServers", containerName + ":9092");
+        sourceConfig.put("groupId", "test-source-group");
+        sourceConfig.put("fetchMinBytes", 1L);
+        sourceConfig.put("autoCommitIntervalMs", 10L);
+        sourceConfig.put("sessionTimeoutMs", 10000L);
+        sourceConfig.put("heartbeatIntervalMs", 5000L);
+        sourceConfig.put("topic", kafkaTopicName);
+        sourceConfig.put("valueDeserializationClass", "org.apache.kafka.common.serialization.ByteArrayDeserializer");
+    }
+
+    @Override
+    public void setServiceContainer(KafkaContainer container) {
+        this.kafkaContainer = container;
+    }
+
+    @Override
+    public void prepareSource() throws Exception {
+        ExecResult execResult = kafkaContainer.execInContainer(
+            "/usr/bin/kafka-topics",
+            "--create",
+            "--bootstrap-server",
+            "localhost:9092",
+            "--partitions",
+            "1",
+            "--replication-factor",
+            "1",
+            "--topic",
+            kafkaTopicName);
+        assertTrue(
+            execResult.getStdout().contains("Created topic"),
+            execResult.getStdout());
+
+        kafkaConsumer = new KafkaConsumer<>(
+            ImmutableMap.of(
+                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers(),
+                ConsumerConfig.GROUP_ID_CONFIG, "source-test-" + randomName(8),
+                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"
+            ),
+            new StringDeserializer(),
+            new StringDeserializer()
+        );
+        kafkaConsumer.subscribe(Arrays.asList(kafkaTopicName));
+        log.info("Successfully subscribe to kafka topic {}", kafkaTopicName);
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        // pass
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        // pass
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        // pass
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) throws Exception{
+        try (KafkaProducer<String, String> producer = new KafkaProducer<>(
+                ImmutableMap.of(
+                        ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers(),
+                        ProducerConfig.CLIENT_ID_CONFIG, UUID.randomUUID().toString()
+                ),
+                new StringSerializer(),
+                new StringSerializer()
+        )) {
+            LinkedHashMap<String, String> kvs = new LinkedHashMap<>();
+            for (int i = 0; i < numMessages; i++) {
+                String key = "key-" + i;
+                String value = "value-" + i;
+                ProducerRecord<String, String> record = new ProducerRecord<>(
+                        kafkaTopicName,
+                        key,
+                        value
+                );
+                kvs.put(key, value);
+                producer.send(record).get();
+            }
+
+            log.info("Successfully produced {} messages to kafka topic {}", numMessages, kafkaTopicName);
+            return kvs;
+        }
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (kafkaConsumer != null) {
+            kafkaConsumer.close();
+            kafkaConsumer = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/MongoSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/MongoSourceTester.java
index a4d6f873f5..239b715de3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/MongoSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/MongoSourceTester.java
@@ -1,156 +1,156 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import com.mongodb.client.model.changestream.ChangeStreamDocument;
-import com.mongodb.client.model.changestream.FullDocument;
-import com.mongodb.reactivestreams.client.ChangeStreamPublisher;
-import com.mongodb.reactivestreams.client.MongoClient;
-import com.mongodb.reactivestreams.client.MongoClients;
-import com.mongodb.reactivestreams.client.MongoDatabase;
-import java.util.Map;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.DebeziumMongoDbContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.bson.Document;
-import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
-import org.testcontainers.containers.Container;
-import org.testcontainers.containers.MongoDBContainer;
-
-@Slf4j
-public class MongoSourceTester extends SourceTester<MongoDBContainer> {
-
-    private static final String SOURCE_TYPE = "mongo";
-
-    private static final String DEFAULT_DATABASE = "test";
-
-    private static final int DEFAULT_BATCH_SIZE = 2;
-
-    private final MongoDBContainer mongoContainer;
-
-    private final PulsarCluster pulsarCluster;
-
-    protected MongoSourceTester(MongoDBContainer mongoContainer, PulsarCluster pulsarCluster) {
-        super(SOURCE_TYPE);
-        this.mongoContainer = mongoContainer;
-        this.pulsarCluster = pulsarCluster;
-
-        sourceConfig.put("mongoUri", mongoContainer.getConnectionString());
-        sourceConfig.put("database", DEFAULT_DATABASE);
-        sourceConfig.put("syncType", "full_sync");
-        sourceConfig.put("batchSize", DEFAULT_BATCH_SIZE);
-    }
-
-    @Override
-    public void setServiceContainer(MongoDBContainer serviceContainer) {
-        log.info("start mongodb server container.");
-        pulsarCluster.startService(DebeziumMongoDbContainer.NAME, mongoContainer);
-    }
-
-    @Override
-    public void prepareSource() throws Exception {
-        MongoClient mongoClient = MongoClients.create(mongoContainer.getConnectionString());
-        MongoDatabase db = mongoClient.getDatabase(DEFAULT_DATABASE);
-        log.info("Subscribing mongodb change streams on: {}", mongoContainer.getReplicaSetUrl(DEFAULT_DATABASE));
-
-        ChangeStreamPublisher<Document> stream = db.watch();
-        stream.batchSize(DEFAULT_BATCH_SIZE)
-                .fullDocument(FullDocument.UPDATE_LOOKUP);
-
-        stream.subscribe(new Subscriber<>() {
-            @Override
-            public void onSubscribe(Subscription subscription) {
-                subscription.request(Integer.MAX_VALUE);
-            }
-
-            @Override
-            public void onNext(ChangeStreamDocument<Document> doc) {
-                log.info("New change doc: {}", doc);
-            }
-
-            @Override
-            public void onError(Throwable error) {
-                log.error("Subscriber error", error);
-            }
-
-            @Override
-            public void onComplete() {
-                log.info("Subscriber complete");
-            }
-        });
-
-        log.info("Successfully subscribe to mongodb change streams");
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        Container.ExecResult execResult = this.mongoContainer.execInContainer(
-                "/usr/bin/mongo",
-                "--eval",
-                "db.products.insert"
-                        + "({"
-                        + "name: \"test-mongo\","
-                        + "description: \"test message\""
-                        + "})"
-        );
-        log.info("Successfully insert a message: {}", execResult.getStdout());
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        Container.ExecResult execResult = mongoContainer.execInContainer(
-                "/usr/bin/mongo",
-                "--eval",
-                "db.products.deleteOne"
-                        + "({"
-                        + "name: \"test-mongo\""
-                        + "})"
-        );
-        log.info("Successfully delete a message: {}", execResult.getStdout());
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        Container.ExecResult execResult = mongoContainer.execInContainer(
-                "/usr/bin/mongo",
-                "--eval",
-                "db.products.update"
-                        + "("
-                        + "{name: \"test-mongo-source\"}"
-                        + ","
-                        + "{$set:{name:\"test-mongo-update\", description: \"updated message\"}}"
-                        + ")"
-        );
-        log.info("Successfully update a message: {}", execResult.getStdout());
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
-        log.info("mongodb server already contains preconfigured data.");
-        return null;
-    }
-
-    @Override
-    public void close() throws Exception {
-        if (mongoContainer != null) {
-            mongoContainer.close();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import com.mongodb.client.model.changestream.ChangeStreamDocument;
+import com.mongodb.client.model.changestream.FullDocument;
+import com.mongodb.reactivestreams.client.ChangeStreamPublisher;
+import com.mongodb.reactivestreams.client.MongoClient;
+import com.mongodb.reactivestreams.client.MongoClients;
+import com.mongodb.reactivestreams.client.MongoDatabase;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.DebeziumMongoDbContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.bson.Document;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import org.testcontainers.containers.Container;
+import org.testcontainers.containers.MongoDBContainer;
+
+@Slf4j
+public class MongoSourceTester extends SourceTester<MongoDBContainer> {
+
+    private static final String SOURCE_TYPE = "mongo";
+
+    private static final String DEFAULT_DATABASE = "test";
+
+    private static final int DEFAULT_BATCH_SIZE = 2;
+
+    private final MongoDBContainer mongoContainer;
+
+    private final PulsarCluster pulsarCluster;
+
+    protected MongoSourceTester(MongoDBContainer mongoContainer, PulsarCluster pulsarCluster) {
+        super(SOURCE_TYPE);
+        this.mongoContainer = mongoContainer;
+        this.pulsarCluster = pulsarCluster;
+
+        sourceConfig.put("mongoUri", mongoContainer.getConnectionString());
+        sourceConfig.put("database", DEFAULT_DATABASE);
+        sourceConfig.put("syncType", "full_sync");
+        sourceConfig.put("batchSize", DEFAULT_BATCH_SIZE);
+    }
+
+    @Override
+    public void setServiceContainer(MongoDBContainer serviceContainer) {
+        log.info("start mongodb server container.");
+        pulsarCluster.startService(DebeziumMongoDbContainer.NAME, mongoContainer);
+    }
+
+    @Override
+    public void prepareSource() throws Exception {
+        MongoClient mongoClient = MongoClients.create(mongoContainer.getConnectionString());
+        MongoDatabase db = mongoClient.getDatabase(DEFAULT_DATABASE);
+        log.info("Subscribing mongodb change streams on: {}", mongoContainer.getReplicaSetUrl(DEFAULT_DATABASE));
+
+        ChangeStreamPublisher<Document> stream = db.watch();
+        stream.batchSize(DEFAULT_BATCH_SIZE)
+                .fullDocument(FullDocument.UPDATE_LOOKUP);
+
+        stream.subscribe(new Subscriber<>() {
+            @Override
+            public void onSubscribe(Subscription subscription) {
+                subscription.request(Integer.MAX_VALUE);
+            }
+
+            @Override
+            public void onNext(ChangeStreamDocument<Document> doc) {
+                log.info("New change doc: {}", doc);
+            }
+
+            @Override
+            public void onError(Throwable error) {
+                log.error("Subscriber error", error);
+            }
+
+            @Override
+            public void onComplete() {
+                log.info("Subscriber complete");
+            }
+        });
+
+        log.info("Successfully subscribe to mongodb change streams");
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        Container.ExecResult execResult = this.mongoContainer.execInContainer(
+                "/usr/bin/mongo",
+                "--eval",
+                "db.products.insert"
+                        + "({"
+                        + "name: \"test-mongo\","
+                        + "description: \"test message\""
+                        + "})"
+        );
+        log.info("Successfully insert a message: {}", execResult.getStdout());
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        Container.ExecResult execResult = mongoContainer.execInContainer(
+                "/usr/bin/mongo",
+                "--eval",
+                "db.products.deleteOne"
+                        + "({"
+                        + "name: \"test-mongo\""
+                        + "})"
+        );
+        log.info("Successfully delete a message: {}", execResult.getStdout());
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        Container.ExecResult execResult = mongoContainer.execInContainer(
+                "/usr/bin/mongo",
+                "--eval",
+                "db.products.update"
+                        + "("
+                        + "{name: \"test-mongo-source\"}"
+                        + ","
+                        + "{$set:{name:\"test-mongo-update\", description: \"updated message\"}}"
+                        + ")"
+        );
+        log.info("Successfully update a message: {}", execResult.getStdout());
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
+        log.info("mongodb server already contains preconfigured data.");
+        return null;
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (mongoContainer != null) {
+            mongoContainer.close();
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarIOSourceRunner.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarIOSourceRunner.java
index 7cd1c3ebf6..df4369f071 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarIOSourceRunner.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarIOSourceRunner.java
@@ -1,310 +1,310 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import com.google.gson.Gson;
-import dev.failsafe.Failsafe;
-import java.util.Map;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.common.policies.data.SourceStatusUtil;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.io.PulsarIOTestRunner;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarTestBase;
-import org.testcontainers.containers.GenericContainer;
-
-@Slf4j
-public class PulsarIOSourceRunner extends PulsarIOTestRunner {
-
-    public PulsarIOSourceRunner(PulsarCluster cluster, String functionRuntimeType) {
-        super(cluster, functionRuntimeType);
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    public <T extends GenericContainer> void testSource(SourceTester<T> tester)  throws Exception {
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "test-source-connector-"
-            + functionRuntimeType + "-output-topic-" + PulsarTestBase.randomName(8);
-        final String sourceName = "test-source-connector-"
-            + functionRuntimeType + "-name-" + PulsarTestBase.randomName(8);
-        final int numMessages = 20;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-            .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-            .topic(outputTopicName)
-            .subscriptionName("source-tester")
-            .subscriptionType(SubscriptionType.Exclusive)
-            .subscribe();
-
-        // prepare the testing environment for source
-        prepareSource(tester);
-
-        // submit the source connector
-        submitSourceConnector(tester, tenant, namespace, sourceName, outputTopicName);
-
-        // get source info
-        getSourceInfoSuccess(tester, tenant, namespace, sourceName);
-
-        // get source status
-        Failsafe.with(statusRetryPolicy).run(() -> getSourceStatus(tenant, namespace, sourceName));
-
-        // produce messages
-        Map<String, String> kvs = tester.produceSourceMessages(numMessages);
-
-        // wait for source to process messages
-        Failsafe.with(statusRetryPolicy).run(() ->
-                waitForProcessingSourceMessages(tenant, namespace, sourceName, numMessages));
-
-        // validate the source result
-        validateSourceResult(consumer, kvs);
-
-        // update the source connector
-        updateSourceConnector(tester, tenant, namespace, sourceName, outputTopicName);
-
-        // delete the source
-        deleteSource(tenant, namespace, sourceName);
-
-        // get source info (source should be deleted)
-        getSourceInfoNotFound(tenant, namespace, sourceName);
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected void prepareSource(SourceTester tester) throws Exception {
-        tester.prepareSource();
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected void submitSourceConnector(SourceTester tester,
-                                         String tenant,
-                                         String namespace,
-                                         String sourceName,
-                                         String outputTopicName) throws Exception {
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "source", "create",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sourceName,
-            "--source-type", tester.sourceType(),
-            "--sourceConfig", new Gson().toJson(tester.sourceConfig()),
-            "--destinationTopicName", outputTopicName,
-            "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
-        };
-
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-            result.getStdout().contains("Created successfully"),
-            result.getStdout());
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected void updateSourceConnector(SourceTester tester,
-                                         String tenant,
-                                         String namespace,
-                                         String sourceName,
-                                         String outputTopicName) throws Exception {
-        final String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "source", "update",
-                "--tenant", tenant,
-                "--namespace", namespace,
-                "--name", sourceName,
-                "--source-type", tester.sourceType(),
-                "--sourceConfig", new Gson().toJson(tester.sourceConfig()),
-                "--destinationTopicName", outputTopicName,
-                "--parallelism", "2",
-                "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
-        };
-
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Updated successfully"),
-                result.getStdout());
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected void getSourceInfoSuccess(SourceTester tester,
-                                        String tenant,
-                                        String namespace,
-                                        String sourceName) throws Exception {
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "source",
-            "get",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sourceName
-        };
-
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get source info : {}", result.getStdout());
-        assertTrue(
-            result.getStdout().contains("\"archive\": \"builtin://" + tester.getSourceType() + "\""),
-            result.getStdout()
-        );
-    }
-
-    protected void getSourceStatus(String tenant, String namespace, String sourceName) throws Exception {
-
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "source",
-            "status",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sourceName
-        };
-
-        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get source status : {}", result.getStdout());
-
-        assertEquals(result.getExitCode(), 0);
-
-        final SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
-
-        assertEquals(sourceStatus.getNumInstances(), 1);
-        assertEquals(sourceStatus.getNumRunning(), 1);
-        assertEquals(sourceStatus.getInstances().size(), 1);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-
-    }
-
-    protected void validateSourceResult(Consumer<String> consumer,
-                                        Map<String, String> kvs) throws Exception {
-        for (Map.Entry<String, String> kv : kvs.entrySet()) {
-            Message<String> msg = consumer.receive();
-            assertEquals(kv.getKey(), msg.getKey());
-            assertEquals(kv.getValue(), msg.getValue());
-        }
-    }
-
-    protected void waitForProcessingSourceMessages(String tenant,
-                                                   String namespace,
-                                                   String sourceName,
-                                                   int numMessages) throws Exception {
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "source",
-            "status",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sourceName
-        };
-
-        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        log.info("Get source status : {}", result.getStdout());
-
-        assertEquals(result.getExitCode(), 0);
-
-        SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
-        assertEquals(sourceStatus.getNumInstances(), 1);
-        assertEquals(sourceStatus.getNumRunning(), 1);
-        assertEquals(sourceStatus.getInstances().size(), 1);
-        assertEquals(sourceStatus.getInstances().get(0).getInstanceId(), 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
-        assertTrue(sourceStatus.getInstances().get(0).getStatus().getLastReceivedTime() > 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumReceivedFromSource(), numMessages);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumWritten(), numMessages);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
-        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
-    }
-
-    protected void deleteSource(String tenant, String namespace, String sourceName) throws Exception {
-
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "source",
-            "delete",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sourceName
-        };
-
-        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
-        assertTrue(
-            result.getStdout().contains("Delete source successfully"),
-            result.getStdout()
-        );
-        result.assertNoStderr();
-
-        final String[] packageCommands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "packages",
-            "delete",
-            "source://" + tenant + "/" + namespace + "/" + sourceName + "@0"
-        };
-
-        try {
-            ContainerExecResult packageResult = pulsarCluster.getAnyWorker().execCmd(packageCommands);
-            log.info("Package metadata deletion result: {}", packageResult.getStdout());
-        } catch (Exception e) {
-            log.warn("Failed to delete package metadata for source://{}/{}/{}@0: {}",
-                     tenant, namespace, sourceName, e.getMessage());
-        }
-    }
-
-    protected void getSourceInfoNotFound(String tenant, String namespace, String sourceName) throws Exception {
-
-        final String[] commands = {
-            PulsarCluster.ADMIN_SCRIPT,
-            "source",
-            "get",
-            "--tenant", tenant,
-            "--namespace", namespace,
-            "--name", sourceName
-        };
-
-        try {
-            pulsarCluster.getAnyWorker().execCmd(commands);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import com.google.gson.Gson;
+import dev.failsafe.Failsafe;
+import java.util.Map;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.common.policies.data.SourceStatusUtil;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.io.PulsarIOTestRunner;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarTestBase;
+import org.testcontainers.containers.GenericContainer;
+
+@Slf4j
+public class PulsarIOSourceRunner extends PulsarIOTestRunner {
+
+    public PulsarIOSourceRunner(PulsarCluster cluster, String functionRuntimeType) {
+        super(cluster, functionRuntimeType);
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public <T extends GenericContainer> void testSource(SourceTester<T> tester)  throws Exception {
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "test-source-connector-"
+            + functionRuntimeType + "-output-topic-" + PulsarTestBase.randomName(8);
+        final String sourceName = "test-source-connector-"
+            + functionRuntimeType + "-name-" + PulsarTestBase.randomName(8);
+        final int numMessages = 20;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+            .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+            .topic(outputTopicName)
+            .subscriptionName("source-tester")
+            .subscriptionType(SubscriptionType.Exclusive)
+            .subscribe();
+
+        // prepare the testing environment for source
+        prepareSource(tester);
+
+        // submit the source connector
+        submitSourceConnector(tester, tenant, namespace, sourceName, outputTopicName);
+
+        // get source info
+        getSourceInfoSuccess(tester, tenant, namespace, sourceName);
+
+        // get source status
+        Failsafe.with(statusRetryPolicy).run(() -> getSourceStatus(tenant, namespace, sourceName));
+
+        // produce messages
+        Map<String, String> kvs = tester.produceSourceMessages(numMessages);
+
+        // wait for source to process messages
+        Failsafe.with(statusRetryPolicy).run(() ->
+                waitForProcessingSourceMessages(tenant, namespace, sourceName, numMessages));
+
+        // validate the source result
+        validateSourceResult(consumer, kvs);
+
+        // update the source connector
+        updateSourceConnector(tester, tenant, namespace, sourceName, outputTopicName);
+
+        // delete the source
+        deleteSource(tenant, namespace, sourceName);
+
+        // get source info (source should be deleted)
+        getSourceInfoNotFound(tenant, namespace, sourceName);
+    }
+
+    @SuppressWarnings("rawtypes")
+    protected void prepareSource(SourceTester tester) throws Exception {
+        tester.prepareSource();
+    }
+
+    @SuppressWarnings("rawtypes")
+    protected void submitSourceConnector(SourceTester tester,
+                                         String tenant,
+                                         String namespace,
+                                         String sourceName,
+                                         String outputTopicName) throws Exception {
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "source", "create",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sourceName,
+            "--source-type", tester.sourceType(),
+            "--sourceConfig", new Gson().toJson(tester.sourceConfig()),
+            "--destinationTopicName", outputTopicName,
+            "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
+        };
+
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+            result.getStdout().contains("Created successfully"),
+            result.getStdout());
+    }
+
+    @SuppressWarnings("rawtypes")
+    protected void updateSourceConnector(SourceTester tester,
+                                         String tenant,
+                                         String namespace,
+                                         String sourceName,
+                                         String outputTopicName) throws Exception {
+        final String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "source", "update",
+                "--tenant", tenant,
+                "--namespace", namespace,
+                "--name", sourceName,
+                "--source-type", tester.sourceType(),
+                "--sourceConfig", new Gson().toJson(tester.sourceConfig()),
+                "--destinationTopicName", outputTopicName,
+                "--parallelism", "2",
+                "--ram", String.valueOf(RUNTIME_INSTANCE_RAM_BYTES)
+        };
+
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Updated successfully"),
+                result.getStdout());
+    }
+
+    @SuppressWarnings("rawtypes")
+    protected void getSourceInfoSuccess(SourceTester tester,
+                                        String tenant,
+                                        String namespace,
+                                        String sourceName) throws Exception {
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "source",
+            "get",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sourceName
+        };
+
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get source info : {}", result.getStdout());
+        assertTrue(
+            result.getStdout().contains("\"archive\": \"builtin://" + tester.getSourceType() + "\""),
+            result.getStdout()
+        );
+    }
+
+    protected void getSourceStatus(String tenant, String namespace, String sourceName) throws Exception {
+
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "source",
+            "status",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sourceName
+        };
+
+        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get source status : {}", result.getStdout());
+
+        assertEquals(result.getExitCode(), 0);
+
+        final SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
+
+        assertEquals(sourceStatus.getNumInstances(), 1);
+        assertEquals(sourceStatus.getNumRunning(), 1);
+        assertEquals(sourceStatus.getInstances().size(), 1);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+
+    }
+
+    protected void validateSourceResult(Consumer<String> consumer,
+                                        Map<String, String> kvs) throws Exception {
+        for (Map.Entry<String, String> kv : kvs.entrySet()) {
+            Message<String> msg = consumer.receive();
+            assertEquals(kv.getKey(), msg.getKey());
+            assertEquals(kv.getValue(), msg.getValue());
+        }
+    }
+
+    protected void waitForProcessingSourceMessages(String tenant,
+                                                   String namespace,
+                                                   String sourceName,
+                                                   int numMessages) throws Exception {
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "source",
+            "status",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sourceName
+        };
+
+        final ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        log.info("Get source status : {}", result.getStdout());
+
+        assertEquals(result.getExitCode(), 0);
+
+        SourceStatus sourceStatus = SourceStatusUtil.decode(result.getStdout());
+        assertEquals(sourceStatus.getNumInstances(), 1);
+        assertEquals(sourceStatus.getNumRunning(), 1);
+        assertEquals(sourceStatus.getInstances().size(), 1);
+        assertEquals(sourceStatus.getInstances().get(0).getInstanceId(), 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().isRunning(), true);
+        assertTrue(sourceStatus.getInstances().get(0).getStatus().getLastReceivedTime() > 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumReceivedFromSource(), numMessages);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumWritten(), numMessages);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getNumRestarts(), 0);
+        assertEquals(sourceStatus.getInstances().get(0).getStatus().getLatestSystemExceptions().size(), 0);
+    }
+
+    protected void deleteSource(String tenant, String namespace, String sourceName) throws Exception {
+
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "source",
+            "delete",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sourceName
+        };
+
+        ContainerExecResult result = pulsarCluster.getAnyWorker().execCmd(commands);
+        assertTrue(
+            result.getStdout().contains("Delete source successfully"),
+            result.getStdout()
+        );
+        result.assertNoStderr();
+
+        final String[] packageCommands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "packages",
+            "delete",
+            "source://" + tenant + "/" + namespace + "/" + sourceName + "@0"
+        };
+
+        try {
+            ContainerExecResult packageResult = pulsarCluster.getAnyWorker().execCmd(packageCommands);
+            log.info("Package metadata deletion result: {}", packageResult.getStdout());
+        } catch (Exception e) {
+            log.warn("Failed to delete package metadata for source://{}/{}/{}@0: {}",
+                     tenant, namespace, sourceName, e.getMessage());
+        }
+    }
+
+    protected void getSourceInfoNotFound(String tenant, String namespace, String sourceName) throws Exception {
+
+        final String[] commands = {
+            PulsarCluster.ADMIN_SCRIPT,
+            "source",
+            "get",
+            "--tenant", tenant,
+            "--namespace", namespace,
+            "--name", sourceName
+        };
+
+        try {
+            pulsarCluster.getAnyWorker().execCmd(commands);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarSourcePropertyTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarSourcePropertyTest.java
index a0e7624e43..d73a09814c 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarSourcePropertyTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/PulsarSourcePropertyTest.java
@@ -1,162 +1,162 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.common.policies.data.SourceStatus;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.awaitility.Awaitility;
-import org.testng.annotations.Test;
-
-/**
- * Source Property related test cases.
- */
-@Slf4j
-public class PulsarSourcePropertyTest extends PulsarStandaloneTestSuite {
-    @Test(groups = {"source"})
-    public void testSourceProperty() throws Exception {
-        String outputTopicName = "test-source-property-input-" + randomName(8);
-        String sourceName = "test-source-property-" + randomName(8);
-        submitSourceConnector(sourceName, outputTopicName, "org.apache.pulsar.tests.integration.io.TestPropertySource",
-                JAVAJAR);
-
-        // get source info
-        getSourceInfoSuccess(sourceName);
-
-        // get source status
-        getSourceStatus(sourceName);
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
-
-            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
-                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
-                assertEquals(status.getInstances().size(), 1);
-                assertTrue(status.getInstances().get(0).getStatus().numWritten > 0);
-            });
-        }
-
-        @Cleanup PulsarClient client = PulsarClient.builder()
-                .serviceUrl(container.getPlainTextServiceUrl())
-                .build();
-        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(outputTopicName)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionName("test-sub")
-                .subscribe();
-
-        for (int i = 0; i < 10; i++) {
-            Message<String> msg = consumer.receive();
-            assertEquals(msg.getValue(), "property");
-            assertEquals(msg.getProperty("hello"), "world");
-            assertEquals(msg.getProperty("foo"), "bar");
-        }
-
-        // delete source
-        deleteSource(sourceName);
-
-        getSourceInfoNotFound(sourceName);
-    }
-
-    private void submitSourceConnector(String sourceName,
-                                       String outputTopicName,
-                                       String className,
-                                       String archive) throws Exception {
-        String[] commands = {
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources", "create",
-                "--name", sourceName,
-                "--destinationTopicName", outputTopicName,
-                "--archive", archive,
-                "--classname", className
-        };
-        log.info("Run command : {}", StringUtils.join(commands, ' '));
-        ContainerExecResult result = container.execCmd(commands);
-        assertTrue(
-                result.getStdout().contains("Created successfully"),
-                result.getStdout());
-    }
-
-    private void getSourceInfoSuccess(String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "get",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
-    }
-
-    private void getSourceStatus(String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "status",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("\"running\" : true"));
-    }
-
-    private void deleteSource(String sourceName) throws Exception {
-        ContainerExecResult result = container.execCmd(
-                PulsarCluster.ADMIN_SCRIPT,
-                "sources",
-                "delete",
-                "--tenant", "public",
-                "--namespace", "default",
-                "--name", sourceName
-        );
-        assertTrue(result.getStdout().contains("Delete source successfully"));
-        result.assertNoStderr();
-    }
-
-    private void getSourceInfoNotFound(String sourceName) throws Exception {
-        try {
-            container.execCmd(
-                    PulsarCluster.ADMIN_SCRIPT,
-                    "sources",
-                    "get",
-                    "--tenant", "public",
-                    "--namespace", "default",
-                    "--name", sourceName);
-            fail("Command should have exited with non-zero");
-        } catch (ContainerExecException e) {
-            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
-        }
-    }
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import static org.apache.pulsar.tests.integration.functions.utils.CommandGenerator.JAVAJAR;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.common.policies.data.SourceStatus;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.awaitility.Awaitility;
+import org.testng.annotations.Test;
+
+/**
+ * Source Property related test cases.
+ */
+@Slf4j
+public class PulsarSourcePropertyTest extends PulsarStandaloneTestSuite {
+    @Test(groups = {"source"})
+    public void testSourceProperty() throws Exception {
+        String outputTopicName = "test-source-property-input-" + randomName(8);
+        String sourceName = "test-source-property-" + randomName(8);
+        submitSourceConnector(sourceName, outputTopicName, "org.apache.pulsar.tests.integration.io.TestPropertySource",
+                JAVAJAR);
+
+        // get source info
+        getSourceInfoSuccess(sourceName);
+
+        // get source status
+        getSourceStatus(sourceName);
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(container.getHttpServiceUrl()).build()) {
+
+            Awaitility.await().ignoreExceptions().untilAsserted(() -> {
+                SourceStatus status = admin.sources().getSourceStatus("public", "default", sourceName);
+                assertEquals(status.getInstances().size(), 1);
+                assertTrue(status.getInstances().get(0).getStatus().numWritten > 0);
+            });
+        }
+
+        @Cleanup PulsarClient client = PulsarClient.builder()
+                .serviceUrl(container.getPlainTextServiceUrl())
+                .build();
+        @Cleanup Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(outputTopicName)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionName("test-sub")
+                .subscribe();
+
+        for (int i = 0; i < 10; i++) {
+            Message<String> msg = consumer.receive();
+            assertEquals(msg.getValue(), "property");
+            assertEquals(msg.getProperty("hello"), "world");
+            assertEquals(msg.getProperty("foo"), "bar");
+        }
+
+        // delete source
+        deleteSource(sourceName);
+
+        getSourceInfoNotFound(sourceName);
+    }
+
+    private void submitSourceConnector(String sourceName,
+                                       String outputTopicName,
+                                       String className,
+                                       String archive) throws Exception {
+        String[] commands = {
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources", "create",
+                "--name", sourceName,
+                "--destinationTopicName", outputTopicName,
+                "--archive", archive,
+                "--classname", className
+        };
+        log.info("Run command : {}", StringUtils.join(commands, ' '));
+        ContainerExecResult result = container.execCmd(commands);
+        assertTrue(
+                result.getStdout().contains("Created successfully"),
+                result.getStdout());
+    }
+
+    private void getSourceInfoSuccess(String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "get",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"name\": \"" + sourceName + "\""));
+    }
+
+    private void getSourceStatus(String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "status",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("\"running\" : true"));
+    }
+
+    private void deleteSource(String sourceName) throws Exception {
+        ContainerExecResult result = container.execCmd(
+                PulsarCluster.ADMIN_SCRIPT,
+                "sources",
+                "delete",
+                "--tenant", "public",
+                "--namespace", "default",
+                "--name", sourceName
+        );
+        assertTrue(result.getStdout().contains("Delete source successfully"));
+        result.assertNoStderr();
+    }
+
+    private void getSourceInfoNotFound(String sourceName) throws Exception {
+        try {
+            container.execCmd(
+                    PulsarCluster.ADMIN_SCRIPT,
+                    "sources",
+                    "get",
+                    "--tenant", "public",
+                    "--namespace", "default",
+                    "--name", sourceName);
+            fail("Command should have exited with non-zero");
+        } catch (ContainerExecException e) {
+            assertTrue(e.getResult().getStderr().contains("Reason: Source " + sourceName + " doesn't exist"));
+        }
+    }
+}
+
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/SourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/SourceTester.java
index bd2c95b577..94853a23a4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/SourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/SourceTester.java
@@ -1,196 +1,196 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources;
-
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.schema.Field;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.common.schema.KeyValue;
-import org.testcontainers.containers.GenericContainer;
-import org.testng.Assert;
-import org.testng.collections.Maps;
-
-/**
- * A tester used for testing a specific source.
- */
-@Getter
-@Slf4j
-public abstract class SourceTester<ServiceContainerT extends GenericContainer> implements AutoCloseable {
-
-    public static final String INSERT = "INSERT";
-
-    public static final String DELETE = "DELETE";
-
-    public static final String UPDATE = "UPDATE";
-
-    protected final String sourceType;
-    protected final Map<String, Object> sourceConfig;
-
-    protected int numEntriesToInsert = 1;
-    protected int numEntriesExpectAfterStart = 9;
-
-    public static final Set<String> DEBEZIUM_FIELD_SET = new HashSet<String>() {{
-        add("before");
-        add("after");
-        add("source");
-        add("op");
-        add("ts_ms");
-        add("ts_us");
-        add("ts_ns");
-        add("transaction");
-    }};
-
-    protected SourceTester(String sourceType) {
-        this.sourceType = sourceType;
-        this.sourceConfig = Maps.newHashMap();
-    }
-
-    public abstract void setServiceContainer(ServiceContainerT serviceContainer);
-
-    public String sourceType() {
-        return sourceType;
-    }
-
-    public Map<String, Object> sourceConfig() {
-        return sourceConfig;
-    }
-
-    public abstract void prepareSource() throws Exception;
-
-    public abstract void prepareInsertEvent() throws Exception;
-
-    public abstract void prepareDeleteEvent() throws Exception;
-
-    public abstract void prepareUpdateEvent() throws Exception;
-
-    public abstract Map<String, String> produceSourceMessages(int numMessages) throws Exception;
-
-    @SuppressWarnings({"unchecked", "rawtypes"})
-    public void validateSourceResult(Consumer consumer, int number,
-                                     String eventType, String converterClassName) throws Exception {
-        doPreValidationCheck(eventType);
-        if (converterClassName.endsWith("AvroConverter")) {
-            validateSourceResultAvro(consumer, number, eventType);
-        } else {
-            validateSourceResultJson(consumer, number, eventType);
-        }
-        doPostValidationCheck(eventType);
-    }
-
-    /**
-     * Execute before regular validation to check database-specific state.
-     */
-    public void doPreValidationCheck(String eventType) {
-        log.info("pre-validation of {}", eventType);
-    }
-
-    /**
-     * Execute after regular validation to check database-specific state.
-     */
-    public void doPostValidationCheck(String eventType) {
-        log.info("post-validation of {}", eventType);
-    }
-
-    public void validateSourceResultJson(Consumer<KeyValue<byte[], byte[]>> consumer, int number, String eventType)
-            throws Exception {
-        int recordsNumber = 0;
-        Message<KeyValue<byte[], byte[]>> msg = consumer.receive(initialDelayForMsgReceive(), TimeUnit.SECONDS);
-        while (msg != null) {
-            recordsNumber++;
-            final String key = new String(msg.getValue().getKey());
-            final String value = new String(msg.getValue().getValue());
-            log.info("Received message: key = {}, value = {}.", key, value);
-            Assert.assertTrue(key.contains(this.keyContains()));
-            Assert.assertTrue(value.contains(this.valueContains()));
-            if (eventType != null) {
-                Assert.assertTrue(value.contains(this.eventContains(eventType, true)));
-            }
-            consumer.acknowledge(msg);
-            msg = consumer.receive(1, TimeUnit.SECONDS);
-        }
-
-        Assert.assertEquals(recordsNumber, number);
-        log.info("Stop {} server container. topic: {} has {} records.", getSourceType(),
-                consumer.getTopic(), recordsNumber);
-    }
-
-    public void validateSourceResultAvro(Consumer<KeyValue<GenericRecord, GenericRecord>> consumer,
-                                     int number, String eventType) throws Exception {
-        int recordsNumber = 0;
-        Message<KeyValue<GenericRecord, GenericRecord>> msg =
-                consumer.receive(initialDelayForMsgReceive(), TimeUnit.SECONDS);
-        while (msg != null) {
-            recordsNumber++;
-            GenericRecord keyRecord = msg.getValue().getKey();
-            Assert.assertNotNull(keyRecord.getFields());
-            Assert.assertTrue(keyRecord.getFields().size() > 0);
-
-            GenericRecord valueRecord = msg.getValue().getValue();
-            Assert.assertNotNull(valueRecord.getFields());
-            Assert.assertTrue(valueRecord.getFields().size() > 0);
-
-            log.info("Received message: key = {}, value = {}.", keyRecord.getNativeObject(),
-                    valueRecord.getNativeObject());
-            for (Field field : valueRecord.getFields()) {
-                log.info("validating field {}", field.getName());
-                Assert.assertTrue(DEBEZIUM_FIELD_SET.contains(field.getName()));
-            }
-
-            if (eventType != null) {
-                String op = valueRecord.getField("op").toString();
-                Assert.assertEquals(this.eventContains(eventType, false), op);
-            }
-            consumer.acknowledge(msg);
-            msg = consumer.receive(1, TimeUnit.SECONDS);
-        }
-
-        Assert.assertEquals(recordsNumber, number);
-        log.info("Stop {} server container. topic: {} has {} records.", getSourceType(),
-                consumer.getTopic(), recordsNumber);
-    }
-
-    public int initialDelayForMsgReceive() {
-        return 2;
-    }
-
-    public String keyContains() {
-        return "dbserver1.inventory.products.Key";
-    }
-
-    public String valueContains() {
-        return "dbserver1.inventory.products.Value";
-    }
-
-    public String eventContains(String eventType, boolean isJson) {
-        if (eventType.equals(INSERT)) {
-            return isJson ? "\"op\":\"c\"" : "c";
-        } else if (eventType.equals(UPDATE)) {
-            return isJson ? "\"op\":\"u\"" : "u";
-        } else {
-            return isJson ? "\"op\":\"d\"" : "d";
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.schema.Field;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.common.schema.KeyValue;
+import org.testcontainers.containers.GenericContainer;
+import org.testng.Assert;
+import org.testng.collections.Maps;
+
+/**
+ * A tester used for testing a specific source.
+ */
+@Getter
+@Slf4j
+public abstract class SourceTester<ServiceContainerT extends GenericContainer> implements AutoCloseable {
+
+    public static final String INSERT = "INSERT";
+
+    public static final String DELETE = "DELETE";
+
+    public static final String UPDATE = "UPDATE";
+
+    protected final String sourceType;
+    protected final Map<String, Object> sourceConfig;
+
+    protected int numEntriesToInsert = 1;
+    protected int numEntriesExpectAfterStart = 9;
+
+    public static final Set<String> DEBEZIUM_FIELD_SET = new HashSet<String>() {{
+        add("before");
+        add("after");
+        add("source");
+        add("op");
+        add("ts_ms");
+        add("ts_us");
+        add("ts_ns");
+        add("transaction");
+    }};
+
+    protected SourceTester(String sourceType) {
+        this.sourceType = sourceType;
+        this.sourceConfig = Maps.newHashMap();
+    }
+
+    public abstract void setServiceContainer(ServiceContainerT serviceContainer);
+
+    public String sourceType() {
+        return sourceType;
+    }
+
+    public Map<String, Object> sourceConfig() {
+        return sourceConfig;
+    }
+
+    public abstract void prepareSource() throws Exception;
+
+    public abstract void prepareInsertEvent() throws Exception;
+
+    public abstract void prepareDeleteEvent() throws Exception;
+
+    public abstract void prepareUpdateEvent() throws Exception;
+
+    public abstract Map<String, String> produceSourceMessages(int numMessages) throws Exception;
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public void validateSourceResult(Consumer consumer, int number,
+                                     String eventType, String converterClassName) throws Exception {
+        doPreValidationCheck(eventType);
+        if (converterClassName.endsWith("AvroConverter")) {
+            validateSourceResultAvro(consumer, number, eventType);
+        } else {
+            validateSourceResultJson(consumer, number, eventType);
+        }
+        doPostValidationCheck(eventType);
+    }
+
+    /**
+     * Execute before regular validation to check database-specific state.
+     */
+    public void doPreValidationCheck(String eventType) {
+        log.info("pre-validation of {}", eventType);
+    }
+
+    /**
+     * Execute after regular validation to check database-specific state.
+     */
+    public void doPostValidationCheck(String eventType) {
+        log.info("post-validation of {}", eventType);
+    }
+
+    public void validateSourceResultJson(Consumer<KeyValue<byte[], byte[]>> consumer, int number, String eventType)
+            throws Exception {
+        int recordsNumber = 0;
+        Message<KeyValue<byte[], byte[]>> msg = consumer.receive(initialDelayForMsgReceive(), TimeUnit.SECONDS);
+        while (msg != null) {
+            recordsNumber++;
+            final String key = new String(msg.getValue().getKey());
+            final String value = new String(msg.getValue().getValue());
+            log.info("Received message: key = {}, value = {}.", key, value);
+            Assert.assertTrue(key.contains(this.keyContains()));
+            Assert.assertTrue(value.contains(this.valueContains()));
+            if (eventType != null) {
+                Assert.assertTrue(value.contains(this.eventContains(eventType, true)));
+            }
+            consumer.acknowledge(msg);
+            msg = consumer.receive(1, TimeUnit.SECONDS);
+        }
+
+        Assert.assertEquals(recordsNumber, number);
+        log.info("Stop {} server container. topic: {} has {} records.", getSourceType(),
+                consumer.getTopic(), recordsNumber);
+    }
+
+    public void validateSourceResultAvro(Consumer<KeyValue<GenericRecord, GenericRecord>> consumer,
+                                     int number, String eventType) throws Exception {
+        int recordsNumber = 0;
+        Message<KeyValue<GenericRecord, GenericRecord>> msg =
+                consumer.receive(initialDelayForMsgReceive(), TimeUnit.SECONDS);
+        while (msg != null) {
+            recordsNumber++;
+            GenericRecord keyRecord = msg.getValue().getKey();
+            Assert.assertNotNull(keyRecord.getFields());
+            Assert.assertTrue(keyRecord.getFields().size() > 0);
+
+            GenericRecord valueRecord = msg.getValue().getValue();
+            Assert.assertNotNull(valueRecord.getFields());
+            Assert.assertTrue(valueRecord.getFields().size() > 0);
+
+            log.info("Received message: key = {}, value = {}.", keyRecord.getNativeObject(),
+                    valueRecord.getNativeObject());
+            for (Field field : valueRecord.getFields()) {
+                log.info("validating field {}", field.getName());
+                Assert.assertTrue(DEBEZIUM_FIELD_SET.contains(field.getName()));
+            }
+
+            if (eventType != null) {
+                String op = valueRecord.getField("op").toString();
+                Assert.assertEquals(this.eventContains(eventType, false), op);
+            }
+            consumer.acknowledge(msg);
+            msg = consumer.receive(1, TimeUnit.SECONDS);
+        }
+
+        Assert.assertEquals(recordsNumber, number);
+        log.info("Stop {} server container. topic: {} has {} records.", getSourceType(),
+                consumer.getTopic(), recordsNumber);
+    }
+
+    public int initialDelayForMsgReceive() {
+        return 2;
+    }
+
+    public String keyContains() {
+        return "dbserver1.inventory.products.Key";
+    }
+
+    public String valueContains() {
+        return "dbserver1.inventory.products.Value";
+    }
+
+    public String eventContains(String eventType, boolean isJson) {
+        if (eventType.equals(INSERT)) {
+            return isJson ? "\"op\":\"c\"" : "c";
+        } else if (eventType.equals(UPDATE)) {
+            return isJson ? "\"op\":\"u\"" : "u";
+        } else {
+            return isJson ? "\"op\":\"d\"" : "d";
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMongoDbSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMongoDbSourceTester.java
index 1826d78f35..3b26142713 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMongoDbSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMongoDbSourceTester.java
@@ -1,126 +1,126 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import java.util.Map;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.DebeziumMongoDbContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-@Slf4j
-public class DebeziumMongoDbSourceTester extends SourceTester<DebeziumMongoDbContainer> {
-
-    private static final String NAME = "debezium-mongodb";
-
-    private final String pulsarServiceUrl;
-
-    @Getter
-    private DebeziumMongoDbContainer debeziumMongoDbContainer;
-
-    private final PulsarCluster pulsarCluster;
-    public DebeziumMongoDbSourceTester(PulsarCluster cluster) {
-        super(NAME);
-        this.pulsarCluster = cluster;
-        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
-
-        sourceConfig.put("mongodb.connection.string",
-                "mongodb://debezium:dbz@" + DebeziumMongoDbContainer.NAME + ":27017/admin?replicaSet=rs0");
-        sourceConfig.put("mongodb.user", "debezium");
-        sourceConfig.put("mongodb.password", "dbz");
-        sourceConfig.put("mongodb.task.id", "1");
-        sourceConfig.put("topic.prefix", "dbserver1");
-        sourceConfig.put("database.include.list", "inventory");
-        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
-        sourceConfig.put("topic.namespace", "debezium/mongodb");
-        sourceConfig.put("capture.mode", "change_streams_update_full");
-        sourceConfig.put("connector.class", "io.debezium.connector.mongodb.MongoDbConnector");
-    }
-
-    @Override
-    public void setServiceContainer(DebeziumMongoDbContainer container) {
-        log.info("start debezium mongodb server container.");
-        debeziumMongoDbContainer = container;
-        pulsarCluster.startService(DebeziumMongoDbContainer.NAME, debeziumMongoDbContainer);
-    }
-
-    @Override
-    public void prepareSource() throws Exception {
-        this.debeziumMongoDbContainer.execCmd("bash", "-c", "/usr/local/bin/init-inventory.sh");
-        log.info("debezium mongodb server already contains preconfigured data.");
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
-                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
-                        + "--eval 'db.products.find()'");
-        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
-                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
-                        + "--eval 'db.products.insert({ "
-                        + "_id : NumberLong(\"110\"),"
-                        + "name : \"test-debezium\","
-                        + "description: \"24 inch spare tire\","
-                        + "weight : 22.2,"
-                        + "quantity : NumberInt(\"5\")})'");
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
-                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
-                        + "--eval 'db.products.find()'");
-        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
-                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
-                        + "--eval 'db.products.deleteOne({name : \"test-debezium-update\"})'");
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
-                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
-                        + "--eval 'db.products.find()'");
-        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
-                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
-                        + "--eval 'db.products.update({"
-                        + "_id : 110},"
-                        + "{$set:{name:\"test-debezium-update\", description: \"this is update description\"}})'");
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
-        log.info("debezium mongodb server already contains preconfigured data.");
-        return null;
-    }
-
-    @Override
-    public String valueContains() {
-        return "dbserver1.inventory.products.Envelope";
-    }
-
-    @Override
-    public void close() {
-        if (debeziumMongoDbContainer != null) {
-            PulsarCluster.stopService(DebeziumMongoDbContainer.NAME, debeziumMongoDbContainer);
-            debeziumMongoDbContainer = null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import java.util.Map;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.DebeziumMongoDbContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+@Slf4j
+public class DebeziumMongoDbSourceTester extends SourceTester<DebeziumMongoDbContainer> {
+
+    private static final String NAME = "debezium-mongodb";
+
+    private final String pulsarServiceUrl;
+
+    @Getter
+    private DebeziumMongoDbContainer debeziumMongoDbContainer;
+
+    private final PulsarCluster pulsarCluster;
+    public DebeziumMongoDbSourceTester(PulsarCluster cluster) {
+        super(NAME);
+        this.pulsarCluster = cluster;
+        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
+
+        sourceConfig.put("mongodb.connection.string",
+                "mongodb://debezium:dbz@" + DebeziumMongoDbContainer.NAME + ":27017/admin?replicaSet=rs0");
+        sourceConfig.put("mongodb.user", "debezium");
+        sourceConfig.put("mongodb.password", "dbz");
+        sourceConfig.put("mongodb.task.id", "1");
+        sourceConfig.put("topic.prefix", "dbserver1");
+        sourceConfig.put("database.include.list", "inventory");
+        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
+        sourceConfig.put("topic.namespace", "debezium/mongodb");
+        sourceConfig.put("capture.mode", "change_streams_update_full");
+        sourceConfig.put("connector.class", "io.debezium.connector.mongodb.MongoDbConnector");
+    }
+
+    @Override
+    public void setServiceContainer(DebeziumMongoDbContainer container) {
+        log.info("start debezium mongodb server container.");
+        debeziumMongoDbContainer = container;
+        pulsarCluster.startService(DebeziumMongoDbContainer.NAME, debeziumMongoDbContainer);
+    }
+
+    @Override
+    public void prepareSource() throws Exception {
+        this.debeziumMongoDbContainer.execCmd("bash", "-c", "/usr/local/bin/init-inventory.sh");
+        log.info("debezium mongodb server already contains preconfigured data.");
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
+                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
+                        + "--eval 'db.products.find()'");
+        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
+                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
+                        + "--eval 'db.products.insert({ "
+                        + "_id : NumberLong(\"110\"),"
+                        + "name : \"test-debezium\","
+                        + "description: \"24 inch spare tire\","
+                        + "weight : 22.2,"
+                        + "quantity : NumberInt(\"5\")})'");
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
+                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
+                        + "--eval 'db.products.find()'");
+        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
+                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
+                        + "--eval 'db.products.deleteOne({name : \"test-debezium-update\"})'");
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
+                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
+                        + "--eval 'db.products.find()'");
+        this.debeziumMongoDbContainer.execCmd("/bin/bash", "-c",
+                "mongosh -u debezium -p dbz --authenticationDatabase admin localhost:27017/inventory "
+                        + "--eval 'db.products.update({"
+                        + "_id : 110},"
+                        + "{$set:{name:\"test-debezium-update\", description: \"this is update description\"}})'");
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
+        log.info("debezium mongodb server already contains preconfigured data.");
+        return null;
+    }
+
+    @Override
+    public String valueContains() {
+        return "dbserver1.inventory.products.Envelope";
+    }
+
+    @Override
+    public void close() {
+        if (debeziumMongoDbContainer != null) {
+            PulsarCluster.stopService(DebeziumMongoDbContainer.NAME, debeziumMongoDbContainer);
+            debeziumMongoDbContainer = null;
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMsSqlSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMsSqlSourceTester.java
index 2295a67066..7027cf3903 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMsSqlSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMsSqlSourceTester.java
@@ -1,170 +1,170 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import com.google.common.base.Preconditions;
-import java.util.Map;
-import lombok.Getter;
-import lombok.SneakyThrows;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.DebeziumMsSqlContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.Assert;
-import org.testng.util.Strings;
-
-/**
- * A tester for testing Debezium Microsoft SQl Server source.
- */
-@Slf4j
-public class DebeziumMsSqlSourceTester extends SourceTester<DebeziumMsSqlContainer> {
-
-    private static final String NAME = "debezium-mssql";
-
-    private final String pulsarServiceUrl;
-
-    @Getter
-    private DebeziumMsSqlContainer debeziumMsSqlContainer;
-
-    private final PulsarCluster pulsarCluster;
-
-    public DebeziumMsSqlSourceTester(PulsarCluster cluster) {
-        super(NAME);
-        this.pulsarCluster = cluster;
-        this.numEntriesToInsert = 1;
-        this.numEntriesExpectAfterStart = 0;
-
-        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
-
-        sourceConfig.put("database.hostname", DebeziumMsSqlContainer.NAME);
-        sourceConfig.put("database.port", "1433");
-        sourceConfig.put("database.user", "sa");
-        sourceConfig.put("database.password", DebeziumMsSqlContainer.SA_PASSWORD);
-        sourceConfig.put("database.names", "TestDB");
-        sourceConfig.put("database.encrypt", "false");
-        sourceConfig.put("snapshot.mode", "schema_only");
-        sourceConfig.put("schema.history.internal.pulsar.topic", "debezium-schema-history-mssql");
-        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
-        sourceConfig.put("topic.prefix", "mssql");
-        sourceConfig.put("topic.namespace", "debezium/mssql");
-        sourceConfig.put("task.id", "1");
-        sourceConfig.put("connector.class", "io.debezium.connector.sqlserver.SqlServerConnector");
-    }
-
-    @Override
-    public void setServiceContainer(DebeziumMsSqlContainer container) {
-        log.info("start debezium MS SQL server container.");
-        Preconditions.checkState(debeziumMsSqlContainer == null);
-        debeziumMsSqlContainer = container;
-        pulsarCluster.startService(DebeziumMsSqlContainer.NAME, debeziumMsSqlContainer);
-    }
-
-    @SneakyThrows
-    @Override
-    public void prepareSource() {
-        runSqlCmd("CREATE DATABASE TestDB;", false);
-        runSqlCmd("EXEC sys.sp_cdc_enable_db;");
-        ContainerExecResult res = runSqlCmd("SELECT is_cdc_enabled FROM sys.databases WHERE database_id = DB_ID();");
-        // " 1" to differentiate from "(1 rows affected)"
-        Assert.assertTrue(res.getStdout().contains(" 1"));
-        runSqlCmd("CREATE TABLE customers ("
-                + "id INT NOT NULL  IDENTITY  PRIMARY KEY, "
-                + "first_name VARCHAR(255) NOT NULL, "
-                + "last_name VARCHAR(255) NOT NULL, "
-                + "email VARCHAR(255) NOT NULL"
-                + ");");
-        runSqlCmd("EXEC sys.sp_cdc_enable_table @source_schema = 'dbo', @source_name = 'customers',"
-                + " @role_name = NULL, @supports_net_changes = 0, @capture_instance = 'dbo_customers_v2';");
-        runSqlCmd("EXEC sys.sp_cdc_start_job;");
-    }
-
-    private ContainerExecResult runSqlCmd(String cmd) throws Exception {
-        return runSqlCmd(cmd, true);
-    }
-
-    private ContainerExecResult runSqlCmd(String cmd, boolean useTestDb) throws Exception {
-        log.info("Executing \"{}\"", cmd);
-        ContainerExecResult response = this.debeziumMsSqlContainer
-                .execCmd("/bin/bash", "-c",
-                "/opt/mssql-tools18/bin/sqlcmd -C -S localhost -U sa -P \""
-                        + DebeziumMsSqlContainer.SA_PASSWORD + "\" -Q \""
-                        + (useTestDb ? "USE TestDB; " : "")
-                        + cmd
-                        + "\""
-                );
-        if (Strings.isNullOrEmpty(response.getStderr())) {
-            log.info("Result of \"{}\":\n{}", cmd, response.getStdout());
-        } else {
-            log.warn("Result of \"{}\":\n{}\n{}", cmd, response.getStdout(), response.getStderr());
-        }
-        return response;
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        runSqlCmd("INSERT INTO customers (first_name, last_name, email) VALUES ('John', 'Doe', 'jdoe@null.dev');");
-        runSqlCmd("SELECT * FROM customers WHERE last_name='Doe';");
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        runSqlCmd("DELETE FROM customers WHERE last_name='Doe';");
-        runSqlCmd("SELECT * FROM customers WHERE last_name='Doe';");
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        runSqlCmd("UPDATE customers SET first_name='Jack' WHERE last_name='Doe';");
-        runSqlCmd("SELECT * FROM customers WHERE last_name='Doe';");
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) {
-        log.info("debezium MS SQL server already contains preconfigured data.");
-        return null;
-    }
-
-    @Override
-    public int initialDelayForMsgReceive() {
-        return 30;
-    }
-
-    @Override
-    public String keyContains() {
-        return "TestDB";
-    }
-
-    @Override
-    public String valueContains() {
-        return "TestDB";
-    }
-
-    @Override
-    public void close() {
-        if (pulsarCluster != null) {
-            if (debeziumMsSqlContainer != null) {
-                PulsarCluster.stopService(DebeziumMsSqlContainer.NAME, debeziumMsSqlContainer);
-                debeziumMsSqlContainer = null;
-            }
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import com.google.common.base.Preconditions;
+import java.util.Map;
+import lombok.Getter;
+import lombok.SneakyThrows;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.DebeziumMsSqlContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.Assert;
+import org.testng.util.Strings;
+
+/**
+ * A tester for testing Debezium Microsoft SQl Server source.
+ */
+@Slf4j
+public class DebeziumMsSqlSourceTester extends SourceTester<DebeziumMsSqlContainer> {
+
+    private static final String NAME = "debezium-mssql";
+
+    private final String pulsarServiceUrl;
+
+    @Getter
+    private DebeziumMsSqlContainer debeziumMsSqlContainer;
+
+    private final PulsarCluster pulsarCluster;
+
+    public DebeziumMsSqlSourceTester(PulsarCluster cluster) {
+        super(NAME);
+        this.pulsarCluster = cluster;
+        this.numEntriesToInsert = 1;
+        this.numEntriesExpectAfterStart = 0;
+
+        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
+
+        sourceConfig.put("database.hostname", DebeziumMsSqlContainer.NAME);
+        sourceConfig.put("database.port", "1433");
+        sourceConfig.put("database.user", "sa");
+        sourceConfig.put("database.password", DebeziumMsSqlContainer.SA_PASSWORD);
+        sourceConfig.put("database.names", "TestDB");
+        sourceConfig.put("database.encrypt", "false");
+        sourceConfig.put("snapshot.mode", "schema_only");
+        sourceConfig.put("schema.history.internal.pulsar.topic", "debezium-schema-history-mssql");
+        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
+        sourceConfig.put("topic.prefix", "mssql");
+        sourceConfig.put("topic.namespace", "debezium/mssql");
+        sourceConfig.put("task.id", "1");
+        sourceConfig.put("connector.class", "io.debezium.connector.sqlserver.SqlServerConnector");
+    }
+
+    @Override
+    public void setServiceContainer(DebeziumMsSqlContainer container) {
+        log.info("start debezium MS SQL server container.");
+        Preconditions.checkState(debeziumMsSqlContainer == null);
+        debeziumMsSqlContainer = container;
+        pulsarCluster.startService(DebeziumMsSqlContainer.NAME, debeziumMsSqlContainer);
+    }
+
+    @SneakyThrows
+    @Override
+    public void prepareSource() {
+        runSqlCmd("CREATE DATABASE TestDB;", false);
+        runSqlCmd("EXEC sys.sp_cdc_enable_db;");
+        ContainerExecResult res = runSqlCmd("SELECT is_cdc_enabled FROM sys.databases WHERE database_id = DB_ID();");
+        // " 1" to differentiate from "(1 rows affected)"
+        Assert.assertTrue(res.getStdout().contains(" 1"));
+        runSqlCmd("CREATE TABLE customers ("
+                + "id INT NOT NULL  IDENTITY  PRIMARY KEY, "
+                + "first_name VARCHAR(255) NOT NULL, "
+                + "last_name VARCHAR(255) NOT NULL, "
+                + "email VARCHAR(255) NOT NULL"
+                + ");");
+        runSqlCmd("EXEC sys.sp_cdc_enable_table @source_schema = 'dbo', @source_name = 'customers',"
+                + " @role_name = NULL, @supports_net_changes = 0, @capture_instance = 'dbo_customers_v2';");
+        runSqlCmd("EXEC sys.sp_cdc_start_job;");
+    }
+
+    private ContainerExecResult runSqlCmd(String cmd) throws Exception {
+        return runSqlCmd(cmd, true);
+    }
+
+    private ContainerExecResult runSqlCmd(String cmd, boolean useTestDb) throws Exception {
+        log.info("Executing \"{}\"", cmd);
+        ContainerExecResult response = this.debeziumMsSqlContainer
+                .execCmd("/bin/bash", "-c",
+                "/opt/mssql-tools18/bin/sqlcmd -C -S localhost -U sa -P \""
+                        + DebeziumMsSqlContainer.SA_PASSWORD + "\" -Q \""
+                        + (useTestDb ? "USE TestDB; " : "")
+                        + cmd
+                        + "\""
+                );
+        if (Strings.isNullOrEmpty(response.getStderr())) {
+            log.info("Result of \"{}\":\n{}", cmd, response.getStdout());
+        } else {
+            log.warn("Result of \"{}\":\n{}\n{}", cmd, response.getStdout(), response.getStderr());
+        }
+        return response;
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        runSqlCmd("INSERT INTO customers (first_name, last_name, email) VALUES ('John', 'Doe', 'jdoe@null.dev');");
+        runSqlCmd("SELECT * FROM customers WHERE last_name='Doe';");
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        runSqlCmd("DELETE FROM customers WHERE last_name='Doe';");
+        runSqlCmd("SELECT * FROM customers WHERE last_name='Doe';");
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        runSqlCmd("UPDATE customers SET first_name='Jack' WHERE last_name='Doe';");
+        runSqlCmd("SELECT * FROM customers WHERE last_name='Doe';");
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) {
+        log.info("debezium MS SQL server already contains preconfigured data.");
+        return null;
+    }
+
+    @Override
+    public int initialDelayForMsgReceive() {
+        return 30;
+    }
+
+    @Override
+    public String keyContains() {
+        return "TestDB";
+    }
+
+    @Override
+    public String valueContains() {
+        return "TestDB";
+    }
+
+    @Override
+    public void close() {
+        if (pulsarCluster != null) {
+            if (debeziumMsSqlContainer != null) {
+                PulsarCluster.stopService(DebeziumMsSqlContainer.NAME, debeziumMsSqlContainer);
+                debeziumMsSqlContainer = null;
+            }
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMySqlSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMySqlSourceTester.java
index 7f9ccbf5d2..ff01226c9b 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMySqlSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumMySqlSourceTester.java
@@ -1,135 +1,135 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import java.util.Map;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.DebeziumMySQLContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-
-/**
- * A tester for testing Debezium MySQL source.
- *
- * It reads binlog from MySQL, and store the debezium output into Pulsar.
- * This test verify that the target topic contains wanted number messages.
- *
- * Debezium MySQL Container is "debezium/example-mysql:0.8",
- * which is a MySQL database server preconfigured with an inventory database.
- */
-@Slf4j
-public class DebeziumMySqlSourceTester extends SourceTester<DebeziumMySQLContainer> {
-
-    private static final String NAME = "debezium-mysql";
-
-    private final String pulsarServiceUrl;
-
-    @Getter
-    private DebeziumMySQLContainer debeziumMySqlContainer;
-
-    private final PulsarCluster pulsarCluster;
-
-    public DebeziumMySqlSourceTester(PulsarCluster cluster, String converterClassName,
-                                     boolean testWithClientBuilder) {
-        super(NAME);
-        this.pulsarCluster = cluster;
-        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
-
-        sourceConfig.put("database.hostname", DebeziumMySQLContainer.NAME);
-        sourceConfig.put("database.port", "3306");
-        sourceConfig.put("database.user", "debezium");
-        sourceConfig.put("database.password", "dbz");
-        sourceConfig.put("database.server.id", "184054");
-        sourceConfig.put("topic.prefix", "dbserver1");
-        sourceConfig.put("database.include.list", "inventory");
-        if (!testWithClientBuilder) {
-            sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
-        }
-        sourceConfig.put("key.converter", converterClassName);
-        sourceConfig.put("value.converter", converterClassName);
-        sourceConfig.put("topic.namespace", "debezium/mysql-"
-               + (converterClassName.endsWith("AvroConverter") ? "avro" : "json"));
-        sourceConfig.put("connector.class", "io.debezium.connector.mysql.MySqlConnector");
-    }
-
-    @Override
-    public void setServiceContainer(DebeziumMySQLContainer container) {
-        log.info("start debezium mysql server container.");
-        debeziumMySqlContainer = container;
-        pulsarCluster.startService(DebeziumMySQLContainer.NAME, debeziumMySqlContainer);
-    }
-
-    @Override
-    public void prepareSource() throws Exception {
-        log.info("debezium mysql server already contains preconfigured data.");
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        this.debeziumMySqlContainer.execCmd(
-                "/bin/bash", "-c",
-                "mysql -h 127.0.0.1 -u root -pdebezium -e 'SELECT * FROM inventory.products'");
-        this.debeziumMySqlContainer.execCmd(
-                "/bin/bash", "-c",
-                "mysql -h 127.0.0.1 -u root -pdebezium "
-                        + "-e \"INSERT INTO inventory.products(name, description, weight) "
-                        + "values('test-debezium', 'This is description', 2.0)\"");
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        this.debeziumMySqlContainer.execCmd(
-                "/bin/bash", "-c",
-                "mysql -h 127.0.0.1 -u root -pdebezium "
-                        + "-e \"UPDATE inventory.products set description='update description', weight=10 "
-                        + "WHERE name='test-debezium'\"");
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        this.debeziumMySqlContainer.execCmd(
-                "/bin/bash", "-c",
-                "mysql -h 127.0.0.1 -u root -pdebezium -e 'SELECT * FROM inventory.products'");
-        this.debeziumMySqlContainer.execCmd(
-                "/bin/bash", "-c",
-                "mysql -h 127.0.0.1 -u root -pdebezium "
-                        + "-e \"DELETE FROM inventory.products WHERE name='test-debezium'\"");
-        this.debeziumMySqlContainer.execCmd(
-                "/bin/bash", "-c",
-                "mysql -h 127.0.0.1 -u root -pdebezium -e 'SELECT * FROM inventory.products'");
-    }
-
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
-        log.info("debezium mysql server already contains preconfigured data.");
-        return null;
-    }
-
-    @Override
-    public void close() {
-        if (debeziumMySqlContainer != null) {
-            PulsarCluster.stopService(DebeziumMySQLContainer.NAME, debeziumMySqlContainer);
-            debeziumMySqlContainer = null;
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import java.util.Map;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.DebeziumMySQLContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+
+/**
+ * A tester for testing Debezium MySQL source.
+ *
+ * It reads binlog from MySQL, and store the debezium output into Pulsar.
+ * This test verify that the target topic contains wanted number messages.
+ *
+ * Debezium MySQL Container is "debezium/example-mysql:0.8",
+ * which is a MySQL database server preconfigured with an inventory database.
+ */
+@Slf4j
+public class DebeziumMySqlSourceTester extends SourceTester<DebeziumMySQLContainer> {
+
+    private static final String NAME = "debezium-mysql";
+
+    private final String pulsarServiceUrl;
+
+    @Getter
+    private DebeziumMySQLContainer debeziumMySqlContainer;
+
+    private final PulsarCluster pulsarCluster;
+
+    public DebeziumMySqlSourceTester(PulsarCluster cluster, String converterClassName,
+                                     boolean testWithClientBuilder) {
+        super(NAME);
+        this.pulsarCluster = cluster;
+        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
+
+        sourceConfig.put("database.hostname", DebeziumMySQLContainer.NAME);
+        sourceConfig.put("database.port", "3306");
+        sourceConfig.put("database.user", "debezium");
+        sourceConfig.put("database.password", "dbz");
+        sourceConfig.put("database.server.id", "184054");
+        sourceConfig.put("topic.prefix", "dbserver1");
+        sourceConfig.put("database.include.list", "inventory");
+        if (!testWithClientBuilder) {
+            sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
+        }
+        sourceConfig.put("key.converter", converterClassName);
+        sourceConfig.put("value.converter", converterClassName);
+        sourceConfig.put("topic.namespace", "debezium/mysql-"
+               + (converterClassName.endsWith("AvroConverter") ? "avro" : "json"));
+        sourceConfig.put("connector.class", "io.debezium.connector.mysql.MySqlConnector");
+    }
+
+    @Override
+    public void setServiceContainer(DebeziumMySQLContainer container) {
+        log.info("start debezium mysql server container.");
+        debeziumMySqlContainer = container;
+        pulsarCluster.startService(DebeziumMySQLContainer.NAME, debeziumMySqlContainer);
+    }
+
+    @Override
+    public void prepareSource() throws Exception {
+        log.info("debezium mysql server already contains preconfigured data.");
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        this.debeziumMySqlContainer.execCmd(
+                "/bin/bash", "-c",
+                "mysql -h 127.0.0.1 -u root -pdebezium -e 'SELECT * FROM inventory.products'");
+        this.debeziumMySqlContainer.execCmd(
+                "/bin/bash", "-c",
+                "mysql -h 127.0.0.1 -u root -pdebezium "
+                        + "-e \"INSERT INTO inventory.products(name, description, weight) "
+                        + "values('test-debezium', 'This is description', 2.0)\"");
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        this.debeziumMySqlContainer.execCmd(
+                "/bin/bash", "-c",
+                "mysql -h 127.0.0.1 -u root -pdebezium "
+                        + "-e \"UPDATE inventory.products set description='update description', weight=10 "
+                        + "WHERE name='test-debezium'\"");
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        this.debeziumMySqlContainer.execCmd(
+                "/bin/bash", "-c",
+                "mysql -h 127.0.0.1 -u root -pdebezium -e 'SELECT * FROM inventory.products'");
+        this.debeziumMySqlContainer.execCmd(
+                "/bin/bash", "-c",
+                "mysql -h 127.0.0.1 -u root -pdebezium "
+                        + "-e \"DELETE FROM inventory.products WHERE name='test-debezium'\"");
+        this.debeziumMySqlContainer.execCmd(
+                "/bin/bash", "-c",
+                "mysql -h 127.0.0.1 -u root -pdebezium -e 'SELECT * FROM inventory.products'");
+    }
+
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) throws Exception {
+        log.info("debezium mysql server already contains preconfigured data.");
+        return null;
+    }
+
+    @Override
+    public void close() {
+        if (debeziumMySqlContainer != null) {
+            PulsarCluster.stopService(DebeziumMySQLContainer.NAME, debeziumMySqlContainer);
+            debeziumMySqlContainer = null;
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumOracleDbSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumOracleDbSourceTester.java
index 39b4361ee8..263c8c1c46 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumOracleDbSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumOracleDbSourceTester.java
@@ -1,258 +1,258 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import com.google.common.base.Preconditions;
-import java.util.Map;
-import lombok.Getter;
-import lombok.SneakyThrows;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.DebeziumOracleDbContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.util.Strings;
-
-/**
- * A tester for testing Debezium OracleDb source.
- */
-@Slf4j
-public class DebeziumOracleDbSourceTester extends SourceTester<DebeziumOracleDbContainer> {
-
-    private static final String NAME = "debezium-oracle";
-    private static final long SLEEP_AFTER_COMMAND_MS = 30_000;
-
-    private final String pulsarServiceUrl;
-
-    @Getter
-    private DebeziumOracleDbContainer debeziumOracleDbContainer;
-
-    private final PulsarCluster pulsarCluster;
-
-    public DebeziumOracleDbSourceTester(PulsarCluster cluster) {
-        super(NAME);
-        this.pulsarCluster = cluster;
-        this.numEntriesToInsert = 1;
-        this.numEntriesExpectAfterStart = 0;
-
-        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
-
-        sourceConfig.put("database.hostname", DebeziumOracleDbContainer.NAME);
-        sourceConfig.put("database.port", "1521");
-        sourceConfig.put("database.user", "dbzuser");
-        sourceConfig.put("database.password", "dbz");
-        sourceConfig.put("topic.prefix", "XE");
-        sourceConfig.put("database.dbname", "XE");
-        sourceConfig.put("snapshot.mode", "schema_only");
-
-        sourceConfig.put("schema.include.list", "inv");
-        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
-        sourceConfig.put("topic.namespace", "debezium/oracle");
-
-        sourceConfig.put("connector.class", "io.debezium.connector.oracle.OracleConnector");
-    }
-
-    @Override
-    public void setServiceContainer(DebeziumOracleDbContainer container) {
-        log.info("start debezium oracle server container.");
-        Preconditions.checkState(debeziumOracleDbContainer == null);
-        debeziumOracleDbContainer = container;
-        pulsarCluster.startService(DebeziumOracleDbContainer.NAME, debeziumOracleDbContainer);
-    }
-
-    @SneakyThrows
-    @Override
-    public void prepareSource() {
-        String[] minerCommands = {
-            "ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;",
-            "ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;",
-            "alter system switch logfile;"
-        };
-        String[] commands = {
-            "CREATE TABLESPACE inv DATAFILE 'tbs_inv01.dbf' SIZE 200M LOGGING;",
-            "CREATE USER inv identified by inv default tablespace inv;",
-            "GRANT CREATE TABLE TO inv;",
-            "GRANT LOCK ANY TABLE TO inv;",
-            "GRANT ALTER ANY TABLE TO inv;",
-            "GRANT CREATE SEQUENCE TO inv;",
-            "GRANT UNLIMITED TABLESPACE TO inv;",
-            "CREATE TABLE inv.customers ("
-                + "id NUMBER(9) GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH 1001) NOT NULL PRIMARY KEY,"
-                + "first_name VARCHAR2(255) NOT NULL,"
-                + "last_name VARCHAR2(255) NOT NULL,"
-                + "email VARCHAR2(255) NOT NULL"
-                + ");",
-            "ALTER TABLE inv.customers ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;",
-
-            // create user for debezium
-            "create role dbz_privs;",
-            "grant create session, execute_catalog_role, select any transaction, select any dictionary to dbz_privs;",
-            "grant select on SYSTEM.LOGMNR_COL$ to dbz_privs;",
-            "grant select on SYSTEM.LOGMNR_OBJ$ to dbz_privs;",
-            "grant select on SYSTEM.LOGMNR_USER$ to dbz_privs;",
-            "grant select on SYSTEM.LOGMNR_UID$ to dbz_privs;",
-            "create user dbzuser identified by dbz default tablespace users;",
-            "grant dbz_privs to dbzuser;",
-            "alter user dbzuser quota unlimited on users;",
-            "grant LOGMINING to dbz_privs;",
-
-            "GRANT CREATE SESSION TO dbzuser;",
-            "GRANT SET CONTAINER TO dbzuser;",
-            "GRANT SELECT ON V_$DATABASE to dbzuser;",
-            "GRANT FLASHBACK ANY TABLE TO dbzuser;",
-            "GRANT SELECT ANY TABLE TO dbzuser;",
-            "GRANT SELECT_CATALOG_ROLE TO dbzuser;",
-            "GRANT EXECUTE_CATALOG_ROLE TO dbzuser;",
-            "GRANT SELECT ANY TRANSACTION TO dbzuser;",
-            "GRANT LOGMINING TO dbzuser;",
-
-            "GRANT CREATE TABLE TO dbzuser;",
-            "GRANT LOCK ANY TABLE TO dbzuser;",
-            "GRANT ALTER ANY TABLE TO dbzuser;",
-            "GRANT CREATE SEQUENCE TO dbzuser;",
-
-            "GRANT EXECUTE ON DBMS_LOGMNR TO dbzuser;",
-            "GRANT EXECUTE ON DBMS_LOGMNR_D TO dbzuser;",
-
-            "GRANT SELECT ON V_$LOG TO dbzuser;",
-            "GRANT SELECT ON V_$LOG_HISTORY TO dbzuser;",
-            "GRANT SELECT ON V_$LOGMNR_LOGS TO dbzuser;",
-            "GRANT SELECT ON V_$LOGMNR_CONTENTS TO dbzuser;",
-            "GRANT SELECT ON V_$LOGMNR_PARAMETERS TO dbzuser;",
-            "GRANT SELECT ON V_$LOGFILE TO dbzuser;",
-            "GRANT SELECT ON V_$ARCHIVED_LOG TO dbzuser;",
-            "GRANT SELECT ON V_$ARCHIVE_DEST_STATUS TO dbzuser;"
-        };
-
-        // good first approximation but still not enough:
-        waitForOracleStatus("OPEN");
-        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
-
-        // configure logminer
-        runSqlCmd("shutdown immediate");
-
-        // good first approximation but still not enough:
-        waitForOracleStatus("ORACLE not available");
-        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
-
-        runSqlCmd("startup mount");
-        // good first approximation but still not enough:
-        waitForOracleStatus("MOUNTED");
-        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
-
-        runSqlCmd("alter database archivelog;");
-        runSqlCmd("alter database open;");
-        // good first approximation but still not enough:
-        waitForOracleStatus("OPEN");
-        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
-
-        for (String cmd: minerCommands) {
-            runSqlCmd(cmd);
-        }
-
-        // create user/tablespace/table
-        for (String cmd: commands) {
-            runSqlCmd(cmd);
-        }
-        // initial event
-        runSqlCmd("INSERT INTO inv.customers (first_name, last_name, email) "
-                + "VALUES ('James', 'Bond', 'jbond@null.dev');");
-    }
-
-    private void waitForOracleStatus(String status) throws Exception {
-        for (int i = 0; i < 1000; i++) {
-            ContainerExecResult response = runSqlCmd("SELECT INSTANCE_NAME, STATUS, DATABASE_STATUS FROM V$INSTANCE;");
-            if ((response.getStderr() != null && response.getStderr().contains(status))
-                    || (response.getStdout() != null && response.getStdout().contains(status))) {
-                return;
-            }
-            Thread.sleep(1000);
-        }
-        throw new IllegalStateException("Oracle did not initialize properly");
-    }
-
-    private ContainerExecResult runSqlCmd(String cmd) throws Exception {
-        log.info("Executing \"{}\"", cmd);
-        ContainerExecResult response = this.debeziumOracleDbContainer
-                .execCmdAsUser("oracle",
-                "/bin/bash", "-c",
-                "echo \"exit;\" | echo \""
-                        + cmd.replace("$", "\\$")
-                        + "\" | sqlplus sys/oracle as sysdba"
-                );
-        if (Strings.isNullOrEmpty(response.getStderr())) {
-            log.info("Result of \"{}\":\n{}", cmd, response.getStdout());
-        } else {
-            log.warn("Result of \"{}\":\n{}\n{}", cmd, response.getStdout(), response.getStderr());
-        }
-        return response;
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        runSqlCmd("INSERT INTO inv.customers (first_name, last_name, email) VALUES ('John', 'Doe', 'jdoe@null.dev');");
-        runSqlCmd("SELECT * FROM inv.customers WHERE last_name='Doe';");
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        runSqlCmd("DELETE FROM inv.customers WHERE last_name='Doe';");
-        runSqlCmd("SELECT * FROM inv.customers WHERE last_name='Doe';");
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        runSqlCmd("UPDATE inv.customers SET first_name='Jack' WHERE last_name='Doe';");
-        runSqlCmd("SELECT * FROM inv.customers WHERE last_name='Doe';");
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) {
-        log.info("debezium oracle server already contains preconfigured data.");
-        return null;
-    }
-
-    @Override
-    public int initialDelayForMsgReceive() {
-        // LogMiner takes a lot of time to get messages out
-        return 30;
-    }
-
-    @Override
-    public String keyContains() {
-        return "XE.INV.CUSTOMERS.Key";
-    }
-
-    @Override
-    public String valueContains() {
-        return "XE.INV.CUSTOMERS.Value";
-    }
-
-    @Override
-    public void close() {
-        if (pulsarCluster != null) {
-            if (debeziumOracleDbContainer != null) {
-                PulsarCluster.stopService(DebeziumOracleDbContainer.NAME, debeziumOracleDbContainer);
-                debeziumOracleDbContainer = null;
-            }
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import com.google.common.base.Preconditions;
+import java.util.Map;
+import lombok.Getter;
+import lombok.SneakyThrows;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.DebeziumOracleDbContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.util.Strings;
+
+/**
+ * A tester for testing Debezium OracleDb source.
+ */
+@Slf4j
+public class DebeziumOracleDbSourceTester extends SourceTester<DebeziumOracleDbContainer> {
+
+    private static final String NAME = "debezium-oracle";
+    private static final long SLEEP_AFTER_COMMAND_MS = 30_000;
+
+    private final String pulsarServiceUrl;
+
+    @Getter
+    private DebeziumOracleDbContainer debeziumOracleDbContainer;
+
+    private final PulsarCluster pulsarCluster;
+
+    public DebeziumOracleDbSourceTester(PulsarCluster cluster) {
+        super(NAME);
+        this.pulsarCluster = cluster;
+        this.numEntriesToInsert = 1;
+        this.numEntriesExpectAfterStart = 0;
+
+        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
+
+        sourceConfig.put("database.hostname", DebeziumOracleDbContainer.NAME);
+        sourceConfig.put("database.port", "1521");
+        sourceConfig.put("database.user", "dbzuser");
+        sourceConfig.put("database.password", "dbz");
+        sourceConfig.put("topic.prefix", "XE");
+        sourceConfig.put("database.dbname", "XE");
+        sourceConfig.put("snapshot.mode", "schema_only");
+
+        sourceConfig.put("schema.include.list", "inv");
+        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
+        sourceConfig.put("topic.namespace", "debezium/oracle");
+
+        sourceConfig.put("connector.class", "io.debezium.connector.oracle.OracleConnector");
+    }
+
+    @Override
+    public void setServiceContainer(DebeziumOracleDbContainer container) {
+        log.info("start debezium oracle server container.");
+        Preconditions.checkState(debeziumOracleDbContainer == null);
+        debeziumOracleDbContainer = container;
+        pulsarCluster.startService(DebeziumOracleDbContainer.NAME, debeziumOracleDbContainer);
+    }
+
+    @SneakyThrows
+    @Override
+    public void prepareSource() {
+        String[] minerCommands = {
+            "ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;",
+            "ALTER DATABASE ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;",
+            "alter system switch logfile;"
+        };
+        String[] commands = {
+            "CREATE TABLESPACE inv DATAFILE 'tbs_inv01.dbf' SIZE 200M LOGGING;",
+            "CREATE USER inv identified by inv default tablespace inv;",
+            "GRANT CREATE TABLE TO inv;",
+            "GRANT LOCK ANY TABLE TO inv;",
+            "GRANT ALTER ANY TABLE TO inv;",
+            "GRANT CREATE SEQUENCE TO inv;",
+            "GRANT UNLIMITED TABLESPACE TO inv;",
+            "CREATE TABLE inv.customers ("
+                + "id NUMBER(9) GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH 1001) NOT NULL PRIMARY KEY,"
+                + "first_name VARCHAR2(255) NOT NULL,"
+                + "last_name VARCHAR2(255) NOT NULL,"
+                + "email VARCHAR2(255) NOT NULL"
+                + ");",
+            "ALTER TABLE inv.customers ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;",
+
+            // create user for debezium
+            "create role dbz_privs;",
+            "grant create session, execute_catalog_role, select any transaction, select any dictionary to dbz_privs;",
+            "grant select on SYSTEM.LOGMNR_COL$ to dbz_privs;",
+            "grant select on SYSTEM.LOGMNR_OBJ$ to dbz_privs;",
+            "grant select on SYSTEM.LOGMNR_USER$ to dbz_privs;",
+            "grant select on SYSTEM.LOGMNR_UID$ to dbz_privs;",
+            "create user dbzuser identified by dbz default tablespace users;",
+            "grant dbz_privs to dbzuser;",
+            "alter user dbzuser quota unlimited on users;",
+            "grant LOGMINING to dbz_privs;",
+
+            "GRANT CREATE SESSION TO dbzuser;",
+            "GRANT SET CONTAINER TO dbzuser;",
+            "GRANT SELECT ON V_$DATABASE to dbzuser;",
+            "GRANT FLASHBACK ANY TABLE TO dbzuser;",
+            "GRANT SELECT ANY TABLE TO dbzuser;",
+            "GRANT SELECT_CATALOG_ROLE TO dbzuser;",
+            "GRANT EXECUTE_CATALOG_ROLE TO dbzuser;",
+            "GRANT SELECT ANY TRANSACTION TO dbzuser;",
+            "GRANT LOGMINING TO dbzuser;",
+
+            "GRANT CREATE TABLE TO dbzuser;",
+            "GRANT LOCK ANY TABLE TO dbzuser;",
+            "GRANT ALTER ANY TABLE TO dbzuser;",
+            "GRANT CREATE SEQUENCE TO dbzuser;",
+
+            "GRANT EXECUTE ON DBMS_LOGMNR TO dbzuser;",
+            "GRANT EXECUTE ON DBMS_LOGMNR_D TO dbzuser;",
+
+            "GRANT SELECT ON V_$LOG TO dbzuser;",
+            "GRANT SELECT ON V_$LOG_HISTORY TO dbzuser;",
+            "GRANT SELECT ON V_$LOGMNR_LOGS TO dbzuser;",
+            "GRANT SELECT ON V_$LOGMNR_CONTENTS TO dbzuser;",
+            "GRANT SELECT ON V_$LOGMNR_PARAMETERS TO dbzuser;",
+            "GRANT SELECT ON V_$LOGFILE TO dbzuser;",
+            "GRANT SELECT ON V_$ARCHIVED_LOG TO dbzuser;",
+            "GRANT SELECT ON V_$ARCHIVE_DEST_STATUS TO dbzuser;"
+        };
+
+        // good first approximation but still not enough:
+        waitForOracleStatus("OPEN");
+        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
+
+        // configure logminer
+        runSqlCmd("shutdown immediate");
+
+        // good first approximation but still not enough:
+        waitForOracleStatus("ORACLE not available");
+        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
+
+        runSqlCmd("startup mount");
+        // good first approximation but still not enough:
+        waitForOracleStatus("MOUNTED");
+        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
+
+        runSqlCmd("alter database archivelog;");
+        runSqlCmd("alter database open;");
+        // good first approximation but still not enough:
+        waitForOracleStatus("OPEN");
+        Thread.sleep(SLEEP_AFTER_COMMAND_MS);
+
+        for (String cmd: minerCommands) {
+            runSqlCmd(cmd);
+        }
+
+        // create user/tablespace/table
+        for (String cmd: commands) {
+            runSqlCmd(cmd);
+        }
+        // initial event
+        runSqlCmd("INSERT INTO inv.customers (first_name, last_name, email) "
+                + "VALUES ('James', 'Bond', 'jbond@null.dev');");
+    }
+
+    private void waitForOracleStatus(String status) throws Exception {
+        for (int i = 0; i < 1000; i++) {
+            ContainerExecResult response = runSqlCmd("SELECT INSTANCE_NAME, STATUS, DATABASE_STATUS FROM V$INSTANCE;");
+            if ((response.getStderr() != null && response.getStderr().contains(status))
+                    || (response.getStdout() != null && response.getStdout().contains(status))) {
+                return;
+            }
+            Thread.sleep(1000);
+        }
+        throw new IllegalStateException("Oracle did not initialize properly");
+    }
+
+    private ContainerExecResult runSqlCmd(String cmd) throws Exception {
+        log.info("Executing \"{}\"", cmd);
+        ContainerExecResult response = this.debeziumOracleDbContainer
+                .execCmdAsUser("oracle",
+                "/bin/bash", "-c",
+                "echo \"exit;\" | echo \""
+                        + cmd.replace("$", "\\$")
+                        + "\" | sqlplus sys/oracle as sysdba"
+                );
+        if (Strings.isNullOrEmpty(response.getStderr())) {
+            log.info("Result of \"{}\":\n{}", cmd, response.getStdout());
+        } else {
+            log.warn("Result of \"{}\":\n{}\n{}", cmd, response.getStdout(), response.getStderr());
+        }
+        return response;
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        runSqlCmd("INSERT INTO inv.customers (first_name, last_name, email) VALUES ('John', 'Doe', 'jdoe@null.dev');");
+        runSqlCmd("SELECT * FROM inv.customers WHERE last_name='Doe';");
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        runSqlCmd("DELETE FROM inv.customers WHERE last_name='Doe';");
+        runSqlCmd("SELECT * FROM inv.customers WHERE last_name='Doe';");
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        runSqlCmd("UPDATE inv.customers SET first_name='Jack' WHERE last_name='Doe';");
+        runSqlCmd("SELECT * FROM inv.customers WHERE last_name='Doe';");
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) {
+        log.info("debezium oracle server already contains preconfigured data.");
+        return null;
+    }
+
+    @Override
+    public int initialDelayForMsgReceive() {
+        // LogMiner takes a lot of time to get messages out
+        return 30;
+    }
+
+    @Override
+    public String keyContains() {
+        return "XE.INV.CUSTOMERS.Key";
+    }
+
+    @Override
+    public String valueContains() {
+        return "XE.INV.CUSTOMERS.Value";
+    }
+
+    @Override
+    public void close() {
+        if (pulsarCluster != null) {
+            if (debeziumOracleDbContainer != null) {
+                PulsarCluster.stopService(DebeziumOracleDbContainer.NAME, debeziumOracleDbContainer);
+                debeziumOracleDbContainer = null;
+            }
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumPostgreSqlSourceTester.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumPostgreSqlSourceTester.java
index e23a5f1ad5..7ecdce344e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumPostgreSqlSourceTester.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/DebeziumPostgreSqlSourceTester.java
@@ -1,167 +1,167 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.DebeziumPostgreSqlContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testng.Assert;
-
-/**
- * A tester for testing Debezium Postgresql source.
- *
- * It reads binlog from Postgres, and store the debezium output into Pulsar.
- * This test verify that the target topic contains wanted number messages.
- *
- * Debezium Postgresql Container is "debezium/example-postgres:0.10",
- * which is a Postgresql database server preconfigured with an inventory database.
- */
-@Slf4j
-public class DebeziumPostgreSqlSourceTester extends SourceTester<DebeziumPostgreSqlContainer> {
-
-    private static final String NAME = "debezium-postgres";
-
-    private final String pulsarServiceUrl;
-
-    @Getter
-    private DebeziumPostgreSqlContainer debeziumPostgresqlContainer;
-
-    private final PulsarCluster pulsarCluster;
-
-    private final AtomicReference<String> confirmedFlushLsn = new AtomicReference<>("not read yet");
-
-    public DebeziumPostgreSqlSourceTester(PulsarCluster cluster) {
-        super(NAME);
-        this.pulsarCluster = cluster;
-        /*
-        todo (possibly solvable by debezium upgrade?):
-         figure out why last message is lost with larger numEntriesToInsert.
-        I.e. numEntriesToInsert = 100 results in 99 events from debezium 1.0.0, 300 results in 299 events.
-        10 is handled ok.
-        Likely this is related to https://issues.redhat.com/browse/DBZ-2288
-        */
-        this.numEntriesToInsert = 10;
-
-        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
-
-        sourceConfig.put("database.hostname", DebeziumPostgreSqlContainer.NAME);
-        sourceConfig.put("database.port", "5432");
-        sourceConfig.put("database.user", "postgres");
-        sourceConfig.put("database.password", "postgres");
-        sourceConfig.put("topic.prefix", "dbserver1");
-        sourceConfig.put("database.dbname", "postgres");
-        sourceConfig.put("schema.include.list", "inventory");
-        sourceConfig.put("table.exclude.list", "inventory.spatial_ref_sys,inventory.geom");
-        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
-        sourceConfig.put("topic.namespace", "debezium/postgresql");
-        sourceConfig.put("connector.class", "io.debezium.connector.postgresql.PostgresConnector");
-    }
-
-    @Override
-    public void setServiceContainer(DebeziumPostgreSqlContainer container) {
-        log.info("start debezium postgresql server container.");
-        debeziumPostgresqlContainer = container;
-        pulsarCluster.startService(DebeziumPostgreSqlContainer.NAME, debeziumPostgresqlContainer);
-    }
-
-    @Override
-    public void prepareSource() {
-        log.info("debezium postgresql server already contains preconfigured data.");
-    }
-
-    @Override
-    public void prepareInsertEvent() throws Exception {
-        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                "psql -h 127.0.0.1 -U postgres -d postgres "
-                        + "-c \"insert into inventory.products(name, description, weight) "
-                        + "values('test-debezium', 'description', 10);\"");
-        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                "psql -h 127.0.0.1 -U postgres -d postgres "
-                        + "-c \"select count(1), "
-                        + "max(id) from inventory.products where name='test-debezium' and weight=10;\"");
-    }
-
-    @Override
-    public void prepareDeleteEvent() throws Exception {
-        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                "psql -h 127.0.0.1 -U postgres -d postgres "
-                       + "-c \"delete from inventory.products where name='test-debezium';\"");
-        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                "psql -h 127.0.0.1 -U postgres -d postgres -c "
-                        + "\"select count(1) from inventory.products where name='test-debezium';\"");
-    }
-
-    @Override
-    public void prepareUpdateEvent() throws Exception {
-        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                "psql -h 127.0.0.1 -U postgres -d postgres "
-                        + "-c \"update inventory.products "
-                        + "set description='test-update-description', weight='20' where name='test-debezium';\"");
-        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                "psql -h 127.0.0.1 -U postgres -d postgres -c "
-                        + "\"select count(1) from inventory.products where name='test-debezium' and weight=20;\"");
-    }
-
-    @Override
-    public void doPostValidationCheck(String eventType) {
-        super.doPostValidationCheck(eventType);
-        /*
-        confirmed_flush_lsn in pg_replication_slots table has to change,
-        otherwise postgres won't truncate WAL and the disk space will grow.
-        I.e. upgrade from debezium 1.0.0 to 1.0.3 resulted in confirmed_flush_lsn
-        not updating in insert-heavy load.
-        */
-        try {
-            ContainerExecResult res = debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
-                    "psql -h 127.0.0.1 -U postgres -d postgres -c "
-                            + "\"select confirmed_flush_lsn from pg_replication_slots;\"");
-            res.assertNoStderr();
-            String lastConfirmedFlushLsn = res.getStdout();
-            log.info("Current confirmedFlushLsn: \n{} \nLast confirmedFlushLsn: \n{}",
-                    confirmedFlushLsn.get(), lastConfirmedFlushLsn);
-            Assert.assertNotEquals(confirmedFlushLsn.get(), lastConfirmedFlushLsn);
-            confirmedFlushLsn.set(lastConfirmedFlushLsn);
-        } catch (Exception e) {
-            Assert.fail("failed to get flush lsn", e);
-        }
-    }
-
-    @Override
-    public Map<String, String> produceSourceMessages(int numMessages) {
-        log.info("debezium postgresql server already contains preconfigured data.");
-        return null;
-    }
-
-    @Override
-    public void close() {
-        if (pulsarCluster != null) {
-            if (debeziumPostgresqlContainer != null) {
-                PulsarCluster.stopService(DebeziumPostgreSqlContainer.NAME, debeziumPostgresqlContainer);
-                debeziumPostgresqlContainer = null;
-            }
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.DebeziumPostgreSqlContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testng.Assert;
+
+/**
+ * A tester for testing Debezium Postgresql source.
+ *
+ * It reads binlog from Postgres, and store the debezium output into Pulsar.
+ * This test verify that the target topic contains wanted number messages.
+ *
+ * Debezium Postgresql Container is "debezium/example-postgres:0.10",
+ * which is a Postgresql database server preconfigured with an inventory database.
+ */
+@Slf4j
+public class DebeziumPostgreSqlSourceTester extends SourceTester<DebeziumPostgreSqlContainer> {
+
+    private static final String NAME = "debezium-postgres";
+
+    private final String pulsarServiceUrl;
+
+    @Getter
+    private DebeziumPostgreSqlContainer debeziumPostgresqlContainer;
+
+    private final PulsarCluster pulsarCluster;
+
+    private final AtomicReference<String> confirmedFlushLsn = new AtomicReference<>("not read yet");
+
+    public DebeziumPostgreSqlSourceTester(PulsarCluster cluster) {
+        super(NAME);
+        this.pulsarCluster = cluster;
+        /*
+        todo (possibly solvable by debezium upgrade?):
+         figure out why last message is lost with larger numEntriesToInsert.
+        I.e. numEntriesToInsert = 100 results in 99 events from debezium 1.0.0, 300 results in 299 events.
+        10 is handled ok.
+        Likely this is related to https://issues.redhat.com/browse/DBZ-2288
+        */
+        this.numEntriesToInsert = 10;
+
+        pulsarServiceUrl = "pulsar://pulsar-proxy:" + PulsarContainer.BROKER_PORT;
+
+        sourceConfig.put("database.hostname", DebeziumPostgreSqlContainer.NAME);
+        sourceConfig.put("database.port", "5432");
+        sourceConfig.put("database.user", "postgres");
+        sourceConfig.put("database.password", "postgres");
+        sourceConfig.put("topic.prefix", "dbserver1");
+        sourceConfig.put("database.dbname", "postgres");
+        sourceConfig.put("schema.include.list", "inventory");
+        sourceConfig.put("table.exclude.list", "inventory.spatial_ref_sys,inventory.geom");
+        sourceConfig.put("schema.history.internal.pulsar.service.url", pulsarServiceUrl);
+        sourceConfig.put("topic.namespace", "debezium/postgresql");
+        sourceConfig.put("connector.class", "io.debezium.connector.postgresql.PostgresConnector");
+    }
+
+    @Override
+    public void setServiceContainer(DebeziumPostgreSqlContainer container) {
+        log.info("start debezium postgresql server container.");
+        debeziumPostgresqlContainer = container;
+        pulsarCluster.startService(DebeziumPostgreSqlContainer.NAME, debeziumPostgresqlContainer);
+    }
+
+    @Override
+    public void prepareSource() {
+        log.info("debezium postgresql server already contains preconfigured data.");
+    }
+
+    @Override
+    public void prepareInsertEvent() throws Exception {
+        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                "psql -h 127.0.0.1 -U postgres -d postgres "
+                        + "-c \"insert into inventory.products(name, description, weight) "
+                        + "values('test-debezium', 'description', 10);\"");
+        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                "psql -h 127.0.0.1 -U postgres -d postgres "
+                        + "-c \"select count(1), "
+                        + "max(id) from inventory.products where name='test-debezium' and weight=10;\"");
+    }
+
+    @Override
+    public void prepareDeleteEvent() throws Exception {
+        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                "psql -h 127.0.0.1 -U postgres -d postgres "
+                       + "-c \"delete from inventory.products where name='test-debezium';\"");
+        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                "psql -h 127.0.0.1 -U postgres -d postgres -c "
+                        + "\"select count(1) from inventory.products where name='test-debezium';\"");
+    }
+
+    @Override
+    public void prepareUpdateEvent() throws Exception {
+        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                "psql -h 127.0.0.1 -U postgres -d postgres "
+                        + "-c \"update inventory.products "
+                        + "set description='test-update-description', weight='20' where name='test-debezium';\"");
+        this.debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                "psql -h 127.0.0.1 -U postgres -d postgres -c "
+                        + "\"select count(1) from inventory.products where name='test-debezium' and weight=20;\"");
+    }
+
+    @Override
+    public void doPostValidationCheck(String eventType) {
+        super.doPostValidationCheck(eventType);
+        /*
+        confirmed_flush_lsn in pg_replication_slots table has to change,
+        otherwise postgres won't truncate WAL and the disk space will grow.
+        I.e. upgrade from debezium 1.0.0 to 1.0.3 resulted in confirmed_flush_lsn
+        not updating in insert-heavy load.
+        */
+        try {
+            ContainerExecResult res = debeziumPostgresqlContainer.execCmd("/bin/bash", "-c",
+                    "psql -h 127.0.0.1 -U postgres -d postgres -c "
+                            + "\"select confirmed_flush_lsn from pg_replication_slots;\"");
+            res.assertNoStderr();
+            String lastConfirmedFlushLsn = res.getStdout();
+            log.info("Current confirmedFlushLsn: \n{} \nLast confirmedFlushLsn: \n{}",
+                    confirmedFlushLsn.get(), lastConfirmedFlushLsn);
+            Assert.assertNotEquals(confirmedFlushLsn.get(), lastConfirmedFlushLsn);
+            confirmedFlushLsn.set(lastConfirmedFlushLsn);
+        } catch (Exception e) {
+            Assert.fail("failed to get flush lsn", e);
+        }
+    }
+
+    @Override
+    public Map<String, String> produceSourceMessages(int numMessages) {
+        log.info("debezium postgresql server already contains preconfigured data.");
+        return null;
+    }
+
+    @Override
+    public void close() {
+        if (pulsarCluster != null) {
+            if (debeziumPostgresqlContainer != null) {
+                PulsarCluster.stopService(DebeziumPostgreSqlContainer.NAME, debeziumPostgresqlContainer);
+                debeziumPostgresqlContainer = null;
+            }
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumOracleSourceTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumOracleSourceTest.java
index 4566a9240c..92026d50af 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumOracleSourceTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumOracleSourceTest.java
@@ -1,107 +1,107 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import com.google.common.collect.Sets;
-import java.util.concurrent.atomic.AtomicInteger;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.common.policies.data.Policies;
-import org.apache.pulsar.common.policies.data.RetentionPolicies;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.tests.integration.containers.DebeziumOracleDbContainer;
-import org.apache.pulsar.tests.integration.io.PulsarIOTestBase;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class PulsarDebeziumOracleSourceTest extends PulsarIOTestBase {
-
-    protected final AtomicInteger testId = new AtomicInteger(0);
-
-    public PulsarDebeziumOracleSourceTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-
-    @Test(groups = "source", timeOut = 1800000)
-    public void testDebeziumOracleDbSource() throws Exception{
-        testDebeziumOracleDbConnect("org.apache.kafka.connect.json.JsonConverter", true);
-    }
-
-    private void testDebeziumOracleDbConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
-        final String consumeTopicName = "debezium/oracle/XE.INV.CUSTOMERS";
-        final String sourceName = "test-source-debezium-oracle-" + functionRuntimeType + "-" + randomName(8);
-
-        // This is the event count to be created by prepareSource.
-        final int numMessages = 1;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        initNamespace(admin);
-
-        admin.topics().createNonPartitionedTopic(consumeTopicName);
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        DebeziumOracleDbSourceTester sourceTester = new DebeziumOracleDbSourceTester(pulsarCluster);
-        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
-
-        // setup debezium oracle server
-        DebeziumOracleDbContainer debeziumOracleDbContainer =
-                new DebeziumOracleDbContainer(pulsarCluster.getClusterName());
-        sourceTester.setServiceContainer(debeziumOracleDbContainer);
-
-        PulsarIODebeziumSourceRunner runner =
-                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
-                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
-                consumeTopicName, client);
-
-        runner.testSource(sourceTester);
-    }
-
-    protected void initNamespace(PulsarAdmin admin) {
-        log.info("[initNamespace] start.");
-        try {
-            admin.tenants().createTenant("debezium", new TenantInfoImpl(Sets.newHashSet(),
-                    Sets.newHashSet(pulsarCluster.getClusterName())));
-            String [] namespaces = {
-                "debezium/oracle"
-            };
-            Policies policies = new Policies();
-            policies.retention_policies = new RetentionPolicies(-1, 50);
-            for (String ns: namespaces) {
-                admin.namespaces().createNamespace(ns, policies);
-            }
-        } catch (Exception e) {
-            log.info("[initNamespace] msg: {}", e.getMessage());
-        }
-        log.info("[initNamespace] finish.");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import com.google.common.collect.Sets;
+import java.util.concurrent.atomic.AtomicInteger;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.common.policies.data.Policies;
+import org.apache.pulsar.common.policies.data.RetentionPolicies;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.tests.integration.containers.DebeziumOracleDbContainer;
+import org.apache.pulsar.tests.integration.io.PulsarIOTestBase;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class PulsarDebeziumOracleSourceTest extends PulsarIOTestBase {
+
+    protected final AtomicInteger testId = new AtomicInteger(0);
+
+    public PulsarDebeziumOracleSourceTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+
+    @Test(groups = "source", timeOut = 1800000)
+    public void testDebeziumOracleDbSource() throws Exception{
+        testDebeziumOracleDbConnect("org.apache.kafka.connect.json.JsonConverter", true);
+    }
+
+    private void testDebeziumOracleDbConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
+        final String consumeTopicName = "debezium/oracle/XE.INV.CUSTOMERS";
+        final String sourceName = "test-source-debezium-oracle-" + functionRuntimeType + "-" + randomName(8);
+
+        // This is the event count to be created by prepareSource.
+        final int numMessages = 1;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        initNamespace(admin);
+
+        admin.topics().createNonPartitionedTopic(consumeTopicName);
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        DebeziumOracleDbSourceTester sourceTester = new DebeziumOracleDbSourceTester(pulsarCluster);
+        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
+
+        // setup debezium oracle server
+        DebeziumOracleDbContainer debeziumOracleDbContainer =
+                new DebeziumOracleDbContainer(pulsarCluster.getClusterName());
+        sourceTester.setServiceContainer(debeziumOracleDbContainer);
+
+        PulsarIODebeziumSourceRunner runner =
+                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
+                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
+                consumeTopicName, client);
+
+        runner.testSource(sourceTester);
+    }
+
+    protected void initNamespace(PulsarAdmin admin) {
+        log.info("[initNamespace] start.");
+        try {
+            admin.tenants().createTenant("debezium", new TenantInfoImpl(Sets.newHashSet(),
+                    Sets.newHashSet(pulsarCluster.getClusterName())));
+            String [] namespaces = {
+                "debezium/oracle"
+            };
+            Policies policies = new Policies();
+            policies.retention_policies = new RetentionPolicies(-1, 50);
+            for (String ns: namespaces) {
+                admin.namespaces().createNamespace(ns, policies);
+            }
+        } catch (Exception e) {
+            log.info("[initNamespace] msg: {}", e.getMessage());
+        }
+        log.info("[initNamespace] finish.");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumSourcesTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumSourcesTest.java
index eb22941039..1e62759d2e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumSourcesTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarDebeziumSourcesTest.java
@@ -1,271 +1,271 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import com.google.common.collect.Sets;
-import java.util.concurrent.atomic.AtomicInteger;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.common.policies.data.Policies;
-import org.apache.pulsar.common.policies.data.RetentionPolicies;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.common.schema.SchemaInfo;
-import org.apache.pulsar.tests.integration.containers.DebeziumMongoDbContainer;
-import org.apache.pulsar.tests.integration.containers.DebeziumMsSqlContainer;
-import org.apache.pulsar.tests.integration.containers.DebeziumMySQLContainer;
-import org.apache.pulsar.tests.integration.containers.DebeziumPostgreSqlContainer;
-import org.apache.pulsar.tests.integration.io.PulsarIOTestBase;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class PulsarDebeziumSourcesTest extends PulsarIOTestBase {
-
-    protected final AtomicInteger testId = new AtomicInteger(0);
-
-    public PulsarDebeziumSourcesTest() {
-        super(FunctionRuntimeType.PROCESS);
-    }
-
-    @Test(groups = "source")
-    public void testDebeziumMySqlSourceJson() throws Exception {
-        testDebeziumMySqlConnect("org.apache.kafka.connect.json.JsonConverter", true, false);
-    }
-
-    @Test(groups = "source")
-    public void testDebeziumMySqlSourceJsonWithClientBuilder() throws Exception {
-        testDebeziumMySqlConnect("org.apache.kafka.connect.json.JsonConverter", true, true);
-    }
-
-    @Test(groups = "source")
-    public void testDebeziumMySqlSourceAvro() throws Exception {
-        testDebeziumMySqlConnect("io.confluent.connect.avro.AvroConverter", false, false);
-    }
-
-    @Test(groups = "source")
-    public void testDebeziumPostgreSqlSource() throws Exception {
-        testDebeziumPostgreSqlConnect("org.apache.kafka.connect.json.JsonConverter", true);
-    }
-
-
-    @Test(groups = "source")
-    public void testDebeziumMongoDbSource() throws Exception{
-        testDebeziumMongoDbConnect("org.apache.kafka.connect.json.JsonConverter", true);
-    }
-
-    @Test(groups = "source")
-    public void testDebeziumMsSqlSource() throws Exception{
-        testDebeziumMsSqlConnect("org.apache.kafka.connect.json.JsonConverter", true);
-    }
-
-    private void testDebeziumMySqlConnect(String converterClassName, boolean jsonWithEnvelope,
-                                          boolean testWithClientBuilder) throws Exception {
-
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
-        boolean isJsonConverter = converterClassName.endsWith("JsonConverter");
-        final String consumeTopicName = "debezium/mysql-"
-                + (isJsonConverter ? "json" : "avro")
-                + "/dbserver1.inventory.products";
-        final String sourceName = "test-source-debezium-mysql" + (isJsonConverter ? "json" : "avro")
-                + "-" + functionRuntimeType + "-" + randomName(8);
-
-        // This is the binlog count that contained in mysql container.
-        final int numMessages = 52;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-            .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        initNamespace(admin);
-
-        try {
-            SchemaInfo lastSchemaInfo = admin.schemas().getSchemaInfo(consumeTopicName);
-            log.info("lastSchemaInfo: {}", lastSchemaInfo == null ? "null" : lastSchemaInfo.toString());
-        } catch (Exception e) {
-            log.warn("failed to get schemaInfo for topic: {}, exceptions message: {}",
-                    consumeTopicName, e.getMessage());
-        }
-
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        DebeziumMySqlSourceTester sourceTester = new DebeziumMySqlSourceTester(pulsarCluster, converterClassName,
-                testWithClientBuilder);
-        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
-
-        // setup debezium mysql server
-        DebeziumMySQLContainer mySQLContainer = new DebeziumMySQLContainer(pulsarCluster.getClusterName());
-        sourceTester.setServiceContainer(mySQLContainer);
-
-        PulsarIODebeziumSourceRunner runner =
-                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
-                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
-                consumeTopicName, client);
-
-        runner.testSource(sourceTester);
-    }
-
-    private void testDebeziumPostgreSqlConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
-
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
-        final String consumeTopicName = "debezium/postgresql/dbserver1.inventory.products";
-        final String sourceName = "test-source-debezium-postgersql-" + functionRuntimeType + "-" + randomName(8);
-
-        // This is the binlog count that contained in postgresql container.
-        final int numMessages = 26;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        initNamespace(admin);
-
-        admin.topics().createNonPartitionedTopic(consumeTopicName);
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        DebeziumPostgreSqlSourceTester sourceTester = new DebeziumPostgreSqlSourceTester(pulsarCluster);
-        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
-
-        // setup debezium postgresql server
-        DebeziumPostgreSqlContainer postgreSqlContainer =
-                new DebeziumPostgreSqlContainer(pulsarCluster.getClusterName());
-        sourceTester.setServiceContainer(postgreSqlContainer);
-
-        PulsarIODebeziumSourceRunner runner =
-                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
-                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
-                consumeTopicName, client);
-
-        runner.testSource(sourceTester);
-    }
-
-    private void testDebeziumMongoDbConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
-
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "debe-output-topic-name";
-        final String consumeTopicName = "debezium/mongodb/dbserver1.inventory.products";
-        final String sourceName = "test-source-connector-"
-                + functionRuntimeType + "-name-" + randomName(8);
-
-        // This is the binlog count that contained in mongodb container.
-        final int numMessages = 17;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        initNamespace(admin);
-
-        admin.topics().createNonPartitionedTopic(consumeTopicName);
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        DebeziumMongoDbSourceTester sourceTester = new DebeziumMongoDbSourceTester(pulsarCluster);
-        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
-
-        // setup debezium mongodb server
-        DebeziumMongoDbContainer mongoDbContainer = new DebeziumMongoDbContainer(pulsarCluster.getClusterName());
-        sourceTester.setServiceContainer(mongoDbContainer);
-
-        PulsarIODebeziumSourceRunner runner =
-                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
-                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
-                consumeTopicName, client);
-
-        runner.testSource(sourceTester);
-    }
-
-    private void testDebeziumMsSqlConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
-
-        final String tenant = TopicName.PUBLIC_TENANT;
-        final String namespace = TopicName.DEFAULT_NAMESPACE;
-        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
-        final String consumeTopicName = "debezium/mssql/mssql.TestDB.dbo.customers";
-        final String sourceName = "test-source-debezium-mssql-" + functionRuntimeType + "-" + randomName(8);
-
-        final int numMessages = 1;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        initNamespace(admin);
-
-        admin.topics().createNonPartitionedTopic(consumeTopicName);
-        admin.topics().createNonPartitionedTopic(outputTopicName);
-
-        @Cleanup
-        DebeziumMsSqlSourceTester sourceTester = new DebeziumMsSqlSourceTester(pulsarCluster);
-        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
-
-        DebeziumMsSqlContainer msSqlContainer = new DebeziumMsSqlContainer(pulsarCluster.getClusterName());
-        sourceTester.setServiceContainer(msSqlContainer);
-
-        PulsarIODebeziumSourceRunner runner =
-                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
-                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
-                consumeTopicName, client);
-
-        runner.testSource(sourceTester);
-    }
-
-    protected void initNamespace(PulsarAdmin admin) {
-        log.info("[initNamespace] start.");
-        try {
-            admin.tenants().createTenant("debezium", new TenantInfoImpl(Sets.newHashSet(),
-                    Sets.newHashSet(pulsarCluster.getClusterName())));
-            String [] namespaces = {
-                "debezium/mysql-json",
-                "debezium/mysql-avro",
-                "debezium/mongodb",
-                "debezium/postgresql",
-                "debezium/mssql",
-            };
-            Policies policies = new Policies();
-            policies.retention_policies = new RetentionPolicies(-1, 50);
-            for (String ns: namespaces) {
-                admin.namespaces().createNamespace(ns, policies);
-            }
-        } catch (Exception e) {
-            log.info("[initNamespace] msg: {}", e.getMessage());
-        }
-        log.info("[initNamespace] finish.");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import com.google.common.collect.Sets;
+import java.util.concurrent.atomic.AtomicInteger;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.common.policies.data.Policies;
+import org.apache.pulsar.common.policies.data.RetentionPolicies;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.common.schema.SchemaInfo;
+import org.apache.pulsar.tests.integration.containers.DebeziumMongoDbContainer;
+import org.apache.pulsar.tests.integration.containers.DebeziumMsSqlContainer;
+import org.apache.pulsar.tests.integration.containers.DebeziumMySQLContainer;
+import org.apache.pulsar.tests.integration.containers.DebeziumPostgreSqlContainer;
+import org.apache.pulsar.tests.integration.io.PulsarIOTestBase;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class PulsarDebeziumSourcesTest extends PulsarIOTestBase {
+
+    protected final AtomicInteger testId = new AtomicInteger(0);
+
+    public PulsarDebeziumSourcesTest() {
+        super(FunctionRuntimeType.PROCESS);
+    }
+
+    @Test(groups = "source")
+    public void testDebeziumMySqlSourceJson() throws Exception {
+        testDebeziumMySqlConnect("org.apache.kafka.connect.json.JsonConverter", true, false);
+    }
+
+    @Test(groups = "source")
+    public void testDebeziumMySqlSourceJsonWithClientBuilder() throws Exception {
+        testDebeziumMySqlConnect("org.apache.kafka.connect.json.JsonConverter", true, true);
+    }
+
+    @Test(groups = "source")
+    public void testDebeziumMySqlSourceAvro() throws Exception {
+        testDebeziumMySqlConnect("io.confluent.connect.avro.AvroConverter", false, false);
+    }
+
+    @Test(groups = "source")
+    public void testDebeziumPostgreSqlSource() throws Exception {
+        testDebeziumPostgreSqlConnect("org.apache.kafka.connect.json.JsonConverter", true);
+    }
+
+
+    @Test(groups = "source")
+    public void testDebeziumMongoDbSource() throws Exception{
+        testDebeziumMongoDbConnect("org.apache.kafka.connect.json.JsonConverter", true);
+    }
+
+    @Test(groups = "source")
+    public void testDebeziumMsSqlSource() throws Exception{
+        testDebeziumMsSqlConnect("org.apache.kafka.connect.json.JsonConverter", true);
+    }
+
+    private void testDebeziumMySqlConnect(String converterClassName, boolean jsonWithEnvelope,
+                                          boolean testWithClientBuilder) throws Exception {
+
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
+        boolean isJsonConverter = converterClassName.endsWith("JsonConverter");
+        final String consumeTopicName = "debezium/mysql-"
+                + (isJsonConverter ? "json" : "avro")
+                + "/dbserver1.inventory.products";
+        final String sourceName = "test-source-debezium-mysql" + (isJsonConverter ? "json" : "avro")
+                + "-" + functionRuntimeType + "-" + randomName(8);
+
+        // This is the binlog count that contained in mysql container.
+        final int numMessages = 52;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+            .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        initNamespace(admin);
+
+        try {
+            SchemaInfo lastSchemaInfo = admin.schemas().getSchemaInfo(consumeTopicName);
+            log.info("lastSchemaInfo: {}", lastSchemaInfo == null ? "null" : lastSchemaInfo.toString());
+        } catch (Exception e) {
+            log.warn("failed to get schemaInfo for topic: {}, exceptions message: {}",
+                    consumeTopicName, e.getMessage());
+        }
+
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        DebeziumMySqlSourceTester sourceTester = new DebeziumMySqlSourceTester(pulsarCluster, converterClassName,
+                testWithClientBuilder);
+        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
+
+        // setup debezium mysql server
+        DebeziumMySQLContainer mySQLContainer = new DebeziumMySQLContainer(pulsarCluster.getClusterName());
+        sourceTester.setServiceContainer(mySQLContainer);
+
+        PulsarIODebeziumSourceRunner runner =
+                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
+                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
+                consumeTopicName, client);
+
+        runner.testSource(sourceTester);
+    }
+
+    private void testDebeziumPostgreSqlConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
+
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
+        final String consumeTopicName = "debezium/postgresql/dbserver1.inventory.products";
+        final String sourceName = "test-source-debezium-postgersql-" + functionRuntimeType + "-" + randomName(8);
+
+        // This is the binlog count that contained in postgresql container.
+        final int numMessages = 26;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        initNamespace(admin);
+
+        admin.topics().createNonPartitionedTopic(consumeTopicName);
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        DebeziumPostgreSqlSourceTester sourceTester = new DebeziumPostgreSqlSourceTester(pulsarCluster);
+        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
+
+        // setup debezium postgresql server
+        DebeziumPostgreSqlContainer postgreSqlContainer =
+                new DebeziumPostgreSqlContainer(pulsarCluster.getClusterName());
+        sourceTester.setServiceContainer(postgreSqlContainer);
+
+        PulsarIODebeziumSourceRunner runner =
+                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
+                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
+                consumeTopicName, client);
+
+        runner.testSource(sourceTester);
+    }
+
+    private void testDebeziumMongoDbConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
+
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "debe-output-topic-name";
+        final String consumeTopicName = "debezium/mongodb/dbserver1.inventory.products";
+        final String sourceName = "test-source-connector-"
+                + functionRuntimeType + "-name-" + randomName(8);
+
+        // This is the binlog count that contained in mongodb container.
+        final int numMessages = 17;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        initNamespace(admin);
+
+        admin.topics().createNonPartitionedTopic(consumeTopicName);
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        DebeziumMongoDbSourceTester sourceTester = new DebeziumMongoDbSourceTester(pulsarCluster);
+        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
+
+        // setup debezium mongodb server
+        DebeziumMongoDbContainer mongoDbContainer = new DebeziumMongoDbContainer(pulsarCluster.getClusterName());
+        sourceTester.setServiceContainer(mongoDbContainer);
+
+        PulsarIODebeziumSourceRunner runner =
+                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
+                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
+                consumeTopicName, client);
+
+        runner.testSource(sourceTester);
+    }
+
+    private void testDebeziumMsSqlConnect(String converterClassName, boolean jsonWithEnvelope) throws Exception {
+
+        final String tenant = TopicName.PUBLIC_TENANT;
+        final String namespace = TopicName.DEFAULT_NAMESPACE;
+        final String outputTopicName = "debe-output-topic-name-" + testId.getAndIncrement();
+        final String consumeTopicName = "debezium/mssql/mssql.TestDB.dbo.customers";
+        final String sourceName = "test-source-debezium-mssql-" + functionRuntimeType + "-" + randomName(8);
+
+        final int numMessages = 1;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        initNamespace(admin);
+
+        admin.topics().createNonPartitionedTopic(consumeTopicName);
+        admin.topics().createNonPartitionedTopic(outputTopicName);
+
+        @Cleanup
+        DebeziumMsSqlSourceTester sourceTester = new DebeziumMsSqlSourceTester(pulsarCluster);
+        sourceTester.getSourceConfig().put("json-with-envelope", jsonWithEnvelope);
+
+        DebeziumMsSqlContainer msSqlContainer = new DebeziumMsSqlContainer(pulsarCluster.getClusterName());
+        sourceTester.setServiceContainer(msSqlContainer);
+
+        PulsarIODebeziumSourceRunner runner =
+                new PulsarIODebeziumSourceRunner(pulsarCluster, functionRuntimeType.toString(),
+                converterClassName, tenant, namespace, sourceName, outputTopicName, numMessages, jsonWithEnvelope,
+                consumeTopicName, client);
+
+        runner.testSource(sourceTester);
+    }
+
+    protected void initNamespace(PulsarAdmin admin) {
+        log.info("[initNamespace] start.");
+        try {
+            admin.tenants().createTenant("debezium", new TenantInfoImpl(Sets.newHashSet(),
+                    Sets.newHashSet(pulsarCluster.getClusterName())));
+            String [] namespaces = {
+                "debezium/mysql-json",
+                "debezium/mysql-avro",
+                "debezium/mongodb",
+                "debezium/postgresql",
+                "debezium/mssql",
+            };
+            Policies policies = new Policies();
+            policies.retention_policies = new RetentionPolicies(-1, 50);
+            for (String ns: namespaces) {
+                admin.namespaces().createNamespace(ns, policies);
+            }
+        } catch (Exception e) {
+            log.info("[initNamespace] msg: {}", e.getMessage());
+        }
+        log.info("[initNamespace] finish.");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarIODebeziumSourceRunner.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarIODebeziumSourceRunner.java
index 5f36ed45ea..ede4bf98b3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarIODebeziumSourceRunner.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/io/sources/debezium/PulsarIODebeziumSourceRunner.java
@@ -1,132 +1,132 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.io.sources.debezium;
-
-import com.google.common.base.Preconditions;
-import dev.failsafe.Failsafe;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.integration.io.sources.PulsarIOSourceRunner;
-import org.apache.pulsar.tests.integration.io.sources.SourceTester;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.testcontainers.containers.GenericContainer;
-
-@Slf4j
-public class PulsarIODebeziumSourceRunner extends PulsarIOSourceRunner {
-
-    private String converterClassName;
-    private String tenant;
-    private String namespace;
-    private String sourceName;
-    private String outputTopicName;
-    private String consumeTopicName;
-    private int numMessages;
-    private boolean jsonWithEnvelope;
-    private PulsarClient client;
-
-    public PulsarIODebeziumSourceRunner(PulsarCluster cluster, String functionRuntimeType, String converterClassName,
-            String tenant, String ns, String sourceName, String outputTopic, int numMessages, boolean jsonWithEnvelope,
-            String consumeTopicName, PulsarClient client) {
-        super(cluster, functionRuntimeType);
-        this.converterClassName = converterClassName;
-        this.tenant = tenant;
-        this.namespace = ns;
-        this.sourceName = sourceName;
-        this.outputTopicName = outputTopic;
-        this.numMessages = numMessages;
-        this.jsonWithEnvelope = jsonWithEnvelope;
-        this.consumeTopicName = consumeTopicName;
-        this.client = client;
-    }
-
-    @Override
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    public <T extends GenericContainer> void testSource(SourceTester<T> sourceTester)  throws Exception {
-        try {
-            internalTestSource(sourceTester);
-        } finally {
-            sourceTester.close();
-        }
-    }
-
-    private <T extends GenericContainer> void internalTestSource
-            (SourceTester<T> sourceTester) throws Exception {
-        // prepare the testing environment for source
-        prepareSource(sourceTester);
-
-        // submit the source connector
-        submitSourceConnector(sourceTester, tenant, namespace, sourceName, outputTopicName);
-
-        // get source info
-        getSourceInfoSuccess(sourceTester, tenant, namespace, sourceName);
-
-        // get source status
-        Failsafe.with(statusRetryPolicy).run(() -> getSourceStatus(tenant, namespace, sourceName));
-
-        // wait for source to process messages
-        Failsafe.with(statusRetryPolicy).run(() ->
-                waitForProcessingSourceMessages(tenant, namespace, sourceName, numMessages));
-
-        @Cleanup
-        Consumer<?> consumer = client.newConsumer(getSchema(jsonWithEnvelope))
-                .topic(consumeTopicName)
-                .subscriptionName("debezium-source-tester")
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscribe();
-        log.info("[debezium mysql test] create consumer finish. converterName: {}", converterClassName);
-
-        // validate the source result
-        sourceTester.validateSourceResult(consumer, sourceTester.getNumEntriesExpectAfterStart(),
-                null, converterClassName);
-
-        final int numEntriesToInsert = sourceTester.getNumEntriesToInsert();
-        Preconditions.checkArgument(numEntriesToInsert >= 1);
-
-        for (int i = 1; i <= numEntriesToInsert; i++) {
-            // prepare insert event
-            sourceTester.prepareInsertEvent();
-            log.info("inserted entry {} of {}", i, numEntriesToInsert);
-            // validate the source insert event
-            sourceTester.validateSourceResult(consumer, 1, SourceTester.INSERT, converterClassName);
-        }
-
-        // prepare update event
-        sourceTester.prepareUpdateEvent();
-
-        // validate the source update event
-        sourceTester.validateSourceResult(consumer, numEntriesToInsert, SourceTester.UPDATE, converterClassName);
-
-        // prepare delete event
-        sourceTester.prepareDeleteEvent();
-
-        // validate the source delete event
-        sourceTester.validateSourceResult(consumer,  numEntriesToInsert, SourceTester.DELETE, converterClassName);
-
-        // delete the source
-        deleteSource(tenant, namespace, sourceName);
-
-        // get source info (source should be deleted)
-        getSourceInfoNotFound(tenant, namespace, sourceName);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.io.sources.debezium;
+
+import com.google.common.base.Preconditions;
+import dev.failsafe.Failsafe;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.integration.io.sources.PulsarIOSourceRunner;
+import org.apache.pulsar.tests.integration.io.sources.SourceTester;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.testcontainers.containers.GenericContainer;
+
+@Slf4j
+public class PulsarIODebeziumSourceRunner extends PulsarIOSourceRunner {
+
+    private String converterClassName;
+    private String tenant;
+    private String namespace;
+    private String sourceName;
+    private String outputTopicName;
+    private String consumeTopicName;
+    private int numMessages;
+    private boolean jsonWithEnvelope;
+    private PulsarClient client;
+
+    public PulsarIODebeziumSourceRunner(PulsarCluster cluster, String functionRuntimeType, String converterClassName,
+            String tenant, String ns, String sourceName, String outputTopic, int numMessages, boolean jsonWithEnvelope,
+            String consumeTopicName, PulsarClient client) {
+        super(cluster, functionRuntimeType);
+        this.converterClassName = converterClassName;
+        this.tenant = tenant;
+        this.namespace = ns;
+        this.sourceName = sourceName;
+        this.outputTopicName = outputTopic;
+        this.numMessages = numMessages;
+        this.jsonWithEnvelope = jsonWithEnvelope;
+        this.consumeTopicName = consumeTopicName;
+        this.client = client;
+    }
+
+    @Override
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public <T extends GenericContainer> void testSource(SourceTester<T> sourceTester)  throws Exception {
+        try {
+            internalTestSource(sourceTester);
+        } finally {
+            sourceTester.close();
+        }
+    }
+
+    private <T extends GenericContainer> void internalTestSource
+            (SourceTester<T> sourceTester) throws Exception {
+        // prepare the testing environment for source
+        prepareSource(sourceTester);
+
+        // submit the source connector
+        submitSourceConnector(sourceTester, tenant, namespace, sourceName, outputTopicName);
+
+        // get source info
+        getSourceInfoSuccess(sourceTester, tenant, namespace, sourceName);
+
+        // get source status
+        Failsafe.with(statusRetryPolicy).run(() -> getSourceStatus(tenant, namespace, sourceName));
+
+        // wait for source to process messages
+        Failsafe.with(statusRetryPolicy).run(() ->
+                waitForProcessingSourceMessages(tenant, namespace, sourceName, numMessages));
+
+        @Cleanup
+        Consumer<?> consumer = client.newConsumer(getSchema(jsonWithEnvelope))
+                .topic(consumeTopicName)
+                .subscriptionName("debezium-source-tester")
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscribe();
+        log.info("[debezium mysql test] create consumer finish. converterName: {}", converterClassName);
+
+        // validate the source result
+        sourceTester.validateSourceResult(consumer, sourceTester.getNumEntriesExpectAfterStart(),
+                null, converterClassName);
+
+        final int numEntriesToInsert = sourceTester.getNumEntriesToInsert();
+        Preconditions.checkArgument(numEntriesToInsert >= 1);
+
+        for (int i = 1; i <= numEntriesToInsert; i++) {
+            // prepare insert event
+            sourceTester.prepareInsertEvent();
+            log.info("inserted entry {} of {}", i, numEntriesToInsert);
+            // validate the source insert event
+            sourceTester.validateSourceResult(consumer, 1, SourceTester.INSERT, converterClassName);
+        }
+
+        // prepare update event
+        sourceTester.prepareUpdateEvent();
+
+        // validate the source update event
+        sourceTester.validateSourceResult(consumer, numEntriesToInsert, SourceTester.UPDATE, converterClassName);
+
+        // prepare delete event
+        sourceTester.prepareDeleteEvent();
+
+        // validate the source delete event
+        sourceTester.validateSourceResult(consumer,  numEntriesToInsert, SourceTester.DELETE, converterClassName);
+
+        // delete the source
+        deleteSource(tenant, namespace, sourceName);
+
+        // get source info (source should be deleted)
+        getSourceInfoNotFound(tenant, namespace, sourceName);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/k8s/AbstractPulsarStandaloneK8STest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/k8s/AbstractPulsarStandaloneK8STest.java
new file mode 100644
index 0000000000..55272c6883
--- /dev/null
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/k8s/AbstractPulsarStandaloneK8STest.java
@@ -0,0 +1,411 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.k8s;
+
+import com.github.dockerjava.api.DockerClient;
+import com.github.dockerjava.api.async.ResultCallbackTemplate;
+import com.github.dockerjava.api.command.ExecCreateCmdResponse;
+import com.github.dockerjava.api.model.Frame;
+import com.github.dockerjava.api.model.StreamType;
+import io.kubernetes.client.Exec;
+import io.kubernetes.client.custom.Quantity;
+import io.kubernetes.client.openapi.ApiClient;
+import io.kubernetes.client.openapi.ApiException;
+import io.kubernetes.client.openapi.apis.CoreV1Api;
+import io.kubernetes.client.openapi.apis.RbacAuthorizationV1Api;
+import io.kubernetes.client.openapi.models.CoreV1EventList;
+import io.kubernetes.client.openapi.models.RbacV1SubjectBuilder;
+import io.kubernetes.client.openapi.models.V1Pod;
+import io.kubernetes.client.openapi.models.V1PodBuilder;
+import io.kubernetes.client.openapi.models.V1PolicyRuleBuilder;
+import io.kubernetes.client.openapi.models.V1Role;
+import io.kubernetes.client.openapi.models.V1RoleBinding;
+import io.kubernetes.client.openapi.models.V1RoleBindingBuilder;
+import io.kubernetes.client.openapi.models.V1RoleBuilder;
+import io.kubernetes.client.openapi.models.V1Service;
+import io.kubernetes.client.openapi.models.V1ServiceAccount;
+import io.kubernetes.client.openapi.models.V1ServiceAccountBuilder;
+import io.kubernetes.client.openapi.models.V1ServiceBuilder;
+import io.kubernetes.client.util.Config;
+import io.kubernetes.client.util.KubeConfig;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringReader;
+import java.io.UncheckedIOException;
+import java.nio.file.Files;
+import java.time.Duration;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.functions.runtime.kubernetes.KubernetesRuntimeFactory;
+import org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator;
+import org.apache.tools.tar.TarEntry;
+import org.apache.tools.tar.TarInputStream;
+import org.testcontainers.containers.wait.strategy.Wait;
+import org.testcontainers.k3s.K3sContainer;
+import org.testcontainers.utility.DockerImageName;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+
+/**
+ * Abstract base class for integration tests that use Kubernetes (K8s) and Pulsar standalone.
+ * This class sets up a Kubernetes environment using the k3s lightweight Kubernetes container
+ * and deploys a standalone Pulsar instance within this Kubernetes cluster.
+ * It provides configuration and utility methods to allow test classes to interact
+ * with the deployed Pulsar instance and Kubernetes cluster.
+ * The main reason to use this base class is to test features in Pulsar which are integrated into Kubernetes
+ * APIs.
+ */
+@Slf4j
+public abstract class AbstractPulsarStandaloneK8STest {
+    private static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/java-test-image:latest");
+    private static final int PULSAR_NODE_PORT = 30101;
+    private static final int PULSAR_HTTP_NODE_PORT = 30102;
+    private static final String K3S_IMAGE_NAME = "rancher/k3s:v1.33.5-k3s1";
+    private static final String PULSAR_STANDALONE_POD = "pulsar-standalone-pod";
+    K3sContainer k3sContainer;
+    KubeConfig kubeConfig;
+    @Getter
+    ApiClient apiClient;
+    DockerClient dockerClient;
+    String dockerHostName;
+    @Getter
+    String pulsarBrokerUrl;
+    @Getter
+    String pulsarWebServiceUrl;
+    @Getter
+    File kubeConfigFile;
+
+    @BeforeClass
+    public final void setupCluster() throws IOException, ApiException, InterruptedException {
+        k3sContainer = new K3sContainer(DockerImageName.parse(K3S_IMAGE_NAME));
+        k3sContainer.addExposedPort(PULSAR_NODE_PORT);
+        k3sContainer.addExposedPort(PULSAR_HTTP_NODE_PORT);
+        k3sContainer.start();
+        dockerHostName = k3sContainer.getHost();
+        pulsarBrokerUrl = "pulsar://" + dockerHostName + ":" + k3sContainer.getMappedPort(PULSAR_NODE_PORT);
+        pulsarWebServiceUrl = "http://" + dockerHostName + ":" + k3sContainer.getMappedPort(PULSAR_HTTP_NODE_PORT);
+        dockerClient = k3sContainer.getDockerClient();
+        String kubeConfigYaml = k3sContainer.getKubeConfigYaml();
+        kubeConfig = KubeConfig.loadKubeConfig(new StringReader(kubeConfigYaml));
+        apiClient = Config.fromConfig(kubeConfig);
+        kubeConfigFile = File.createTempFile("kubeconfig", ".yaml");
+        Files.writeString(kubeConfigFile.toPath(), kubeConfigYaml);
+        log.info("Pulsar broker URL: {} http URL: {}", pulsarBrokerUrl, pulsarWebServiceUrl);
+        log.info("For debugging k8s, use KUBECONFIG={}", kubeConfigFile.getAbsolutePath());
+        importPulsarImage();
+        deployPulsarStandalonePod();
+        log.info("Waiting for Pulsar cluster to be ready");
+        Wait.forHttp("/admin/v2/tenants")
+                .forPort(PULSAR_HTTP_NODE_PORT)
+                // when Pulsar Functions are ready, there will also be a pulsar tenant created
+                .forResponsePredicate("[\"public\",\"pulsar\"]"::equals)
+                .withStartupTimeout(Duration.ofMinutes(5))
+                .waitUntilReady(k3sContainer);
+        log.info("Pulsar cluster ready. Waiting 3 seconds before continuing for Functions Leader to be ready.");
+        Thread.sleep(3000);
+    }
+
+    @AfterClass(alwaysRun = true)
+    public final void cleanupCluster() throws InterruptedException {
+        if (k3sContainer != null) {
+            copyLogsToTargetDirectory();
+            k3sContainer.stop();
+            kubeConfigFile.delete();
+        }
+    }
+
+    private void copyLogsToTargetDirectory() {
+        if (apiClient != null) {
+            File targetDirectoryForLogs = getTargetDirectoryForLogs();
+            Exec exec = new Exec(apiClient);
+            try {
+                log.info("Copying logs from Pulsar standalone pod to target directory: {}", targetDirectoryForLogs);
+                Process process = exec.newExecutionBuilder(getNamespace(), PULSAR_STANDALONE_POD,
+                        new String[]{"sh", "-c", "cd /pulsar/logs && tar cf - *"}
+                ).setTty(false).setStdin(false).setStderr(false).setStdout(true).execute();
+                try (TarInputStream tarInputStream = new TarInputStream(process.getInputStream())) {
+                    TarEntry tarEntry;
+                    while ((tarEntry = tarInputStream.getNextEntry()) != null) {
+                        if (tarEntry.isFile()) {
+                            File targetFile = new File(targetDirectoryForLogs, new File(tarEntry.getName()).getName());
+                            Files.copy(tarInputStream, targetFile.toPath());
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                log.error("Error copying logs from Pulsar standalone pod to target directory.", e);
+            }
+
+            CoreV1Api coreApi = new CoreV1Api(apiClient);
+            File eventsFile = new File(targetDirectoryForLogs, "k8s_events.json");
+            try {
+                log.info("Copying events from Kubernetes cluster namespace {} to {}.", getNamespace(), eventsFile);
+                CoreV1EventList eventList = coreApi.listNamespacedEvent(getNamespace()).execute();
+                Files.writeString(eventsFile.toPath(), eventList.toJson());
+            } catch (Exception e) {
+                log.error("Error copying events from Kubernetes cluster to {}.", eventsFile, e);
+            }
+        }
+    }
+
+    private File getTargetDirectoryForLogs() {
+        String base = System.getProperty("maven.buildDirectory");
+        if (base == null) {
+            base = "target";
+        }
+        // use the container-logs directory since it's used in CI for integration tests as the file location
+        File directory = new File(new File(base, "container-logs"),
+                "k8s_" + getClass().getSimpleName() + "_" + System.currentTimeMillis());
+        if (!directory.exists() && !directory.mkdirs()) {
+            log.error("Error creating directory for logs.");
+        }
+        return directory;
+    }
+
+    protected String getPulsarImageName() {
+        return DEFAULT_IMAGE_NAME;
+    }
+
+    private void deployPulsarStandalonePod() throws ApiException {
+        createServiceAccountAndRoleAndRoleBinding();
+        CoreV1Api coreApi = new CoreV1Api(apiClient);
+        String namespace = getNamespace();
+        V1Pod pod = createPulsarPod();
+        coreApi.createNamespacedPod(namespace, pod).execute();
+        V1Service service = createPulsarService();
+        coreApi.createNamespacedService(namespace, service).execute();
+    }
+
+    protected String getNamespace() {
+        return "default";
+    }
+
+    private void importPulsarImage() throws InterruptedException {
+        importImageToK3S(getPulsarImageName());
+    }
+
+    /**
+     * Imports a local Docker image into the k3s container's containerd registry.
+     * This method allows the image to be used by Kubernetes pods within the k3s cluster.
+     * When using this imported image in pod specs, the imagePullPolicy should be set to "Never"
+     * since the image is already available locally in the cluster.
+     * @param imageName The name of the Docker image to import
+     * @throws UncheckedIOException if there is an error during image import
+     * @throws InterruptedException if the import is interrupted
+     */
+    protected void importImageToK3S(String imageName) throws InterruptedException {
+        // Stream the saved image directly to "ctr images import -" inside the k3s container
+        try (InputStream is = dockerClient.saveImageCmd(imageName).exec()) {
+            String[] importCommand = {"ctr", "images", "import", "-"};
+            ExecCreateCmdResponse execCreateCmdResponse = dockerClient.execCreateCmd(k3sContainer.getContainerId())
+                    .withAttachStdin(true)
+                    .withAttachStdout(true)
+                    .withAttachStderr(true)
+                    .withTty(false)
+                    .withCmd(importCommand)
+                    .exec();
+            dockerClient.execStartCmd(execCreateCmdResponse.getId())
+                    .withStdIn(is)
+                    .withTty(false)
+                    .withDetach(false)
+                    .exec(new ResultCallbackTemplate<>() {
+                        @Override
+                        public void onNext(Frame frame) {
+                            String logMessage =
+                                    String.join(" ", importCommand) + ": " + new String(frame.getPayload()).trim();
+                            if (frame.getStreamType() == StreamType.STDERR) {
+                                log.error(logMessage);
+                            } else {
+                                log.info(logMessage);
+                            }
+                        }
+                    })
+                    .awaitCompletion();
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    private void createServiceAccountAndRoleAndRoleBinding() throws ApiException {
+        CoreV1Api coreApi = new CoreV1Api(apiClient);
+        V1ServiceAccount serviceAccount = new V1ServiceAccountBuilder()
+                .withNewMetadata()
+                .withName("pulsar-standalone-sa")
+                .endMetadata()
+                .build();
+        coreApi.createNamespacedServiceAccount(getNamespace(), serviceAccount).execute();
+        V1Role role = new V1RoleBuilder()
+                .withNewMetadata()
+                .withName("pulsar-functions-role")
+                .endMetadata()
+                .withRules(
+                        new V1PolicyRuleBuilder()
+                                .addToApiGroups("")
+                                .addToResources("services", "configmaps", "pods")
+                                .addToVerbs("*").build(),
+                        new V1PolicyRuleBuilder()
+                                .addToApiGroups("apps")
+                                .addToResources("statefulsets")
+                                .addToVerbs("*").build()
+                )
+                .build();
+        RbacAuthorizationV1Api rbacApi = new RbacAuthorizationV1Api(apiClient);
+        rbacApi.createNamespacedRole(getNamespace(), role).execute();
+        V1RoleBinding roleBinding = new V1RoleBindingBuilder()
+                .withNewMetadata()
+                .withName("pulsar-functions-role-binding")
+                .endMetadata()
+                .withNewRoleRef()
+                .withKind("Role")
+                .withName("pulsar-functions-role")
+                .endRoleRef()
+                .withSubjects(new RbacV1SubjectBuilder()
+                        .withKind("ServiceAccount")
+                        .withName("pulsar-standalone-sa")
+                        .withNamespace(getNamespace())
+                        .build())
+                .build();
+        rbacApi.createNamespacedRoleBinding(getNamespace(), roleBinding).execute();
+    }
+
+    private V1Pod createPulsarPod() {
+        V1PodBuilder podBuilder = new V1PodBuilder();
+        var containerBuilder = podBuilder
+                .withNewMetadata()
+                .withName(PULSAR_STANDALONE_POD)
+                .addToLabels("app", "pulsar")
+                .addToLabels("component", "standalone")
+                .endMetadata()
+                .withNewSpec()
+                .withServiceAccountName("pulsar-standalone-sa")
+                .addNewContainer();
+
+        // Container
+        containerBuilder
+                .withName("pulsar")
+                .withImage(getPulsarImageName())
+                .withImagePullPolicy("Never")
+                .withCommand("sh", "-c",
+                        "bin/apply-config-from-env.py conf/standalone.conf && "
+                                + "bin/gen-yml-from-env.py conf/functions_worker.yml && "
+                                + "bin/update-rocksdb-conf-from-env.py conf/entry_location_rocksdb.conf && "
+                                + "bin/pulsar standalone")
+                // Ports
+                .addNewPort()
+                .withName("pulsar")
+                .withContainerPort(6650)
+                .withProtocol("TCP")
+                .endPort()
+                .addNewPort()
+                .withName("http")
+                .withContainerPort(8080)
+                .withProtocol("TCP")
+                .endPort()
+                .addNewPort()
+                .withName("pulsar-nodeport")
+                .withContainerPort(16650)
+                .withProtocol("TCP")
+                .endPort();
+
+        // Environment variables
+        for (Map.Entry<String, String> env : getBrokerEnv().entrySet()) {
+            containerBuilder.addNewEnv()
+                    .withName(env.getKey())
+                    .withValue(env.getValue())
+                    .endEnv();
+        }
+
+        // Resource limits
+        containerBuilder.withNewResources()
+                .withLimits(null)
+                .addToRequests("memory", new Quantity("128Mi"))
+                .addToRequests("cpu", new Quantity("100m"))
+                .endResources();
+
+        return containerBuilder.endContainer()
+                .withOverhead(null)
+                .endSpec().build();
+    }
+
+    protected Map<String, String> getBrokerEnv() {
+        Map<String, String> envVars = new LinkedHashMap<>() {
+            {
+                put("PULSAR_MEM", "-Xmx256m");
+                put("PULSAR_GC", "-XX:+UseG1GC");
+                put("bindAddresses", "nodeport:pulsar://0.0.0.0:16650");
+                put("PULSAR_PREFIX_advertisedListeners",
+                        "internal:pulsar://pulsar.default.svc.cluster.local:6650,nodeport:" + pulsarBrokerUrl);
+                // log to file since docker logs will get truncated
+                put("PULSAR_ROUTING_APPENDER_DEFAULT", "RollingFile");
+                put("dbStorage_writeCacheMaxSizeMb", "32");
+                put("dbStorage_readAheadCacheMaxSizeMb", "32");
+                put("PF_functionsDirectory", "/pulsar/examples");
+                put("PF_functionRuntimeFactoryClassName", KubernetesRuntimeFactory.class.getName());
+                put("PF_secretsProviderConfiguratorClassName", KubernetesSecretsProviderConfigurator.class.getName());
+                put("PF_functionRuntimeFactoryConfigs_pulsarDockerImageName", getPulsarImageName());
+                put("PF_kubernetesContainerFactory_imagePullPolicy", "Never");
+                put("PF_functionRuntimeFactoryConfigs_submittingInsidePod", "true");
+                put("PF_functionRuntimeFactoryConfigs_installUserCodeDependencies", "true");
+                put("PF_functionRuntimeFactoryConfigs_jobNamespace", getNamespace());
+                put("PF_functionRuntimeFactoryConfigs_pulsarAdminUrl", "http://pulsar.default.svc.cluster.local");
+                put("PF_functionRuntimeFactoryConfigs_pulsarServiceUrl",
+                        "pulsar://pulsar.default.svc.cluster.local:6650");
+            }
+        };
+        return envVars;
+    }
+
+    public V1Service createPulsarService() {
+        V1Service service = new V1ServiceBuilder()
+                .withNewMetadata()
+                .withName("pulsar")
+                .endMetadata()
+                .withNewSpec()
+                .withType("NodePort")
+                .withSelector(Map.of("app", "pulsar", "component", "standalone"))
+                // Ports
+                .addNewPort()
+                .withName("pulsar-nodeport")
+                .withNodePort(PULSAR_NODE_PORT)
+                .withPort(16650)
+                .withNewTargetPort(16650)
+                .withProtocol("TCP")
+                .endPort()
+                .addNewPort()
+                .withName("http")
+                .withPort(80)
+                .withNodePort(PULSAR_HTTP_NODE_PORT)
+                .withNewTargetPort(8080)
+                .withProtocol("TCP")
+                .endPort()
+                .addNewPort()
+                .withName("pulsar")
+                .withPort(6650)
+                .withNewTargetPort(6650)
+                .withProtocol("TCP")
+                .endPort()
+                .endSpec()
+                .build();
+        return service;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/loadbalance/ExtensibleLoadManagerTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/loadbalance/ExtensibleLoadManagerTest.java
index 1bc2ac52c4..733041f7fc 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/loadbalance/ExtensibleLoadManagerTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/loadbalance/ExtensibleLoadManagerTest.java
@@ -1,488 +1,488 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.loadbalance;
-
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_HTTP_PORT;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertNotEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.common.policies.data.AutoFailoverPolicyData;
-import org.apache.pulsar.common.policies.data.AutoFailoverPolicyType;
-import org.apache.pulsar.common.policies.data.BundlesData;
-import org.apache.pulsar.common.policies.data.FailureDomain;
-import org.apache.pulsar.common.policies.data.NamespaceIsolationData;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.awaitility.Awaitility;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Factory;
-import org.testng.annotations.Test;
-
-
-/**
- * Integration tests for Pulsar ExtensibleLoadManagerImpl.
- */
-@Slf4j
-public class ExtensibleLoadManagerTest extends TestRetrySupport {
-
-    private static final int NUM_BROKERS = 3;
-    private static final String DEFAULT_TENANT = "my-tenant";
-    private static final String DEFAULT_NAMESPACE = DEFAULT_TENANT + "/my-namespace";
-    private static final String nsSuffix = "-anti-affinity-enabled";
-
-    private final String clusterName = "MultiLoadManagerTest-" + UUID.randomUUID();
-    private final PulsarClusterSpec spec = PulsarClusterSpec.builder()
-            .clusterName(clusterName)
-            .numBrokers(NUM_BROKERS).build();
-    private PulsarCluster pulsarCluster = null;
-    private String hosts;
-    private PulsarAdmin admin;
-    protected String serviceUnitStateTableViewClassName;
-
-    @Factory(dataProvider = "serviceUnitStateTableViewClassName")
-    public ExtensibleLoadManagerTest(String serviceUnitStateTableViewClassName) {
-        this.serviceUnitStateTableViewClassName = serviceUnitStateTableViewClassName;
-    }
-
-    @DataProvider(name = "serviceUnitStateTableViewClassName")
-    public static Object[][] serviceUnitStateTableViewClassName() {
-        return new Object[][]{
-                {"org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitStateMetadataStoreTableViewImpl"},
-                {"org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitStateTableViewImpl"}
-        };
-    }
-
-    @BeforeClass(alwaysRun = true)
-    public void setup() throws Exception {
-        incrementSetupNumber();
-        Map<String, String> brokerEnvs = new HashMap<>();
-        brokerEnvs.put("loadManagerClassName",
-                "org.apache.pulsar.broker.loadbalance.extensions.ExtensibleLoadManagerImpl");
-        brokerEnvs.put("loadBalancerLoadSheddingStrategy",
-                "org.apache.pulsar.broker.loadbalance.extensions.scheduler.TransferShedder");
-        brokerEnvs.put("loadManagerServiceUnitStateTableViewClassName",
-                serviceUnitStateTableViewClassName);
-        brokerEnvs.put("forceDeleteNamespaceAllowed", "true");
-        brokerEnvs.put("loadBalancerDebugModeEnabled", "true");
-        brokerEnvs.put("PULSAR_MEM", "-Xmx512M");
-        spec.brokerEnvs(brokerEnvs);
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-
-        admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-        // all brokers alive
-        assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), NUM_BROKERS);
-
-        admin.tenants().createTenant(DEFAULT_TENANT,
-                new TenantInfoImpl(new HashSet<>(), Set.of(pulsarCluster.getClusterName())));
-        admin.namespaces().createNamespace(DEFAULT_NAMESPACE, 100);
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void cleanup() {
-        markCurrentSetupNumberCleaned();
-        if (pulsarCluster != null) {
-            pulsarCluster.stop();
-            pulsarCluster = null;
-        }
-        if (admin != null) {
-            admin.close();
-            admin = null;
-        }
-    }
-
-    @BeforeMethod(alwaysRun = true)
-    public void startBroker() {
-        if (pulsarCluster != null) {
-            pulsarCluster.getBrokers().forEach(brokerContainer -> {
-                if (!brokerContainer.isRunning()) {
-                    brokerContainer.start();
-                }
-            });
-            String topicName = "persistent://" + DEFAULT_NAMESPACE + "/startBrokerCheck";
-            Awaitility.await().atMost(120, TimeUnit.SECONDS).ignoreExceptions().until(
-                    () -> {
-                        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
-                            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(
-                                    brokerContainer.getHttpServiceUrl()).build()) {
-                                if (admin.brokers().getActiveBrokers(clusterName).size() != NUM_BROKERS) {
-                                    return false;
-                                }
-                                try {
-                                    admin.topics().createPartitionedTopic(topicName, 10);
-                                } catch (PulsarAdminException.ConflictException e) {
-                                    // expected
-                                }
-                                admin.lookups().lookupPartitionedTopic(topicName);
-                            }
-                        }
-                        return true;
-                    }
-            );
-        }
-    }
-
-    @Test(timeOut = 40 * 1000)
-    public void testConcurrentLookups() throws Exception {
-        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/testConcurrentLookups";
-        List<PulsarAdmin> admins = new ArrayList<>();
-        int numAdminForBroker = 10;
-        for (int i = 0; i < numAdminForBroker; i++) {
-            admins.add(PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build());
-        }
-
-        admin.topics().createPartitionedTopic(topicName, 100);
-
-        var executor = Executors.newFixedThreadPool(admins.size());
-
-        CountDownLatch latch = new CountDownLatch(admins.size());
-        List<Map<String, String>> result = new CopyOnWriteArrayList<>();
-        for (var admin : admins) {
-            executor.execute(() -> {
-                try {
-                    result.add(admin.lookups().lookupPartitionedTopic(topicName));
-                } catch (PulsarAdminException e) {
-                    log.error("Lookup partitioned topic failed.", e);
-                }
-                latch.countDown();
-            });
-        }
-        latch.await();
-
-        assertEquals(result.size(), admins.size());
-
-        for (int i = 1; i < admins.size(); i++) {
-            assertEquals(result.get(i - 1), result.get(i));
-        }
-        admins.forEach(a -> a.close());
-        executor.shutdown();
-    }
-
-    @Test(timeOut = 30 * 1000)
-    public void testTransferAdminApi() throws Exception {
-        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/testUnloadAdminApi";
-        createNonPartitionedTopicAndRetry(topicName);
-        String broker = admin.lookups().lookupTopic(topicName);
-
-        int index = extractBrokerIndex(broker);
-
-        String bundleRange = admin.lookups().getBundleRange(topicName);
-
-        // Test transfer to current broker.
-        try {
-            admin.namespaces().unloadNamespaceBundle(DEFAULT_NAMESPACE, bundleRange, getBrokerUrl(index));
-            fail();
-        } catch (PulsarAdminException ex) {
-            assertTrue(ex.getMessage().contains("cannot be transfer to same broker"));
-        }
-
-        int transferToIndex = generateRandomExcludingX(NUM_BROKERS, index);
-        assertNotEquals(transferToIndex, index);
-        String transferTo = getBrokerUrl(transferToIndex);
-        admin.namespaces().unloadNamespaceBundle(DEFAULT_NAMESPACE, bundleRange, transferTo);
-
-        broker = admin.lookups().lookupTopic(topicName);
-
-        index = extractBrokerIndex(broker);
-        assertEquals(index, transferToIndex);
-    }
-
-    @Test(timeOut = 30 * 1000)
-    public void testSplitBundleAdminApi() throws Exception {
-        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/testSplitBundleAdminApi";
-        createNonPartitionedTopicAndRetry(topicName);
-        String broker = admin.lookups().lookupTopic(topicName);
-        log.info("The topic: {} owned by {}", topicName, broker);
-        BundlesData bundles = admin.namespaces().getBundles(DEFAULT_NAMESPACE);
-        int numBundles = bundles.getNumBundles();
-        var bundleRanges = bundles.getBoundaries().stream().map(Long::decode).sorted().toList();
-        String firstBundle = bundleRanges.get(0) + "_" + bundleRanges.get(1);
-        admin.namespaces().splitNamespaceBundle(DEFAULT_NAMESPACE, firstBundle, true, null);
-        long mid = bundleRanges.get(0) + (bundleRanges.get(1) - bundleRanges.get(0)) / 2;
-        Awaitility.waitAtMost(10, TimeUnit.SECONDS).pollDelay(100, TimeUnit.MILLISECONDS)
-                .untilAsserted(
-                        () -> {
-                            BundlesData bundlesData = admin.namespaces().getBundles(DEFAULT_NAMESPACE);
-                            assertEquals(bundlesData.getNumBundles(), numBundles + 1);
-                            String lowBundle = String.format("0x%08x", bundleRanges.get(0));
-                            String midBundle = String.format("0x%08x", mid);
-                            String highBundle = String.format("0x%08x", bundleRanges.get(1));
-                            assertTrue(bundlesData.getBoundaries().contains(lowBundle));
-                            assertTrue(bundlesData.getBoundaries().contains(midBundle));
-                            assertTrue(bundlesData.getBoundaries().contains(highBundle));
-                        }
-                );
-
-
-        // Test split bundle with invalid bundle range.
-        try {
-            admin.namespaces().splitNamespaceBundle(DEFAULT_NAMESPACE, "invalid", true, null);
-            fail();
-        } catch (PulsarAdminException ex) {
-            assertTrue(ex.getMessage().contains("Invalid bundle range"));
-        }
-    }
-
-    @Test(timeOut = 30 * 1000)
-    public void testDeleteNamespace() throws Exception {
-        String namespace = DEFAULT_TENANT + "/test-delete-namespace";
-        String topicName = "persistent://" + namespace + "/test-delete-namespace-topic";
-        admin.namespaces().createNamespace(namespace);
-        admin.namespaces().setNamespaceReplicationClusters(namespace, Sets.newHashSet(clusterName));
-        assertTrue(admin.namespaces().getNamespaces(DEFAULT_TENANT).contains(namespace));
-        admin.topics().createPartitionedTopic(topicName, 2);
-        String broker = admin.lookups().lookupTopic(topicName);
-        log.info("The topic: {} owned by: {}", topicName, broker);
-        admin.namespaces().deleteNamespace(namespace, true);
-        assertFalse(admin.namespaces().getNamespaces(DEFAULT_TENANT).contains(namespace));
-    }
-
-    @Test(timeOut = 120 * 1000)
-    public void testStopBroker() throws Exception {
-        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/test-stop-broker-topic";
-
-        createNonPartitionedTopicAndRetry(topicName);
-        String broker = admin.lookups().lookupTopic(topicName);
-        log.info("The topic: {} owned by: {}", topicName, broker);
-
-        int idx = extractBrokerIndex(broker);
-        for (BrokerContainer container : pulsarCluster.getBrokers()) {
-            String name = container.getHostName();
-            if (name.contains(String.valueOf(idx))) {
-                container.stop();
-            }
-        }
-
-        Awaitility.waitAtMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(() -> {
-            String broker1 = admin.lookups().lookupTopic(topicName);
-            assertNotEquals(broker1, broker);
-        });
-
-    }
-
-    @Test(timeOut = 80 * 1000)
-    public void testAntiAffinityPolicy() throws PulsarAdminException {
-        final String namespaceAntiAffinityGroup = "my-anti-affinity-filter";
-        final String antiAffinityEnabledNameSpace = DEFAULT_TENANT + "/my-ns-filter" + nsSuffix;
-        final int numPartition = 20;
-
-        List<String> activeBrokers = admin.brokers().getActiveBrokers();
-
-        assertEquals(activeBrokers.size(), NUM_BROKERS);
-
-        Set<String> antiAffinityEnabledNameSpacesReq = new HashSet<>();
-        for (int i = 0; i < activeBrokers.size(); i++) {
-            String namespace = antiAffinityEnabledNameSpace + "-" + i;
-            antiAffinityEnabledNameSpacesReq.add(namespace);
-            admin.namespaces().createNamespace(namespace, 1);
-            admin.namespaces().setNamespaceAntiAffinityGroup(namespace, namespaceAntiAffinityGroup);
-            admin.clusters().createFailureDomain(clusterName, namespaceAntiAffinityGroup, FailureDomain.builder()
-                    .brokers(Set.of(activeBrokers.get(i))).build());
-            String namespaceAntiAffinityGroupResp = admin.namespaces().getNamespaceAntiAffinityGroup(namespace);
-            assertEquals(namespaceAntiAffinityGroupResp, namespaceAntiAffinityGroup);
-            FailureDomain failureDomainResp =
-                    admin.clusters().getFailureDomain(clusterName, namespaceAntiAffinityGroup);
-            assertEquals(failureDomainResp.getBrokers(), Set.of(activeBrokers.get(i)));
-        }
-
-        List<String> antiAffinityNamespacesResp =
-                admin.namespaces().getAntiAffinityNamespaces(DEFAULT_TENANT, clusterName, namespaceAntiAffinityGroup);
-        assertEquals(new HashSet<>(antiAffinityNamespacesResp), antiAffinityEnabledNameSpacesReq);
-
-        Set<String> result = new HashSet<>();
-        for (int i = 0; i < activeBrokers.size(); i++) {
-            final String topic = "persistent://" + antiAffinityEnabledNameSpace + "-" + i + "/topic";
-            admin.topics().createPartitionedTopic(topic, numPartition);
-
-            Map<String, String> topicToBroker = admin.lookups().lookupPartitionedTopic(topic);
-
-            assertEquals(topicToBroker.size(), numPartition);
-
-            HashSet<String> brokers = new HashSet<>(topicToBroker.values());
-
-            assertEquals(brokers.size(), 1);
-            result.add(brokers.iterator().next());
-            log.info("Topic: {}, lookup result: {}", topic, brokers.iterator().next());
-        }
-
-        assertEquals(result.size(), NUM_BROKERS);
-    }
-
-    @Test(timeOut = 300 * 1000)
-    public void testIsolationPolicy() throws Exception {
-        final String namespaceIsolationPolicyName = "my-isolation-policy";
-        final String isolationEnabledNameSpace = DEFAULT_TENANT + "/my-isolation-policy" + nsSuffix;
-        Map<String, String> parameters1 = new HashMap<>();
-        parameters1.put("min_limit", "1");
-        parameters1.put("usage_threshold", "100");
-
-        Awaitility.await().atMost(10, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
-                () -> {
-                    List<String> activeBrokers = admin.brokers().getActiveBrokersAsync()
-                            .get(5, TimeUnit.SECONDS);
-                    assertEquals(activeBrokers.size(), NUM_BROKERS);
-                }
-        );
-        try {
-            admin.namespaces().createNamespace(isolationEnabledNameSpace);
-        } catch (PulsarAdminException.ConflictException e) {
-            //expected when retried
-        }
-
-        try {
-            admin.clusters()
-                    .createNamespaceIsolationPolicy(clusterName, namespaceIsolationPolicyName, NamespaceIsolationData
-                            .builder()
-                            .namespaces(List.of(isolationEnabledNameSpace))
-                            .autoFailoverPolicy(AutoFailoverPolicyData.builder()
-                                    .policyType(AutoFailoverPolicyType.min_available)
-                                    .parameters(parameters1)
-                                    .build())
-                            .primary(List.of(getHostName(0)))
-                            .secondary(List.of(getHostName(1)))
-                            .build());
-        } catch (PulsarAdminException.ConflictException e) {
-            //expected when retried
-        }
-
-        final String topic = "persistent://" + isolationEnabledNameSpace + "/topic";
-        createNonPartitionedTopicAndRetry(topic);
-
-        String broker = admin.lookups().lookupTopic(topic);
-        assertEquals(extractBrokerIndex(broker), 0);
-
-        for (BrokerContainer container : pulsarCluster.getBrokers()) {
-            String name = container.getHostName();
-            if (name.contains("0")) {
-                container.stop();
-            }
-        }
-
-        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
-                () -> {
-                    List<String> activeBrokers = admin.brokers().getActiveBrokersAsync()
-                            .get(5, TimeUnit.SECONDS);
-                    assertEquals(activeBrokers.size(), 2);
-                }
-        );
-
-        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(() -> {
-            String ownerBroker = admin.lookups().lookupTopicAsync(topic).get(5, TimeUnit.SECONDS);
-            assertEquals(extractBrokerIndex(ownerBroker), 1);
-        });
-
-        for (BrokerContainer container : pulsarCluster.getBrokers()) {
-            String name = container.getHostName();
-            if (name.contains("1")) {
-                container.stop();
-            }
-        }
-
-        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
-                () -> {
-                    List<String> activeBrokers = admin.brokers().getActiveBrokersAsync().get(5, TimeUnit.SECONDS);
-                    assertEquals(activeBrokers.size(), 1);
-                }
-        );
-
-        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
-                () -> {
-                    try {
-                        admin.lookups().lookupTopicAsync(topic).get(5, TimeUnit.SECONDS);
-                        fail();
-                    } catch (Exception ex) {
-                        log.error("Failed to lookup topic: ", ex);
-                        assertThat(ex.getMessage()).contains("Service Unavailable");
-                    }
-                }
-        );
-
-    }
-
-    private void createNonPartitionedTopicAndRetry(String topicName) throws Exception {
-        Awaitility.await().atMost(10, TimeUnit.SECONDS).until(() -> {
-            try {
-                admin.topics().createNonPartitionedTopic(topicName);
-                return true;
-            } catch (PulsarAdminException.ConflictException e) {
-                return true;
-                //expected when retried
-            } catch (Exception e) {
-                log.error("Failed to create topic: ", e);
-                return false;
-            }
-        });
-    }
-
-    private String getBrokerUrl(int index) {
-        return String.format("pulsar-broker-%d:%d", index, BROKER_HTTP_PORT);
-    }
-
-    private String getHostName(int index) {
-        return String.format("pulsar-broker-%d", index);
-    }
-
-    private int extractBrokerIndex(String broker) {
-        String pattern = "pulsar://.*-(\\d+):\\d+";
-        Pattern compiledPattern = Pattern.compile(pattern);
-        Matcher matcher = compiledPattern.matcher(broker);
-        if (!matcher.find()){
-            throw new IllegalArgumentException("Failed to extract broker index");
-        }
-        return Integer.parseInt(matcher.group(1));
-    }
-
-    private int generateRandomExcludingX(int n, int x) {
-        Random random = new Random();
-        int randomNumber;
-
-        do {
-            randomNumber = random.nextInt(n);
-        } while (randomNumber == x);
-
-        return randomNumber;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.loadbalance;
+
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_HTTP_PORT;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import com.google.common.collect.Sets;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.common.policies.data.AutoFailoverPolicyData;
+import org.apache.pulsar.common.policies.data.AutoFailoverPolicyType;
+import org.apache.pulsar.common.policies.data.BundlesData;
+import org.apache.pulsar.common.policies.data.FailureDomain;
+import org.apache.pulsar.common.policies.data.NamespaceIsolationData;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.awaitility.Awaitility;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Factory;
+import org.testng.annotations.Test;
+
+
+/**
+ * Integration tests for Pulsar ExtensibleLoadManagerImpl.
+ */
+@Slf4j
+public class ExtensibleLoadManagerTest extends TestRetrySupport {
+
+    private static final int NUM_BROKERS = 3;
+    private static final String DEFAULT_TENANT = "my-tenant";
+    private static final String DEFAULT_NAMESPACE = DEFAULT_TENANT + "/my-namespace";
+    private static final String nsSuffix = "-anti-affinity-enabled";
+
+    private final String clusterName = "MultiLoadManagerTest-" + UUID.randomUUID();
+    private final PulsarClusterSpec spec = PulsarClusterSpec.builder()
+            .clusterName(clusterName)
+            .numBrokers(NUM_BROKERS).build();
+    private PulsarCluster pulsarCluster = null;
+    private String hosts;
+    private PulsarAdmin admin;
+    protected String serviceUnitStateTableViewClassName;
+
+    @Factory(dataProvider = "serviceUnitStateTableViewClassName")
+    public ExtensibleLoadManagerTest(String serviceUnitStateTableViewClassName) {
+        this.serviceUnitStateTableViewClassName = serviceUnitStateTableViewClassName;
+    }
+
+    @DataProvider(name = "serviceUnitStateTableViewClassName")
+    public static Object[][] serviceUnitStateTableViewClassName() {
+        return new Object[][]{
+                {"org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitStateMetadataStoreTableViewImpl"},
+                {"org.apache.pulsar.broker.loadbalance.extensions.channel.ServiceUnitStateTableViewImpl"}
+        };
+    }
+
+    @BeforeClass(alwaysRun = true)
+    public void setup() throws Exception {
+        incrementSetupNumber();
+        Map<String, String> brokerEnvs = new HashMap<>();
+        brokerEnvs.put("loadManagerClassName",
+                "org.apache.pulsar.broker.loadbalance.extensions.ExtensibleLoadManagerImpl");
+        brokerEnvs.put("loadBalancerLoadSheddingStrategy",
+                "org.apache.pulsar.broker.loadbalance.extensions.scheduler.TransferShedder");
+        brokerEnvs.put("loadManagerServiceUnitStateTableViewClassName",
+                serviceUnitStateTableViewClassName);
+        brokerEnvs.put("forceDeleteNamespaceAllowed", "true");
+        brokerEnvs.put("loadBalancerDebugModeEnabled", "true");
+        brokerEnvs.put("PULSAR_MEM", "-Xmx512M");
+        spec.brokerEnvs(brokerEnvs);
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+
+        admin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+        // all brokers alive
+        assertEquals(admin.brokers().getActiveBrokers(clusterName).size(), NUM_BROKERS);
+
+        admin.tenants().createTenant(DEFAULT_TENANT,
+                new TenantInfoImpl(new HashSet<>(), Set.of(pulsarCluster.getClusterName())));
+        admin.namespaces().createNamespace(DEFAULT_NAMESPACE, 100);
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void cleanup() {
+        markCurrentSetupNumberCleaned();
+        if (pulsarCluster != null) {
+            pulsarCluster.stop();
+            pulsarCluster = null;
+        }
+        if (admin != null) {
+            admin.close();
+            admin = null;
+        }
+    }
+
+    @BeforeMethod(alwaysRun = true)
+    public void startBroker() {
+        if (pulsarCluster != null) {
+            pulsarCluster.getBrokers().forEach(brokerContainer -> {
+                if (!brokerContainer.isRunning()) {
+                    brokerContainer.start();
+                }
+            });
+            String topicName = "persistent://" + DEFAULT_NAMESPACE + "/startBrokerCheck";
+            Awaitility.await().atMost(120, TimeUnit.SECONDS).ignoreExceptions().until(
+                    () -> {
+                        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
+                            try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(
+                                    brokerContainer.getHttpServiceUrl()).build()) {
+                                if (admin.brokers().getActiveBrokers(clusterName).size() != NUM_BROKERS) {
+                                    return false;
+                                }
+                                try {
+                                    admin.topics().createPartitionedTopic(topicName, 10);
+                                } catch (PulsarAdminException.ConflictException e) {
+                                    // expected
+                                }
+                                admin.lookups().lookupPartitionedTopic(topicName);
+                            }
+                        }
+                        return true;
+                    }
+            );
+        }
+    }
+
+    @Test(timeOut = 40 * 1000)
+    public void testConcurrentLookups() throws Exception {
+        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/testConcurrentLookups";
+        List<PulsarAdmin> admins = new ArrayList<>();
+        int numAdminForBroker = 10;
+        for (int i = 0; i < numAdminForBroker; i++) {
+            admins.add(PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build());
+        }
+
+        admin.topics().createPartitionedTopic(topicName, 100);
+
+        var executor = Executors.newFixedThreadPool(admins.size());
+
+        CountDownLatch latch = new CountDownLatch(admins.size());
+        List<Map<String, String>> result = new CopyOnWriteArrayList<>();
+        for (var admin : admins) {
+            executor.execute(() -> {
+                try {
+                    result.add(admin.lookups().lookupPartitionedTopic(topicName));
+                } catch (PulsarAdminException e) {
+                    log.error("Lookup partitioned topic failed.", e);
+                }
+                latch.countDown();
+            });
+        }
+        latch.await();
+
+        assertEquals(result.size(), admins.size());
+
+        for (int i = 1; i < admins.size(); i++) {
+            assertEquals(result.get(i - 1), result.get(i));
+        }
+        admins.forEach(a -> a.close());
+        executor.shutdown();
+    }
+
+    @Test(timeOut = 30 * 1000)
+    public void testTransferAdminApi() throws Exception {
+        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/testUnloadAdminApi";
+        createNonPartitionedTopicAndRetry(topicName);
+        String broker = admin.lookups().lookupTopic(topicName);
+
+        int index = extractBrokerIndex(broker);
+
+        String bundleRange = admin.lookups().getBundleRange(topicName);
+
+        // Test transfer to current broker.
+        try {
+            admin.namespaces().unloadNamespaceBundle(DEFAULT_NAMESPACE, bundleRange, getBrokerUrl(index));
+            fail();
+        } catch (PulsarAdminException ex) {
+            assertTrue(ex.getMessage().contains("cannot be transfer to same broker"));
+        }
+
+        int transferToIndex = generateRandomExcludingX(NUM_BROKERS, index);
+        assertNotEquals(transferToIndex, index);
+        String transferTo = getBrokerUrl(transferToIndex);
+        admin.namespaces().unloadNamespaceBundle(DEFAULT_NAMESPACE, bundleRange, transferTo);
+
+        broker = admin.lookups().lookupTopic(topicName);
+
+        index = extractBrokerIndex(broker);
+        assertEquals(index, transferToIndex);
+    }
+
+    @Test(timeOut = 30 * 1000)
+    public void testSplitBundleAdminApi() throws Exception {
+        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/testSplitBundleAdminApi";
+        createNonPartitionedTopicAndRetry(topicName);
+        String broker = admin.lookups().lookupTopic(topicName);
+        log.info("The topic: {} owned by {}", topicName, broker);
+        BundlesData bundles = admin.namespaces().getBundles(DEFAULT_NAMESPACE);
+        int numBundles = bundles.getNumBundles();
+        var bundleRanges = bundles.getBoundaries().stream().map(Long::decode).sorted().toList();
+        String firstBundle = bundleRanges.get(0) + "_" + bundleRanges.get(1);
+        admin.namespaces().splitNamespaceBundle(DEFAULT_NAMESPACE, firstBundle, true, null);
+        long mid = bundleRanges.get(0) + (bundleRanges.get(1) - bundleRanges.get(0)) / 2;
+        Awaitility.waitAtMost(10, TimeUnit.SECONDS).pollDelay(100, TimeUnit.MILLISECONDS)
+                .untilAsserted(
+                        () -> {
+                            BundlesData bundlesData = admin.namespaces().getBundles(DEFAULT_NAMESPACE);
+                            assertEquals(bundlesData.getNumBundles(), numBundles + 1);
+                            String lowBundle = String.format("0x%08x", bundleRanges.get(0));
+                            String midBundle = String.format("0x%08x", mid);
+                            String highBundle = String.format("0x%08x", bundleRanges.get(1));
+                            assertTrue(bundlesData.getBoundaries().contains(lowBundle));
+                            assertTrue(bundlesData.getBoundaries().contains(midBundle));
+                            assertTrue(bundlesData.getBoundaries().contains(highBundle));
+                        }
+                );
+
+
+        // Test split bundle with invalid bundle range.
+        try {
+            admin.namespaces().splitNamespaceBundle(DEFAULT_NAMESPACE, "invalid", true, null);
+            fail();
+        } catch (PulsarAdminException ex) {
+            assertTrue(ex.getMessage().contains("Invalid bundle range"));
+        }
+    }
+
+    @Test(timeOut = 30 * 1000)
+    public void testDeleteNamespace() throws Exception {
+        String namespace = DEFAULT_TENANT + "/test-delete-namespace";
+        String topicName = "persistent://" + namespace + "/test-delete-namespace-topic";
+        admin.namespaces().createNamespace(namespace);
+        admin.namespaces().setNamespaceReplicationClusters(namespace, Sets.newHashSet(clusterName));
+        assertTrue(admin.namespaces().getNamespaces(DEFAULT_TENANT).contains(namespace));
+        admin.topics().createPartitionedTopic(topicName, 2);
+        String broker = admin.lookups().lookupTopic(topicName);
+        log.info("The topic: {} owned by: {}", topicName, broker);
+        admin.namespaces().deleteNamespace(namespace, true);
+        assertFalse(admin.namespaces().getNamespaces(DEFAULT_TENANT).contains(namespace));
+    }
+
+    @Test(timeOut = 120 * 1000)
+    public void testStopBroker() throws Exception {
+        String topicName = "persistent://" + DEFAULT_NAMESPACE + "/test-stop-broker-topic";
+
+        createNonPartitionedTopicAndRetry(topicName);
+        String broker = admin.lookups().lookupTopic(topicName);
+        log.info("The topic: {} owned by: {}", topicName, broker);
+
+        int idx = extractBrokerIndex(broker);
+        for (BrokerContainer container : pulsarCluster.getBrokers()) {
+            String name = container.getHostName();
+            if (name.contains(String.valueOf(idx))) {
+                container.stop();
+            }
+        }
+
+        Awaitility.waitAtMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(() -> {
+            String broker1 = admin.lookups().lookupTopic(topicName);
+            assertNotEquals(broker1, broker);
+        });
+
+    }
+
+    @Test(timeOut = 80 * 1000)
+    public void testAntiAffinityPolicy() throws PulsarAdminException {
+        final String namespaceAntiAffinityGroup = "my-anti-affinity-filter";
+        final String antiAffinityEnabledNameSpace = DEFAULT_TENANT + "/my-ns-filter" + nsSuffix;
+        final int numPartition = 20;
+
+        List<String> activeBrokers = admin.brokers().getActiveBrokers();
+
+        assertEquals(activeBrokers.size(), NUM_BROKERS);
+
+        Set<String> antiAffinityEnabledNameSpacesReq = new HashSet<>();
+        for (int i = 0; i < activeBrokers.size(); i++) {
+            String namespace = antiAffinityEnabledNameSpace + "-" + i;
+            antiAffinityEnabledNameSpacesReq.add(namespace);
+            admin.namespaces().createNamespace(namespace, 1);
+            admin.namespaces().setNamespaceAntiAffinityGroup(namespace, namespaceAntiAffinityGroup);
+            admin.clusters().createFailureDomain(clusterName, namespaceAntiAffinityGroup, FailureDomain.builder()
+                    .brokers(Set.of(activeBrokers.get(i))).build());
+            String namespaceAntiAffinityGroupResp = admin.namespaces().getNamespaceAntiAffinityGroup(namespace);
+            assertEquals(namespaceAntiAffinityGroupResp, namespaceAntiAffinityGroup);
+            FailureDomain failureDomainResp =
+                    admin.clusters().getFailureDomain(clusterName, namespaceAntiAffinityGroup);
+            assertEquals(failureDomainResp.getBrokers(), Set.of(activeBrokers.get(i)));
+        }
+
+        List<String> antiAffinityNamespacesResp =
+                admin.namespaces().getAntiAffinityNamespaces(DEFAULT_TENANT, clusterName, namespaceAntiAffinityGroup);
+        assertEquals(new HashSet<>(antiAffinityNamespacesResp), antiAffinityEnabledNameSpacesReq);
+
+        Set<String> result = new HashSet<>();
+        for (int i = 0; i < activeBrokers.size(); i++) {
+            final String topic = "persistent://" + antiAffinityEnabledNameSpace + "-" + i + "/topic";
+            admin.topics().createPartitionedTopic(topic, numPartition);
+
+            Map<String, String> topicToBroker = admin.lookups().lookupPartitionedTopic(topic);
+
+            assertEquals(topicToBroker.size(), numPartition);
+
+            HashSet<String> brokers = new HashSet<>(topicToBroker.values());
+
+            assertEquals(brokers.size(), 1);
+            result.add(brokers.iterator().next());
+            log.info("Topic: {}, lookup result: {}", topic, brokers.iterator().next());
+        }
+
+        assertEquals(result.size(), NUM_BROKERS);
+    }
+
+    @Test(timeOut = 300 * 1000)
+    public void testIsolationPolicy() throws Exception {
+        final String namespaceIsolationPolicyName = "my-isolation-policy";
+        final String isolationEnabledNameSpace = DEFAULT_TENANT + "/my-isolation-policy" + nsSuffix;
+        Map<String, String> parameters1 = new HashMap<>();
+        parameters1.put("min_limit", "1");
+        parameters1.put("usage_threshold", "100");
+
+        Awaitility.await().atMost(10, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
+                () -> {
+                    List<String> activeBrokers = admin.brokers().getActiveBrokersAsync()
+                            .get(5, TimeUnit.SECONDS);
+                    assertEquals(activeBrokers.size(), NUM_BROKERS);
+                }
+        );
+        try {
+            admin.namespaces().createNamespace(isolationEnabledNameSpace);
+        } catch (PulsarAdminException.ConflictException e) {
+            //expected when retried
+        }
+
+        try {
+            admin.clusters()
+                    .createNamespaceIsolationPolicy(clusterName, namespaceIsolationPolicyName, NamespaceIsolationData
+                            .builder()
+                            .namespaces(List.of(isolationEnabledNameSpace))
+                            .autoFailoverPolicy(AutoFailoverPolicyData.builder()
+                                    .policyType(AutoFailoverPolicyType.min_available)
+                                    .parameters(parameters1)
+                                    .build())
+                            .primary(List.of(getHostName(0)))
+                            .secondary(List.of(getHostName(1)))
+                            .build());
+        } catch (PulsarAdminException.ConflictException e) {
+            //expected when retried
+        }
+
+        final String topic = "persistent://" + isolationEnabledNameSpace + "/topic";
+        createNonPartitionedTopicAndRetry(topic);
+
+        String broker = admin.lookups().lookupTopic(topic);
+        assertEquals(extractBrokerIndex(broker), 0);
+
+        for (BrokerContainer container : pulsarCluster.getBrokers()) {
+            String name = container.getHostName();
+            if (name.contains("0")) {
+                container.stop();
+            }
+        }
+
+        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
+                () -> {
+                    List<String> activeBrokers = admin.brokers().getActiveBrokersAsync()
+                            .get(5, TimeUnit.SECONDS);
+                    assertEquals(activeBrokers.size(), 2);
+                }
+        );
+
+        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(() -> {
+            String ownerBroker = admin.lookups().lookupTopicAsync(topic).get(5, TimeUnit.SECONDS);
+            assertEquals(extractBrokerIndex(ownerBroker), 1);
+        });
+
+        for (BrokerContainer container : pulsarCluster.getBrokers()) {
+            String name = container.getHostName();
+            if (name.contains("1")) {
+                container.stop();
+            }
+        }
+
+        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
+                () -> {
+                    List<String> activeBrokers = admin.brokers().getActiveBrokersAsync().get(5, TimeUnit.SECONDS);
+                    assertEquals(activeBrokers.size(), 1);
+                }
+        );
+
+        Awaitility.await().atMost(60, TimeUnit.SECONDS).ignoreExceptions().untilAsserted(
+                () -> {
+                    try {
+                        admin.lookups().lookupTopicAsync(topic).get(5, TimeUnit.SECONDS);
+                        fail();
+                    } catch (Exception ex) {
+                        log.error("Failed to lookup topic: ", ex);
+                        assertThat(ex.getMessage()).contains("Service Unavailable");
+                    }
+                }
+        );
+
+    }
+
+    private void createNonPartitionedTopicAndRetry(String topicName) throws Exception {
+        Awaitility.await().atMost(10, TimeUnit.SECONDS).until(() -> {
+            try {
+                admin.topics().createNonPartitionedTopic(topicName);
+                return true;
+            } catch (PulsarAdminException.ConflictException e) {
+                return true;
+                //expected when retried
+            } catch (Exception e) {
+                log.error("Failed to create topic: ", e);
+                return false;
+            }
+        });
+    }
+
+    private String getBrokerUrl(int index) {
+        return String.format("pulsar-broker-%d:%d", index, BROKER_HTTP_PORT);
+    }
+
+    private String getHostName(int index) {
+        return String.format("pulsar-broker-%d", index);
+    }
+
+    private int extractBrokerIndex(String broker) {
+        String pattern = "pulsar://.*-(\\d+):\\d+";
+        Pattern compiledPattern = Pattern.compile(pattern);
+        Matcher matcher = compiledPattern.matcher(broker);
+        if (!matcher.find()){
+            throw new IllegalArgumentException("Failed to extract broker index");
+        }
+        return Integer.parseInt(matcher.group(1));
+    }
+
+    private int generateRandomExcludingX(int n, int x) {
+        Random random = new Random();
+        int randomNumber;
+
+        do {
+            randomNumber = random.nextInt(n);
+        } while (randomNumber == x);
+
+        return randomNumber;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/DelayMessagingTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/DelayMessagingTest.java
index effaef5c19..d77edfbe17 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/DelayMessagingTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/DelayMessagingTest.java
@@ -1,106 +1,106 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.DeadLetterPolicy;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * Delay messaging test.
- */
-@Slf4j
-public class DelayMessagingTest extends PulsarTestSuite {
-
-    @Test(dataProvider = "ServiceUrls")
-    public void delayMsgBlockTest(Supplier<String> serviceUrl) throws Exception {
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-
-        String topic = generateTopicName(nsName, "testDelayMsgBlock", true);
-        pulsarCluster.createPartitionedTopic(topic, 3);
-
-        String retryTopic = topic + "-RETRY";
-        String deadLetterTopic = topic + "-DLT";
-
-        @Cleanup
-        PulsarClient pulsarClient = PulsarClient.builder().serviceUrl(serviceUrl.get()).build();
-
-        @Cleanup
-        Producer<byte[]> producer = pulsarClient.newProducer()
-                .topic(topic)
-                .create();
-
-        final int redeliverCnt = 10;
-        final int delayTimeSeconds = 5;
-        @Cleanup
-        Consumer<byte[]> consumer = pulsarClient.newConsumer()
-                .topic(topic)
-                .subscriptionName("test")
-                .subscriptionType(SubscriptionType.Shared)
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .enableRetry(true)
-                .deadLetterPolicy(DeadLetterPolicy.builder()
-                        .maxRedeliverCount(redeliverCnt)
-                        .retryLetterTopic(retryTopic)
-                        .deadLetterTopic(deadLetterTopic)
-                        .build())
-                .receiverQueueSize(100)
-                .ackTimeout(60, TimeUnit.SECONDS)
-                .subscribe();
-
-        producer.newMessage().value("hello".getBytes()).send();
-
-        // receive message at first time
-        Message<byte[]> message = consumer.receive(delayTimeSeconds * 2, TimeUnit.SECONDS);
-        Assert.assertNotNull(message, "Can't receive message at the first time.");
-        consumer.reconsumeLater(message, delayTimeSeconds, TimeUnit.SECONDS);
-
-        // receive retry messages
-        for (int i = 0; i < redeliverCnt; i++) {
-            message = consumer.receive(delayTimeSeconds * 2, TimeUnit.SECONDS);
-            Assert.assertNotNull(message, "Consumer can't receive message in double delayTimeSeconds time "
-                    + delayTimeSeconds * 2 + "s");
-            log.info("receive msg. reConsumeTimes: {}", message.getProperty("RECONSUMETIMES"));
-            consumer.reconsumeLater(message, delayTimeSeconds, TimeUnit.SECONDS);
-        }
-
-        @Cleanup
-        Consumer<byte[]> dltConsumer = pulsarClient.newConsumer()
-                .topic(deadLetterTopic)
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscriptionName("test")
-                .subscribe();
-
-        message = dltConsumer.receive(10, TimeUnit.SECONDS);
-        Assert.assertNotNull(message, "Dead letter topic consumer can't receive message.");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.DeadLetterPolicy;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * Delay messaging test.
+ */
+@Slf4j
+public class DelayMessagingTest extends PulsarTestSuite {
+
+    @Test(dataProvider = "ServiceUrls")
+    public void delayMsgBlockTest(Supplier<String> serviceUrl) throws Exception {
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+
+        String topic = generateTopicName(nsName, "testDelayMsgBlock", true);
+        pulsarCluster.createPartitionedTopic(topic, 3);
+
+        String retryTopic = topic + "-RETRY";
+        String deadLetterTopic = topic + "-DLT";
+
+        @Cleanup
+        PulsarClient pulsarClient = PulsarClient.builder().serviceUrl(serviceUrl.get()).build();
+
+        @Cleanup
+        Producer<byte[]> producer = pulsarClient.newProducer()
+                .topic(topic)
+                .create();
+
+        final int redeliverCnt = 10;
+        final int delayTimeSeconds = 5;
+        @Cleanup
+        Consumer<byte[]> consumer = pulsarClient.newConsumer()
+                .topic(topic)
+                .subscriptionName("test")
+                .subscriptionType(SubscriptionType.Shared)
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .enableRetry(true)
+                .deadLetterPolicy(DeadLetterPolicy.builder()
+                        .maxRedeliverCount(redeliverCnt)
+                        .retryLetterTopic(retryTopic)
+                        .deadLetterTopic(deadLetterTopic)
+                        .build())
+                .receiverQueueSize(100)
+                .ackTimeout(60, TimeUnit.SECONDS)
+                .subscribe();
+
+        producer.newMessage().value("hello".getBytes()).send();
+
+        // receive message at first time
+        Message<byte[]> message = consumer.receive(delayTimeSeconds * 2, TimeUnit.SECONDS);
+        Assert.assertNotNull(message, "Can't receive message at the first time.");
+        consumer.reconsumeLater(message, delayTimeSeconds, TimeUnit.SECONDS);
+
+        // receive retry messages
+        for (int i = 0; i < redeliverCnt; i++) {
+            message = consumer.receive(delayTimeSeconds * 2, TimeUnit.SECONDS);
+            Assert.assertNotNull(message, "Consumer can't receive message in double delayTimeSeconds time "
+                    + delayTimeSeconds * 2 + "s");
+            log.info("receive msg. reConsumeTimes: {}", message.getProperty("RECONSUMETIMES"));
+            consumer.reconsumeLater(message, delayTimeSeconds, TimeUnit.SECONDS);
+        }
+
+        @Cleanup
+        Consumer<byte[]> dltConsumer = pulsarClient.newConsumer()
+                .topic(deadLetterTopic)
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscriptionName("test")
+                .subscribe();
+
+        message = dltConsumer.receive(10, TimeUnit.SECONDS);
+        Assert.assertNotNull(message, "Dead letter topic consumer can't receive message.");
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/GeoReplicationTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/GeoReplicationTest.java
index 46511536f9..1a37ba1492 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/GeoReplicationTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/GeoReplicationTest.java
@@ -1,128 +1,128 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import java.nio.charset.StandardCharsets;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarGeoClusterTestBase;
-import org.awaitility.Awaitility;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-/**
- * Geo replication test.
- */
-@Slf4j
-public class GeoReplicationTest extends PulsarGeoClusterTestBase {
-
-    @BeforeClass(alwaysRun = true)
-    public final void setupBeforeClass() throws Exception {
-        setup();
-    }
-
-    @Override
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder[] beforeSetupCluster (
-            PulsarClusterSpec.PulsarClusterSpecBuilder... specBuilder) {
-        if (specBuilder != null) {
-            Map<String, String> brokerEnvs = new HashMap<>();
-            brokerEnvs.put("systemTopicEnabled", "false");
-            brokerEnvs.put("topicLevelPoliciesEnabled", "false");
-            for (PulsarClusterSpec.PulsarClusterSpecBuilder builder : specBuilder) {
-                builder.brokerEnvs(brokerEnvs);
-            }
-        }
-        return specBuilder;
-    }
-
-    @AfterClass(alwaysRun = true)
-    public final void tearDownAfterClass() throws Exception {
-        cleanup();
-    }
-
-    @Test(timeOut = 1000 * 30, dataProvider = "TopicDomain")
-    public void testTopicReplication(String domain) throws Exception {
-        String cluster1 = getGeoCluster().getClusters()[0].getClusterName();
-        String cluster2 = getGeoCluster().getClusters()[1].getClusterName();
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(getGeoCluster().getClusters()[0].getHttpServiceUrl())
-                .requestTimeout(30, TimeUnit.SECONDS)
-                .build();
-
-        String topic = domain + "://public/default/testTopicReplication-" + UUID.randomUUID();
-        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {
-            try {
-                admin.topics().createPartitionedTopic(topic, 10);
-            } catch (Exception e) {
-                log.error("Failed to create partitioned topic {}.", topic, e);
-                Assert.fail("Failed to create partitioned topic " + topic);
-            }
-            Assert.assertEquals(admin.topics().getPartitionedTopicMetadata(topic).partitions, 10);
-        });
-        log.info("Test geo-replication produce and consume for topic {}.", topic);
-
-        @Cleanup
-        PulsarClient client1 = PulsarClient.builder()
-                .serviceUrl(getGeoCluster().getClusters()[0].getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        PulsarClient client2 = PulsarClient.builder()
-                .serviceUrl(getGeoCluster().getClusters()[1].getPlainTextServiceUrl())
-                .build();
-
-        @Cleanup
-        Producer<byte[]> p = client1.newProducer()
-                .topic(topic)
-                .create();
-        log.info("Successfully create producer in cluster {} for topic {}.", cluster1, topic);
-
-        @Cleanup
-        Consumer<byte[]> c = client2.newConsumer()
-                .topic(topic)
-                .subscriptionName("geo-sub")
-                .subscribe();
-        log.info("Successfully create consumer in cluster {} for topic {}.", cluster2, topic);
-
-        for (int i = 0; i < 10; i++) {
-            p.send(String.format("Message [%d]", i).getBytes(StandardCharsets.UTF_8));
-        }
-        log.info("Successfully produce message to cluster {} for topic {}.", cluster1, topic);
-
-        for (int i = 0; i < 10; i++) {
-            Message<byte[]> message = c.receive(10, TimeUnit.SECONDS);
-            Assert.assertNotNull(message);
-        }
-        log.info("Successfully consume message from cluster {} for topic {}.", cluster2, topic);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarGeoClusterTestBase;
+import org.awaitility.Awaitility;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+/**
+ * Geo replication test.
+ */
+@Slf4j
+public class GeoReplicationTest extends PulsarGeoClusterTestBase {
+
+    @BeforeClass(alwaysRun = true)
+    public final void setupBeforeClass() throws Exception {
+        setup();
+    }
+
+    @Override
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder[] beforeSetupCluster (
+            PulsarClusterSpec.PulsarClusterSpecBuilder... specBuilder) {
+        if (specBuilder != null) {
+            Map<String, String> brokerEnvs = new HashMap<>();
+            brokerEnvs.put("systemTopicEnabled", "false");
+            brokerEnvs.put("topicLevelPoliciesEnabled", "false");
+            for (PulsarClusterSpec.PulsarClusterSpecBuilder builder : specBuilder) {
+                builder.brokerEnvs(brokerEnvs);
+            }
+        }
+        return specBuilder;
+    }
+
+    @AfterClass(alwaysRun = true)
+    public final void tearDownAfterClass() throws Exception {
+        cleanup();
+    }
+
+    @Test(timeOut = 1000 * 30, dataProvider = "TopicDomain")
+    public void testTopicReplication(String domain) throws Exception {
+        String cluster1 = getGeoCluster().getClusters()[0].getClusterName();
+        String cluster2 = getGeoCluster().getClusters()[1].getClusterName();
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(getGeoCluster().getClusters()[0].getHttpServiceUrl())
+                .requestTimeout(30, TimeUnit.SECONDS)
+                .build();
+
+        String topic = domain + "://public/default/testTopicReplication-" + UUID.randomUUID();
+        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {
+            try {
+                admin.topics().createPartitionedTopic(topic, 10);
+            } catch (Exception e) {
+                log.error("Failed to create partitioned topic {}.", topic, e);
+                Assert.fail("Failed to create partitioned topic " + topic);
+            }
+            Assert.assertEquals(admin.topics().getPartitionedTopicMetadata(topic).partitions, 10);
+        });
+        log.info("Test geo-replication produce and consume for topic {}.", topic);
+
+        @Cleanup
+        PulsarClient client1 = PulsarClient.builder()
+                .serviceUrl(getGeoCluster().getClusters()[0].getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        PulsarClient client2 = PulsarClient.builder()
+                .serviceUrl(getGeoCluster().getClusters()[1].getPlainTextServiceUrl())
+                .build();
+
+        @Cleanup
+        Producer<byte[]> p = client1.newProducer()
+                .topic(topic)
+                .create();
+        log.info("Successfully create producer in cluster {} for topic {}.", cluster1, topic);
+
+        @Cleanup
+        Consumer<byte[]> c = client2.newConsumer()
+                .topic(topic)
+                .subscriptionName("geo-sub")
+                .subscribe();
+        log.info("Successfully create consumer in cluster {} for topic {}.", cluster2, topic);
+
+        for (int i = 0; i < 10; i++) {
+            p.send(String.format("Message [%d]", i).getBytes(StandardCharsets.UTF_8));
+        }
+        log.info("Successfully produce message to cluster {} for topic {}.", cluster1, topic);
+
+        for (int i = 0; i < 10; i++) {
+            Message<byte[]> message = c.receive(10, TimeUnit.SECONDS);
+            Assert.assertNotNull(message);
+        }
+        log.info("Successfully consume message from cluster {} for topic {}.", cluster2, topic);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingBase.java
index 390d6abee5..13b05dc108 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingBase.java
@@ -1,168 +1,168 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.AssertJUnit.assertEquals;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import java.lang.reflect.Method;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.annotations.BeforeMethod;
-
-@Slf4j
-public abstract class MessagingBase extends PulsarTestSuite {
-
-    protected String methodName;
-
-    @BeforeMethod(alwaysRun = true)
-    public void beforeMethod(Method m) throws Exception {
-        methodName = m.getName();
-    }
-
-    protected String getNonPartitionedTopic(String topicPrefix, boolean isPersistent) throws Exception {
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-
-        return generateTopicName(nsName, topicPrefix, true);
-    }
-
-    protected String getPartitionedTopic(String topicPrefix, boolean isPersistent, int partitions) throws Exception {
-        assertTrue(partitions > 0, "partitions must greater than 1");
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-
-        String topicName = generateTopicName(nsName, topicPrefix, true);
-        pulsarCluster.createPartitionedTopic(topicName, partitions);
-        return topicName;
-    }
-
-    protected <T extends Comparable<T>> void receiveMessagesCheckOrderAndDuplicate
-            (List<Consumer<T>> consumerList, int messagesToReceive) throws PulsarClientException {
-        Set<T> messagesReceived = Sets.newHashSet();
-        for (Consumer<T> consumer : consumerList) {
-            Message<T> currentReceived;
-            Map<String, Message<T>> lastReceivedMap = new HashMap<>();
-            while (true) {
-                try {
-                    currentReceived = consumer.receive(3, TimeUnit.SECONDS);
-                } catch (PulsarClientException e) {
-                    log.info("no more messages to receive for consumer {}", consumer.getConsumerName());
-                    break;
-                }
-                // Make sure that messages are received in order
-                if (currentReceived != null) {
-                    consumer.acknowledge(currentReceived);
-                    if (lastReceivedMap.containsKey(currentReceived.getTopicName())) {
-                        assertTrue(currentReceived.getMessageId().compareTo(
-                                lastReceivedMap.get(currentReceived.getTopicName()).getMessageId()) > 0,
-                                "Received messages are not in order.");
-                    }
-                } else {
-                    break;
-                }
-                lastReceivedMap.put(currentReceived.getTopicName(), currentReceived);
-                // Make sure that there are no duplicates
-                assertTrue(messagesReceived.add(currentReceived.getValue()),
-                        "Received duplicate message " + currentReceived.getValue());
-            }
-        }
-        assertEquals(messagesToReceive, messagesReceived.size());
-    }
-
-    protected <T> void receiveMessagesCheckDuplicate
-            (List<Consumer<T>> consumerList, int messagesToReceive) throws PulsarClientException {
-        Set<T> messagesReceived = Sets.newHashSet();
-        for (Consumer<T> consumer : consumerList) {
-            Message<T> currentReceived = null;
-            while (true) {
-                try {
-                    currentReceived = consumer.receive(3, TimeUnit.SECONDS);
-                } catch (PulsarClientException e) {
-                    log.info("no more messages to receive for consumer {}", consumer.getConsumerName());
-                    break;
-                }
-                if (currentReceived != null) {
-                    consumer.acknowledge(currentReceived);
-                    // Make sure that there are no duplicates
-                    assertTrue(messagesReceived.add(currentReceived.getValue()),
-                            "Received duplicate message " + currentReceived.getValue());
-                } else {
-                    break;
-                }
-            }
-        }
-        assertEquals(messagesReceived.size(), messagesToReceive);
-    }
-
-    protected <T> void receiveMessagesCheckStickyKeyAndDuplicate
-            (List<Consumer<T>> consumerList, int messagesToReceive) throws PulsarClientException {
-        Map<String, Set<String>> consumerKeys = Maps.newHashMap();
-        Set<T> messagesReceived = Sets.newHashSet();
-        for (Consumer<T> consumer : consumerList) {
-            Message<T> currentReceived;
-            while (true) {
-                try {
-                    currentReceived = consumer.receive(3, TimeUnit.SECONDS);
-                } catch (PulsarClientException e) {
-                    log.info("no more messages to receive for consumer {}", consumer.getConsumerName());
-                    break;
-                }
-                if (currentReceived != null) {
-                    consumer.acknowledge(currentReceived);
-                    assertNotNull(currentReceived.getKey());
-                    consumerKeys.putIfAbsent(consumer.getConsumerName(), Sets.newHashSet());
-                    consumerKeys.get(consumer.getConsumerName()).add(currentReceived.getKey());
-                    // Make sure that there are no duplicates
-                    assertTrue(messagesReceived.add(currentReceived.getValue()),
-                            "Received duplicate message " + currentReceived.getValue());
-                } else {
-                    break;
-                }
-            }
-        }
-        // Make sure key will not be distributed to multiple consumers (except null key)
-        Set<String> allKeys = Sets.newHashSet();
-        consumerKeys.forEach((k, v) -> v.stream().filter(Objects::nonNull).forEach(key -> {
-            assertTrue(allKeys.add(key),
-                    "Key " + key + " is distributed to multiple consumers");
-        }));
-        assertEquals(messagesReceived.size(), messagesToReceive);
-    }
-
-    protected <T> void closeConsumers(List<Consumer<T>> consumerList) throws PulsarClientException {
-        Iterator<Consumer<T>> iterator = consumerList.iterator();
-        while (iterator.hasNext()) {
-            iterator.next().close();
-            iterator.remove();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.AssertJUnit.assertEquals;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.annotations.BeforeMethod;
+
+@Slf4j
+public abstract class MessagingBase extends PulsarTestSuite {
+
+    protected String methodName;
+
+    @BeforeMethod(alwaysRun = true)
+    public void beforeMethod(Method m) throws Exception {
+        methodName = m.getName();
+    }
+
+    protected String getNonPartitionedTopic(String topicPrefix, boolean isPersistent) throws Exception {
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+
+        return generateTopicName(nsName, topicPrefix, true);
+    }
+
+    protected String getPartitionedTopic(String topicPrefix, boolean isPersistent, int partitions) throws Exception {
+        assertTrue(partitions > 0, "partitions must greater than 1");
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+
+        String topicName = generateTopicName(nsName, topicPrefix, true);
+        pulsarCluster.createPartitionedTopic(topicName, partitions);
+        return topicName;
+    }
+
+    protected <T extends Comparable<T>> void receiveMessagesCheckOrderAndDuplicate
+            (List<Consumer<T>> consumerList, int messagesToReceive) throws PulsarClientException {
+        Set<T> messagesReceived = Sets.newHashSet();
+        for (Consumer<T> consumer : consumerList) {
+            Message<T> currentReceived;
+            Map<String, Message<T>> lastReceivedMap = new HashMap<>();
+            while (true) {
+                try {
+                    currentReceived = consumer.receive(3, TimeUnit.SECONDS);
+                } catch (PulsarClientException e) {
+                    log.info("no more messages to receive for consumer {}", consumer.getConsumerName());
+                    break;
+                }
+                // Make sure that messages are received in order
+                if (currentReceived != null) {
+                    consumer.acknowledge(currentReceived);
+                    if (lastReceivedMap.containsKey(currentReceived.getTopicName())) {
+                        assertTrue(currentReceived.getMessageId().compareTo(
+                                lastReceivedMap.get(currentReceived.getTopicName()).getMessageId()) > 0,
+                                "Received messages are not in order.");
+                    }
+                } else {
+                    break;
+                }
+                lastReceivedMap.put(currentReceived.getTopicName(), currentReceived);
+                // Make sure that there are no duplicates
+                assertTrue(messagesReceived.add(currentReceived.getValue()),
+                        "Received duplicate message " + currentReceived.getValue());
+            }
+        }
+        assertEquals(messagesToReceive, messagesReceived.size());
+    }
+
+    protected <T> void receiveMessagesCheckDuplicate
+            (List<Consumer<T>> consumerList, int messagesToReceive) throws PulsarClientException {
+        Set<T> messagesReceived = Sets.newHashSet();
+        for (Consumer<T> consumer : consumerList) {
+            Message<T> currentReceived = null;
+            while (true) {
+                try {
+                    currentReceived = consumer.receive(3, TimeUnit.SECONDS);
+                } catch (PulsarClientException e) {
+                    log.info("no more messages to receive for consumer {}", consumer.getConsumerName());
+                    break;
+                }
+                if (currentReceived != null) {
+                    consumer.acknowledge(currentReceived);
+                    // Make sure that there are no duplicates
+                    assertTrue(messagesReceived.add(currentReceived.getValue()),
+                            "Received duplicate message " + currentReceived.getValue());
+                } else {
+                    break;
+                }
+            }
+        }
+        assertEquals(messagesReceived.size(), messagesToReceive);
+    }
+
+    protected <T> void receiveMessagesCheckStickyKeyAndDuplicate
+            (List<Consumer<T>> consumerList, int messagesToReceive) throws PulsarClientException {
+        Map<String, Set<String>> consumerKeys = Maps.newHashMap();
+        Set<T> messagesReceived = Sets.newHashSet();
+        for (Consumer<T> consumer : consumerList) {
+            Message<T> currentReceived;
+            while (true) {
+                try {
+                    currentReceived = consumer.receive(3, TimeUnit.SECONDS);
+                } catch (PulsarClientException e) {
+                    log.info("no more messages to receive for consumer {}", consumer.getConsumerName());
+                    break;
+                }
+                if (currentReceived != null) {
+                    consumer.acknowledge(currentReceived);
+                    assertNotNull(currentReceived.getKey());
+                    consumerKeys.putIfAbsent(consumer.getConsumerName(), Sets.newHashSet());
+                    consumerKeys.get(consumer.getConsumerName()).add(currentReceived.getKey());
+                    // Make sure that there are no duplicates
+                    assertTrue(messagesReceived.add(currentReceived.getValue()),
+                            "Received duplicate message " + currentReceived.getValue());
+                } else {
+                    break;
+                }
+            }
+        }
+        // Make sure key will not be distributed to multiple consumers (except null key)
+        Set<String> allKeys = Sets.newHashSet();
+        consumerKeys.forEach((k, v) -> v.stream().filter(Objects::nonNull).forEach(key -> {
+            assertTrue(allKeys.add(key),
+                    "Key " + key + " is distributed to multiple consumers");
+        }));
+        assertEquals(messagesReceived.size(), messagesToReceive);
+    }
+
+    protected <T> void closeConsumers(List<Consumer<T>> consumerList) throws PulsarClientException {
+        Iterator<Consumer<T>> iterator = consumerList.iterator();
+        while (iterator.hasNext()) {
+            iterator.next().close();
+            iterator.remove();
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingSmokeTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingSmokeTest.java
index 618053ac00..4724c56a97 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingSmokeTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/MessagingSmokeTest.java
@@ -1,107 +1,107 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
-import org.apache.pulsar.broker.loadbalance.extensions.ExtensibleLoadManagerImpl;
-import org.apache.pulsar.broker.loadbalance.extensions.scheduler.TransferShedder;
-import org.apache.pulsar.common.naming.TopicDomain;
-import org.testng.ITest;
-import org.testng.annotations.Factory;
-import org.testng.annotations.Test;
-
-public class MessagingSmokeTest extends TopicMessagingBase implements ITest {
-
-    @Factory
-    public static Object[] messagingTests() {
-        List<?> tests = List.of(
-                new MessagingSmokeTest("Extensible Load Manager",
-                        Map.of("loadManagerClassName", ExtensibleLoadManagerImpl.class.getName(),
-                                "loadBalancerLoadSheddingStrategy", TransferShedder.class.getName())),
-                new MessagingSmokeTest("Extensible Load Manager with TX Coordinator",
-                        Map.of("loadManagerClassName", ExtensibleLoadManagerImpl.class.getName(),
-                                "loadBalancerLoadSheddingStrategy", TransferShedder.class.getName(),
-                                "transactionCoordinatorEnabled", "true"))
-        );
-        return tests.toArray();
-    }
-
-    private final String name;
-
-    public MessagingSmokeTest(String name, Map<String, String> brokerEnvs) {
-        super();
-        this.brokerEnvs.putAll(brokerEnvs);
-        this.name = name;
-    }
-
-    @Override
-    public String getTestName() {
-        return name;
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testNonPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        nonPartitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        partitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testNonPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        nonPartitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        partitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testNonPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        nonPartitionedTopicSendAndReceiveWithShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        partitionedTopicSendAndReceiveWithShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testNonPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        nonPartitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-
-    @Test(dataProvider = "serviceUrlAndTopicDomain")
-    public void testPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
-            throws Exception {
-        partitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+import org.apache.pulsar.broker.loadbalance.extensions.ExtensibleLoadManagerImpl;
+import org.apache.pulsar.broker.loadbalance.extensions.scheduler.TransferShedder;
+import org.apache.pulsar.common.naming.TopicDomain;
+import org.testng.ITest;
+import org.testng.annotations.Factory;
+import org.testng.annotations.Test;
+
+public class MessagingSmokeTest extends TopicMessagingBase implements ITest {
+
+    @Factory
+    public static Object[] messagingTests() {
+        List<?> tests = List.of(
+                new MessagingSmokeTest("Extensible Load Manager",
+                        Map.of("loadManagerClassName", ExtensibleLoadManagerImpl.class.getName(),
+                                "loadBalancerLoadSheddingStrategy", TransferShedder.class.getName())),
+                new MessagingSmokeTest("Extensible Load Manager with TX Coordinator",
+                        Map.of("loadManagerClassName", ExtensibleLoadManagerImpl.class.getName(),
+                                "loadBalancerLoadSheddingStrategy", TransferShedder.class.getName(),
+                                "transactionCoordinatorEnabled", "true"))
+        );
+        return tests.toArray();
+    }
+
+    private final String name;
+
+    public MessagingSmokeTest(String name, Map<String, String> brokerEnvs) {
+        super();
+        this.brokerEnvs.putAll(brokerEnvs);
+        this.name = name;
+    }
+
+    @Override
+    public String getTestName() {
+        return name;
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testNonPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        nonPartitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        partitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testNonPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        nonPartitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        partitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testNonPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        nonPartitionedTopicSendAndReceiveWithShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        partitionedTopicSendAndReceiveWithShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testNonPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        nonPartitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+
+    @Test(dataProvider = "serviceUrlAndTopicDomain")
+    public void testPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl, TopicDomain topicDomain)
+            throws Exception {
+        partitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), TopicDomain.persistent.equals(topicDomain));
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonDurableConsumerMessagingTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonDurableConsumerMessagingTest.java
index e7eff6a2d2..fc954d3fba 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonDurableConsumerMessagingTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonDurableConsumerMessagingTest.java
@@ -1,70 +1,70 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
-import java.util.function.Supplier;
-import java.util.stream.IntStream;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionMode;
-import org.testng.annotations.Test;
-
-public class NonDurableConsumerMessagingTest extends MessagingBase {
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonDurableConsumer(Supplier<String> serviceUrl) throws Exception {
-        final String topicName = getNonPartitionedTopic("test-non-durable-consumer", false);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build();
-
-        int numMessages = 20;
-
-        try (final Producer<byte[]> producer = client.newProducer()
-            .topic(topicName)
-            .create()) {
-
-            IntStream.range(0, numMessages).forEach(i -> {
-                String payload = "message-" + i;
-                producer.sendAsync(payload.getBytes(UTF_8));
-            });
-            // flush the producer to make sure all messages are persisted
-            producer.flush();
-
-            try (final Consumer<byte[]> consumer = client.newConsumer()
-                .topic(topicName)
-                .subscriptionName("non-durable-consumer")
-                .subscriptionMode(SubscriptionMode.NonDurable)
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscribe()) {
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<byte[]> msg = consumer.receive();
-                    assertEquals(new String(msg.getValue(), UTF_8), "message-" + i);
-                }
-            }
-        }
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
+import java.util.function.Supplier;
+import java.util.stream.IntStream;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionMode;
+import org.testng.annotations.Test;
+
+public class NonDurableConsumerMessagingTest extends MessagingBase {
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonDurableConsumer(Supplier<String> serviceUrl) throws Exception {
+        final String topicName = getNonPartitionedTopic("test-non-durable-consumer", false);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build();
+
+        int numMessages = 20;
+
+        try (final Producer<byte[]> producer = client.newProducer()
+            .topic(topicName)
+            .create()) {
+
+            IntStream.range(0, numMessages).forEach(i -> {
+                String payload = "message-" + i;
+                producer.sendAsync(payload.getBytes(UTF_8));
+            });
+            // flush the producer to make sure all messages are persisted
+            producer.flush();
+
+            try (final Consumer<byte[]> consumer = client.newConsumer()
+                .topic(topicName)
+                .subscriptionName("non-durable-consumer")
+                .subscriptionMode(SubscriptionMode.NonDurable)
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscribe()) {
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<byte[]> msg = consumer.receive();
+                    assertEquals(new String(msg.getValue(), UTF_8), "message-" + i);
+                }
+            }
+        }
+
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonPersistentTopicMessagingTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonPersistentTopicMessagingTest.java
index 0b379af395..f78d41705c 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonPersistentTopicMessagingTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/NonPersistentTopicMessagingTest.java
@@ -1,67 +1,67 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class NonPersistentTopicMessagingTest extends TopicMessagingBase {
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithShared(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithShared(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), false);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), false);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class NonPersistentTopicMessagingTest extends TopicMessagingBase {
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithShared(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithShared(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), false);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), false);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/PersistentTopicMessagingTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/PersistentTopicMessagingTest.java
index 5675aa88ec..03c9688063 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/PersistentTopicMessagingTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/PersistentTopicMessagingTest.java
@@ -1,68 +1,68 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class PersistentTopicMessagingTest extends TopicMessagingBase {
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithShared(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithShared(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testNonPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
-        nonPartitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), true);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
-        partitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), true);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class PersistentTopicMessagingTest extends TopicMessagingBase {
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithExclusive(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithExclusive(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithFailover(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithFailover(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithShared(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithShared(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithShared(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testNonPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
+        nonPartitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), true);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testPartitionedTopicMessagingWithKeyShared(Supplier<String> serviceUrl) throws Exception {
+        partitionedTopicSendAndReceiveWithKeyShared(serviceUrl.get(), true);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/ReaderMessagingTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/ReaderMessagingTest.java
index 4bfd964e98..7e93c17c45 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/ReaderMessagingTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/ReaderMessagingTest.java
@@ -1,142 +1,142 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Reader;
-import org.apache.pulsar.client.api.Schema;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class ReaderMessagingTest extends MessagingBase {
-
-    @Test(dataProvider = "ServiceAndAdminUrls")
-    public void testReaderReconnectAndRead(Supplier<String> serviceUrl, Supplier<String> adminUrl) throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final String topicName = getNonPartitionedTopic("test-reader-reconnect-read", false);
-        @Cleanup final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl.get())
-                .build();
-        @Cleanup final Reader<String> reader = client.newReader(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                // Here we need to make sure that setting the startMessageId should not cause a change in the
-                // behavior of the reader under non.
-                .startMessageId(MessageId.earliest)
-                .create();
-
-        final int messagesToSend = 10;
-        @Cleanup final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value("message-" + i).send();
-            assertNotNull(messageId);
-        }
-
-        for (int i = 0; i < messagesToSend; i++) {
-            Message<String> msg = reader.readNext();
-            assertEquals(msg.getValue(), "message-" + i);
-        }
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(adminUrl.get())
-                .build();
-
-        admin.topics().unload(topicName);
-
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value("message-" + i).send();
-            assertNotNull(messageId);
-        }
-
-        for (int i = 0; i < messagesToSend; i++) {
-            Message<String> msg = reader.readNext();
-            assertEquals(msg.getValue(), "message-" + i);
-        }
-
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    @Test(dataProvider = "ServiceAndAdminUrls")
-    public void testReaderReconnectAndReadBatchMessages(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final String topicName = getNonPartitionedTopic("test-reader-reconnect-read-batch", false);
-        @Cleanup final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl.get())
-                .build();
-        @Cleanup final Reader<String> reader = client.newReader(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                // Here we need to make sure that setting the startMessageId should not cause a change in the
-                // behavior of the reader under non.
-                .startMessageId(MessageId.earliest)
-                .create();
-
-        final int messagesToSend = 10;
-        @Cleanup final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(true)
-                .batchingMaxPublishDelay(5, TimeUnit.SECONDS)
-                .batchingMaxMessages(5)
-                .create();
-
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value("message-" + i).send();
-            assertNotNull(messageId);
-        }
-
-        for (int i = 0; i < messagesToSend; i++) {
-            Message<String> msg = reader.readNext();
-            assertEquals(msg.getValue(), "message-" + i);
-        }
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(adminUrl.get())
-                .build();
-
-        admin.topics().unload(topicName);
-
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value("message-" + i).send();
-            assertNotNull(messageId);
-        }
-
-        for (int i = 0; i < messagesToSend; i++) {
-            Message<String> msg = reader.readNext();
-            assertEquals(msg.getValue(), "message-" + i);
-        }
-
-        log.info("-- Exiting {} test --", methodName);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Reader;
+import org.apache.pulsar.client.api.Schema;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class ReaderMessagingTest extends MessagingBase {
+
+    @Test(dataProvider = "ServiceAndAdminUrls")
+    public void testReaderReconnectAndRead(Supplier<String> serviceUrl, Supplier<String> adminUrl) throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final String topicName = getNonPartitionedTopic("test-reader-reconnect-read", false);
+        @Cleanup final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl.get())
+                .build();
+        @Cleanup final Reader<String> reader = client.newReader(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                // Here we need to make sure that setting the startMessageId should not cause a change in the
+                // behavior of the reader under non.
+                .startMessageId(MessageId.earliest)
+                .create();
+
+        final int messagesToSend = 10;
+        @Cleanup final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value("message-" + i).send();
+            assertNotNull(messageId);
+        }
+
+        for (int i = 0; i < messagesToSend; i++) {
+            Message<String> msg = reader.readNext();
+            assertEquals(msg.getValue(), "message-" + i);
+        }
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(adminUrl.get())
+                .build();
+
+        admin.topics().unload(topicName);
+
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value("message-" + i).send();
+            assertNotNull(messageId);
+        }
+
+        for (int i = 0; i < messagesToSend; i++) {
+            Message<String> msg = reader.readNext();
+            assertEquals(msg.getValue(), "message-" + i);
+        }
+
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    @Test(dataProvider = "ServiceAndAdminUrls")
+    public void testReaderReconnectAndReadBatchMessages(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final String topicName = getNonPartitionedTopic("test-reader-reconnect-read-batch", false);
+        @Cleanup final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl.get())
+                .build();
+        @Cleanup final Reader<String> reader = client.newReader(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                // Here we need to make sure that setting the startMessageId should not cause a change in the
+                // behavior of the reader under non.
+                .startMessageId(MessageId.earliest)
+                .create();
+
+        final int messagesToSend = 10;
+        @Cleanup final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(true)
+                .batchingMaxPublishDelay(5, TimeUnit.SECONDS)
+                .batchingMaxMessages(5)
+                .create();
+
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value("message-" + i).send();
+            assertNotNull(messageId);
+        }
+
+        for (int i = 0; i < messagesToSend; i++) {
+            Message<String> msg = reader.readNext();
+            assertEquals(msg.getValue(), "message-" + i);
+        }
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(adminUrl.get())
+                .build();
+
+        admin.topics().unload(topicName);
+
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value("message-" + i).send();
+            assertNotNull(messageId);
+        }
+
+        for (int i = 0; i < messagesToSend; i++) {
+            Message<String> msg = reader.readNext();
+            assertEquals(msg.getValue(), "message-" + i);
+        }
+
+        log.info("-- Exiting {} test --", methodName);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/TopicMessagingBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/TopicMessagingBase.java
index f932244feb..a3e94f39af 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/TopicMessagingBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/messaging/TopicMessagingBase.java
@@ -1,448 +1,448 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.messaging;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.UUID;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.MessageRoutingMode;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-
-@Slf4j
-public class TopicMessagingBase extends MessagingBase {
-
-    protected void nonPartitionedTopicSendAndReceiveWithExclusive(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-exclusive", isPersistent);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        @Cleanup
-        final Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-        try {
-            client.newConsumer(Schema.STRING)
-                    .topic(topicName)
-                    .subscriptionName("test-sub")
-                    .subscriptionType(SubscriptionType.Exclusive)
-                    .subscribe();
-            fail("should be failed");
-        } catch (PulsarClientException ignore) {
-        }
-        final int messagesToSend = 10;
-        final String producerName = "producerForExclusive";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        log.info("public messages complete.");
-        receiveMessagesCheckOrderAndDuplicate(Collections.singletonList(consumer), messagesToSend);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void partitionedTopicSendAndReceiveWithExclusive(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final int partitions = 3;
-        String topicName = getPartitionedTopic("test-partitioned-consume-exclusive", isPersistent, partitions);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(3);
-        for (int i = 0; i < partitions; i++) {
-            Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                    .topic(topicName + "-partition-" + i)
-                    .subscriptionName("test-sub")
-                    .subscriptionType(SubscriptionType.Exclusive)
-                    .subscribe();
-            consumerList.add(consumer);
-        }
-        assertEquals(partitions, consumerList.size());
-        try {
-            client.newConsumer(Schema.STRING)
-                    .topic(topicName + "-partition-" + 0)
-                    .subscriptionName("test-sub")
-                    .subscriptionType(SubscriptionType.Exclusive)
-                    .subscribe();
-            fail("should be failed");
-        } catch (PulsarClientException ignore) {
-        }
-        final int messagesToSend = 9;
-        final String producerName = "producerForExclusive";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .messageRoutingMode(MessageRoutingMode.RoundRobinPartition)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        log.info("public messages complete.");
-        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend - 3);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void nonPartitionedTopicSendAndReceiveWithFailover(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-failover", isPersistent);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(2);
-        final Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Failover)
-                .subscribe();
-        consumerList.add(consumer);
-        final Consumer<String> standbyConsumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Failover)
-                .subscribe();
-        assertNotNull(standbyConsumer);
-        assertTrue(standbyConsumer.isConnected());
-        consumerList.add(standbyConsumer);
-        final int messagesToSend = 10;
-        final String producerName = "producerForFailover";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        log.info("public messages complete.");
-        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        // wait ack send
-        Thread.sleep(3000);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-                MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-                assertNotNull(messageId);
-        }
-        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void partitionedTopicSendAndReceiveWithFailover(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final int partitions = 3;
-        String topicName = getPartitionedTopic("test-partitioned-consume-failover", isPersistent, partitions);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(3);
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Failover)
-                .subscribe();
-        consumerList.add(consumer);
-        Consumer<String> standbyConsumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Failover)
-                .subscribe();
-        assertNotNull(standbyConsumer);
-        assertTrue(standbyConsumer.isConnected());
-        consumerList.add(standbyConsumer);
-        assertEquals(consumerList.size(), 2);
-        final int messagesToSend = 9;
-        final String producerName = "producerForFailover";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        log.info("public messages complete.");
-        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        // wait ack send
-        Thread.sleep(3000);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void nonPartitionedTopicSendAndReceiveWithShared(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-shared", isPersistent);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(2);
-        final Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Shared)
-                .subscribe();
-        consumerList.add(consumer);
-        Consumer<String> moreConsumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Shared)
-                .subscribe();
-        assertNotNull(moreConsumer);
-        assertTrue(moreConsumer.isConnected());
-        consumerList.add(moreConsumer);
-        final int messagesToSend = 10;
-        final String producerName = "producerForShared";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        log.info("public messages complete.");
-        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void partitionedTopicSendAndReceiveWithShared(String serviceUrl, boolean isPersistent) throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final int partitions = 3;
-        String topicName = getPartitionedTopic("test-partitioned-consume-shared", isPersistent, partitions);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(3);
-        for (int i = 0; i < partitions; i++) {
-            Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                    .topic(topicName)
-                    .subscriptionName("test-sub")
-                    .subscriptionType(SubscriptionType.Shared)
-                    .subscribe();
-            consumerList.add(consumer);
-        }
-        assertEquals(partitions, consumerList.size());
-        final int messagesToSend = 10;
-        final String producerName = "producerForFailover";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        log.info("public messages complete.");
-        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
-            assertNotNull(messageId);
-        }
-        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void nonPartitionedTopicSendAndReceiveWithKeyShared(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-key-shared", isPersistent);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(2);
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Key_Shared)
-                .subscribe();
-        assertTrue(consumer.isConnected());
-        consumerList.add(consumer);
-        Consumer<String> moreConsumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Key_Shared)
-                .subscribe();
-        assertNotNull(moreConsumer);
-        assertTrue(moreConsumer.isConnected());
-        consumerList.add(moreConsumer);
-        final int messagesToSend = 10;
-        final String producerName = "producerForKeyShared";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage()
-                    .key(UUID.randomUUID().toString())
-                    .value(producer.getProducerName() + "-" + i)
-                    .send();
-            assertNotNull(messageId);
-        }
-        log.info("publish messages complete.");
-        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage()
-                    .key(UUID.randomUUID().toString())
-                    .value(producer.getProducerName() + "-" + i)
-                    .send();
-            assertNotNull(messageId);
-        }
-        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-    protected void partitionedTopicSendAndReceiveWithKeyShared(String serviceUrl, boolean isPersistent)
-            throws Exception {
-        log.info("-- Starting {} test --", methodName);
-        final int partitions = 3;
-        String topicName = getPartitionedTopic("test-partitioned-consume-key-shared", isPersistent, partitions);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        List<Consumer<String>> consumerList = new ArrayList<>(2);
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Key_Shared)
-                .subscribe();
-        assertTrue(consumer.isConnected());
-        consumerList.add(consumer);
-        Consumer<String> moreConsumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscriptionType(SubscriptionType.Key_Shared)
-                .subscribe();
-        assertNotNull(moreConsumer);
-        assertTrue(moreConsumer.isConnected());
-        consumerList.add(moreConsumer);
-        final int messagesToSend = 10;
-        final String producerName = "producerForKeyShared";
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName(producerName)
-                .create();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage()
-                    .key(UUID.randomUUID().toString())
-                    .value(producer.getProducerName() + "-" + i)
-                    .send();
-            assertNotNull(messageId);
-        }
-        log.info("publish messages complete.");
-        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
-        // To simulate a consumer crashed
-        Consumer<String> crashedConsumer = consumerList.remove(0);
-        crashedConsumer.close();
-        for (int i = 0; i < messagesToSend; i++) {
-            MessageId messageId = producer.newMessage()
-                    .key(UUID.randomUUID().toString())
-                    .value(producer.getProducerName() + "-" + i)
-                    .send();
-            assertNotNull(messageId);
-        }
-        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
-        closeConsumers(consumerList);
-        log.info("-- Exiting {} test --", methodName);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.messaging;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.UUID;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.MessageRoutingMode;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+
+@Slf4j
+public class TopicMessagingBase extends MessagingBase {
+
+    protected void nonPartitionedTopicSendAndReceiveWithExclusive(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-exclusive", isPersistent);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        @Cleanup
+        final Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+        try {
+            client.newConsumer(Schema.STRING)
+                    .topic(topicName)
+                    .subscriptionName("test-sub")
+                    .subscriptionType(SubscriptionType.Exclusive)
+                    .subscribe();
+            fail("should be failed");
+        } catch (PulsarClientException ignore) {
+        }
+        final int messagesToSend = 10;
+        final String producerName = "producerForExclusive";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        log.info("public messages complete.");
+        receiveMessagesCheckOrderAndDuplicate(Collections.singletonList(consumer), messagesToSend);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void partitionedTopicSendAndReceiveWithExclusive(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final int partitions = 3;
+        String topicName = getPartitionedTopic("test-partitioned-consume-exclusive", isPersistent, partitions);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(3);
+        for (int i = 0; i < partitions; i++) {
+            Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                    .topic(topicName + "-partition-" + i)
+                    .subscriptionName("test-sub")
+                    .subscriptionType(SubscriptionType.Exclusive)
+                    .subscribe();
+            consumerList.add(consumer);
+        }
+        assertEquals(partitions, consumerList.size());
+        try {
+            client.newConsumer(Schema.STRING)
+                    .topic(topicName + "-partition-" + 0)
+                    .subscriptionName("test-sub")
+                    .subscriptionType(SubscriptionType.Exclusive)
+                    .subscribe();
+            fail("should be failed");
+        } catch (PulsarClientException ignore) {
+        }
+        final int messagesToSend = 9;
+        final String producerName = "producerForExclusive";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .messageRoutingMode(MessageRoutingMode.RoundRobinPartition)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        log.info("public messages complete.");
+        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend - 3);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void nonPartitionedTopicSendAndReceiveWithFailover(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-failover", isPersistent);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(2);
+        final Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Failover)
+                .subscribe();
+        consumerList.add(consumer);
+        final Consumer<String> standbyConsumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Failover)
+                .subscribe();
+        assertNotNull(standbyConsumer);
+        assertTrue(standbyConsumer.isConnected());
+        consumerList.add(standbyConsumer);
+        final int messagesToSend = 10;
+        final String producerName = "producerForFailover";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        log.info("public messages complete.");
+        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        // wait ack send
+        Thread.sleep(3000);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+                MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+                assertNotNull(messageId);
+        }
+        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void partitionedTopicSendAndReceiveWithFailover(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final int partitions = 3;
+        String topicName = getPartitionedTopic("test-partitioned-consume-failover", isPersistent, partitions);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(3);
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Failover)
+                .subscribe();
+        consumerList.add(consumer);
+        Consumer<String> standbyConsumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Failover)
+                .subscribe();
+        assertNotNull(standbyConsumer);
+        assertTrue(standbyConsumer.isConnected());
+        consumerList.add(standbyConsumer);
+        assertEquals(consumerList.size(), 2);
+        final int messagesToSend = 9;
+        final String producerName = "producerForFailover";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        log.info("public messages complete.");
+        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        // wait ack send
+        Thread.sleep(3000);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        receiveMessagesCheckOrderAndDuplicate(consumerList, messagesToSend);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void nonPartitionedTopicSendAndReceiveWithShared(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-shared", isPersistent);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(2);
+        final Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Shared)
+                .subscribe();
+        consumerList.add(consumer);
+        Consumer<String> moreConsumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Shared)
+                .subscribe();
+        assertNotNull(moreConsumer);
+        assertTrue(moreConsumer.isConnected());
+        consumerList.add(moreConsumer);
+        final int messagesToSend = 10;
+        final String producerName = "producerForShared";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        log.info("public messages complete.");
+        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void partitionedTopicSendAndReceiveWithShared(String serviceUrl, boolean isPersistent) throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final int partitions = 3;
+        String topicName = getPartitionedTopic("test-partitioned-consume-shared", isPersistent, partitions);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(3);
+        for (int i = 0; i < partitions; i++) {
+            Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                    .topic(topicName)
+                    .subscriptionName("test-sub")
+                    .subscriptionType(SubscriptionType.Shared)
+                    .subscribe();
+            consumerList.add(consumer);
+        }
+        assertEquals(partitions, consumerList.size());
+        final int messagesToSend = 10;
+        final String producerName = "producerForFailover";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        log.info("public messages complete.");
+        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage().value(producer.getProducerName() + "-" + i).send();
+            assertNotNull(messageId);
+        }
+        receiveMessagesCheckDuplicate(consumerList, messagesToSend);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void nonPartitionedTopicSendAndReceiveWithKeyShared(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final String topicName = getNonPartitionedTopic("test-non-partitioned-consume-key-shared", isPersistent);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(2);
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Key_Shared)
+                .subscribe();
+        assertTrue(consumer.isConnected());
+        consumerList.add(consumer);
+        Consumer<String> moreConsumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Key_Shared)
+                .subscribe();
+        assertNotNull(moreConsumer);
+        assertTrue(moreConsumer.isConnected());
+        consumerList.add(moreConsumer);
+        final int messagesToSend = 10;
+        final String producerName = "producerForKeyShared";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage()
+                    .key(UUID.randomUUID().toString())
+                    .value(producer.getProducerName() + "-" + i)
+                    .send();
+            assertNotNull(messageId);
+        }
+        log.info("publish messages complete.");
+        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage()
+                    .key(UUID.randomUUID().toString())
+                    .value(producer.getProducerName() + "-" + i)
+                    .send();
+            assertNotNull(messageId);
+        }
+        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+    protected void partitionedTopicSendAndReceiveWithKeyShared(String serviceUrl, boolean isPersistent)
+            throws Exception {
+        log.info("-- Starting {} test --", methodName);
+        final int partitions = 3;
+        String topicName = getPartitionedTopic("test-partitioned-consume-key-shared", isPersistent, partitions);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        List<Consumer<String>> consumerList = new ArrayList<>(2);
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Key_Shared)
+                .subscribe();
+        assertTrue(consumer.isConnected());
+        consumerList.add(consumer);
+        Consumer<String> moreConsumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscriptionType(SubscriptionType.Key_Shared)
+                .subscribe();
+        assertNotNull(moreConsumer);
+        assertTrue(moreConsumer.isConnected());
+        consumerList.add(moreConsumer);
+        final int messagesToSend = 10;
+        final String producerName = "producerForKeyShared";
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName(producerName)
+                .create();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage()
+                    .key(UUID.randomUUID().toString())
+                    .value(producer.getProducerName() + "-" + i)
+                    .send();
+            assertNotNull(messageId);
+        }
+        log.info("publish messages complete.");
+        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
+        // To simulate a consumer crashed
+        Consumer<String> crashedConsumer = consumerList.remove(0);
+        crashedConsumer.close();
+        for (int i = 0; i < messagesToSend; i++) {
+            MessageId messageId = producer.newMessage()
+                    .key(UUID.randomUUID().toString())
+                    .value(producer.getProducerName() + "-" + i)
+                    .send();
+            assertNotNull(messageId);
+        }
+        receiveMessagesCheckStickyKeyAndDuplicate(consumerList, messagesToSend);
+        closeConsumers(consumerList);
+        log.info("-- Exiting {} test --", methodName);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/metrics/OpenTelemetrySanityTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/metrics/OpenTelemetrySanityTest.java
index 4e6847d172..a569cb22d3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/metrics/OpenTelemetrySanityTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/metrics/OpenTelemetrySanityTest.java
@@ -1,171 +1,171 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.metrics;
-
-import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
-import static org.awaitility.Awaitility.waitAtMost;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.commons.lang3.tuple.Pair;
-import org.apache.pulsar.PulsarVersion;
-import org.apache.pulsar.broker.stats.PulsarBrokerOpenTelemetry;
-import org.apache.pulsar.broker.stats.prometheus.PrometheusMetricsClient;
-import org.apache.pulsar.functions.worker.PulsarWorkerOpenTelemetry;
-import org.apache.pulsar.proxy.stats.PulsarProxyOpenTelemetry;
-import org.apache.pulsar.tests.integration.containers.ChaosContainer;
-import org.apache.pulsar.tests.integration.containers.OpenTelemetryCollectorContainer;
-import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarTestBase;
-import org.testng.annotations.Test;
-
-public class OpenTelemetrySanityTest {
-
-    // Validate that the OpenTelemetry metrics can be exported to a remote OpenTelemetry collector.
-    @Test(timeOut = 360_000)
-    public void testOpenTelemetryMetricsOtlpExport() throws Exception {
-        var clusterName = "testOpenTelemetryMetrics-" + UUID.randomUUID();
-        var openTelemetryCollectorContainer = new OpenTelemetryCollectorContainer(clusterName);
-
-        var exporter = "otlp";
-        var otlpEndpointProp =
-                Pair.of("OTEL_EXPORTER_OTLP_ENDPOINT", openTelemetryCollectorContainer.getOtlpEndpoint());
-
-        var brokerCollectorProps = getOpenTelemetryProps(exporter, otlpEndpointProp);
-        var proxyCollectorProps = getOpenTelemetryProps(exporter, otlpEndpointProp);
-        var functionWorkerCollectorProps = getOpenTelemetryProps(exporter, otlpEndpointProp);
-
-        var spec = PulsarClusterSpec.builder()
-                .clusterName(clusterName)
-                .brokerEnvs(brokerCollectorProps)
-                .proxyEnvs(proxyCollectorProps)
-                .externalService("otel-collector", openTelemetryCollectorContainer)
-                .functionWorkerEnvs(functionWorkerCollectorProps)
-                .build();
-        @Cleanup("stop")
-        var pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-        pulsarCluster.setupFunctionWorkers(PulsarTestBase.randomName(), FunctionRuntimeType.PROCESS, 1);
-
-        // TODO: Validate cluster name and service version are present once
-        // https://github.com/open-telemetry/opentelemetry-java/issues/6108 is solved.
-        var metricName = "queueSize_ratio"; // Sent automatically by the OpenTelemetry SDK.
-        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).until(() -> {
-            var metrics = getMetricsFromPrometheus(
-                    openTelemetryCollectorContainer, OpenTelemetryCollectorContainer.PROMETHEUS_EXPORTER_PORT);
-            return !metrics.findByNameAndLabels(metricName, "job", PulsarBrokerOpenTelemetry.SERVICE_NAME).isEmpty();
-        });
-        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).until(() -> {
-            var metrics = getMetricsFromPrometheus(
-                    openTelemetryCollectorContainer, OpenTelemetryCollectorContainer.PROMETHEUS_EXPORTER_PORT);
-            return !metrics.findByNameAndLabels(metricName, "job", PulsarProxyOpenTelemetry.SERVICE_NAME).isEmpty();
-        });
-        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).until(() -> {
-            var metrics = getMetricsFromPrometheus(
-                    openTelemetryCollectorContainer, OpenTelemetryCollectorContainer.PROMETHEUS_EXPORTER_PORT);
-            return !metrics.findByNameAndLabels(metricName, "job", PulsarWorkerOpenTelemetry.SERVICE_NAME).isEmpty();
-        });
-    }
-
-    /*
-     * Validate that the OpenTelemetry metrics can be exported to a local Prometheus endpoint running in the same
-     * process space as the broker/proxy/function-worker.
-     * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#prometheus-exporter
-     */
-    @Test(timeOut = 360_000)
-    public void testOpenTelemetryMetricsPrometheusExport() throws Exception {
-        var prometheusExporterPort = 9464;
-        var clusterName = "testOpenTelemetryMetrics-" + UUID.randomUUID();
-
-        var exporter = "prometheus";
-        var prometheusExporterPortProp =
-                Pair.of("OTEL_EXPORTER_PROMETHEUS_PORT", Integer.toString(prometheusExporterPort));
-
-        var brokerCollectorProps = getOpenTelemetryProps(exporter, prometheusExporterPortProp);
-        var proxyCollectorProps = getOpenTelemetryProps(exporter, prometheusExporterPortProp);
-        var functionWorkerCollectorProps = getOpenTelemetryProps(exporter, prometheusExporterPortProp);
-
-        var spec = PulsarClusterSpec.builder()
-                .clusterName(clusterName)
-                .brokerEnvs(brokerCollectorProps)
-                .brokerAdditionalPorts(List.of(prometheusExporterPort))
-                .proxyEnvs(proxyCollectorProps)
-                .proxyAdditionalPorts(List.of(prometheusExporterPort))
-                .functionWorkerEnvs(functionWorkerCollectorProps)
-                .functionWorkerAdditionalPorts(List.of(prometheusExporterPort))
-                .build();
-        @Cleanup("stop")
-        var pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-        pulsarCluster.setupFunctionWorkers(PulsarTestBase.randomName(), FunctionRuntimeType.PROCESS, 1);
-
-        var targetInfoMetricName = "target_info"; // Sent automatically by the OpenTelemetry SDK.
-        var cpuCountMetricName = "jvm_cpu_count"; // Configured by the OpenTelemetryService.
-        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).untilAsserted(() -> {
-            var expectedMetrics = new String[] {targetInfoMetricName, cpuCountMetricName,
-                    "pulsar_broker_topic_producer_count"};
-            var actualMetrics = getMetricsFromPrometheus(pulsarCluster.getBroker(0), prometheusExporterPort);
-            assertThat(expectedMetrics).allMatch(expectedMetric -> !actualMetrics.findByNameAndLabels(expectedMetric,
-                    Pair.of("pulsar_cluster", clusterName),
-                    Pair.of("service_name", PulsarBrokerOpenTelemetry.SERVICE_NAME),
-                    Pair.of("service_version", PulsarVersion.getVersion()),
-                    Pair.of("host_name", pulsarCluster.getBroker(0).getHostname())).isEmpty());
-        });
-        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).untilAsserted(() -> {
-            var expectedMetrics = new String[] {targetInfoMetricName, cpuCountMetricName};
-            var actualMetrics = getMetricsFromPrometheus(pulsarCluster.getProxy(), prometheusExporterPort);
-            assertThat(expectedMetrics).allMatch(expectedMetric -> !actualMetrics.findByNameAndLabels(expectedMetric,
-                    Pair.of("pulsar_cluster", clusterName),
-                    Pair.of("service_name", PulsarProxyOpenTelemetry.SERVICE_NAME),
-                    Pair.of("service_version", PulsarVersion.getVersion()),
-                    Pair.of("host_name", pulsarCluster.getProxy().getHostname())).isEmpty());
-        });
-        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).untilAsserted(() -> {
-            var expectedMetrics = new String[] {targetInfoMetricName, cpuCountMetricName};
-            var actualMetrics = getMetricsFromPrometheus(pulsarCluster.getAnyWorker(), prometheusExporterPort);
-            assertThat(expectedMetrics).allMatch(expectedMetric -> !actualMetrics.findByNameAndLabels(expectedMetric,
-                    Pair.of("pulsar_cluster", clusterName),
-                    Pair.of("service_name", PulsarWorkerOpenTelemetry.SERVICE_NAME),
-                    Pair.of("service_version", PulsarVersion.getVersion()),
-                    Pair.of("host_name", pulsarCluster.getAnyWorker().getHostname())).isEmpty());
-        });
-    }
-
-    private static PrometheusMetricsClient.Metrics getMetricsFromPrometheus(ChaosContainer<?> container, int port) {
-        var client = new PrometheusMetricsClient(container.getHost(), container.getMappedPort(port));
-        return client.getMetrics();
-    }
-
-    private static Map<String, String> getOpenTelemetryProps(String exporter, Pair<String, String> ... extraProps) {
-        var defaultProps = Map.of(
-                "OTEL_SDK_DISABLED", "false",
-                "OTEL_METRIC_EXPORT_INTERVAL", "1000",
-                "OTEL_METRICS_EXPORTER", exporter
-        );
-        var props = new HashMap<>(defaultProps);
-        Arrays.stream(extraProps).forEach(p -> props.put(p.getKey(), p.getValue()));
-        return props;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.metrics;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
+import static org.awaitility.Awaitility.waitAtMost;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.pulsar.PulsarVersion;
+import org.apache.pulsar.broker.stats.PulsarBrokerOpenTelemetry;
+import org.apache.pulsar.broker.stats.prometheus.PrometheusMetricsClient;
+import org.apache.pulsar.functions.worker.PulsarWorkerOpenTelemetry;
+import org.apache.pulsar.proxy.stats.PulsarProxyOpenTelemetry;
+import org.apache.pulsar.tests.integration.containers.ChaosContainer;
+import org.apache.pulsar.tests.integration.containers.OpenTelemetryCollectorContainer;
+import org.apache.pulsar.tests.integration.topologies.FunctionRuntimeType;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarTestBase;
+import org.testng.annotations.Test;
+
+public class OpenTelemetrySanityTest {
+
+    // Validate that the OpenTelemetry metrics can be exported to a remote OpenTelemetry collector.
+    @Test(timeOut = 360_000)
+    public void testOpenTelemetryMetricsOtlpExport() throws Exception {
+        var clusterName = "testOpenTelemetryMetrics-" + UUID.randomUUID();
+        var openTelemetryCollectorContainer = new OpenTelemetryCollectorContainer(clusterName);
+
+        var exporter = "otlp";
+        var otlpEndpointProp =
+                Pair.of("OTEL_EXPORTER_OTLP_ENDPOINT", openTelemetryCollectorContainer.getOtlpEndpoint());
+
+        var brokerCollectorProps = getOpenTelemetryProps(exporter, otlpEndpointProp);
+        var proxyCollectorProps = getOpenTelemetryProps(exporter, otlpEndpointProp);
+        var functionWorkerCollectorProps = getOpenTelemetryProps(exporter, otlpEndpointProp);
+
+        var spec = PulsarClusterSpec.builder()
+                .clusterName(clusterName)
+                .brokerEnvs(brokerCollectorProps)
+                .proxyEnvs(proxyCollectorProps)
+                .externalService("otel-collector", openTelemetryCollectorContainer)
+                .functionWorkerEnvs(functionWorkerCollectorProps)
+                .build();
+        @Cleanup("stop")
+        var pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+        pulsarCluster.setupFunctionWorkers(PulsarTestBase.randomName(), FunctionRuntimeType.PROCESS, 1);
+
+        // TODO: Validate cluster name and service version are present once
+        // https://github.com/open-telemetry/opentelemetry-java/issues/6108 is solved.
+        var metricName = "queueSize_ratio"; // Sent automatically by the OpenTelemetry SDK.
+        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).until(() -> {
+            var metrics = getMetricsFromPrometheus(
+                    openTelemetryCollectorContainer, OpenTelemetryCollectorContainer.PROMETHEUS_EXPORTER_PORT);
+            return !metrics.findByNameAndLabels(metricName, "job", PulsarBrokerOpenTelemetry.SERVICE_NAME).isEmpty();
+        });
+        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).until(() -> {
+            var metrics = getMetricsFromPrometheus(
+                    openTelemetryCollectorContainer, OpenTelemetryCollectorContainer.PROMETHEUS_EXPORTER_PORT);
+            return !metrics.findByNameAndLabels(metricName, "job", PulsarProxyOpenTelemetry.SERVICE_NAME).isEmpty();
+        });
+        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).until(() -> {
+            var metrics = getMetricsFromPrometheus(
+                    openTelemetryCollectorContainer, OpenTelemetryCollectorContainer.PROMETHEUS_EXPORTER_PORT);
+            return !metrics.findByNameAndLabels(metricName, "job", PulsarWorkerOpenTelemetry.SERVICE_NAME).isEmpty();
+        });
+    }
+
+    /*
+     * Validate that the OpenTelemetry metrics can be exported to a local Prometheus endpoint running in the same
+     * process space as the broker/proxy/function-worker.
+     * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk-extensions/autoconfigure/README.md#prometheus-exporter
+     */
+    @Test(timeOut = 360_000)
+    public void testOpenTelemetryMetricsPrometheusExport() throws Exception {
+        var prometheusExporterPort = 9464;
+        var clusterName = "testOpenTelemetryMetrics-" + UUID.randomUUID();
+
+        var exporter = "prometheus";
+        var prometheusExporterPortProp =
+                Pair.of("OTEL_EXPORTER_PROMETHEUS_PORT", Integer.toString(prometheusExporterPort));
+
+        var brokerCollectorProps = getOpenTelemetryProps(exporter, prometheusExporterPortProp);
+        var proxyCollectorProps = getOpenTelemetryProps(exporter, prometheusExporterPortProp);
+        var functionWorkerCollectorProps = getOpenTelemetryProps(exporter, prometheusExporterPortProp);
+
+        var spec = PulsarClusterSpec.builder()
+                .clusterName(clusterName)
+                .brokerEnvs(brokerCollectorProps)
+                .brokerAdditionalPorts(List.of(prometheusExporterPort))
+                .proxyEnvs(proxyCollectorProps)
+                .proxyAdditionalPorts(List.of(prometheusExporterPort))
+                .functionWorkerEnvs(functionWorkerCollectorProps)
+                .functionWorkerAdditionalPorts(List.of(prometheusExporterPort))
+                .build();
+        @Cleanup("stop")
+        var pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+        pulsarCluster.setupFunctionWorkers(PulsarTestBase.randomName(), FunctionRuntimeType.PROCESS, 1);
+
+        var targetInfoMetricName = "target_info"; // Sent automatically by the OpenTelemetry SDK.
+        var cpuCountMetricName = "jvm_cpu_count"; // Configured by the OpenTelemetryService.
+        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).untilAsserted(() -> {
+            var expectedMetrics = new String[] {targetInfoMetricName, cpuCountMetricName,
+                    "pulsar_broker_topic_producer_count"};
+            var actualMetrics = getMetricsFromPrometheus(pulsarCluster.getBroker(0), prometheusExporterPort);
+            assertThat(expectedMetrics).allMatch(expectedMetric -> !actualMetrics.findByNameAndLabels(expectedMetric,
+                    Pair.of("pulsar_cluster", clusterName),
+                    Pair.of("service_name", PulsarBrokerOpenTelemetry.SERVICE_NAME),
+                    Pair.of("service_version", PulsarVersion.getVersion()),
+                    Pair.of("host_name", pulsarCluster.getBroker(0).getHostname())).isEmpty());
+        });
+        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).untilAsserted(() -> {
+            var expectedMetrics = new String[] {targetInfoMetricName, cpuCountMetricName};
+            var actualMetrics = getMetricsFromPrometheus(pulsarCluster.getProxy(), prometheusExporterPort);
+            assertThat(expectedMetrics).allMatch(expectedMetric -> !actualMetrics.findByNameAndLabels(expectedMetric,
+                    Pair.of("pulsar_cluster", clusterName),
+                    Pair.of("service_name", PulsarProxyOpenTelemetry.SERVICE_NAME),
+                    Pair.of("service_version", PulsarVersion.getVersion()),
+                    Pair.of("host_name", pulsarCluster.getProxy().getHostname())).isEmpty());
+        });
+        waitAtMost(90, TimeUnit.SECONDS).ignoreExceptions().pollInterval(1, TimeUnit.SECONDS).untilAsserted(() -> {
+            var expectedMetrics = new String[] {targetInfoMetricName, cpuCountMetricName};
+            var actualMetrics = getMetricsFromPrometheus(pulsarCluster.getAnyWorker(), prometheusExporterPort);
+            assertThat(expectedMetrics).allMatch(expectedMetric -> !actualMetrics.findByNameAndLabels(expectedMetric,
+                    Pair.of("pulsar_cluster", clusterName),
+                    Pair.of("service_name", PulsarWorkerOpenTelemetry.SERVICE_NAME),
+                    Pair.of("service_version", PulsarVersion.getVersion()),
+                    Pair.of("host_name", pulsarCluster.getAnyWorker().getHostname())).isEmpty());
+        });
+    }
+
+    private static PrometheusMetricsClient.Metrics getMetricsFromPrometheus(ChaosContainer<?> container, int port) {
+        var client = new PrometheusMetricsClient(container.getHost(), container.getMappedPort(port));
+        return client.getMetrics();
+    }
+
+    private static Map<String, String> getOpenTelemetryProps(String exporter, Pair<String, String> ... extraProps) {
+        var defaultProps = Map.of(
+                "OTEL_SDK_DISABLED", "false",
+                "OTEL_METRIC_EXPORT_INTERVAL", "1000",
+                "OTEL_METRICS_EXPORTER", exporter
+        );
+        var props = new HashMap<>(defaultProps);
+        Arrays.stream(extraProps).forEach(p -> props.put(p.getKey(), p.getValue()));
+        return props;
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestBaseOffload.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestBaseOffload.java
index 339660fd78..f9a6ea3fd1 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestBaseOffload.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestBaseOffload.java
@@ -1,467 +1,467 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.offload;
-
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.bookkeeper.client.BKException;
-import org.apache.bookkeeper.client.BookKeeper;
-import org.apache.bookkeeper.client.BookKeeperAdmin;
-import org.apache.bookkeeper.conf.ClientConfiguration;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.common.policies.data.PersistentTopicInternalStats;
-import org.apache.pulsar.tests.integration.suites.PulsarTieredStorageTestSuite;
-import org.awaitility.Awaitility;
-import org.testng.Assert;
-
-@Slf4j
-public abstract class TestBaseOffload extends PulsarTieredStorageTestSuite {
-    protected int getEntrySize() {
-        return 1024;
-    };
-
-    private byte[] buildEntry(String pattern) {
-        byte[] entry = new byte[getEntrySize()];
-        byte[] patternBytes = pattern.getBytes();
-
-        for (int i = 0; i < entry.length; i++) {
-            entry[i] = patternBytes[i % patternBytes.length];
-        }
-        return entry;
-    }
-
-    protected void testPublishOffloadAndConsumeViaCLI(String serviceUrl, String adminUrl) throws Exception {
-        final String tenant = "offload-test-cli-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
-                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
-                "--admin-roles", "offload-admin", tenant);
-
-        pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces",
-                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        long firstLedger = -1;
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
-            Producer<byte[]> producer = client.newProducer().topic(topic)
-                    .maxPendingMessages(getNumEntriesPerLedger() / 2).sendTimeout(60, TimeUnit.SECONDS)
-                    .blockIfQueueFull(true).enableBatching(false).create();) {
-            client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe().close();
-
-            // write enough to topic to make it roll
-            int i = 0;
-            AtomicBoolean success = new AtomicBoolean(true);
-
-            for (; i < getNumEntriesPerLedger() * 1.5; i++) {
-                producer.sendAsync(buildEntry("offload-message" + i))
-                        .exceptionally(e -> {
-                            log.error("failed to send a message", e);
-                            success.set(false);
-                            return null;
-                        });
-            }
-            producer.flush();
-            Assert.assertTrue(success.get());
-        }
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
-            // read managed ledger info, check ledgers exist
-            firstLedger = admin.topics().getInternalStats(topic).ledgers.get(0).ledgerId;
-
-            // first offload with a high threshold, nothing should offload
-
-            String output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "offload", "--size-threshold", "100G", topic).getStdout();
-            Assert.assertTrue(output.contains("Nothing to offload"));
-
-            output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "offload-status", topic).getStdout();
-            Assert.assertTrue(output.contains("Offload has not been run"));
-
-            // offload with a low threshold
-            output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "offload", "--size-threshold", "1M", topic).getStdout();
-            Assert.assertTrue(output.contains("Offload triggered"));
-
-            output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "offload-status", "-w", topic).getStdout();
-            Assert.assertTrue(output.contains("Offload was a success"));
-
-            // delete the first ledger, so that we cannot possibly read from it
-            ClientConfiguration bkConf = new ClientConfiguration();
-            bkConf.setZkServers(pulsarCluster.getZKConnString());
-            try (BookKeeper bk = new BookKeeper(bkConf)) {
-                bk.deleteLedger(firstLedger);
-            }
-
-            // Unload topic to clear all caches, open handles, etc
-            admin.topics().unload(topic);
-        }
-
-        log.info("Read back the data (which would be in that first ledger)");
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
-            Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe()) {
-            // read back from topic
-            for (int i = 0; i < getNumEntriesPerLedger() * 1.5; i++) {
-                Message<byte[]> m = consumer.receive(1, TimeUnit.MINUTES);
-                Assert.assertEquals(buildEntry("offload-message" + i), m.getData());
-            }
-        }
-    }
-
-    protected void testPublishOffloadAndConsumeViaThreshold(String serviceUrl, String adminUrl) throws Exception {
-        final String tenant = "offload-test-threshold-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
-                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
-                "--admin-roles", "offload-admin", tenant);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-offload-threshold", "--size", "1M", namespace);
-
-        long firstLedger = 0;
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
-            Producer<byte[]> producer = client.newProducer().topic(topic)
-                    .maxPendingMessages(getNumEntriesPerLedger() / 2).sendTimeout(60, TimeUnit.SECONDS)
-                    .blockIfQueueFull(true).enableBatching(false).create()) {
-
-            client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe().close();
-
-            AtomicBoolean success = new AtomicBoolean(true);
-            // write enough to topic to make it roll twice
-            for (int i = 0; i < getNumEntriesPerLedger() * 2.5; i++) {
-                producer.sendAsync(buildEntry("offload-message" + i))
-                        .exceptionally(e -> {
-                            log.error("failed to send a message", e);
-                            success.set(false);
-                            return null;
-                        });
-            }
-
-            producer.flush();
-            Assert.assertTrue(success.get());
-        }
-
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
-            firstLedger = admin.topics().getInternalStats(topic).ledgers.get(0).ledgerId;
-
-            // wait up to 30 seconds for offload to occur
-            for (int i = 0; i < 100 && !admin.topics().getInternalStats(topic).ledgers.get(0).offloaded; i++) {
-                Thread.sleep(300);
-            }
-            Assert.assertTrue(admin.topics().getInternalStats(topic).ledgers.get(0).offloaded);
-
-            // delete the first ledger, so that we cannot possibly read from it
-            ClientConfiguration bkConf = new ClientConfiguration();
-            bkConf.setZkServers(pulsarCluster.getZKConnString());
-            try (BookKeeper bk = new BookKeeper(bkConf)) {
-                bk.deleteLedger(firstLedger);
-            }
-
-            // Unload topic to clear all caches, open handles, etc
-            admin.topics().unload(topic);
-        }
-
-        log.info("Read back the data (which would be in that first ledger)");
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
-             Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe()) {
-            // read back from topic
-            for (int i = 0; i < getNumEntriesPerLedger() * 2.5; i++) {
-                Message<byte[]> m = consumer.receive(1, TimeUnit.MINUTES);
-                Assert.assertNotNull(m);
-                Assert.assertEquals(buildEntry("offload-message" + i), m.getData());
-            }
-        }
-
-        // try disabling
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-offload-threshold", "--size", "-1", namespace);
-
-        // hard to validate that it has been disabled as we'd be waiting for
-        // something _not_ to happen (i.e. waiting for ages), so just check
-        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
-            Assert.assertEquals(admin.namespaces().getOffloadThreshold(namespace), -1L);
-        }
-    }
-
-    private boolean ledgerOffloaded(List<PersistentTopicInternalStats.LedgerInfo> ledgers, long ledgerId) {
-        return ledgers.stream().filter(l -> l.ledgerId == ledgerId)
-                .map(l -> l.offloaded).findFirst().get();
-    }
-
-    private long writeAndWaitForOffload(String serviceUrl, String adminUrl, String topic)
-            throws Exception {
-        return writeAndWaitForOffload(serviceUrl, adminUrl, topic, -1);
-    }
-
-    private long writeAndWaitForOffload(String serviceUrl, String adminUrl, String topic, int partitionNum)
-            throws Exception {
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
-            Producer<byte[]> producer = client.newProducer().topic(topic)
-                    .maxPendingMessages(getNumEntriesPerLedger() / 2).sendTimeout(60, TimeUnit.SECONDS)
-                    .blockIfQueueFull(true).enableBatching(false).create();
-            PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
-
-            String topicToCheck = partitionNum >= 0
-                    ? topic + "-partition-" + partitionNum
-                    : topic;
-
-            List<PersistentTopicInternalStats.LedgerInfo> ledgers = admin.topics()
-                    .getInternalStats(topicToCheck).ledgers;
-            long currentLedger = ledgers.get(ledgers.size() - 1).ledgerId;
-
-            client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe().close();
-
-            AtomicBoolean success = new AtomicBoolean(true);
-            // write enough to topic to make it roll twice
-            for (int i = 0;
-                 i < getNumEntriesPerLedger() * 2.5 * (partitionNum > 0 ? partitionNum + 1 : 1);
-                 i++) {
-                producer.sendAsync(buildEntry("offload-message" + i))
-                        .exceptionally(e -> {
-                            log.error("failed to send a message", e);
-                            success.set(false);
-                            return null;
-                        });
-            }
-            producer.flush();
-            producer.send(buildEntry("final-offload-message"));
-            Assert.assertTrue(success.get());
-
-            // wait up to 30 seconds for offload to occur
-            for (int i = 0;
-                 i < 100 && !ledgerOffloaded(admin.topics().getInternalStats(topicToCheck).ledgers, currentLedger);
-                 i++) {
-                Thread.sleep(300);
-            }
-            Assert.assertTrue(ledgerOffloaded(admin.topics().getInternalStats(topicToCheck).ledgers, currentLedger));
-
-            return currentLedger;
-        }
-    }
-
-    public boolean ledgerExistsInBookKeeper(long ledgerId) throws Exception {
-        ClientConfiguration bkConf = new ClientConfiguration();
-        bkConf.setZkServers(pulsarCluster.getZKConnString());
-        try (BookKeeperAdmin bk = new BookKeeperAdmin(bkConf)) {
-            try {
-                bk.openLedger(ledgerId).close();
-                return true;
-            } catch (BKException.BKNoSuchLedgerExistsException
-                | BKException.BKNoSuchLedgerExistsOnMetadataServerException e) {
-                return false;
-            }
-        }
-    }
-
-    protected void testPublishOffloadAndConsumeDeletionLag(String serviceUrl, String adminUrl) throws Exception {
-        final String tenant = "offload-test-deletion-lag-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
-                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
-                "--admin-roles", "offload-admin", tenant);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        // set threshold to offload runs immediately after role
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-offload-threshold", "--size", "0", namespace);
-
-        String output = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
-        Assert.assertTrue(output.contains("Unset for namespace"));
-
-        long offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic);
-        // give it up to 5 seconds to delete, it shouldn't
-        // so we wait this every time
-        Thread.sleep(5000);
-        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-offload-deletion-lag", namespace,
-                "--lag", "0m");
-        output = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
-        Assert.assertTrue(output.contains("0 minute(s)"));
-
-        offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic);
-        // wait up to 10 seconds for ledger to be deleted
-        for (int i = 0; i < 10 && ledgerExistsInBookKeeper(offloadedLedger); i++) {
-            writeAndWaitForOffload(serviceUrl, adminUrl, topic);
-            Thread.sleep(1000);
-        }
-        Assert.assertFalse(ledgerExistsInBookKeeper(offloadedLedger));
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "clear-offload-deletion-lag", namespace);
-
-        Thread.sleep(5); // wait 5 seconds to allow broker to see update
-
-        output = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
-        Assert.assertTrue(output.contains("Unset for namespace"));
-
-        offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic);
-
-        // give it up to 5 seconds to delete, it shouldn't
-        // so we wait this every time
-        Thread.sleep(5000);
-        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
-    }
-
-    protected void testDeleteOffloadedTopic(String serviceUrl, String adminUrl,
-                                            boolean unloadBeforeDelete, int numPartitions) throws Exception {
-        final String tenant = "offload-test-cli-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
-                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
-                "--admin-roles", "offload-admin", tenant);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        // set threshold to offload runs immediately after role
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-offload-threshold", "--size", "0", namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-retention", "--size", "100M", "--time", "100m", namespace);
-
-        String output = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
-        Assert.assertTrue(output.contains("Unset for namespace"));
-
-        if (numPartitions > 0) {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "create-partitioned-topic", topic,
-                    "--partitions", Integer.toString(numPartitions));
-        } else {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "create", topic);
-        }
-
-        long offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
-        // give it up to 5 seconds to delete, it shouldn't
-        // so we wait this every time
-        Thread.sleep(5000);
-        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-offload-deletion-lag", namespace,
-                "--lag", "0m");
-        output = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
-        Assert.assertTrue(output.contains("0 minute(s)"));
-
-        offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
-        // wait up to 10 seconds for ledger to be deleted
-        for (int i = 0; i < 10 && ledgerExistsInBookKeeper(offloadedLedger); i++) {
-            writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
-            Thread.sleep(1000);
-        }
-
-        Assert.assertFalse(ledgerExistsInBookKeeper(offloadedLedger));
-        Assert.assertTrue(offloadedLedgerExists(topic, numPartitions - 1, offloadedLedger));
-
-        if (unloadBeforeDelete) {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "unload", topic);
-        }
-        if (numPartitions > 0) {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete-partitioned-topic", topic);
-        } else {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete", topic);
-        }
-        final long ledgerId = offloadedLedger;
-        Awaitility.await().atMost(30, TimeUnit.SECONDS).untilAsserted(() -> {
-            Assert.assertFalse(offloadedLedgerExists(topic, numPartitions - 1, ledgerId));
-        });
-    }
-
-    protected void testDeleteOffloadedTopicExistsInBk(String serviceUrl, String adminUrl,
-                                            boolean unloadBeforeDelete, int numPartitions) throws Exception {
-        final String tenant = "offload-test-cli-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
-                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
-                "--admin-roles", "offload-admin", tenant);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        // set threshold to offload runs immediately after role
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-offload-threshold", "--size", "0", namespace);
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-retention", "--size", "100M", "--time", "100m", namespace);
-
-        if (numPartitions > 0) {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "create-partitioned-topic", topic,
-                    "--partitions", Integer.toString(numPartitions));
-        } else {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "create", topic);
-        }
-
-        String output = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
-        Assert.assertTrue(output.contains("Unset for namespace"));
-
-        long offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
-        // give it up to 5 seconds to delete, it shouldn't
-        // so we wait this every time
-        Thread.sleep(5000);
-        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
-
-        Assert.assertTrue(offloadedLedgerExists(topic, numPartitions - 1, offloadedLedger));
-
-        if (unloadBeforeDelete) {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "unload", topic);
-        }
-        if (numPartitions > 0) {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete-partitioned-topic", topic);
-        } else {
-            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete", topic);
-        }
-        final long ledgerId = offloadedLedger;
-        Awaitility.await().atMost(30, TimeUnit.SECONDS).untilAsserted(() -> {
-            Assert.assertFalse(offloadedLedgerExists(topic, numPartitions - 1, ledgerId));
-        });
-        Assert.assertFalse(ledgerExistsInBookKeeper(offloadedLedger));
-    }
-
-    protected boolean offloadedLedgerExists(String topic, int partitionNum, long firstLedger) {
-        throw new RuntimeException("not implemented");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.offload;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.bookkeeper.client.BKException;
+import org.apache.bookkeeper.client.BookKeeper;
+import org.apache.bookkeeper.client.BookKeeperAdmin;
+import org.apache.bookkeeper.conf.ClientConfiguration;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.common.policies.data.PersistentTopicInternalStats;
+import org.apache.pulsar.tests.integration.suites.PulsarTieredStorageTestSuite;
+import org.awaitility.Awaitility;
+import org.testng.Assert;
+
+@Slf4j
+public abstract class TestBaseOffload extends PulsarTieredStorageTestSuite {
+    protected int getEntrySize() {
+        return 1024;
+    };
+
+    private byte[] buildEntry(String pattern) {
+        byte[] entry = new byte[getEntrySize()];
+        byte[] patternBytes = pattern.getBytes();
+
+        for (int i = 0; i < entry.length; i++) {
+            entry[i] = patternBytes[i % patternBytes.length];
+        }
+        return entry;
+    }
+
+    protected void testPublishOffloadAndConsumeViaCLI(String serviceUrl, String adminUrl) throws Exception {
+        final String tenant = "offload-test-cli-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
+                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
+                "--admin-roles", "offload-admin", tenant);
+
+        pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces",
+                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        long firstLedger = -1;
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
+            Producer<byte[]> producer = client.newProducer().topic(topic)
+                    .maxPendingMessages(getNumEntriesPerLedger() / 2).sendTimeout(60, TimeUnit.SECONDS)
+                    .blockIfQueueFull(true).enableBatching(false).create();) {
+            client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe().close();
+
+            // write enough to topic to make it roll
+            int i = 0;
+            AtomicBoolean success = new AtomicBoolean(true);
+
+            for (; i < getNumEntriesPerLedger() * 1.5; i++) {
+                producer.sendAsync(buildEntry("offload-message" + i))
+                        .exceptionally(e -> {
+                            log.error("failed to send a message", e);
+                            success.set(false);
+                            return null;
+                        });
+            }
+            producer.flush();
+            Assert.assertTrue(success.get());
+        }
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
+            // read managed ledger info, check ledgers exist
+            firstLedger = admin.topics().getInternalStats(topic).ledgers.get(0).ledgerId;
+
+            // first offload with a high threshold, nothing should offload
+
+            String output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "offload", "--size-threshold", "100G", topic).getStdout();
+            Assert.assertTrue(output.contains("Nothing to offload"));
+
+            output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "offload-status", topic).getStdout();
+            Assert.assertTrue(output.contains("Offload has not been run"));
+
+            // offload with a low threshold
+            output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "offload", "--size-threshold", "1M", topic).getStdout();
+            Assert.assertTrue(output.contains("Offload triggered"));
+
+            output = pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "offload-status", "-w", topic).getStdout();
+            Assert.assertTrue(output.contains("Offload was a success"));
+
+            // delete the first ledger, so that we cannot possibly read from it
+            ClientConfiguration bkConf = new ClientConfiguration();
+            bkConf.setZkServers(pulsarCluster.getZKConnString());
+            try (BookKeeper bk = new BookKeeper(bkConf)) {
+                bk.deleteLedger(firstLedger);
+            }
+
+            // Unload topic to clear all caches, open handles, etc
+            admin.topics().unload(topic);
+        }
+
+        log.info("Read back the data (which would be in that first ledger)");
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
+            Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe()) {
+            // read back from topic
+            for (int i = 0; i < getNumEntriesPerLedger() * 1.5; i++) {
+                Message<byte[]> m = consumer.receive(1, TimeUnit.MINUTES);
+                Assert.assertEquals(buildEntry("offload-message" + i), m.getData());
+            }
+        }
+    }
+
+    protected void testPublishOffloadAndConsumeViaThreshold(String serviceUrl, String adminUrl) throws Exception {
+        final String tenant = "offload-test-threshold-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
+                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
+                "--admin-roles", "offload-admin", tenant);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-offload-threshold", "--size", "1M", namespace);
+
+        long firstLedger = 0;
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
+            Producer<byte[]> producer = client.newProducer().topic(topic)
+                    .maxPendingMessages(getNumEntriesPerLedger() / 2).sendTimeout(60, TimeUnit.SECONDS)
+                    .blockIfQueueFull(true).enableBatching(false).create()) {
+
+            client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe().close();
+
+            AtomicBoolean success = new AtomicBoolean(true);
+            // write enough to topic to make it roll twice
+            for (int i = 0; i < getNumEntriesPerLedger() * 2.5; i++) {
+                producer.sendAsync(buildEntry("offload-message" + i))
+                        .exceptionally(e -> {
+                            log.error("failed to send a message", e);
+                            success.set(false);
+                            return null;
+                        });
+            }
+
+            producer.flush();
+            Assert.assertTrue(success.get());
+        }
+
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
+            firstLedger = admin.topics().getInternalStats(topic).ledgers.get(0).ledgerId;
+
+            // wait up to 30 seconds for offload to occur
+            for (int i = 0; i < 100 && !admin.topics().getInternalStats(topic).ledgers.get(0).offloaded; i++) {
+                Thread.sleep(300);
+            }
+            Assert.assertTrue(admin.topics().getInternalStats(topic).ledgers.get(0).offloaded);
+
+            // delete the first ledger, so that we cannot possibly read from it
+            ClientConfiguration bkConf = new ClientConfiguration();
+            bkConf.setZkServers(pulsarCluster.getZKConnString());
+            try (BookKeeper bk = new BookKeeper(bkConf)) {
+                bk.deleteLedger(firstLedger);
+            }
+
+            // Unload topic to clear all caches, open handles, etc
+            admin.topics().unload(topic);
+        }
+
+        log.info("Read back the data (which would be in that first ledger)");
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
+             Consumer<byte[]> consumer = client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe()) {
+            // read back from topic
+            for (int i = 0; i < getNumEntriesPerLedger() * 2.5; i++) {
+                Message<byte[]> m = consumer.receive(1, TimeUnit.MINUTES);
+                Assert.assertNotNull(m);
+                Assert.assertEquals(buildEntry("offload-message" + i), m.getData());
+            }
+        }
+
+        // try disabling
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-offload-threshold", "--size", "-1", namespace);
+
+        // hard to validate that it has been disabled as we'd be waiting for
+        // something _not_ to happen (i.e. waiting for ages), so just check
+        try (PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
+            Assert.assertEquals(admin.namespaces().getOffloadThreshold(namespace), -1L);
+        }
+    }
+
+    private boolean ledgerOffloaded(List<PersistentTopicInternalStats.LedgerInfo> ledgers, long ledgerId) {
+        return ledgers.stream().filter(l -> l.ledgerId == ledgerId)
+                .map(l -> l.offloaded).findFirst().get();
+    }
+
+    private long writeAndWaitForOffload(String serviceUrl, String adminUrl, String topic)
+            throws Exception {
+        return writeAndWaitForOffload(serviceUrl, adminUrl, topic, -1);
+    }
+
+    private long writeAndWaitForOffload(String serviceUrl, String adminUrl, String topic, int partitionNum)
+            throws Exception {
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl).build();
+            Producer<byte[]> producer = client.newProducer().topic(topic)
+                    .maxPendingMessages(getNumEntriesPerLedger() / 2).sendTimeout(60, TimeUnit.SECONDS)
+                    .blockIfQueueFull(true).enableBatching(false).create();
+            PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(adminUrl).build()) {
+
+            String topicToCheck = partitionNum >= 0
+                    ? topic + "-partition-" + partitionNum
+                    : topic;
+
+            List<PersistentTopicInternalStats.LedgerInfo> ledgers = admin.topics()
+                    .getInternalStats(topicToCheck).ledgers;
+            long currentLedger = ledgers.get(ledgers.size() - 1).ledgerId;
+
+            client.newConsumer().topic(topic).subscriptionName("my-sub").subscribe().close();
+
+            AtomicBoolean success = new AtomicBoolean(true);
+            // write enough to topic to make it roll twice
+            for (int i = 0;
+                 i < getNumEntriesPerLedger() * 2.5 * (partitionNum > 0 ? partitionNum + 1 : 1);
+                 i++) {
+                producer.sendAsync(buildEntry("offload-message" + i))
+                        .exceptionally(e -> {
+                            log.error("failed to send a message", e);
+                            success.set(false);
+                            return null;
+                        });
+            }
+            producer.flush();
+            producer.send(buildEntry("final-offload-message"));
+            Assert.assertTrue(success.get());
+
+            // wait up to 30 seconds for offload to occur
+            for (int i = 0;
+                 i < 100 && !ledgerOffloaded(admin.topics().getInternalStats(topicToCheck).ledgers, currentLedger);
+                 i++) {
+                Thread.sleep(300);
+            }
+            Assert.assertTrue(ledgerOffloaded(admin.topics().getInternalStats(topicToCheck).ledgers, currentLedger));
+
+            return currentLedger;
+        }
+    }
+
+    public boolean ledgerExistsInBookKeeper(long ledgerId) throws Exception {
+        ClientConfiguration bkConf = new ClientConfiguration();
+        bkConf.setZkServers(pulsarCluster.getZKConnString());
+        try (BookKeeperAdmin bk = new BookKeeperAdmin(bkConf)) {
+            try {
+                bk.openLedger(ledgerId).close();
+                return true;
+            } catch (BKException.BKNoSuchLedgerExistsException
+                | BKException.BKNoSuchLedgerExistsOnMetadataServerException e) {
+                return false;
+            }
+        }
+    }
+
+    protected void testPublishOffloadAndConsumeDeletionLag(String serviceUrl, String adminUrl) throws Exception {
+        final String tenant = "offload-test-deletion-lag-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
+                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
+                "--admin-roles", "offload-admin", tenant);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        // set threshold to offload runs immediately after role
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-offload-threshold", "--size", "0", namespace);
+
+        String output = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
+        Assert.assertTrue(output.contains("Unset for namespace"));
+
+        long offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic);
+        // give it up to 5 seconds to delete, it shouldn't
+        // so we wait this every time
+        Thread.sleep(5000);
+        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-offload-deletion-lag", namespace,
+                "--lag", "0m");
+        output = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
+        Assert.assertTrue(output.contains("0 minute(s)"));
+
+        offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic);
+        // wait up to 10 seconds for ledger to be deleted
+        for (int i = 0; i < 10 && ledgerExistsInBookKeeper(offloadedLedger); i++) {
+            writeAndWaitForOffload(serviceUrl, adminUrl, topic);
+            Thread.sleep(1000);
+        }
+        Assert.assertFalse(ledgerExistsInBookKeeper(offloadedLedger));
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "clear-offload-deletion-lag", namespace);
+
+        Thread.sleep(5); // wait 5 seconds to allow broker to see update
+
+        output = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
+        Assert.assertTrue(output.contains("Unset for namespace"));
+
+        offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic);
+
+        // give it up to 5 seconds to delete, it shouldn't
+        // so we wait this every time
+        Thread.sleep(5000);
+        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
+    }
+
+    protected void testDeleteOffloadedTopic(String serviceUrl, String adminUrl,
+                                            boolean unloadBeforeDelete, int numPartitions) throws Exception {
+        final String tenant = "offload-test-cli-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
+                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
+                "--admin-roles", "offload-admin", tenant);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        // set threshold to offload runs immediately after role
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-offload-threshold", "--size", "0", namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-retention", "--size", "100M", "--time", "100m", namespace);
+
+        String output = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
+        Assert.assertTrue(output.contains("Unset for namespace"));
+
+        if (numPartitions > 0) {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "create-partitioned-topic", topic,
+                    "--partitions", Integer.toString(numPartitions));
+        } else {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "create", topic);
+        }
+
+        long offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
+        // give it up to 5 seconds to delete, it shouldn't
+        // so we wait this every time
+        Thread.sleep(5000);
+        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces", "set-offload-deletion-lag", namespace,
+                "--lag", "0m");
+        output = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
+        Assert.assertTrue(output.contains("0 minute(s)"));
+
+        offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
+        // wait up to 10 seconds for ledger to be deleted
+        for (int i = 0; i < 10 && ledgerExistsInBookKeeper(offloadedLedger); i++) {
+            writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
+            Thread.sleep(1000);
+        }
+
+        Assert.assertFalse(ledgerExistsInBookKeeper(offloadedLedger));
+        Assert.assertTrue(offloadedLedgerExists(topic, numPartitions - 1, offloadedLedger));
+
+        if (unloadBeforeDelete) {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "unload", topic);
+        }
+        if (numPartitions > 0) {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete-partitioned-topic", topic);
+        } else {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete", topic);
+        }
+        final long ledgerId = offloadedLedger;
+        Awaitility.await().atMost(30, TimeUnit.SECONDS).untilAsserted(() -> {
+            Assert.assertFalse(offloadedLedgerExists(topic, numPartitions - 1, ledgerId));
+        });
+    }
+
+    protected void testDeleteOffloadedTopicExistsInBk(String serviceUrl, String adminUrl,
+                                            boolean unloadBeforeDelete, int numPartitions) throws Exception {
+        final String tenant = "offload-test-cli-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        pulsarCluster.runAdminCommandOnAnyBroker("tenants",
+                "create", "--allowed-clusters", pulsarCluster.getClusterName(),
+                "--admin-roles", "offload-admin", tenant);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "create", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        // set threshold to offload runs immediately after role
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-offload-threshold", "--size", "0", namespace);
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-retention", "--size", "100M", "--time", "100m", namespace);
+
+        if (numPartitions > 0) {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "create-partitioned-topic", topic,
+                    "--partitions", Integer.toString(numPartitions));
+        } else {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "create", topic);
+        }
+
+        String output = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces", "get-offload-deletion-lag", namespace).getStdout();
+        Assert.assertTrue(output.contains("Unset for namespace"));
+
+        long offloadedLedger = writeAndWaitForOffload(serviceUrl, adminUrl, topic, numPartitions - 1);
+        // give it up to 5 seconds to delete, it shouldn't
+        // so we wait this every time
+        Thread.sleep(5000);
+        Assert.assertTrue(ledgerExistsInBookKeeper(offloadedLedger));
+
+        Assert.assertTrue(offloadedLedgerExists(topic, numPartitions - 1, offloadedLedger));
+
+        if (unloadBeforeDelete) {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "unload", topic);
+        }
+        if (numPartitions > 0) {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete-partitioned-topic", topic);
+        } else {
+            pulsarCluster.runAdminCommandOnAnyBroker("topics", "delete", topic);
+        }
+        final long ledgerId = offloadedLedger;
+        Awaitility.await().atMost(30, TimeUnit.SECONDS).untilAsserted(() -> {
+            Assert.assertFalse(offloadedLedgerExists(topic, numPartitions - 1, ledgerId));
+        });
+        Assert.assertFalse(ledgerExistsInBookKeeper(offloadedLedger));
+    }
+
+    protected boolean offloadedLedgerExists(String topic, int partitionNum, long firstLedger) {
+        throw new RuntimeException("not implemented");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestFileSystemOffload.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestFileSystemOffload.java
index d658d80ddf..34a63568d3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestFileSystemOffload.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestFileSystemOffload.java
@@ -1,59 +1,59 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.offload;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class TestFileSystemOffload extends TestBaseOffload {
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeViaCLI(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeViaCLI(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeViaThreshold(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeViaThreshold(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeDeletionLag(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeDeletionLag(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Override
-    protected Map<String, String> getEnv() {
-        Map<String, String> result = new HashMap<>();
-        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
-        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
-        result.put("managedLedgerOffloadDriver", "filesystem");
-        result.put("fileSystemURI", "file:///tmp");
-
-        return result;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.offload;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class TestFileSystemOffload extends TestBaseOffload {
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeViaCLI(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeViaCLI(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeViaThreshold(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeViaThreshold(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeDeletionLag(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeDeletionLag(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Override
+    protected Map<String, String> getEnv() {
+        Map<String, String> result = new HashMap<>();
+        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
+        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
+        result.put("managedLedgerOffloadDriver", "filesystem");
+        result.put("fileSystemURI", "file:///tmp");
+
+        return result;
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestOffloadDeletionFS.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestOffloadDeletionFS.java
index 70c2527e8a..579deb20f5 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestOffloadDeletionFS.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestOffloadDeletionFS.java
@@ -1,144 +1,144 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.offload;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class TestOffloadDeletionFS extends TestBaseOffload {
-
-    @Override
-    protected int getEntrySize() {
-        return 512;
-    }
-
-    @Override
-    protected int getNumEntriesPerLedger() {
-        return 200;
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteOffloadedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl) throws Exception {
-        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), false, 0);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteUnloadedOffloadedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), true, 0);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteOffloadedTopicExistsInBk(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), false, 0);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteUnloadedOffloadedTopicExistsInBk(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), true, 0);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteOffloadedPartitionedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), false, 3);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteUnloadedOffloadedPartitionedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), true, 3);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteOffloadedPartitionedTopicExistsInBk(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), false, 3);
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testDeleteUnloadedOffloadedPartitionedTopicExistsInBk(Supplier<String> serviceUrl,
-                                                                      Supplier<String> adminUrl) throws Exception {
-        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), true, 3);
-    }
-
-    @Override
-    protected Map<String, String> getEnv() {
-        Map<String, String> result = new HashMap<>();
-        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
-        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
-        result.put("managedLedgerOffloadDriver", "filesystem");
-        result.put("fileSystemURI", "file:///");
-
-        return result;
-    }
-
-    @Override
-    protected boolean offloadedLedgerExists(String topic, int partitionNum, long ledger) {
-        log.info("offloadedLedgerExists(topic = {}, partitionNum={},ledger={})",
-                topic, partitionNum, ledger);
-        if (partitionNum > -1) {
-            topic = topic + "-partition-" + partitionNum;
-        }
-        String managedLedgerName = TopicName.get(topic).getPersistenceNamingEncoding();
-        String rootPath = "pulsar/";
-        String dirPath = rootPath + managedLedgerName + "/";
-
-        List<String> result = new LinkedList<>();
-        String[] cmds = {
-                "ls",
-                "-1",
-                dirPath
-                };
-        pulsarCluster.getBrokers().forEach(broker -> {
-            try {
-                ContainerExecResult res = broker.execCmd(cmds);
-                log.info("offloadedLedgerExists broker {} 'ls -1 {}' got {}",
-                        broker.getContainerName(), dirPath, res.getStdout());
-                Arrays.stream(res.getStdout().split("\n"))
-                        .filter(x -> x.startsWith(ledger + "-"))
-                        .forEach(x -> result.add(x));
-            } catch (ContainerExecException ce) {
-                log.info("offloadedLedgerExists broker {} 'ls -1 {}' got error code {}",
-                        broker.getContainerName(), dirPath, ce.getResult().getExitCode());
-                // ignore 2 (No such file or directory)
-                if (ce.getResult().getExitCode() != 2) {
-                    throw new RuntimeException(ce);
-                }
-            } catch (Exception e) {
-                throw new RuntimeException(e);
-            }
-        });
-
-        return !result.isEmpty();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.offload;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class TestOffloadDeletionFS extends TestBaseOffload {
+
+    @Override
+    protected int getEntrySize() {
+        return 512;
+    }
+
+    @Override
+    protected int getNumEntriesPerLedger() {
+        return 200;
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteOffloadedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl) throws Exception {
+        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), false, 0);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteUnloadedOffloadedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), true, 0);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteOffloadedTopicExistsInBk(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), false, 0);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteUnloadedOffloadedTopicExistsInBk(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), true, 0);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteOffloadedPartitionedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), false, 3);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteUnloadedOffloadedPartitionedTopic(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testDeleteOffloadedTopic(serviceUrl.get(), adminUrl.get(), true, 3);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteOffloadedPartitionedTopicExistsInBk(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), false, 3);
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testDeleteUnloadedOffloadedPartitionedTopicExistsInBk(Supplier<String> serviceUrl,
+                                                                      Supplier<String> adminUrl) throws Exception {
+        super.testDeleteOffloadedTopicExistsInBk(serviceUrl.get(), adminUrl.get(), true, 3);
+    }
+
+    @Override
+    protected Map<String, String> getEnv() {
+        Map<String, String> result = new HashMap<>();
+        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
+        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
+        result.put("managedLedgerOffloadDriver", "filesystem");
+        result.put("fileSystemURI", "file:///");
+
+        return result;
+    }
+
+    @Override
+    protected boolean offloadedLedgerExists(String topic, int partitionNum, long ledger) {
+        log.info("offloadedLedgerExists(topic = {}, partitionNum={},ledger={})",
+                topic, partitionNum, ledger);
+        if (partitionNum > -1) {
+            topic = topic + "-partition-" + partitionNum;
+        }
+        String managedLedgerName = TopicName.get(topic).getPersistenceNamingEncoding();
+        String rootPath = "pulsar/";
+        String dirPath = rootPath + managedLedgerName + "/";
+
+        List<String> result = new LinkedList<>();
+        String[] cmds = {
+                "ls",
+                "-1",
+                dirPath
+                };
+        pulsarCluster.getBrokers().forEach(broker -> {
+            try {
+                ContainerExecResult res = broker.execCmd(cmds);
+                log.info("offloadedLedgerExists broker {} 'ls -1 {}' got {}",
+                        broker.getContainerName(), dirPath, res.getStdout());
+                Arrays.stream(res.getStdout().split("\n"))
+                        .filter(x -> x.startsWith(ledger + "-"))
+                        .forEach(x -> result.add(x));
+            } catch (ContainerExecException ce) {
+                log.info("offloadedLedgerExists broker {} 'ls -1 {}' got error code {}",
+                        broker.getContainerName(), dirPath, ce.getResult().getExitCode());
+                // ignore 2 (No such file or directory)
+                if (ce.getResult().getExitCode() != 2) {
+                    throw new RuntimeException(ce);
+                }
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        });
+
+        return !result.isEmpty();
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestS3Offload.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestS3Offload.java
index 3106994d2d..12935dff35 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestS3Offload.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestS3Offload.java
@@ -1,88 +1,88 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.offload;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.S3Container;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class TestS3Offload extends TestBaseOffload {
-
-    private S3Container s3Container;
-
-    @Override
-    protected void beforeStartCluster() throws Exception {
-        super.beforeStartCluster();
-
-        log.info("s3 container init");
-        s3Container = new S3Container(
-                pulsarCluster.getClusterName(),
-                S3Container.NAME)
-                .withNetwork(pulsarCluster.getNetwork())
-                .withNetworkAliases(S3Container.NAME);
-        s3Container.start();
-        log.info("s3 container start finish.");
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void teardownS3() {
-        if (null != s3Container) {
-            s3Container.stop();
-        }
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeViaCLI(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeViaCLI(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeViaThreshold(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeViaThreshold(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeDeletionLag(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeDeletionLag(serviceUrl.get(), adminUrl.get());
-
-    }
-
-
-    @Override
-    protected Map<String, String> getEnv() {
-        Map<String, String> result = new HashMap<>();
-        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
-        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
-        result.put("managedLedgerOffloadDriver", "aws-s3");
-        result.put("s3ManagedLedgerOffloadBucket", "pulsar-integtest");
-        result.put("s3ManagedLedgerOffloadServiceEndpoint", "http://" + S3Container.NAME + ":9090");
-
-        return result;
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.offload;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.S3Container;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class TestS3Offload extends TestBaseOffload {
+
+    private S3Container s3Container;
+
+    @Override
+    protected void beforeStartCluster() throws Exception {
+        super.beforeStartCluster();
+
+        log.info("s3 container init");
+        s3Container = new S3Container(
+                pulsarCluster.getClusterName(),
+                S3Container.NAME)
+                .withNetwork(pulsarCluster.getNetwork())
+                .withNetworkAliases(S3Container.NAME);
+        s3Container.start();
+        log.info("s3 container start finish.");
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void teardownS3() {
+        if (null != s3Container) {
+            s3Container.stop();
+        }
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeViaCLI(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeViaCLI(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeViaThreshold(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeViaThreshold(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeDeletionLag(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeDeletionLag(serviceUrl.get(), adminUrl.get());
+
+    }
+
+
+    @Override
+    protected Map<String, String> getEnv() {
+        Map<String, String> result = new HashMap<>();
+        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
+        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
+        result.put("managedLedgerOffloadDriver", "aws-s3");
+        result.put("s3ManagedLedgerOffloadBucket", "pulsar-integtest");
+        result.put("s3ManagedLedgerOffloadServiceEndpoint", "http://" + S3Container.NAME + ":9090");
+
+        return result;
+    }
+
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestUniversalConfigurations.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestUniversalConfigurations.java
index 4ac5a0cb8d..7034de57db 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestUniversalConfigurations.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/offload/TestUniversalConfigurations.java
@@ -1,86 +1,86 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.offload;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.S3Container;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class TestUniversalConfigurations extends TestBaseOffload {
-
-    private S3Container s3Container;
-
-    @Override
-    protected void beforeStartCluster() throws Exception {
-        super.beforeStartCluster();
-
-        log.info("s3 container init");
-        s3Container = new S3Container(
-                pulsarCluster.getClusterName(),
-                S3Container.NAME)
-                .withNetwork(pulsarCluster.getNetwork())
-                .withNetworkAliases(S3Container.NAME);
-        s3Container.start();
-        log.info("s3 container start finish.");
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void teardownS3() {
-        if (null != s3Container) {
-            s3Container.stop();
-        }
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeViaCLI(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeViaCLI(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeViaThreshold(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeViaThreshold(serviceUrl.get(), adminUrl.get());
-    }
-
-    @Test(dataProvider =  "ServiceAndAdminUrls")
-    public void testPublishOffloadAndConsumeDeletionLag(Supplier<String> serviceUrl, Supplier<String> adminUrl)
-            throws Exception {
-        super.testPublishOffloadAndConsumeDeletionLag(serviceUrl.get(), adminUrl.get());
-
-    }
-
-    @Override
-    protected Map<String, String> getEnv() {
-        Map<String, String> result = new HashMap<>();
-        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
-        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
-        result.put("managedLedgerOffloadDriver", "aws-s3");
-        result.put("managedLedgerOffloadBucket", "pulsar-integtest");
-        result.put("managedLedgerOffloadServiceEndpoint", "http://" + S3Container.NAME + ":9090");
-
-        return result;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.offload;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.S3Container;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class TestUniversalConfigurations extends TestBaseOffload {
+
+    private S3Container s3Container;
+
+    @Override
+    protected void beforeStartCluster() throws Exception {
+        super.beforeStartCluster();
+
+        log.info("s3 container init");
+        s3Container = new S3Container(
+                pulsarCluster.getClusterName(),
+                S3Container.NAME)
+                .withNetwork(pulsarCluster.getNetwork())
+                .withNetworkAliases(S3Container.NAME);
+        s3Container.start();
+        log.info("s3 container start finish.");
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void teardownS3() {
+        if (null != s3Container) {
+            s3Container.stop();
+        }
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeViaCLI(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeViaCLI(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeViaThreshold(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeViaThreshold(serviceUrl.get(), adminUrl.get());
+    }
+
+    @Test(dataProvider =  "ServiceAndAdminUrls")
+    public void testPublishOffloadAndConsumeDeletionLag(Supplier<String> serviceUrl, Supplier<String> adminUrl)
+            throws Exception {
+        super.testPublishOffloadAndConsumeDeletionLag(serviceUrl.get(), adminUrl.get());
+
+    }
+
+    @Override
+    protected Map<String, String> getEnv() {
+        Map<String, String> result = new HashMap<>();
+        result.put("managedLedgerMaxEntriesPerLedger", String.valueOf(getNumEntriesPerLedger()));
+        result.put("managedLedgerMinLedgerRolloverTimeMinutes", "0");
+        result.put("managedLedgerOffloadDriver", "aws-s3");
+        result.put("managedLedgerOffloadBucket", "pulsar-integtest");
+        result.put("managedLedgerOffloadServiceEndpoint", "http://" + S3Container.NAME + ":9090");
+
+        return result;
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaContainer.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaContainer.java
index 18d2dd77b7..61faa64fd1 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaContainer.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaContainer.java
@@ -1,72 +1,72 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.apache.pulsar.tests.integration.oxia;
-
-import java.time.Duration;
-import org.apache.pulsar.tests.integration.containers.ChaosContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.testcontainers.containers.wait.strategy.Wait;
-
-public class OxiaContainer extends ChaosContainer<OxiaContainer> {
-
-    public static final String NAME = "oxia";
-
-    public static final int OXIA_PORT = 6648;
-    public static final int METRICS_PORT = 8080;
-    private static final int DEFAULT_SHARDS = 1;
-
-    private static final String DEFAULT_IMAGE_NAME = "streamnative/oxia:main";
-
-    public OxiaContainer(String clusterName) {
-        this(clusterName, DEFAULT_IMAGE_NAME, DEFAULT_SHARDS);
-    }
-
-    @SuppressWarnings("resource")
-    OxiaContainer(String clusterName, String imageName, int shards) {
-        super(clusterName, imageName);
-        if (shards <= 0) {
-            throw new IllegalArgumentException("shards must be greater than zero");
-        }
-        addExposedPorts(OXIA_PORT, METRICS_PORT);
-        this.withCreateContainerCmdModifier(createContainerCmd -> {
-            createContainerCmd.withHostName("oxia");
-            createContainerCmd.withName(getContainerName());
-        });
-        setCommand("oxia", "standalone",
-                "--shards=" + shards,
-                "--wal-sync-data=false");
-        waitingFor(
-                Wait.forHttp("/metrics")
-                        .forPort(METRICS_PORT)
-                        .forStatusCode(200)
-                        .withStartupTimeout(Duration.ofSeconds(30)));
-
-        PulsarContainer.configureLeaveContainerRunning(this);
-    }
-
-    public String getServiceAddress() {
-        return OxiaContainer.NAME + ":" + OXIA_PORT;
-    }
-
-    @Override
-    public String getContainerName() {
-        return clusterName + "-oxia";
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.pulsar.tests.integration.oxia;
+
+import java.time.Duration;
+import org.apache.pulsar.tests.integration.containers.ChaosContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.testcontainers.containers.wait.strategy.Wait;
+
+public class OxiaContainer extends ChaosContainer<OxiaContainer> {
+
+    public static final String NAME = "oxia";
+
+    public static final int OXIA_PORT = 6648;
+    public static final int METRICS_PORT = 8080;
+    private static final int DEFAULT_SHARDS = 1;
+
+    private static final String DEFAULT_IMAGE_NAME = "streamnative/oxia:main";
+
+    public OxiaContainer(String clusterName) {
+        this(clusterName, DEFAULT_IMAGE_NAME, DEFAULT_SHARDS);
+    }
+
+    @SuppressWarnings("resource")
+    OxiaContainer(String clusterName, String imageName, int shards) {
+        super(clusterName, imageName);
+        if (shards <= 0) {
+            throw new IllegalArgumentException("shards must be greater than zero");
+        }
+        addExposedPorts(OXIA_PORT, METRICS_PORT);
+        this.withCreateContainerCmdModifier(createContainerCmd -> {
+            createContainerCmd.withHostName("oxia");
+            createContainerCmd.withName(getContainerName());
+        });
+        setCommand("oxia", "standalone",
+                "--shards=" + shards,
+                "--wal-sync-data=false");
+        waitingFor(
+                Wait.forHttp("/metrics")
+                        .forPort(METRICS_PORT)
+                        .forStatusCode(200)
+                        .withStartupTimeout(Duration.ofSeconds(30)));
+
+        PulsarContainer.configureLeaveContainerRunning(this);
+    }
+
+    public String getServiceAddress() {
+        return OxiaContainer.NAME + ":" + OXIA_PORT;
+    }
+
+    @Override
+    public String getContainerName() {
+        return clusterName + "-oxia";
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaSmokeTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaSmokeTest.java
index d060dc5208..0d9a1e11c9 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaSmokeTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/oxia/OxiaSmokeTest.java
@@ -1,48 +1,48 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.oxia;
-
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.Test;
-
-/**
- * Test pulsar produce/consume semantics.
- */
-@Slf4j
-public class OxiaSmokeTest extends PulsarTestSuite {
-
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
-            String clusterName, PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-        specBuilder.enableOxia(true);
-        return specBuilder;
-    }
-
-    //
-    // Test Basic Publish & Consume Operations
-    //
-
-    @Test(dataProvider = "ServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.oxia;
+
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.Test;
+
+/**
+ * Test pulsar produce/consume semantics.
+ */
+@Slf4j
+public class OxiaSmokeTest extends PulsarTestSuite {
+
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
+            String clusterName, PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+        specBuilder.enableOxia(true);
+        return specBuilder;
+    }
+
+    //
+    // Test Basic Publish & Consume Operations
+    //
+
+    @Test(dataProvider = "ServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestAdditionalServlets.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestAdditionalServlets.java
index a13ae917f6..938f1a2ea3 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestAdditionalServlets.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestAdditionalServlets.java
@@ -1,99 +1,99 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import java.io.IOException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.http.HttpClient;
-import java.net.http.HttpRequest;
-import java.net.http.HttpResponse;
-import java.util.Arrays;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.ProxyContainer;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-public class TestAdditionalServlets extends PulsarTestSuite {
-
-    private static final String NAME = "random";
-    private static final String PREFIX = "PULSAR_PREFIX_";
-    public static final int SEQUENCE_LENGTH = 7;
-
-    @Override
-    public void setupCluster() throws Exception {
-        brokerEnvs.put(PREFIX + "additionalServlets", NAME);
-        brokerEnvs.put(PREFIX + "additionalServletDirectory", "/pulsar/examples");
-        brokerEnvs.put(PREFIX + "randomServletSequenceLength", "" + SEQUENCE_LENGTH);
-        brokerEnvs.put(PREFIX + "narExtractionDirectory", "/tmp");
-
-        proxyEnvs.put(PREFIX + "additionalServlets", NAME);
-        proxyEnvs.put(PREFIX + "additionalServletDirectory", "/pulsar/examples");
-        proxyEnvs.put(PREFIX + "randomServletSequenceLength", "" + SEQUENCE_LENGTH);
-        proxyEnvs.put(PREFIX + "narExtractionDirectory", "/tmp");
-
-        super.setupCluster();
-    }
-
-    @Test
-    public void testBrokerAdditionalServlet() throws Exception {
-        BrokerContainer broker = getPulsarCluster().getAnyBroker();
-        String host = broker.getHost();
-        Integer httpPort = broker.getMappedPort(BrokerContainer.BROKER_HTTP_PORT);
-
-        testAddress(host, httpPort);
-    }
-
-
-    @Test
-    public void testProxyAdditionalServlet() throws Exception {
-        ProxyContainer proxy = getPulsarCluster().getProxy();
-
-        String host = proxy.getHost();
-        Integer httpPort = proxy.getMappedPort(ProxyContainer.BROKER_HTTP_PORT);
-
-        testAddress(host, httpPort);
-    }
-
-
-
-    private void testAddress(String host, Integer httpPort) throws IOException, InterruptedException,
-            URISyntaxException {
-        ExecutorService executor = null;
-        try {
-            executor = Executors.newSingleThreadExecutor();
-            HttpClient httpClient = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.ALWAYS)
-                    .executor(executor).build();
-            HttpRequest request = HttpRequest.newBuilder()
-                    .uri(new URI("http://" + host + ":" + httpPort + "/" + NAME + "/")).GET().build();
-            String response = httpClient.send(request, HttpResponse.BodyHandlers.ofString()).body();
-            Assert.assertEquals(IntStream.range(0, SEQUENCE_LENGTH).boxed().collect(Collectors.toSet()),
-                    Arrays.stream(response.split(",")).map(Integer::parseInt).collect(Collectors.toSet()));
-        } finally {
-            if (executor != null) {
-                executor.shutdown();
-            }
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+import java.util.Arrays;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.ProxyContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public class TestAdditionalServlets extends PulsarTestSuite {
+
+    private static final String NAME = "random";
+    private static final String PREFIX = "PULSAR_PREFIX_";
+    public static final int SEQUENCE_LENGTH = 7;
+
+    @Override
+    public void setupCluster() throws Exception {
+        brokerEnvs.put(PREFIX + "additionalServlets", NAME);
+        brokerEnvs.put(PREFIX + "additionalServletDirectory", "/pulsar/examples");
+        brokerEnvs.put(PREFIX + "randomServletSequenceLength", "" + SEQUENCE_LENGTH);
+        brokerEnvs.put(PREFIX + "narExtractionDirectory", "/tmp");
+
+        proxyEnvs.put(PREFIX + "additionalServlets", NAME);
+        proxyEnvs.put(PREFIX + "additionalServletDirectory", "/pulsar/examples");
+        proxyEnvs.put(PREFIX + "randomServletSequenceLength", "" + SEQUENCE_LENGTH);
+        proxyEnvs.put(PREFIX + "narExtractionDirectory", "/tmp");
+
+        super.setupCluster();
+    }
+
+    @Test
+    public void testBrokerAdditionalServlet() throws Exception {
+        BrokerContainer broker = getPulsarCluster().getAnyBroker();
+        String host = broker.getHost();
+        Integer httpPort = broker.getMappedPort(BrokerContainer.BROKER_HTTP_PORT);
+
+        testAddress(host, httpPort);
+    }
+
+
+    @Test
+    public void testProxyAdditionalServlet() throws Exception {
+        ProxyContainer proxy = getPulsarCluster().getProxy();
+
+        String host = proxy.getHost();
+        Integer httpPort = proxy.getMappedPort(ProxyContainer.BROKER_HTTP_PORT);
+
+        testAddress(host, httpPort);
+    }
+
+
+
+    private void testAddress(String host, Integer httpPort) throws IOException, InterruptedException,
+            URISyntaxException {
+        ExecutorService executor = null;
+        try {
+            executor = Executors.newSingleThreadExecutor();
+            HttpClient httpClient = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.ALWAYS)
+                    .executor(executor).build();
+            HttpRequest request = HttpRequest.newBuilder()
+                    .uri(new URI("http://" + host + ":" + httpPort + "/" + NAME + "/")).GET().build();
+            String response = httpClient.send(request, HttpResponse.BodyHandlers.ofString()).body();
+            Assert.assertEquals(IntStream.range(0, SEQUENCE_LENGTH).boxed().collect(Collectors.toSet()),
+                    Arrays.stream(response.split(",")).map(Integer::parseInt).collect(Collectors.toSet()));
+        } finally {
+            if (executor != null) {
+                executor.shutdown();
+            }
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java
index 513d77307e..8882bd7377 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestBrokerInterceptors.java
@@ -1,113 +1,113 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.ConsumerBuilder;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.Test;
-
-public class TestBrokerInterceptors extends TopicMessagingBase {
-
-    private static final String PREFIX = "PULSAR_PREFIX_";
-
-    @Override
-    public void setupCluster() throws Exception {
-        brokerEnvs.put(PREFIX + "disableBrokerInterceptors", "false");
-        brokerEnvs.put(PREFIX + "brokerInterceptorsDirectory", "/pulsar/examples");
-        brokerEnvs.put(PREFIX + "brokerInterceptors", "loggingInterceptor");
-        super.setupCluster();
-    }
-
-    @Override
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(String clusterName,
-                                      PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-        specBuilder.numBrokers(1);
-        return specBuilder;
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void test(Supplier<String> serviceUrlSupplier) throws Exception {
-        String serviceUrl = serviceUrlSupplier.get();
-
-        final String topicName = getNonPartitionedTopic("interceptorTest-topic", true);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName("producer")
-                .create();
-        int messagesToSend = 20;
-        for (int i = 0; i < messagesToSend; i++) {
-            String messageValue = producer.getProducerName() + "-" + i;
-            MessageId messageId = producer.newMessage()
-                    .value(messageValue)
-                    .send();
-            assertNotNull(messageId);
-        }
-
-        try (Consumer<String> consumer = createConsumer(client, topicName)) {
-            for (int i = 0; i < messagesToSend; ++i) {
-                consumer.receive(3, TimeUnit.SECONDS);
-            }
-        }
-
-        String log = pulsarCluster.getAnyBroker()
-                .execCmd("cat", "/var/log/pulsar/broker.log").getStdout();
-
-        for (String line : new String[]{
-                "initialize: OK",
-                "onConnectionCreated",
-                "producerCreated",
-                "consumerCreated",
-                "messageProduced",
-                "beforeSendMessage: OK",
-                "onFilter",
-        }) {
-            assertTrue(log.contains("LoggingBrokerInterceptor - " + line), "Log did not contain line '" + line + "'");
-        }
-
-    }
-
-    private Consumer<String> createConsumer(PulsarClient client, String topicName) throws Exception {
-        ConsumerBuilder<String> builder = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName(randomName(8))
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest);
-        return builder.subscribe();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerBuilder;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.Test;
+
+public class TestBrokerInterceptors extends TopicMessagingBase {
+
+    private static final String PREFIX = "PULSAR_PREFIX_";
+
+    @Override
+    public void setupCluster() throws Exception {
+        brokerEnvs.put(PREFIX + "disableBrokerInterceptors", "false");
+        brokerEnvs.put(PREFIX + "brokerInterceptorsDirectory", "/pulsar/examples");
+        brokerEnvs.put(PREFIX + "brokerInterceptors", "loggingInterceptor");
+        super.setupCluster();
+    }
+
+    @Override
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(String clusterName,
+                                      PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+        specBuilder.numBrokers(1);
+        return specBuilder;
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void test(Supplier<String> serviceUrlSupplier) throws Exception {
+        String serviceUrl = serviceUrlSupplier.get();
+
+        final String topicName = getNonPartitionedTopic("interceptorTest-topic", true);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName("producer")
+                .create();
+        int messagesToSend = 20;
+        for (int i = 0; i < messagesToSend; i++) {
+            String messageValue = producer.getProducerName() + "-" + i;
+            MessageId messageId = producer.newMessage()
+                    .value(messageValue)
+                    .send();
+            assertNotNull(messageId);
+        }
+
+        try (Consumer<String> consumer = createConsumer(client, topicName)) {
+            for (int i = 0; i < messagesToSend; ++i) {
+                consumer.receive(3, TimeUnit.SECONDS);
+            }
+        }
+
+        String log = pulsarCluster.getAnyBroker()
+                .execCmd("cat", "/var/log/pulsar/broker.log").getStdout();
+
+        for (String line : new String[]{
+                "initialize: OK",
+                "onConnectionCreated",
+                "producerCreated",
+                "consumerCreated",
+                "messageProduced",
+                "beforeSendMessage: OK",
+                "onFilter",
+        }) {
+            assertTrue(log.contains("LoggingBrokerInterceptor - " + line), "Log did not contain line '" + line + "'");
+        }
+
+    }
+
+    private Consumer<String> createConsumer(PulsarClient client, String topicName) throws Exception {
+        ConsumerBuilder<String> builder = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName(randomName(8))
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest);
+        return builder.subscribe();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestEntryFilters.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestEntryFilters.java
index 1da3dacda8..db754b214d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestEntryFilters.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestEntryFilters.java
@@ -1,98 +1,98 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import static org.testng.Assert.assertNotNull;
-import java.util.Collections;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.ConsumerBuilder;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
-import org.testng.annotations.Test;
-
-public class TestEntryFilters extends TopicMessagingBase {
-
-    private static final String PREFIX = "PULSAR_PREFIX_";
-
-    @Override
-    public void setupCluster() throws Exception {
-        brokerEnvs.put(PREFIX + "entryFilterNames", "pattern_filter");
-        brokerEnvs.put(PREFIX + "entryFiltersDirectory", "/pulsar/examples");
-        super.setupCluster();
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void test(Supplier<String> serviceUrlSupplier) throws Exception {
-        String serviceUrl = serviceUrlSupplier.get();
-
-        final String topicName = getNonPartitionedTopic("filtered-topic", true);
-        @Cleanup
-        final PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-
-        String evenPattern = "^[a-z]+-\\d*[02468]$";
-
-        @Cleanup
-        final Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .enableBatching(false)
-                .producerName("producer")
-                .create();
-        int messagesToSend = 20;
-        for (int i = 0; i < messagesToSend; i++) {
-            String messageValue = producer.getProducerName() + "-" + i;
-            MessageId messageId = producer.newMessage()
-                    .value(messageValue)
-                    .property("filter_property", messageValue)
-                    .send();
-            assertNotNull(messageId);
-        }
-
-        try (Consumer<String> consumer = createConsumer(client, topicName, evenPattern)) {
-            receiveMessagesCheckOrderAndDuplicate(Collections.singletonList(consumer), messagesToSend / 2);
-
-        }
-        try (Consumer<String> consumer = createConsumer(client, topicName, null)) {
-            receiveMessagesCheckOrderAndDuplicate(Collections.singletonList(consumer), messagesToSend);
-
-        }
-    }
-
-    private Consumer<String> createConsumer(
-            PulsarClient client, String topicName, String filterPattern) throws Exception {
-        ConsumerBuilder<String> builder = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName(randomName(8))
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest);
-        if (filterPattern != null) {
-                builder.subscriptionProperties(Collections.singletonMap("entry_filter_pattern", filterPattern));
-        }
-        return builder.subscribe();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import static org.testng.Assert.assertNotNull;
+import java.util.Collections;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerBuilder;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.integration.messaging.TopicMessagingBase;
+import org.testng.annotations.Test;
+
+public class TestEntryFilters extends TopicMessagingBase {
+
+    private static final String PREFIX = "PULSAR_PREFIX_";
+
+    @Override
+    public void setupCluster() throws Exception {
+        brokerEnvs.put(PREFIX + "entryFilterNames", "pattern_filter");
+        brokerEnvs.put(PREFIX + "entryFiltersDirectory", "/pulsar/examples");
+        super.setupCluster();
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void test(Supplier<String> serviceUrlSupplier) throws Exception {
+        String serviceUrl = serviceUrlSupplier.get();
+
+        final String topicName = getNonPartitionedTopic("filtered-topic", true);
+        @Cleanup
+        final PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+
+        String evenPattern = "^[a-z]+-\\d*[02468]$";
+
+        @Cleanup
+        final Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .enableBatching(false)
+                .producerName("producer")
+                .create();
+        int messagesToSend = 20;
+        for (int i = 0; i < messagesToSend; i++) {
+            String messageValue = producer.getProducerName() + "-" + i;
+            MessageId messageId = producer.newMessage()
+                    .value(messageValue)
+                    .property("filter_property", messageValue)
+                    .send();
+            assertNotNull(messageId);
+        }
+
+        try (Consumer<String> consumer = createConsumer(client, topicName, evenPattern)) {
+            receiveMessagesCheckOrderAndDuplicate(Collections.singletonList(consumer), messagesToSend / 2);
+
+        }
+        try (Consumer<String> consumer = createConsumer(client, topicName, null)) {
+            receiveMessagesCheckOrderAndDuplicate(Collections.singletonList(consumer), messagesToSend);
+
+        }
+    }
+
+    private Consumer<String> createConsumer(
+            PulsarClient client, String topicName, String filterPattern) throws Exception {
+        ConsumerBuilder<String> builder = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName(randomName(8))
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest);
+        if (filterPattern != null) {
+                builder.subscriptionProperties(Collections.singletonMap("entry_filter_pattern", filterPattern));
+        }
+        return builder.subscribe();
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestProtocolHandlers.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestProtocolHandlers.java
index 8cb2c7dcdd..547f248ae4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestProtocolHandlers.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/plugins/TestProtocolHandlers.java
@@ -1,69 +1,69 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.plugins;
-
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-
-public class TestProtocolHandlers extends PulsarTestSuite {
-
-    private static final Logger LOG = LoggerFactory.getLogger(TestProtocolHandlers.class);
-
-    private static final int PORT = 55000;
-    private static final String PREFIX = "PULSAR_PREFIX_";
-    public static final int DATA_LENGTH = 127;
-
-    @Override
-    public void setupCluster() throws Exception {
-        brokerEnvs.put(PREFIX + "messagingProtocols", "echo");
-        brokerEnvs.put(PREFIX + "protocolHandlerDirectory", "/pulsar/examples");
-        brokerEnvs.put(PREFIX + "echoServerPort", "" + PORT);
-        brokerAdditionalPorts.add(PORT);
-        super.setupCluster();
-    }
-
-    @Test
-    public void test() throws Exception {
-        BrokerContainer broker = pulsarCluster.getAnyBroker();
-        String host = broker.getHost();
-        String data = randomName(DATA_LENGTH);
-        int mappedPort = broker.getMappedPort(PORT);
-        LOG.debug("Sending data to {}:{}", host, mappedPort);
-        try (Socket client = new Socket(host, mappedPort);
-             OutputStream out = client.getOutputStream();
-             InputStream in = client.getInputStream()) {
-            LOG.debug("Connection established");
-            out.write(data.getBytes());
-            LOG.debug("Data sent");
-            byte[] response = in.readNBytes(DATA_LENGTH);
-            Assert.assertEquals(new String(response), data);
-        }
-    }
-
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.plugins;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+
+public class TestProtocolHandlers extends PulsarTestSuite {
+
+    private static final Logger LOG = LoggerFactory.getLogger(TestProtocolHandlers.class);
+
+    private static final int PORT = 55000;
+    private static final String PREFIX = "PULSAR_PREFIX_";
+    public static final int DATA_LENGTH = 127;
+
+    @Override
+    public void setupCluster() throws Exception {
+        brokerEnvs.put(PREFIX + "messagingProtocols", "echo");
+        brokerEnvs.put(PREFIX + "protocolHandlerDirectory", "/pulsar/examples");
+        brokerEnvs.put(PREFIX + "echoServerPort", "" + PORT);
+        brokerAdditionalPorts.add(PORT);
+        super.setupCluster();
+    }
+
+    @Test
+    public void test() throws Exception {
+        BrokerContainer broker = pulsarCluster.getAnyBroker();
+        String host = broker.getHost();
+        String data = randomName(DATA_LENGTH);
+        int mappedPort = broker.getMappedPort(PORT);
+        LOG.debug("Sending data to {}:{}", host, mappedPort);
+        try (Socket client = new Socket(host, mappedPort);
+             OutputStream out = client.getOutputStream();
+             InputStream in = client.getInputStream()) {
+            LOG.debug("Connection established");
+            out.write(data.getBytes());
+            LOG.debug("Data sent");
+            byte[] response = in.readNBytes(DATA_LENGTH);
+            Assert.assertEquals(new String(response), data);
+        }
+    }
+
+
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/profiling/PulsarProfilingTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/profiling/PulsarProfilingTest.java
new file mode 100644
index 0000000000..d12fe09d15
--- /dev/null
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/profiling/PulsarProfilingTest.java
@@ -0,0 +1,324 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.profiling;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Files;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.common.util.FutureUtil;
+import org.apache.pulsar.tests.ManualTestUtil;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.utils.DockerUtils;
+import org.testcontainers.containers.BindMode;
+import org.testcontainers.containers.GenericContainer;
+import org.testng.annotations.Test;
+
+/**
+ * Sample test that profiles the broker side with Async Profiler.
+ *
+ * Example usage:
+ * # This has been tested on Mac with Orbstack (https://orbstack.dev/) docker
+ * # compile integration test dependencies
+ * mvn -am -pl tests/integration -Dcheckstyle.skip=true -Dlicense.skip=true -Dspotbugs.skip=true -DskipTests install
+ * # compile apachepulsar/java-test-image with async profiler (add "clean" to ensure a clean build with recent changes)
+ * ./build/build_java_test_image.sh -Ddocker.install.asyncprofiler=true -Pdocker-wolfi
+ * # set environment variables
+ * export PULSAR_TEST_IMAGE_NAME=apachepulsar/java-test-image:latest
+ * export NETTY_LEAK_DETECTION=off
+ * export ENABLE_MANUAL_TEST=true
+ * # enable perf events for profiling and tune it
+ * docker run --rm -it --privileged --cap-add SYS_ADMIN --security-opt seccomp=unconfined \
+ *   alpine sh -c "echo 1 > /proc/sys/kernel/perf_event_paranoid \
+ *   && echo 0 > /proc/sys/kernel/kptr_restrict \
+ *   && echo 1024 > /proc/sys/kernel/perf_event_max_stack \
+ *   && echo 2048 > /proc/sys/kernel/perf_event_mlock_kb"
+ * # translated to sysctl settings (for persistent configuration on Linux hosts)
+ * kernel.perf_event_paranoid=1
+ * kernel.kptr_restrict=0
+ * kernel.perf_event_max_stack=1024
+ * kernel.perf_event_mlock_kb=2048
+ * # run the test
+ * mvn -DintegrationTests -pl tests/integration -Dtest=PulsarProfilingTest -DtestRetryCount=0 \
+ *   -DredirectTestOutputToFile=false test
+ * By default, the .jfr files will go into tests/integration/target
+ * You can use jfrconv from async profiler to convert them into html flamegraphs or use other tools such
+ * as Eclipse Mission Control (https://adoptium.net/jmc) or IntelliJ to open them.
+ */
+@Slf4j
+public class PulsarProfilingTest extends PulsarTestSuite {
+    // this assumes that Transparent Huge Pages are available on the host machine
+    // Please notice that "madvise" mode is recommended for performance reasons.
+    // For example:
+    // echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled
+    // echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/defrag
+    // More info about -XX:+UseTransparentHugePages at
+    // https://shipilev.net/jvm/anatomy-quarks/2-transparent-huge-pages/
+    private static final String DEFAULT_PULSAR_MEM = "-Xms512m -Xmx1g -XX:+UseTransparentHugePages -XX:+AlwaysPreTouch";
+    private static final String BROKER_PULSAR_MEM = "-Xms2g -Xmx2g -XX:+UseTransparentHugePages -XX:+AlwaysPreTouch";
+
+    // A container that runs pulsar-perf, arguments are currently hard-coded since this is an example
+    static class PulsarPerfContainer extends GenericContainer<PulsarPerfContainer> {
+        private final String brokerHostname;
+        private final long numberOfMessages = 100_000_000;
+
+        public PulsarPerfContainer(String clusterName,
+                                   String brokerHostname,
+                                   String hostname) {
+            super(PulsarContainer.DEFAULT_IMAGE_NAME);
+            this.brokerHostname = brokerHostname;
+            withCreateContainerCmdModifier(createContainerCmd -> {
+                createContainerCmd.withHostName(hostname);
+                createContainerCmd.withName(clusterName + "-" + hostname);
+            });
+            withEnv("PULSAR_MEM", DEFAULT_PULSAR_MEM);
+            withEnv("PULSAR_GC", "-XX:+UseZGC -XX:+ZGenerational");
+            setCommand("sleep 1000000");
+            File testOutputDir = new File("target");
+            if (!testOutputDir.exists()) {
+                if (!testOutputDir.mkdirs()) {
+                    throw new IllegalArgumentException("Test output directory + '" + testOutputDir.getAbsolutePath()
+                                    + "' doesn't exist and cannot be created.");
+                }
+            }
+            if (!testOutputDir.isDirectory()) {
+                throw new IllegalArgumentException(
+                        "Test output directory '" + testOutputDir.getAbsolutePath() + "' isn't a directory.");
+            }
+            // change access to testOutputDir to allow all access so the the container user can write to it
+            // This matters only on Linux
+            try {
+                Files.setPosixFilePermissions(testOutputDir.toPath(), PosixFilePermissions.fromString("rwxrwxrwx"));
+            } catch (IOException e) {
+                throw new UncheckedIOException("Cannot change access to test output directory", e);
+            }
+            withFileSystemBind(testOutputDir.getAbsolutePath(), "/testoutput", BindMode.READ_WRITE);
+        }
+
+        public CompletableFuture<Long> consume(String topicName) throws Exception {
+            return DockerUtils.runCommandAsyncWithLogging(getDockerClient(), getContainerId(),
+                    "bash", "-c", "echo $$ > /tmp/command.pid; "
+                            + "/pulsar/bin/pulsar-perf consume " + topicName + " "
+                            + "-u pulsar://" + brokerHostname + ":6650 "
+                            + "-st Shared "
+                            + "-q 50000 "
+                            + "-m " + numberOfMessages + " -ml 400M "
+                            + "--histogram-file=/testoutput/consume.histogram.$(date +%s).hdr "
+                            + "2>&1 | tee /testoutput/consume.$(date +%s).txt");
+        }
+
+        public CompletableFuture<Long> produce(String topicName) throws Exception {
+            return DockerUtils.runCommandAsyncWithLogging(getDockerClient(), getContainerId(),
+                    "bash", "-c", "echo $$ > /tmp/command.pid; "
+                            + "/pulsar/bin/pulsar-perf produce " + topicName + " "
+                            + "-u pulsar://" + brokerHostname + ":6650 "
+                            + "-au http://" + brokerHostname + ":8080 "
+                            + "-r " + Integer.MAX_VALUE + " "
+                            + "-s 128 -db "
+                            + "-o 20000 "
+                            + "-m " + numberOfMessages + " -ml 400M "
+                            + "--histogram-file=/testoutput/produce.histogram.$(date +%s).hdr "
+                            + "2>&1 | tee /testoutput/produce.$(date +%s).txt");
+        }
+
+        public CompletableFuture<Long> stats(String topicName) throws Exception {
+            String basePath = "http://" + brokerHostname + ":8080/admin/v2/" + topicName.replace("://", "/");
+            // print out stats and internal stats every 10 seconds
+            return DockerUtils.runCommandAsyncWithLogging(getDockerClient(), getContainerId(),
+                    "bash", "-c",
+                    String.format("echo $$ > /tmp/command.pid; "
+                            + "while [[ 1 ]]; do "
+                            + "curl -s %s/stats | jq | tee /testoutput/stats.$(date +%%s).txt; "
+                            + "sleep 1; "
+                            + "curl -s %s/internalStats | jq | tee /testoutput/internal_stats.$(date +%%s).txt; "
+                            + "curl -s http://%s:8080/metrics/ > /testoutput/metrics.$(date +%%s).txt; "
+                            + " sleep 10; "
+                            + "done",
+                            basePath, basePath, brokerHostname));
+        }
+
+        public void triggerShutdown() {
+            if (isRunning()) {
+                // attempt to stop containers gracefully
+                DockerUtils.runCommandAsyncWithLogging(getDockerClient(), getContainerId(),
+                                "bash", "-c", "pkill java; while pgrep -c java; do "
+                                        + "echo Waiting for java processes to stop.; sleep 1; done; "
+                                        + "kill $(cat /tmp/command.pid)")
+                        .orTimeout(10, TimeUnit.SECONDS)
+                        .exceptionally(t -> null)
+                        .join();
+            }
+        }
+
+        public void stop() {
+            if (isRunning()) {
+                // attempt to stop containers gracefully
+                dockerClient.stopContainerCmd(getContainerId())
+                        .withTimeout(15)
+                        .exec();
+            }
+            super.stop();
+        }
+    }
+
+    private PulsarPerfContainer perfConsume;
+    private PulsarPerfContainer perfProduce;
+    private PulsarPerfContainer printStats;
+
+    @Override
+    public void setupCluster() throws Exception {
+        ManualTestUtil.skipManualTestIfNotEnabled();
+        super.setupCluster();
+    }
+
+    @Override
+    public void tearDownCluster() throws Exception {
+        if (printStats != null) {
+            printStats.triggerShutdown();
+        }
+        if (perfProduce != null) {
+            perfProduce.triggerShutdown();
+        }
+        if (perfConsume != null) {
+            perfConsume.triggerShutdown();
+        }
+        if (printStats != null) {
+            printStats.stop();
+            printStats = null;
+        }
+        if (perfProduce != null) {
+            perfProduce.stop();
+            perfProduce = null;
+        }
+        if (perfConsume != null) {
+            perfConsume.stop();
+            perfConsume = null;
+        }
+        super.tearDownCluster();
+    }
+
+    @Override
+    protected void beforeStartCluster() throws Exception {
+        super.beforeStartCluster();
+        pulsarCluster.forEachContainer(
+                // This is effective only when -Pdocker-wolfi has been passed when building java-test-image
+                // setting mmap_threshold explicitly will avoid it's dynamic increase
+                // https://sourceware.org/glibc/manual/latest/html_node/Memory-Allocation-Tunables.html
+                c -> c.withEnv("GLIBC_TUNABLES",
+                        "glibc.malloc.hugetlb=1:glibc.malloc.mmap_threshold=131072:glibc.malloc.arena_max=4"));
+    }
+
+    @Override
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(String clusterName,
+        PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+
+        // Enable profiling on the broker
+        specBuilder.profileBroker(true);
+
+        // Only run one broker so that all load goes to a single broker
+        specBuilder.numBrokers(1);
+        // Have 3 bookies to reduce bottleneck on bookie
+        specBuilder.numBookies(3);
+        // no need for proxy
+        specBuilder.numProxies(0);
+
+        // Increase memory for brokers and configure more aggressive rollover
+        Map<String, String> brokerEnvs = new HashMap<>();
+        brokerEnvs.put("PULSAR_MEM", BROKER_PULSAR_MEM);
+        brokerEnvs.put("managedLedgerMinLedgerRolloverTimeMinutes", "1");
+        brokerEnvs.put("managedLedgerMaxLedgerRolloverTimeMinutes", "5");
+        brokerEnvs.put("managedLedgerMaxSizePerLedgerMbytes", "512");
+        brokerEnvs.put("managedLedgerDefaultEnsembleSize", "1");
+        brokerEnvs.put("managedLedgerDefaultWriteQuorum", "1");
+        brokerEnvs.put("managedLedgerDefaultAckQuorum", "1");
+        //brokerEnvs.put("maxPendingPublishRequestsPerConnection", "1000");
+        brokerEnvs.put("dispatcherRetryBackoffInitialTimeInMs", "0");
+        brokerEnvs.put("dispatcherRetryBackoffMaxTimeInMs", "0");
+        brokerEnvs.put("preciseDispatcherFlowControl", "true");
+        //brokerEnvs.put("PULSAR_PREFIX_subscriptionKeySharedUseClassicPersistentImplementation", "true");
+        //brokerEnvs.put("PULSAR_PREFIX_subscriptionSharedUseClassicPersistentImplementation", "true");
+        brokerEnvs.put("dispatcherMaxReadBatchSize", "1000");
+        //brokerEnvs.put("dispatcherMaxReadSizeBytes", "10000000");
+        //brokerEnvs.put("dispatcherDispatchMessagesInSubscriptionThread", "false");
+        //brokerEnvs.put("dispatcherMaxRoundRobinBatchSize", "1000");
+        specBuilder.brokerEnvs(brokerEnvs);
+
+        // Increase memory for bookkeepers and make compaction run more often
+        Map<String, String> bkEnv = new HashMap<>();
+        bkEnv.put("PULSAR_MEM", DEFAULT_PULSAR_MEM);
+        bkEnv.put("dbStorage_writeCacheMaxSizeMb", "64");
+        bkEnv.put("dbStorage_readAheadCacheMaxSizeMb", "96");
+        bkEnv.put("journalMaxSizeMB", "256");
+        bkEnv.put("journalSyncData", "false");
+        bkEnv.put("majorCompactionInterval", "300");
+        bkEnv.put("minorCompactionInterval", "30");
+        bkEnv.put("compactionRateByEntries", "20000");
+        bkEnv.put("gcWaitTime", "30000");
+        bkEnv.put("isForceGCAllowWhenNoSpace", "true");
+        bkEnv.put("diskUsageLwmThreshold", "0.75");
+        bkEnv.put("diskCheckInterval", "60");
+        specBuilder.bookkeeperEnvs(bkEnv);
+
+        // Create pulsar-perf containers
+        String brokerHostname = clusterName + "-pulsar-broker-0";
+        perfProduce = new PulsarPerfContainer(clusterName, brokerHostname, "perf-produce");
+        perfConsume = new PulsarPerfContainer(clusterName, brokerHostname, "perf-consume");
+        printStats = new PulsarPerfContainer(clusterName, brokerHostname, "print-stats");
+        specBuilder.externalServices(Map.of(
+                "pulsar-produce", perfProduce,
+                "pulsar-consume", perfConsume,
+                "print-stats", printStats
+        ));
+
+        return specBuilder;
+    }
+
+    @Test(timeOut = 600_000)
+    public void runPulsarPerf() throws Exception {
+        String topicName = generateTopicName("profiletest", true);
+        CompletableFuture<Long> consumeFuture = perfConsume.consume(topicName);
+        Thread.sleep(1000);
+        CompletableFuture<Long> produceFuture = perfProduce.produce(topicName);
+        Thread.sleep(4000);
+        printStats.stats(topicName);
+        FutureUtil.waitForAll(List.of(consumeFuture, produceFuture))
+                .orTimeout(3, TimeUnit.MINUTES)
+                .exceptionally(t -> {
+                    if (FutureUtil.unwrapCompletionException(t) instanceof TimeoutException) {
+                        // ignore test timeout
+                        log.info("Test timed out, ignoring this in profiling.");
+                        return null;
+                    } else {
+                        log.error("Failed to run pulsar-perf", t);
+                    }
+                    throw FutureUtil.wrapToCompletionException(t);
+                })
+                .get();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/proxy/TestProxy.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/proxy/TestProxy.java
index 11019b27e0..ad838d6d5f 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/proxy/TestProxy.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/proxy/TestProxy.java
@@ -1,122 +1,122 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.proxy;
-
-import static org.testng.Assert.assertEquals;
-import java.util.Collections;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.common.policies.data.TopicStats;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.annotations.Test;
-
-/**
- * Test cases for proxy.
- */
-public class TestProxy extends PulsarTestSuite {
-    private static final Logger log = LoggerFactory.getLogger(TestProxy.class);
-
-    @Override
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
-            String clusterName,
-            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-        return super.beforeSetupCluster(clusterName, specBuilder);
-    }
-
-    private void testProxy(String serviceUrl, String httpServiceUrl) throws Exception {
-        final String tenant = "proxy-test-" + randomName(10);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-            .serviceHttpUrl(httpServiceUrl)
-            .build();
-
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(Collections.emptySet(), Collections.singleton(pulsarCluster.getClusterName())));
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(serviceUrl)
-            .build();
-
-        client.newConsumer()
-                .topic(topic)
-                .subscriptionName("sub1")
-                .subscribe()
-                .close();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topic)
-                .create();
-        producer.send("content-0");
-        producer.send("content-1");
-
-        for (int i = 0; i < 10; i++) {
-            // Ensure we can get the stats for the topic irrespective of which broker the proxy decides to connect to
-            TopicStats stats = admin.topics().getStats(topic);
-            assertEquals(stats.getPublishers().size(), 1);
-        }
-    }
-
-    @Test
-    public void testProxyWithServiceDiscovery() throws Exception {
-        testProxy(pulsarCluster.getPlainTextServiceUrl(), pulsarCluster.getHttpServiceUrl());
-    }
-
-    @Test
-    public void testProxyWithNoServiceDiscoveryProxyConnectsViaURL() throws Exception {
-        testProxy(pulsarCluster.getProxy().getPlainTextServiceUrl(), pulsarCluster.getProxy().getHttpServiceUrl());
-    }
-
-    @Test
-    public void testProxyRequestBodyRedirect() throws Exception {
-        // See GH issue #5360, this ensures that we properly get a request with a body to be processed
-        final String tenant = "proxy-test-" + randomName(10);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/topic1";
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getProxy().getHttpServiceUrl())
-                .build();
-
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(Collections.emptySet(), Collections.singleton(pulsarCluster.getClusterName())));
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-
-        for (int i = 0; i < 10; i++) {
-            // Ensure we the command works even if re-directs happen with a request body
-            admin.topics().createSubscription(topic, "test-" + i, MessageId.earliest);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.proxy;
+
+import static org.testng.Assert.assertEquals;
+import java.util.Collections;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.common.policies.data.TopicStats;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.Test;
+
+/**
+ * Test cases for proxy.
+ */
+public class TestProxy extends PulsarTestSuite {
+    private static final Logger log = LoggerFactory.getLogger(TestProxy.class);
+
+    @Override
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
+            String clusterName,
+            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+        return super.beforeSetupCluster(clusterName, specBuilder);
+    }
+
+    private void testProxy(String serviceUrl, String httpServiceUrl) throws Exception {
+        final String tenant = "proxy-test-" + randomName(10);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+            .serviceHttpUrl(httpServiceUrl)
+            .build();
+
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(Collections.emptySet(), Collections.singleton(pulsarCluster.getClusterName())));
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(serviceUrl)
+            .build();
+
+        client.newConsumer()
+                .topic(topic)
+                .subscriptionName("sub1")
+                .subscribe()
+                .close();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topic)
+                .create();
+        producer.send("content-0");
+        producer.send("content-1");
+
+        for (int i = 0; i < 10; i++) {
+            // Ensure we can get the stats for the topic irrespective of which broker the proxy decides to connect to
+            TopicStats stats = admin.topics().getStats(topic);
+            assertEquals(stats.getPublishers().size(), 1);
+        }
+    }
+
+    @Test
+    public void testProxyWithServiceDiscovery() throws Exception {
+        testProxy(pulsarCluster.getPlainTextServiceUrl(), pulsarCluster.getHttpServiceUrl());
+    }
+
+    @Test
+    public void testProxyWithNoServiceDiscoveryProxyConnectsViaURL() throws Exception {
+        testProxy(pulsarCluster.getProxy().getPlainTextServiceUrl(), pulsarCluster.getProxy().getHttpServiceUrl());
+    }
+
+    @Test
+    public void testProxyRequestBodyRedirect() throws Exception {
+        // See GH issue #5360, this ensures that we properly get a request with a body to be processed
+        final String tenant = "proxy-test-" + randomName(10);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/topic1";
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getProxy().getHttpServiceUrl())
+                .build();
+
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(Collections.emptySet(), Collections.singleton(pulsarCluster.getClusterName())));
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+
+        for (int i = 0; i < 10; i++) {
+            // Ensure we the command works even if re-directs happen with a request body
+            admin.topics().createSubscription(topic, "test-" + i, MessageId.earliest);
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/python/PythonSchemaTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/python/PythonSchemaTest.java
index 165b8407a1..7a90db5ce4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/python/PythonSchemaTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/python/PythonSchemaTest.java
@@ -1,122 +1,122 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.python;
-
-import static org.testng.Assert.assertEquals;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import lombok.Data;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.annotations.Test;
-
-/**
- * Test pulsar Python/Java schema interoperability.
- */
-public class PythonSchemaTest extends PulsarTestSuite {
-
-    @Data
-    static class Example1 {
-        private Integer x;
-        private Long y;
-    }
-
-    @Data
-    static class Example2 {
-        private String a;
-        private int b;
-    }
-
-    /**
-     * Publish from Java and consume from Python.
-     */
-    @Test(dataProvider = "ServiceUrls")
-    public void testJavaPublishPythonConsume(Supplier<String> serviceUrl) throws Exception {
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-
-        String topicName = generateTopicName(nsName, "testJavaPublishPythonConsume", true);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl.get())
-                .build();
-
-        // Create subscription to retain data
-        client.newConsumer(Schema.JSON(Example1.class))
-                .topic(topicName)
-                .subscriptionName("my-subscription")
-                .subscribe()
-                .close();
-
-        @Cleanup
-        Producer<Example1> producer = client.newProducer(Schema.JSON(Example1.class))
-                .topic(topicName)
-                .create();
-
-        Example1 e1 = new Example1();
-        e1.setX(1);
-        e1.setY(2L);
-        producer.send(e1);
-
-        // Verify Python can receive the typed message
-
-        ContainerExecResult res = pulsarCluster.getAnyBroker()
-                .execCmd("/pulsar/examples/python-examples/consumer_schema.py", "pulsar://localhost:6650", topicName);
-        assertEquals(res.getExitCode(), 0);
-    }
-
-    /**
-     * Publish from Java and consume from Python.
-     */
-    @Test(dataProvider = "ServiceUrls")
-    public void testPythonPublishJavaConsume(Supplier<String> serviceUrl) throws Exception {
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-
-        String topicName = generateTopicName(nsName, "testPythonPublishJavaConsume", true);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl.get())
-                .build();
-
-        @Cleanup
-        Consumer<Example2> consumer = client.newConsumer(Schema.AVRO(Example2.class))
-                .topic(topicName)
-                .subscriptionName("test-sub")
-                .subscribe();
-
-        // Verify Python can receive the typed message
-
-        ContainerExecResult res = pulsarCluster.getAnyBroker()
-                .execCmd("/pulsar/examples/python-examples/producer_schema.py", "pulsar://localhost:6650", topicName);
-        assertEquals(res.getExitCode(), 0);
-
-        Message<Example2> msg = consumer.receive();
-        Example2 e2 = msg.getValue();
-        assertEquals(e2.a, "Hello");
-        assertEquals(e2.b, 1);
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.python;
+
+import static org.testng.Assert.assertEquals;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import lombok.Data;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.annotations.Test;
+
+/**
+ * Test pulsar Python/Java schema interoperability.
+ */
+public class PythonSchemaTest extends PulsarTestSuite {
+
+    @Data
+    static class Example1 {
+        private Integer x;
+        private Long y;
+    }
+
+    @Data
+    static class Example2 {
+        private String a;
+        private int b;
+    }
+
+    /**
+     * Publish from Java and consume from Python.
+     */
+    @Test(dataProvider = "ServiceUrls")
+    public void testJavaPublishPythonConsume(Supplier<String> serviceUrl) throws Exception {
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+
+        String topicName = generateTopicName(nsName, "testJavaPublishPythonConsume", true);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl.get())
+                .build();
+
+        // Create subscription to retain data
+        client.newConsumer(Schema.JSON(Example1.class))
+                .topic(topicName)
+                .subscriptionName("my-subscription")
+                .subscribe()
+                .close();
+
+        @Cleanup
+        Producer<Example1> producer = client.newProducer(Schema.JSON(Example1.class))
+                .topic(topicName)
+                .create();
+
+        Example1 e1 = new Example1();
+        e1.setX(1);
+        e1.setY(2L);
+        producer.send(e1);
+
+        // Verify Python can receive the typed message
+
+        ContainerExecResult res = pulsarCluster.getAnyBroker()
+                .execCmd("/pulsar/examples/python-examples/consumer_schema.py", "pulsar://localhost:6650", topicName);
+        assertEquals(res.getExitCode(), 0);
+    }
+
+    /**
+     * Publish from Java and consume from Python.
+     */
+    @Test(dataProvider = "ServiceUrls")
+    public void testPythonPublishJavaConsume(Supplier<String> serviceUrl) throws Exception {
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+
+        String topicName = generateTopicName(nsName, "testPythonPublishJavaConsume", true);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl.get())
+                .build();
+
+        @Cleanup
+        Consumer<Example2> consumer = client.newConsumer(Schema.AVRO(Example2.class))
+                .topic(topicName)
+                .subscriptionName("test-sub")
+                .subscribe();
+
+        // Verify Python can receive the typed message
+
+        ContainerExecResult res = pulsarCluster.getAnyBroker()
+                .execCmd("/pulsar/examples/python-examples/producer_schema.py", "pulsar://localhost:6650", topicName);
+        assertEquals(res.getExitCode(), 0);
+
+        Message<Example2> msg = consumer.receive();
+        Example2 e2 = msg.getValue();
+        assertEquals(e2.a, "Hello");
+        assertEquals(e2.b, 1);
+    }
 }
\ No newline at end of file
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/JodaTimeTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/JodaTimeTest.java
index 83205b273d..504317607f 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/JodaTimeTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/JodaTimeTest.java
@@ -1,138 +1,138 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.schema;
-
-import static org.apache.pulsar.common.naming.TopicName.PUBLIC_TENANT;
-import static org.testng.Assert.assertEquals;
-import com.google.common.collect.Sets;
-import java.math.BigDecimal;
-import java.time.LocalDate;
-import java.time.LocalTime;
-import java.time.temporal.ChronoUnit;
-import lombok.Data;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.common.naming.TopicDomain;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.joda.time.DateTime;
-import org.joda.time.chrono.ISOChronology;
-import org.testng.annotations.Test;
-
-@Slf4j
-public class JodaTimeTest extends PulsarTestSuite {
-
-    private PulsarClient client;
-    private PulsarAdmin admin;
-
-    public void setupCluster() throws Exception {
-        super.setupCluster();
-        this.client = PulsarClient.builder()
-                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-                .build();
-        this.admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-                .build();
-    }
-
-    @Override
-    public void tearDownCluster() throws Exception {
-        if (client != null) {
-            client.close();
-        }
-        if (admin != null) {
-            admin.close();
-        }
-        super.tearDownCluster();
-    }
-
-    @Data
-    private static class JodaSchema {
-
-        @org.apache.avro.reflect.AvroSchema("{\n"
-                + "  \"type\": \"bytes\",\n"
-                + "  \"logicalType\": \"decimal\",\n"
-                + "  \"precision\": 4,\n"
-                + "  \"scale\": 2\n"
-                + "}")
-        BigDecimal decimal;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"date\"}")
-        LocalDate date;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}")
-        DateTime timestampMillis;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"time-millis\"}")
-        LocalTime timeMillis;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-micros\"}")
-        long timestampMicros;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"time-micros\"}")
-        long timeMicros;
-    }
-
-    @Test
-    public void testJodaTime() throws PulsarAdminException, PulsarClientException {
-        final String tenant = PUBLIC_TENANT;
-        final String namespace = "test-namespace-" + randomName(16);
-        final String topic = "test-joda-time-schema";
-        final String fqtn = TopicName.get(
-                TopicDomain.persistent.value(),
-                tenant,
-                namespace,
-                topic
-        ).toString();
-
-        admin.namespaces().createNamespace(
-                tenant + "/" + namespace,
-                Sets.newHashSet(pulsarCluster.getClusterName())
-        );
-
-        JodaSchema forSend = new JodaSchema();
-        forSend.setDecimal(new BigDecimal("12.34"));
-        forSend.setTimeMicros(System.currentTimeMillis() * 1000);
-        forSend.setTimestampMillis(new DateTime("2019-03-26T04:39:58.469Z", ISOChronology.getInstanceUTC()));
-        forSend.setTimeMillis(LocalTime.now().truncatedTo(ChronoUnit.MILLIS));
-        forSend.setTimeMicros(System.currentTimeMillis() * 1000);
-        forSend.setDate(LocalDate.now());
-
-        Producer<JodaSchema> producer = client
-                .newProducer(Schema.AVRO(JodaSchema.class))
-                .topic(fqtn)
-                .create();
-
-        Consumer<JodaSchema> consumer = client
-                .newConsumer(Schema.AVRO(JodaSchema.class))
-                .topic(fqtn)
-                .subscriptionName("test")
-                .subscribe();
-
-        producer.send(forSend);
-        JodaSchema received = consumer.receive().getValue();
-        assertEquals(received, forSend);
-
-        producer.close();
-        consumer.close();
-
-        log.info("Successfully Joda time logical type message : {}", received);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.schema;
+
+import static org.apache.pulsar.common.naming.TopicName.PUBLIC_TENANT;
+import static org.testng.Assert.assertEquals;
+import com.google.common.collect.Sets;
+import java.math.BigDecimal;
+import java.time.LocalDate;
+import java.time.LocalTime;
+import java.time.temporal.ChronoUnit;
+import lombok.Data;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.common.naming.TopicDomain;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.joda.time.DateTime;
+import org.joda.time.chrono.ISOChronology;
+import org.testng.annotations.Test;
+
+@Slf4j
+public class JodaTimeTest extends PulsarTestSuite {
+
+    private PulsarClient client;
+    private PulsarAdmin admin;
+
+    public void setupCluster() throws Exception {
+        super.setupCluster();
+        this.client = PulsarClient.builder()
+                .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+                .build();
+        this.admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+                .build();
+    }
+
+    @Override
+    public void tearDownCluster() throws Exception {
+        if (client != null) {
+            client.close();
+        }
+        if (admin != null) {
+            admin.close();
+        }
+        super.tearDownCluster();
+    }
+
+    @Data
+    private static class JodaSchema {
+
+        @org.apache.avro.reflect.AvroSchema("{\n"
+                + "  \"type\": \"bytes\",\n"
+                + "  \"logicalType\": \"decimal\",\n"
+                + "  \"precision\": 4,\n"
+                + "  \"scale\": 2\n"
+                + "}")
+        BigDecimal decimal;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"date\"}")
+        LocalDate date;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}")
+        DateTime timestampMillis;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"time-millis\"}")
+        LocalTime timeMillis;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-micros\"}")
+        long timestampMicros;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"time-micros\"}")
+        long timeMicros;
+    }
+
+    @Test
+    public void testJodaTime() throws PulsarAdminException, PulsarClientException {
+        final String tenant = PUBLIC_TENANT;
+        final String namespace = "test-namespace-" + randomName(16);
+        final String topic = "test-joda-time-schema";
+        final String fqtn = TopicName.get(
+                TopicDomain.persistent.value(),
+                tenant,
+                namespace,
+                topic
+        ).toString();
+
+        admin.namespaces().createNamespace(
+                tenant + "/" + namespace,
+                Sets.newHashSet(pulsarCluster.getClusterName())
+        );
+
+        JodaSchema forSend = new JodaSchema();
+        forSend.setDecimal(new BigDecimal("12.34"));
+        forSend.setTimeMicros(System.currentTimeMillis() * 1000);
+        forSend.setTimestampMillis(new DateTime("2019-03-26T04:39:58.469Z", ISOChronology.getInstanceUTC()));
+        forSend.setTimeMillis(LocalTime.now().truncatedTo(ChronoUnit.MILLIS));
+        forSend.setTimeMicros(System.currentTimeMillis() * 1000);
+        forSend.setDate(LocalDate.now());
+
+        Producer<JodaSchema> producer = client
+                .newProducer(Schema.AVRO(JodaSchema.class))
+                .topic(fqtn)
+                .create();
+
+        Consumer<JodaSchema> consumer = client
+                .newConsumer(Schema.AVRO(JodaSchema.class))
+                .topic(fqtn)
+                .subscriptionName("test")
+                .subscribe();
+
+        producer.send(forSend);
+        JodaSchema received = consumer.receive().getValue();
+        assertEquals(received, forSend);
+
+        producer.close();
+        consumer.close();
+
+        log.info("Successfully Joda time logical type message : {}", received);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/SchemaTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/SchemaTest.java
index c9c6a50892..d2d4a06520 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/SchemaTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/SchemaTest.java
@@ -1,334 +1,334 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.schema;
-
-import static org.apache.pulsar.common.naming.TopicName.PUBLIC_TENANT;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotEquals;
-import com.google.common.collect.Sets;
-import java.math.BigDecimal;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalTime;
-import java.time.temporal.ChronoUnit;
-import java.util.ArrayList;
-import java.util.List;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.schema.GenericRecord;
-import org.apache.pulsar.client.api.schema.SchemaDefinition;
-import org.apache.pulsar.common.naming.TopicDomain;
-import org.apache.pulsar.common.naming.TopicName;
-import org.apache.pulsar.common.schema.SchemaInfo;
-import org.apache.pulsar.common.schema.SchemaType;
-import org.apache.pulsar.tests.integration.schema.Schemas.AvroLogicalType;
-import org.apache.pulsar.tests.integration.schema.Schemas.Person;
-import org.apache.pulsar.tests.integration.schema.Schemas.PersonConsumeSchema;
-import org.apache.pulsar.tests.integration.schema.Schemas.Student;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.annotations.Test;
-
-/**
- * Test Pulsar Schema.
- */
-@Slf4j
-public class SchemaTest extends PulsarTestSuite {
-
-    private PulsarClient client;
-    private PulsarAdmin admin;
-
-    public void setupCluster() throws Exception {
-        super.setupCluster();
-        this.client = PulsarClient.builder()
-            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-            .build();
-        this.admin = PulsarAdmin.builder()
-            .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-            .build();
-    }
-
-    @Override
-    public void tearDownCluster() throws Exception {
-        if (client != null) {
-            client.close();
-            client = null;
-        }
-        if (admin != null) {
-            admin.close();
-            admin = null;
-        }
-        super.tearDownCluster();
-    }
-
-    @Test
-    public void testCreateSchemaAfterDeletion() throws Exception {
-        final String tenant = PUBLIC_TENANT;
-        final String namespace = "test-namespace-" + randomName(16);
-        final String topic = "test-create-schema-after-deletion";
-        final String fqtn = TopicName.get(
-             TopicDomain.persistent.value(),
-             tenant,
-             namespace,
-             topic
-         ).toString();
-
-        admin.namespaces().createNamespace(
-            tenant + "/" + namespace,
-            Sets.newHashSet(pulsarCluster.getClusterName())
-        );
-
-        // Create a topic with `Person`
-        try (Producer<Person> producer = client.newProducer(Schema.AVRO(Person.class))
-             .topic(fqtn)
-             .create()
-        ) {
-            Person person = new Person();
-            person.setName("Tom Hanks");
-            person.setAge(60);
-
-            producer.send(person);
-
-            log.info("Successfully published person : {}", person);
-        }
-
-        log.info("Deleting schema of topic {}", fqtn);
-        // delete the schema
-        admin.schemas().deleteSchema(fqtn);
-        log.info("Successfully deleted schema of topic {}", fqtn);
-
-        // after deleting the topic, try to create a topic with a different schema
-        try (Producer<Student> producer = client.newProducer(Schema.AVRO(Student.class))
-             .topic(fqtn)
-             .create()
-        ) {
-            Student student = new Student();
-            student.setName("Tom Jerry");
-            student.setAge(30);
-            student.setGpa(6);
-            student.setGpa(10);
-
-            producer.send(student);
-
-            log.info("Successfully published student : {}", student);
-        }
-    }
-
-    @Test
-    public void testMultiVersionSchema() throws Exception {
-        final String tenant = PUBLIC_TENANT;
-        final String namespace = "test-namespace-" + randomName(16);
-        final String topic = "test-multi-version-schema";
-        final String fqtn = TopicName.get(
-                TopicDomain.persistent.value(),
-                tenant,
-                namespace,
-                topic
-        ).toString();
-
-        admin.namespaces().createNamespace(
-                tenant + "/" + namespace,
-                Sets.newHashSet(pulsarCluster.getClusterName())
-        );
-
-        Producer<Person> producer = client.newProducer(Schema.AVRO(
-                SchemaDefinition.<Person>builder().withAlwaysAllowNull
-                        (false).withSupportSchemaVersioning(true).
-                        withPojo(Person.class).build()))
-                .topic(fqtn)
-                .create();
-
-        Person person = new Person();
-        person.setName("Tom Hanks");
-        person.setAge(60);
-
-        Consumer<PersonConsumeSchema> consumer = client.newConsumer(Schema.AVRO(
-                SchemaDefinition.<PersonConsumeSchema>builder().withAlwaysAllowNull
-                        (false).withSupportSchemaVersioning(true).
-                        withPojo(PersonConsumeSchema.class).build()))
-                .subscriptionName("test")
-                .topic(fqtn)
-                .subscribe();
-
-        producer.send(person);
-        log.info("Successfully published person : {}", person);
-
-        PersonConsumeSchema personConsumeSchema = consumer.receive().getValue();
-        assertEquals("Tom Hanks", personConsumeSchema.getName());
-        assertEquals(60, personConsumeSchema.getAge());
-        assertEquals("male", personConsumeSchema.getGender());
-
-        producer.close();
-        consumer.close();
-        log.info("Successfully consumer personConsumeSchema : {}", personConsumeSchema);
-    }
-
-    @Test
-    public void testAvroLogicalType() throws Exception {
-        final String tenant = PUBLIC_TENANT;
-        final String namespace = "test-namespace-" + randomName(16);
-        final String topic = "test-logical-type-schema";
-        final String fqtn = TopicName.get(
-                TopicDomain.persistent.value(),
-                tenant,
-                namespace,
-                topic
-        ).toString();
-
-        admin.namespaces().createNamespace(
-                tenant + "/" + namespace,
-                Sets.newHashSet(pulsarCluster.getClusterName())
-        );
-
-        AvroLogicalType messageForSend = AvroLogicalType.builder()
-                .decimal(new BigDecimal("12.34"))
-                .timestampMicros(System.currentTimeMillis() * 1000)
-                .timestampMillis(Instant.parse("2019-03-26T04:39:58.469Z"))
-                .timeMillis(LocalTime.now().truncatedTo(ChronoUnit.MILLIS))
-                .timeMicros(System.currentTimeMillis() * 1000)
-                .date(LocalDate.now())
-                .build();
-
-        Producer<AvroLogicalType> producer = client
-                .newProducer(Schema.AVRO(SchemaDefinition.<AvroLogicalType>builder().withPojo(AvroLogicalType.class)
-                        .withJSR310ConversionEnabled(true).build()))
-                .topic(fqtn)
-                .create();
-
-        Consumer<AvroLogicalType> consumer = client
-                .newConsumer(Schema.AVRO(AvroLogicalType.class))
-                .topic(fqtn)
-                .subscriptionName("test")
-                .subscribe();
-
-        producer.send(messageForSend);
-        log.info("Successfully published avro logical type message : {}", messageForSend);
-
-        AvroLogicalType received = consumer.receive().getValue();
-        assertEquals(received, messageForSend);
-
-        producer.close();
-        consumer.close();
-
-        log.info("Successfully consumer avro logical type message : {}", received);
-    }
-
-    @Test
-    public void testAutoConsumeSchemaSubscribeFirst() throws Exception {
-        final String tenant = PUBLIC_TENANT;
-        final String namespace = "test-namespace-" + randomName(16);
-        final String topic = "test-auto-consume-schema";
-        final String fqtn = TopicName.get(
-                TopicDomain.persistent.value(),
-                tenant,
-                namespace,
-                topic
-        ).toString();
-
-        admin.namespaces().createNamespace(
-                tenant + "/" + namespace,
-                Sets.newHashSet(pulsarCluster.getClusterName())
-        );
-
-        Consumer<GenericRecord> consumer = client
-                .newConsumer(Schema.AUTO_CONSUME())
-                .topic(fqtn)
-                .subscriptionName("test")
-                .subscribe();
-
-        Producer<Person> producer = client
-                .newProducer(Schema.AVRO(Person.class))
-                .topic(fqtn)
-                .create();
-
-        Person person = new Person();
-        person.setName("Tom Hanks");
-        person.setAge(60);
-        producer.send(person);
-
-        GenericRecord genericRecord = consumer.receive().getValue();
-
-        assertEquals(genericRecord.getField("name"), "Tom Hanks");
-        assertEquals(genericRecord.getField("age"), 60);
-
-        consumer.close();
-        producer.close();
-    }
-
-    @Test
-    public void testPrimitiveSchemaTypeCompatibilityCheck() {
-        List<Schema<?>> schemas = new ArrayList<>();
-
-        schemas.add(Schema.STRING);
-        schemas.add(Schema.INT8);
-        schemas.add(Schema.INT16);
-        schemas.add(Schema.INT32);
-        schemas.add(Schema.INT64);
-        schemas.add(Schema.BOOL);
-        schemas.add(Schema.DOUBLE);
-        schemas.add(Schema.FLOAT);
-        schemas.add(Schema.DATE);
-        schemas.add(Schema.TIME);
-        schemas.add(Schema.TIMESTAMP);
-        schemas.add(Schema.INSTANT);
-        schemas.add(Schema.LOCAL_DATE);
-        schemas.add(Schema.LOCAL_TIME);
-        schemas.add(Schema.LOCAL_DATE_TIME);
-
-        schemas.forEach(schemaProducer -> {
-            schemas.forEach(schemaConsumer -> {
-                try {
-                    String topicName = schemaProducer.getSchemaInfo().getName()
-                            + schemaConsumer.getSchemaInfo().getName();
-                        client.newProducer(schemaProducer)
-                                .topic(topicName)
-                                .create().close();
-
-                        client.newConsumer(schemaConsumer)
-                                .topic(topicName)
-                                .subscriptionName("test")
-                                .subscribe().close();
-                    assertEquals(schemaProducer.getSchemaInfo().getType(),
-                            schemaConsumer.getSchemaInfo().getType());
-
-                } catch (PulsarClientException e) {
-                    assertNotEquals(schemaProducer.getSchemaInfo().getType(),
-                            schemaConsumer.getSchemaInfo().getType());
-                }
-
-            });
-        });
-
-    }
-
-    @Test
-    public void testDeletePartitionedTopicWhenTopicReferenceIsNotReady() throws Exception {
-        final String topic = "persistent://public/default/tp-ref";
-        admin.topics().createPartitionedTopic(topic, 20);
-        admin.schemas().createSchema(topic,
-                SchemaInfo.builder().type(SchemaType.STRING).schema(new byte[0]).build());
-        admin.topics().deletePartitionedTopic(topic, false);
-    }
-
-}
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.schema;
+
+import static org.apache.pulsar.common.naming.TopicName.PUBLIC_TENANT;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import com.google.common.collect.Sets;
+import java.math.BigDecimal;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.LocalTime;
+import java.time.temporal.ChronoUnit;
+import java.util.ArrayList;
+import java.util.List;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.schema.GenericRecord;
+import org.apache.pulsar.client.api.schema.SchemaDefinition;
+import org.apache.pulsar.common.naming.TopicDomain;
+import org.apache.pulsar.common.naming.TopicName;
+import org.apache.pulsar.common.schema.SchemaInfo;
+import org.apache.pulsar.common.schema.SchemaType;
+import org.apache.pulsar.tests.integration.schema.Schemas.AvroLogicalType;
+import org.apache.pulsar.tests.integration.schema.Schemas.Person;
+import org.apache.pulsar.tests.integration.schema.Schemas.PersonConsumeSchema;
+import org.apache.pulsar.tests.integration.schema.Schemas.Student;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.annotations.Test;
+
+/**
+ * Test Pulsar Schema.
+ */
+@Slf4j
+public class SchemaTest extends PulsarTestSuite {
+
+    private PulsarClient client;
+    private PulsarAdmin admin;
+
+    public void setupCluster() throws Exception {
+        super.setupCluster();
+        this.client = PulsarClient.builder()
+            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+            .build();
+        this.admin = PulsarAdmin.builder()
+            .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+            .build();
+    }
+
+    @Override
+    public void tearDownCluster() throws Exception {
+        if (client != null) {
+            client.close();
+            client = null;
+        }
+        if (admin != null) {
+            admin.close();
+            admin = null;
+        }
+        super.tearDownCluster();
+    }
+
+    @Test
+    public void testCreateSchemaAfterDeletion() throws Exception {
+        final String tenant = PUBLIC_TENANT;
+        final String namespace = "test-namespace-" + randomName(16);
+        final String topic = "test-create-schema-after-deletion";
+        final String fqtn = TopicName.get(
+             TopicDomain.persistent.value(),
+             tenant,
+             namespace,
+             topic
+         ).toString();
+
+        admin.namespaces().createNamespace(
+            tenant + "/" + namespace,
+            Sets.newHashSet(pulsarCluster.getClusterName())
+        );
+
+        // Create a topic with `Person`
+        try (Producer<Person> producer = client.newProducer(Schema.AVRO(Person.class))
+             .topic(fqtn)
+             .create()
+        ) {
+            Person person = new Person();
+            person.setName("Tom Hanks");
+            person.setAge(60);
+
+            producer.send(person);
+
+            log.info("Successfully published person : {}", person);
+        }
+
+        log.info("Deleting schema of topic {}", fqtn);
+        // delete the schema
+        admin.schemas().deleteSchema(fqtn);
+        log.info("Successfully deleted schema of topic {}", fqtn);
+
+        // after deleting the topic, try to create a topic with a different schema
+        try (Producer<Student> producer = client.newProducer(Schema.AVRO(Student.class))
+             .topic(fqtn)
+             .create()
+        ) {
+            Student student = new Student();
+            student.setName("Tom Jerry");
+            student.setAge(30);
+            student.setGpa(6);
+            student.setGpa(10);
+
+            producer.send(student);
+
+            log.info("Successfully published student : {}", student);
+        }
+    }
+
+    @Test
+    public void testMultiVersionSchema() throws Exception {
+        final String tenant = PUBLIC_TENANT;
+        final String namespace = "test-namespace-" + randomName(16);
+        final String topic = "test-multi-version-schema";
+        final String fqtn = TopicName.get(
+                TopicDomain.persistent.value(),
+                tenant,
+                namespace,
+                topic
+        ).toString();
+
+        admin.namespaces().createNamespace(
+                tenant + "/" + namespace,
+                Sets.newHashSet(pulsarCluster.getClusterName())
+        );
+
+        Producer<Person> producer = client.newProducer(Schema.AVRO(
+                SchemaDefinition.<Person>builder().withAlwaysAllowNull
+                        (false).withSupportSchemaVersioning(true).
+                        withPojo(Person.class).build()))
+                .topic(fqtn)
+                .create();
+
+        Person person = new Person();
+        person.setName("Tom Hanks");
+        person.setAge(60);
+
+        Consumer<PersonConsumeSchema> consumer = client.newConsumer(Schema.AVRO(
+                SchemaDefinition.<PersonConsumeSchema>builder().withAlwaysAllowNull
+                        (false).withSupportSchemaVersioning(true).
+                        withPojo(PersonConsumeSchema.class).build()))
+                .subscriptionName("test")
+                .topic(fqtn)
+                .subscribe();
+
+        producer.send(person);
+        log.info("Successfully published person : {}", person);
+
+        PersonConsumeSchema personConsumeSchema = consumer.receive().getValue();
+        assertEquals("Tom Hanks", personConsumeSchema.getName());
+        assertEquals(60, personConsumeSchema.getAge());
+        assertEquals("male", personConsumeSchema.getGender());
+
+        producer.close();
+        consumer.close();
+        log.info("Successfully consumer personConsumeSchema : {}", personConsumeSchema);
+    }
+
+    @Test
+    public void testAvroLogicalType() throws Exception {
+        final String tenant = PUBLIC_TENANT;
+        final String namespace = "test-namespace-" + randomName(16);
+        final String topic = "test-logical-type-schema";
+        final String fqtn = TopicName.get(
+                TopicDomain.persistent.value(),
+                tenant,
+                namespace,
+                topic
+        ).toString();
+
+        admin.namespaces().createNamespace(
+                tenant + "/" + namespace,
+                Sets.newHashSet(pulsarCluster.getClusterName())
+        );
+
+        AvroLogicalType messageForSend = AvroLogicalType.builder()
+                .decimal(new BigDecimal("12.34"))
+                .timestampMicros(System.currentTimeMillis() * 1000)
+                .timestampMillis(Instant.parse("2019-03-26T04:39:58.469Z"))
+                .timeMillis(LocalTime.now().truncatedTo(ChronoUnit.MILLIS))
+                .timeMicros(System.currentTimeMillis() * 1000)
+                .date(LocalDate.now())
+                .build();
+
+        Producer<AvroLogicalType> producer = client
+                .newProducer(Schema.AVRO(SchemaDefinition.<AvroLogicalType>builder().withPojo(AvroLogicalType.class)
+                        .withJSR310ConversionEnabled(true).build()))
+                .topic(fqtn)
+                .create();
+
+        Consumer<AvroLogicalType> consumer = client
+                .newConsumer(Schema.AVRO(AvroLogicalType.class))
+                .topic(fqtn)
+                .subscriptionName("test")
+                .subscribe();
+
+        producer.send(messageForSend);
+        log.info("Successfully published avro logical type message : {}", messageForSend);
+
+        AvroLogicalType received = consumer.receive().getValue();
+        assertEquals(received, messageForSend);
+
+        producer.close();
+        consumer.close();
+
+        log.info("Successfully consumer avro logical type message : {}", received);
+    }
+
+    @Test
+    public void testAutoConsumeSchemaSubscribeFirst() throws Exception {
+        final String tenant = PUBLIC_TENANT;
+        final String namespace = "test-namespace-" + randomName(16);
+        final String topic = "test-auto-consume-schema";
+        final String fqtn = TopicName.get(
+                TopicDomain.persistent.value(),
+                tenant,
+                namespace,
+                topic
+        ).toString();
+
+        admin.namespaces().createNamespace(
+                tenant + "/" + namespace,
+                Sets.newHashSet(pulsarCluster.getClusterName())
+        );
+
+        Consumer<GenericRecord> consumer = client
+                .newConsumer(Schema.AUTO_CONSUME())
+                .topic(fqtn)
+                .subscriptionName("test")
+                .subscribe();
+
+        Producer<Person> producer = client
+                .newProducer(Schema.AVRO(Person.class))
+                .topic(fqtn)
+                .create();
+
+        Person person = new Person();
+        person.setName("Tom Hanks");
+        person.setAge(60);
+        producer.send(person);
+
+        GenericRecord genericRecord = consumer.receive().getValue();
+
+        assertEquals(genericRecord.getField("name"), "Tom Hanks");
+        assertEquals(genericRecord.getField("age"), 60);
+
+        consumer.close();
+        producer.close();
+    }
+
+    @Test
+    public void testPrimitiveSchemaTypeCompatibilityCheck() {
+        List<Schema<?>> schemas = new ArrayList<>();
+
+        schemas.add(Schema.STRING);
+        schemas.add(Schema.INT8);
+        schemas.add(Schema.INT16);
+        schemas.add(Schema.INT32);
+        schemas.add(Schema.INT64);
+        schemas.add(Schema.BOOL);
+        schemas.add(Schema.DOUBLE);
+        schemas.add(Schema.FLOAT);
+        schemas.add(Schema.DATE);
+        schemas.add(Schema.TIME);
+        schemas.add(Schema.TIMESTAMP);
+        schemas.add(Schema.INSTANT);
+        schemas.add(Schema.LOCAL_DATE);
+        schemas.add(Schema.LOCAL_TIME);
+        schemas.add(Schema.LOCAL_DATE_TIME);
+
+        schemas.forEach(schemaProducer -> {
+            schemas.forEach(schemaConsumer -> {
+                try {
+                    String topicName = schemaProducer.getSchemaInfo().getName()
+                            + schemaConsumer.getSchemaInfo().getName();
+                        client.newProducer(schemaProducer)
+                                .topic(topicName)
+                                .create().close();
+
+                        client.newConsumer(schemaConsumer)
+                                .topic(topicName)
+                                .subscriptionName("test")
+                                .subscribe().close();
+                    assertEquals(schemaProducer.getSchemaInfo().getType(),
+                            schemaConsumer.getSchemaInfo().getType());
+
+                } catch (PulsarClientException e) {
+                    assertNotEquals(schemaProducer.getSchemaInfo().getType(),
+                            schemaConsumer.getSchemaInfo().getType());
+                }
+
+            });
+        });
+
+    }
+
+    @Test
+    public void testDeletePartitionedTopicWhenTopicReferenceIsNotReady() throws Exception {
+        final String topic = "persistent://public/default/tp-ref";
+        admin.topics().createPartitionedTopic(topic, 20);
+        admin.schemas().createSchema(topic,
+                SchemaInfo.builder().type(SchemaType.STRING).schema(new byte[0]).build());
+        admin.topics().deletePartitionedTopic(topic, false);
+    }
+
+}
+
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/Schemas.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/Schemas.java
index 4bef699076..25a31bbbe5 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/Schemas.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/schema/Schemas.java
@@ -1,145 +1,145 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-/**
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pulsar.tests.integration.schema;
-
-import java.math.BigDecimal;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalTime;
-import lombok.AllArgsConstructor;
-import lombok.Builder;
-import lombok.Data;
-import lombok.NoArgsConstructor;
-import org.apache.avro.reflect.AvroDefault;
-
-/**
- * Keep a list of schemas for testing.
- */
-public final class Schemas {
-
-    /**
-     * A Person Struct.
-     */
-    @Data
-    public static class Person {
-
-        private String name;
-        private int age;
-
-    }
-
-    /**
-     * A Person Struct.
-     */
-    @Data
-    public static class PersonConsumeSchema {
-
-        private String name;
-        private int age;
-        @AvroDefault("\"male\"")
-        private String gender;
-
-    }
-
-    /**
-     * A Student Struct.
-     */
-    @Data
-    public static class Student {
-
-        private String name;
-        private int age;
-        private int gpa;
-        private int grade;
-
-    }
-
-    @Data
-    @NoArgsConstructor
-    @AllArgsConstructor
-    @Builder
-    public static class AvroLogicalType{
-        @org.apache.avro.reflect.AvroSchema("{\n"
-                + "  \"type\": \"bytes\",\n"
-                + "  \"logicalType\": \"decimal\",\n"
-                + "  \"precision\": 4,\n"
-                + "  \"scale\": 2\n"
-                + "}")
-        BigDecimal decimal;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"date\"}")
-        LocalDate date;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}")
-        Instant timestampMillis;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"time-millis\"}")
-        LocalTime timeMillis;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-micros\"}")
-        long timestampMicros;
-        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"time-micros\"}")
-        long timeMicros;
-    }
-
-    private Schemas() {}
-
-    @Data
-    @AllArgsConstructor
-    @NoArgsConstructor
-    public static class PersonOne{
-        int id;
-    }
-
-    @Data
-    @AllArgsConstructor
-    @NoArgsConstructor
-    public static class PersonTwo{
-        int id;
-
-        @AvroDefault("\"Tom\"")
-        String name;
-    }
-
-    @Data
-    public static class PersonThree{
-        int id;
-
-        String name;
-    }
-
-    @Data
-    public static class PersonFour{
-        int id;
-
-        String name;
-
-        int age;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pulsar.tests.integration.schema;
+
+import java.math.BigDecimal;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.LocalTime;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.apache.avro.reflect.AvroDefault;
+
+/**
+ * Keep a list of schemas for testing.
+ */
+public final class Schemas {
+
+    /**
+     * A Person Struct.
+     */
+    @Data
+    public static class Person {
+
+        private String name;
+        private int age;
+
+    }
+
+    /**
+     * A Person Struct.
+     */
+    @Data
+    public static class PersonConsumeSchema {
+
+        private String name;
+        private int age;
+        @AvroDefault("\"male\"")
+        private String gender;
+
+    }
+
+    /**
+     * A Student Struct.
+     */
+    @Data
+    public static class Student {
+
+        private String name;
+        private int age;
+        private int gpa;
+        private int grade;
+
+    }
+
+    @Data
+    @NoArgsConstructor
+    @AllArgsConstructor
+    @Builder
+    public static class AvroLogicalType{
+        @org.apache.avro.reflect.AvroSchema("{\n"
+                + "  \"type\": \"bytes\",\n"
+                + "  \"logicalType\": \"decimal\",\n"
+                + "  \"precision\": 4,\n"
+                + "  \"scale\": 2\n"
+                + "}")
+        BigDecimal decimal;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"date\"}")
+        LocalDate date;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-millis\"}")
+        Instant timestampMillis;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"int\",\"logicalType\":\"time-millis\"}")
+        LocalTime timeMillis;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"timestamp-micros\"}")
+        long timestampMicros;
+        @org.apache.avro.reflect.AvroSchema("{\"type\":\"long\",\"logicalType\":\"time-micros\"}")
+        long timeMicros;
+    }
+
+    private Schemas() {}
+
+    @Data
+    @AllArgsConstructor
+    @NoArgsConstructor
+    public static class PersonOne{
+        int id;
+    }
+
+    @Data
+    @AllArgsConstructor
+    @NoArgsConstructor
+    public static class PersonTwo{
+        int id;
+
+        @AvroDefault("\"Tom\"")
+        String name;
+    }
+
+    @Data
+    public static class PersonThree{
+        int id;
+
+        String name;
+    }
+
+    @Data
+    public static class PersonFour{
+        int id;
+
+        String name;
+
+        int age;
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/semantics/SemanticsTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/semantics/SemanticsTest.java
index 230a15b60c..3659425c42 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/semantics/SemanticsTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/semantics/SemanticsTest.java
@@ -1,292 +1,292 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.semantics;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.api.TopicMessageId;
-import org.apache.pulsar.client.impl.BatchMessageIdImpl;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.testng.annotations.Test;
-import org.testng.collections.Lists;
-
-/**
- * Test pulsar produce/consume semantics.
- */
-@Slf4j
-public class SemanticsTest extends PulsarTestSuite {
-
-    //
-    // Test Basic Publish & Consume Operations
-    //
-
-    @Test(dataProvider = "ServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testEffectivelyOnceDisabled(Supplier<String> serviceUrl) throws Exception {
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-
-        String topicName = generateTopicName(nsName, "testeffectivelyonce", true);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(serviceUrl.get())
-            .build();
-
-        @Cleanup
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-            .topic(topicName)
-            .subscriptionName("test-sub")
-            .ackTimeout(10, TimeUnit.SECONDS)
-            .subscriptionType(SubscriptionType.Exclusive)
-            .subscribe();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-            .topic(topicName)
-            .enableBatching(false)
-            .producerName("effectively-once-producer")
-            .initialSequenceId(1L)
-            .create();
-
-        // send messages
-        sendMessagesIdempotency(producer);
-
-        // checkout the result
-        checkMessagesIdempotencyDisabled(consumer);
-    }
-
-    private static void sendMessagesIdempotency(Producer<String> producer) throws Exception {
-        // sending message
-        producer.newMessage()
-            .sequenceId(1L)
-            .value("message-1")
-            .send();
-
-        // sending a duplicated message
-        producer.newMessage()
-            .sequenceId(1L)
-            .value("duplicated-message-1")
-            .send();
-
-        // sending a second message
-        producer.newMessage()
-            .sequenceId(2L)
-            .value("message-2")
-            .send();
-    }
-
-    private static void checkMessagesIdempotencyDisabled(Consumer<String> consumer) throws Exception {
-        receiveAndAssertMessage(consumer, 1L, "message-1");
-        receiveAndAssertMessage(consumer, 1L, "duplicated-message-1");
-        receiveAndAssertMessage(consumer, 2L, "message-2");
-    }
-
-    private static void receiveAndAssertMessage(Consumer<String> consumer,
-                                                long expectedSequenceId,
-                                                String expectedContent) throws Exception {
-        Message<String> msg = consumer.receive();
-        log.info("Received message {}", msg);
-        assertEquals(expectedSequenceId, msg.getSequenceId());
-        assertEquals(expectedContent, msg.getValue());
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testEffectivelyOnceEnabled(Supplier<String> serviceUrl) throws Exception {
-        String nsName = generateNamespaceName();
-        pulsarCluster.createNamespace(nsName);
-        pulsarCluster.enableDeduplication(nsName, true);
-
-        String topicName = generateTopicName(nsName, "testeffectivelyonce", true);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-            .serviceUrl(serviceUrl.get())
-            .build();
-
-        @Cleanup
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-            .topic(topicName)
-            .subscriptionName("test-sub")
-            .ackTimeout(10, TimeUnit.SECONDS)
-            .subscriptionType(SubscriptionType.Exclusive)
-            .subscribe();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-            .topic(topicName)
-            .enableBatching(false)
-            .producerName("effectively-once-producer")
-            .initialSequenceId(1L)
-            .create();
-
-        // send messages
-        sendMessagesIdempotency(producer);
-
-        // checkout the result
-        checkMessagesIdempotencyEnabled(consumer);
-    }
-
-    private static void checkMessagesIdempotencyEnabled(Consumer<String> consumer) throws Exception {
-        receiveAndAssertMessage(consumer, 1L, "message-1");
-        receiveAndAssertMessage(consumer, 2L, "message-2");
-    }
-
-    @Test
-    public void testSubscriptionInitialPositionOneTopic() throws Exception {
-        testSubscriptionInitialPosition(1);
-    }
-
-    @Test
-    public void testSubscriptionInitialPositionTwoTopics() throws Exception {
-        testSubscriptionInitialPosition(2);
-    }
-
-    private void testSubscriptionInitialPosition(int numTopics) throws Exception {
-        String topicName = generateTopicName("test-subscription-initial-pos", true);
-
-        int numMessages = 10;
-
-        try (PulsarClient client = PulsarClient.builder()
-            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
-            .build()) {
-
-            for (int t = 0; t < numTopics; t++) {
-                try (Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(topicName + "-" + t)
-                    .create()) {
-
-                    for (int i = 0; i < numMessages; i++) {
-                        producer.send("sip-topic-" + t + "-message-" + i);
-                    }
-                }
-            }
-
-            String[] topics = new String[numTopics];
-            Map<Integer, AtomicInteger> topicCounters = new HashMap<>(numTopics);
-            for (int i = 0; i < numTopics; i++) {
-                topics[i] = topicName + "-" + i;
-                topicCounters.put(i, new AtomicInteger(0));
-            }
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topics)
-                .subscriptionName("my-sub")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscribe()) {
-
-                for (int i = 0; i < numTopics * numMessages; i++) {
-                    Message<String> m = consumer.receive();
-                    int topicIdx;
-                    if (numTopics > 1) {
-                        String topic = ((TopicMessageId) m.getMessageId()).getOwnerTopic();
-
-                        String[] topicParts = StringUtils.split(topic, '-');
-                        topicIdx = Integer.parseInt(topicParts[topicParts.length - 1]);
-                    } else {
-                        topicIdx = 0;
-                    }
-                    int topicSeq = topicCounters.get(topicIdx).getAndIncrement();
-
-                    assertEquals("sip-topic-" + topicIdx + "-message-" + topicSeq, m.getValue());
-                }
-            }
-        }
-    }
-
-    @Test(dataProvider = "ServiceUrls")
-    public void testBatchProducing(Supplier<String> serviceUrl) throws Exception {
-        String topicName = generateTopicName("testbatchproducing", true);
-
-        int numMessages = 10;
-
-        List<MessageId> producedMsgIds;
-
-        try (PulsarClient client = PulsarClient.builder()
-            .serviceUrl(serviceUrl.get())
-            .build()) {
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("my-sub")
-                .subscribe()) {
-
-                try (Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(topicName)
-                    .enableBatching(true)
-                    .batchingMaxMessages(5)
-                    .batchingMaxPublishDelay(1, TimeUnit.HOURS)
-                    .create()) {
-
-                    List<CompletableFuture<MessageId>> sendFutures = Lists.newArrayList();
-                    for (int i = 0; i < numMessages; i++) {
-                        sendFutures.add(producer.sendAsync("batch-message-" + i));
-                    }
-                    CompletableFuture.allOf(sendFutures.toArray(new CompletableFuture<?>[numMessages])).get();
-                    producedMsgIds = sendFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());
-                }
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<String> m = consumer.receive();
-                    assertEquals(producedMsgIds.get(i), m.getMessageId());
-                    assertEquals("batch-message-" + i, m.getValue());
-                }
-            }
-        }
-
-        // inspect the message ids
-        for (int i = 0; i < 5; i++) {
-            assertTrue(producedMsgIds.get(i) instanceof BatchMessageIdImpl);
-            BatchMessageIdImpl mid = (BatchMessageIdImpl) producedMsgIds.get(i);
-            log.info("Message {} id : {}", i, mid);
-
-            assertEquals(i, mid.getBatchIndex());
-        }
-        for (int i = 5; i < 10; i++) {
-            assertTrue(producedMsgIds.get(i) instanceof BatchMessageIdImpl);
-            BatchMessageIdImpl mid = (BatchMessageIdImpl) producedMsgIds.get(i);
-            log.info("Message {} id : {}", i, mid);
-
-            assertEquals(i - 5, mid.getBatchIndex());
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.semantics;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.api.TopicMessageId;
+import org.apache.pulsar.client.impl.BatchMessageIdImpl;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.testng.annotations.Test;
+import org.testng.collections.Lists;
+
+/**
+ * Test pulsar produce/consume semantics.
+ */
+@Slf4j
+public class SemanticsTest extends PulsarTestSuite {
+
+    //
+    // Test Basic Publish & Consume Operations
+    //
+
+    @Test(dataProvider = "ServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testEffectivelyOnceDisabled(Supplier<String> serviceUrl) throws Exception {
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+
+        String topicName = generateTopicName(nsName, "testeffectivelyonce", true);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(serviceUrl.get())
+            .build();
+
+        @Cleanup
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+            .topic(topicName)
+            .subscriptionName("test-sub")
+            .ackTimeout(10, TimeUnit.SECONDS)
+            .subscriptionType(SubscriptionType.Exclusive)
+            .subscribe();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+            .topic(topicName)
+            .enableBatching(false)
+            .producerName("effectively-once-producer")
+            .initialSequenceId(1L)
+            .create();
+
+        // send messages
+        sendMessagesIdempotency(producer);
+
+        // checkout the result
+        checkMessagesIdempotencyDisabled(consumer);
+    }
+
+    private static void sendMessagesIdempotency(Producer<String> producer) throws Exception {
+        // sending message
+        producer.newMessage()
+            .sequenceId(1L)
+            .value("message-1")
+            .send();
+
+        // sending a duplicated message
+        producer.newMessage()
+            .sequenceId(1L)
+            .value("duplicated-message-1")
+            .send();
+
+        // sending a second message
+        producer.newMessage()
+            .sequenceId(2L)
+            .value("message-2")
+            .send();
+    }
+
+    private static void checkMessagesIdempotencyDisabled(Consumer<String> consumer) throws Exception {
+        receiveAndAssertMessage(consumer, 1L, "message-1");
+        receiveAndAssertMessage(consumer, 1L, "duplicated-message-1");
+        receiveAndAssertMessage(consumer, 2L, "message-2");
+    }
+
+    private static void receiveAndAssertMessage(Consumer<String> consumer,
+                                                long expectedSequenceId,
+                                                String expectedContent) throws Exception {
+        Message<String> msg = consumer.receive();
+        log.info("Received message {}", msg);
+        assertEquals(expectedSequenceId, msg.getSequenceId());
+        assertEquals(expectedContent, msg.getValue());
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testEffectivelyOnceEnabled(Supplier<String> serviceUrl) throws Exception {
+        String nsName = generateNamespaceName();
+        pulsarCluster.createNamespace(nsName);
+        pulsarCluster.enableDeduplication(nsName, true);
+
+        String topicName = generateTopicName(nsName, "testeffectivelyonce", true);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+            .serviceUrl(serviceUrl.get())
+            .build();
+
+        @Cleanup
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+            .topic(topicName)
+            .subscriptionName("test-sub")
+            .ackTimeout(10, TimeUnit.SECONDS)
+            .subscriptionType(SubscriptionType.Exclusive)
+            .subscribe();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+            .topic(topicName)
+            .enableBatching(false)
+            .producerName("effectively-once-producer")
+            .initialSequenceId(1L)
+            .create();
+
+        // send messages
+        sendMessagesIdempotency(producer);
+
+        // checkout the result
+        checkMessagesIdempotencyEnabled(consumer);
+    }
+
+    private static void checkMessagesIdempotencyEnabled(Consumer<String> consumer) throws Exception {
+        receiveAndAssertMessage(consumer, 1L, "message-1");
+        receiveAndAssertMessage(consumer, 2L, "message-2");
+    }
+
+    @Test
+    public void testSubscriptionInitialPositionOneTopic() throws Exception {
+        testSubscriptionInitialPosition(1);
+    }
+
+    @Test
+    public void testSubscriptionInitialPositionTwoTopics() throws Exception {
+        testSubscriptionInitialPosition(2);
+    }
+
+    private void testSubscriptionInitialPosition(int numTopics) throws Exception {
+        String topicName = generateTopicName("test-subscription-initial-pos", true);
+
+        int numMessages = 10;
+
+        try (PulsarClient client = PulsarClient.builder()
+            .serviceUrl(pulsarCluster.getPlainTextServiceUrl())
+            .build()) {
+
+            for (int t = 0; t < numTopics; t++) {
+                try (Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(topicName + "-" + t)
+                    .create()) {
+
+                    for (int i = 0; i < numMessages; i++) {
+                        producer.send("sip-topic-" + t + "-message-" + i);
+                    }
+                }
+            }
+
+            String[] topics = new String[numTopics];
+            Map<Integer, AtomicInteger> topicCounters = new HashMap<>(numTopics);
+            for (int i = 0; i < numTopics; i++) {
+                topics[i] = topicName + "-" + i;
+                topicCounters.put(i, new AtomicInteger(0));
+            }
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topics)
+                .subscriptionName("my-sub")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscribe()) {
+
+                for (int i = 0; i < numTopics * numMessages; i++) {
+                    Message<String> m = consumer.receive();
+                    int topicIdx;
+                    if (numTopics > 1) {
+                        String topic = ((TopicMessageId) m.getMessageId()).getOwnerTopic();
+
+                        String[] topicParts = StringUtils.split(topic, '-');
+                        topicIdx = Integer.parseInt(topicParts[topicParts.length - 1]);
+                    } else {
+                        topicIdx = 0;
+                    }
+                    int topicSeq = topicCounters.get(topicIdx).getAndIncrement();
+
+                    assertEquals("sip-topic-" + topicIdx + "-message-" + topicSeq, m.getValue());
+                }
+            }
+        }
+    }
+
+    @Test(dataProvider = "ServiceUrls")
+    public void testBatchProducing(Supplier<String> serviceUrl) throws Exception {
+        String topicName = generateTopicName("testbatchproducing", true);
+
+        int numMessages = 10;
+
+        List<MessageId> producedMsgIds;
+
+        try (PulsarClient client = PulsarClient.builder()
+            .serviceUrl(serviceUrl.get())
+            .build()) {
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("my-sub")
+                .subscribe()) {
+
+                try (Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(topicName)
+                    .enableBatching(true)
+                    .batchingMaxMessages(5)
+                    .batchingMaxPublishDelay(1, TimeUnit.HOURS)
+                    .create()) {
+
+                    List<CompletableFuture<MessageId>> sendFutures = Lists.newArrayList();
+                    for (int i = 0; i < numMessages; i++) {
+                        sendFutures.add(producer.sendAsync("batch-message-" + i));
+                    }
+                    CompletableFuture.allOf(sendFutures.toArray(new CompletableFuture<?>[numMessages])).get();
+                    producedMsgIds = sendFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());
+                }
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<String> m = consumer.receive();
+                    assertEquals(producedMsgIds.get(i), m.getMessageId());
+                    assertEquals("batch-message-" + i, m.getValue());
+                }
+            }
+        }
+
+        // inspect the message ids
+        for (int i = 0; i < 5; i++) {
+            assertTrue(producedMsgIds.get(i) instanceof BatchMessageIdImpl);
+            BatchMessageIdImpl mid = (BatchMessageIdImpl) producedMsgIds.get(i);
+            log.info("Message {} id : {}", i, mid);
+
+            assertEquals(i, mid.getBatchIndex());
+        }
+        for (int i = 5; i < 10; i++) {
+            assertTrue(producedMsgIds.get(i) instanceof BatchMessageIdImpl);
+            BatchMessageIdImpl mid = (BatchMessageIdImpl) producedMsgIds.get(i);
+            log.info("Message {} id : {}", i, mid);
+
+            assertEquals(i - 5, mid.getBatchIndex());
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/standalone/SmokeTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/standalone/SmokeTest.java
index 726aab0878..6eeb951537 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/standalone/SmokeTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/standalone/SmokeTest.java
@@ -1,31 +1,31 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.standalone;
-
-import java.util.function.Supplier;
-import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends PulsarStandaloneTestSuite {
-
-    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.standalone;
+
+import java.util.function.Supplier;
+import org.apache.pulsar.tests.integration.suites.PulsarStandaloneTestSuite;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends PulsarStandaloneTestSuite {
+
+    @Test(dataProvider = "StandaloneServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        super.testPublishAndConsume(serviceUrl.get(), isPersistent);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarCliTestSuite.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarCliTestSuite.java
index 2ddd20f12b..01c4b8f298 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarCliTestSuite.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarCliTestSuite.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.suites;
-
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-
-public abstract class PulsarCliTestSuite extends PulsarClusterTestBase {
-    @BeforeClass(alwaysRun = true)
-    public void before() throws Exception {
-        setup();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public void after() throws Exception {
-        cleanup();
-    }
-
-    protected final void enableTopicPolicies() {
-        this.brokerEnvs.put("systemTopicEnabled", "true");
-        this.brokerEnvs.put("topicLevelPoliciesEnabled", "true");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.suites;
+
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+
+public abstract class PulsarCliTestSuite extends PulsarClusterTestBase {
+    @BeforeClass(alwaysRun = true)
+    public void before() throws Exception {
+        setup();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public void after() throws Exception {
+        cleanup();
+    }
+
+    protected final void enableTopicPolicies() {
+        this.brokerEnvs.put("systemTopicEnabled", "true");
+        this.brokerEnvs.put("topicLevelPoliciesEnabled", "true");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarStandaloneTestSuite.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarStandaloneTestSuite.java
index 6b38f6000e..832ec9f809 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarStandaloneTestSuite.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarStandaloneTestSuite.java
@@ -1,59 +1,59 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.suites;
-
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarStandaloneTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-
-public abstract class PulsarStandaloneTestSuite extends PulsarStandaloneTestBase {
-    private final String imageName;
-
-    protected PulsarStandaloneTestSuite() {
-        this(PulsarContainer.DEFAULT_IMAGE_NAME);
-    }
-
-    protected PulsarStandaloneTestSuite(String imageName) {
-        this.imageName = imageName;
-    }
-
-    public void setUpCluster() throws Exception {
-        incrementSetupNumber();
-        super.startCluster(imageName);
-    }
-
-    public void tearDownCluster() throws Exception {
-        markCurrentSetupNumberCleaned();
-        super.stopCluster();
-    }
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    protected final void setup() throws Exception {
-        setUpCluster();
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    protected final void cleanup() throws Exception {
-        tearDownCluster();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.suites;
+
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarStandaloneTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+
+public abstract class PulsarStandaloneTestSuite extends PulsarStandaloneTestBase {
+    private final String imageName;
+
+    protected PulsarStandaloneTestSuite() {
+        this(PulsarContainer.DEFAULT_IMAGE_NAME);
+    }
+
+    protected PulsarStandaloneTestSuite(String imageName) {
+        this.imageName = imageName;
+    }
+
+    public void setUpCluster() throws Exception {
+        incrementSetupNumber();
+        super.startCluster(imageName);
+    }
+
+    public void tearDownCluster() throws Exception {
+        markCurrentSetupNumberCleaned();
+        super.stopCluster();
+    }
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    protected final void setup() throws Exception {
+        setUpCluster();
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    protected final void cleanup() throws Exception {
+        tearDownCluster();
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTestSuite.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTestSuite.java
index 28ec303104..5aae4e3a4a 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTestSuite.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTestSuite.java
@@ -1,63 +1,63 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.suites;
-
-import java.util.function.Predicate;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-
-public abstract class PulsarTestSuite extends PulsarClusterTestBase {
-
-    @BeforeClass(alwaysRun = true)
-    public final void setupBeforeClass() throws Exception {
-        setup();
-    }
-
-    @AfterClass(alwaysRun = true)
-    public final void tearDownAfterClass() throws Exception {
-        cleanup();
-    }
-
-    public static void retryStrategically(Predicate<Void> predicate, int retryCount, long intSleepTimeInMillis)
-            throws Exception {
-        retryStrategically(predicate, retryCount, intSleepTimeInMillis, false);
-    }
-
-    public static void retryStrategically(Predicate<Void> predicate, int retryCount, long intSleepTimeInMillis,
-                                          boolean throwException) throws Exception {
-
-        for (int i = 0; i < retryCount; i++) {
-            if (throwException) {
-                if (i == (retryCount - 1)) {
-                    throw new RuntimeException("Action was not successful after " + retryCount + " retries");
-                }
-                if (predicate.test(null)) {
-                    break;
-                }
-            } else {
-                if (predicate.test(null) || i == (retryCount - 1)) {
-                    break;
-                }
-            }
-
-           Thread.sleep(intSleepTimeInMillis + (intSleepTimeInMillis * i));
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.suites;
+
+import java.util.function.Predicate;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+
+public abstract class PulsarTestSuite extends PulsarClusterTestBase {
+
+    @BeforeClass(alwaysRun = true)
+    public final void setupBeforeClass() throws Exception {
+        setup();
+    }
+
+    @AfterClass(alwaysRun = true)
+    public final void tearDownAfterClass() throws Exception {
+        cleanup();
+    }
+
+    public static void retryStrategically(Predicate<Void> predicate, int retryCount, long intSleepTimeInMillis)
+            throws Exception {
+        retryStrategically(predicate, retryCount, intSleepTimeInMillis, false);
+    }
+
+    public static void retryStrategically(Predicate<Void> predicate, int retryCount, long intSleepTimeInMillis,
+                                          boolean throwException) throws Exception {
+
+        for (int i = 0; i < retryCount; i++) {
+            if (throwException) {
+                if (i == (retryCount - 1)) {
+                    throw new RuntimeException("Action was not successful after " + retryCount + " retries");
+                }
+                if (predicate.test(null)) {
+                    break;
+                }
+            } else {
+                if (predicate.test(null) || i == (retryCount - 1)) {
+                    break;
+                }
+            }
+
+           Thread.sleep(intSleepTimeInMillis + (intSleepTimeInMillis * i));
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTieredStorageTestSuite.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTieredStorageTestSuite.java
index 6bf4061760..14c3125ba9 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTieredStorageTestSuite.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/suites/PulsarTieredStorageTestSuite.java
@@ -1,69 +1,69 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.suites;
-
-import static java.util.stream.Collectors.joining;
-import java.util.Map;
-import java.util.stream.Stream;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-
-@Slf4j
-public abstract class PulsarTieredStorageTestSuite extends PulsarClusterTestBase {
-
-    protected int getNumEntriesPerLedger() {
-        return 1024;
-    }
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public final void setupCluster() throws Exception {
-        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
-                .filter(s -> s != null && !s.isEmpty())
-                .collect(joining("-"));
-
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-            .numBookies(2)
-            .numBrokers(1)
-            .clusterName(clusterName)
-            .build();
-
-        setupCluster(spec);
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    public final void tearDownCluster() throws Exception {
-        super.tearDownCluster();
-    }
-
-    protected abstract Map<String, String> getEnv();
-
-    @Override
-    protected void beforeStartCluster() throws Exception {
-        super.beforeStartCluster();
-        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
-            getEnv().forEach(brokerContainer::withEnv);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.suites;
+
+import static java.util.stream.Collectors.joining;
+import java.util.Map;
+import java.util.stream.Stream;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+
+@Slf4j
+public abstract class PulsarTieredStorageTestSuite extends PulsarClusterTestBase {
+
+    protected int getNumEntriesPerLedger() {
+        return 1024;
+    }
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public final void setupCluster() throws Exception {
+        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
+                .filter(s -> s != null && !s.isEmpty())
+                .collect(joining("-"));
+
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+            .numBookies(2)
+            .numBrokers(1)
+            .clusterName(clusterName)
+            .build();
+
+        setupCluster(spec);
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    public final void tearDownCluster() throws Exception {
+        super.tearDownCluster();
+    }
+
+    protected abstract Map<String, String> getEnv();
+
+    @Override
+    protected void beforeStartCluster() throws Exception {
+        super.beforeStartCluster();
+        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
+            getEnv().forEach(brokerContainer::withEnv);
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsAbsoluteAdvertisedAddressTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsAbsoluteAdvertisedAddressTest.java
index 9f87a1c9ce..c137ef10e4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsAbsoluteAdvertisedAddressTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsAbsoluteAdvertisedAddressTest.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.tls;
-
-/**
- * Test that the client can connect to a broker using TLS with an absolute advertised address.
- */
-public class ClientTlsAbsoluteAdvertisedAddressTest extends ClientTlsTest {
-    @Override
-    protected void beforeStartCluster() throws Exception {
-        super.beforeStartCluster();
-        getPulsarCluster().getBrokers().forEach(brokerContainer -> {
-            // make the advertised address absolute by adding a dot at the end
-            brokerContainer.withEnv("advertisedAddress", brokerContainer.getHostName() + ".");
-        });
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.tls;
+
+/**
+ * Test that the client can connect to a broker using TLS with an absolute advertised address.
+ */
+public class ClientTlsAbsoluteAdvertisedAddressTest extends ClientTlsTest {
+    @Override
+    protected void beforeStartCluster() throws Exception {
+        super.beforeStartCluster();
+        getPulsarCluster().getBrokers().forEach(brokerContainer -> {
+            // make the advertised address absolute by adding a dot at the end
+            brokerContainer.withEnv("advertisedAddress", brokerContainer.getHostName() + ".");
+        });
+    }
 }
\ No newline at end of file
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsTest.java
index af03f10f08..f1490d4062 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/tls/ClientTlsTest.java
@@ -1,91 +1,91 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.tls;
-
-import com.google.common.io.Resources;
-import java.nio.charset.StandardCharsets;
-import java.util.UUID;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.DataProvider;
-import org.testng.annotations.Test;
-
-public class ClientTlsTest extends PulsarTestSuite {
-    private static final String tlsTrustCertsFilePath = loadCertificateAuthorityFile("certs/ca.cert.pem");
-    private static final String tlsKeyFilePath = loadCertificateAuthorityFile("client-keys/admin.key-pk8.pem");
-    private static final String tlsCertificateFilePath = loadCertificateAuthorityFile("client-keys/admin.cert.pem");
-
-    private static String loadCertificateAuthorityFile(String name) {
-        return Resources.getResource("certificate-authority/" + name).getPath();
-    }
-
-    @Override
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
-            String clusterName,
-            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-        specBuilder.enableTls(true);
-        return specBuilder;
-    }
-
-    @DataProvider(name = "adminUrls")
-    public Object[][] adminUrls() {
-        return new Object[][]{
-                {stringSupplier(() -> getPulsarCluster().getAnyBrokersHttpsServiceUrl())},
-                {stringSupplier(() -> getPulsarCluster().getProxy().getHttpsServiceUrl())}
-        };
-    }
-
-    @DataProvider(name = "serviceUrls")
-    public Object[][] serviceUrls() {
-        return new Object[][]{
-                {stringSupplier(() -> getPulsarCluster().getProxy().getServiceUrlTls())},
-        };
-    }
-
-    @Test(dataProvider = "adminUrls")
-    public void testAdmin(Supplier<String> urlSupplier) throws PulsarAdminException, PulsarClientException {
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(urlSupplier.get())
-                .tlsTrustCertsFilePath(tlsTrustCertsFilePath)
-                .tlsKeyFilePath(tlsKeyFilePath)
-                .tlsCertificateFilePath(tlsCertificateFilePath)
-                .build();
-        admin.tenants().getTenants();
-    }
-
-    @Test(dataProvider = "serviceUrls")
-    public void testClient(Supplier<String> urlSupplier) throws PulsarClientException {
-        @Cleanup
-        PulsarClient client = PulsarClient.builder().serviceUrl(urlSupplier.get())
-                .tlsTrustCertsFilePath(tlsTrustCertsFilePath)
-                .tlsKeyFilePath(tlsKeyFilePath)
-                .tlsCertificateFilePath(tlsCertificateFilePath)
-                .build();
-        @Cleanup
-        Producer<byte[]> producer = client.newProducer().topic(UUID.randomUUID().toString()).create();
-        producer.send("Hello".getBytes(StandardCharsets.UTF_8));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.tls;
+
+import com.google.common.io.Resources;
+import java.nio.charset.StandardCharsets;
+import java.util.UUID;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+
+public class ClientTlsTest extends PulsarTestSuite {
+    private static final String tlsTrustCertsFilePath = loadCertificateAuthorityFile("certs/ca.cert.pem");
+    private static final String tlsKeyFilePath = loadCertificateAuthorityFile("client-keys/admin.key-pk8.pem");
+    private static final String tlsCertificateFilePath = loadCertificateAuthorityFile("client-keys/admin.cert.pem");
+
+    private static String loadCertificateAuthorityFile(String name) {
+        return Resources.getResource("certificate-authority/" + name).getPath();
+    }
+
+    @Override
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
+            String clusterName,
+            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+        specBuilder.enableTls(true);
+        return specBuilder;
+    }
+
+    @DataProvider(name = "adminUrls")
+    public Object[][] adminUrls() {
+        return new Object[][]{
+                {stringSupplier(() -> getPulsarCluster().getAnyBrokersHttpsServiceUrl())},
+                {stringSupplier(() -> getPulsarCluster().getProxy().getHttpsServiceUrl())}
+        };
+    }
+
+    @DataProvider(name = "serviceUrls")
+    public Object[][] serviceUrls() {
+        return new Object[][]{
+                {stringSupplier(() -> getPulsarCluster().getProxy().getServiceUrlTls())},
+        };
+    }
+
+    @Test(dataProvider = "adminUrls")
+    public void testAdmin(Supplier<String> urlSupplier) throws PulsarAdminException, PulsarClientException {
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(urlSupplier.get())
+                .tlsTrustCertsFilePath(tlsTrustCertsFilePath)
+                .tlsKeyFilePath(tlsKeyFilePath)
+                .tlsCertificateFilePath(tlsCertificateFilePath)
+                .build();
+        admin.tenants().getTenants();
+    }
+
+    @Test(dataProvider = "serviceUrls")
+    public void testClient(Supplier<String> urlSupplier) throws PulsarClientException {
+        @Cleanup
+        PulsarClient client = PulsarClient.builder().serviceUrl(urlSupplier.get())
+                .tlsTrustCertsFilePath(tlsTrustCertsFilePath)
+                .tlsKeyFilePath(tlsKeyFilePath)
+                .tlsCertificateFilePath(tlsCertificateFilePath)
+                .build();
+        @Cleanup
+        Producer<byte[]> producer = client.newProducer().topic(UUID.randomUUID().toString()).create();
+        producer.send("Hello".getBytes(StandardCharsets.UTF_8));
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topics/TestTopicDeletion.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topics/TestTopicDeletion.java
index d106bc13b3..3baab72a3b 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topics/TestTopicDeletion.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topics/TestTopicDeletion.java
@@ -1,181 +1,181 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topics;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotEquals;
-import static org.testng.Assert.fail;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.Test;
-
-/**
- * Test cases for compaction.
- */
-@Slf4j
-public class TestTopicDeletion extends PulsarTestSuite {
-
-    private final boolean unload = false;
-    private final int numBrokers = 2;
-
-    public void setupCluster() throws Exception {
-        brokerEnvs.put("managedLedgerMaxEntriesPerLedger", "10");
-        brokerEnvs.put("brokerDeleteInactivePartitionedTopicMetadataEnabled", "false");
-        brokerEnvs.put("brokerDeleteInactiveTopicsEnabled", "false");
-        this.setupCluster("");
-    }
-
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
-            String clusterName,
-            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-        specBuilder.numBrokers(numBrokers);
-        specBuilder.enableContainerLog(true);
-        return specBuilder;
-    }
-
-    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
-    public void testPartitionedTopicForceDeletion(Supplier<String> serviceUrl) throws Exception {
-
-        log.info("Creating tenant and namespace");
-
-        final String tenant = "test-partitioned-topic-" + randomName(4);
-        final String namespace = tenant + "/ns1";
-        final String topic = "persistent://" + namespace + "/partitioned-topic";
-        final int numPartitions = numBrokers * 3;
-        final int numKeys = numPartitions * 50;
-        final String subscriptionName = "sub1";
-
-        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
-
-        this.createNamespace(namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-clusters", "--clusters", pulsarCluster.getClusterName(), namespace);
-
-        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-retention", "--size", "100M", "--time", "100m", namespace);
-
-        this.createPartitionedTopic(topic, numPartitions);
-
-        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
-
-            log.info("Creating consumer");
-            Consumer<byte[]> consumer = client.newConsumer()
-                    .topic(topic)
-                    .subscriptionName(subscriptionName)
-                    .subscribe();
-
-            log.info("Producing messages");
-            try (Producer<byte[]> producer = client.newProducer()
-                .topic(topic)
-                .create()
-            ) {
-                for (int i = 0; i < numKeys; i++) {
-                    producer.newMessage()
-                        .key("" + i)
-                        .value(("value-" + i).getBytes(UTF_8))
-                        .sendAsync();
-                }
-                producer.flush();
-                log.info("Successfully wrote {} values", numKeys);
-            }
-
-            log.info("Consuming half of the messages");
-            for (int i = 0; i < numKeys / 2; i++) {
-                Message<byte[]> m = consumer.receive(1, TimeUnit.MINUTES);
-                log.info("Read value {}", m.getKey());
-            }
-
-            if (unload) {
-                log.info("Unloading topic");
-                pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                        "unload", topic);
-            }
-
-            ContainerExecResult res;
-            log.info("Deleting the topic");
-            try {
-                res = pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                        "delete-partitioned-topic", "--force", topic);
-                assertNotEquals(0, res.getExitCode());
-            } catch (ContainerExecException e) {
-                log.info("Second delete failed with ContainerExecException, could be ok", e);
-                if (!e.getMessage().contains("with error code 1")) {
-                    fail("Expected different error code");
-                }
-            }
-
-            log.info("Close the consumer and delete the topic again");
-            consumer.close();
-
-            res = pulsarCluster.runAdminCommandOnAnyBroker("topics",
-                    "delete-partitioned-topic", "--force", topic);
-            assertNotEquals(0, res.getExitCode());
-
-            Thread.sleep(5000);
-            // should succeed
-            log.info("Creating the topic again");
-            this.createPartitionedTopic(topic, numBrokers * 2);
-        }
-    }
-
-
-    private ContainerExecResult createTenantName(final String tenantName,
-                                                 final String allowedClusterName,
-                                                 final String adminRoleName) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "tenants", "create", "--allowed-clusters", allowedClusterName,
-            "--admin-roles", adminRoleName, tenantName);
-        assertEquals(0, result.getExitCode());
-        return result;
-    }
-
-    private ContainerExecResult createNamespace(final String ns) throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-                "namespaces",
-                "create",
-                "--clusters",
-                pulsarCluster.getClusterName(), ns);
-        assertEquals(0, result.getExitCode());
-        return result;
-    }
-
-    private ContainerExecResult createPartitionedTopic(final String partitionedTopicName, int numPartitions)
-            throws Exception {
-        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
-            "topics",
-            "create-partitioned-topic",
-            "--partitions", "" + numPartitions,
-            partitionedTopicName);
-        assertEquals(0, result.getExitCode());
-        return result;
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topics;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.fail;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.Test;
+
+/**
+ * Test cases for compaction.
+ */
+@Slf4j
+public class TestTopicDeletion extends PulsarTestSuite {
+
+    private final boolean unload = false;
+    private final int numBrokers = 2;
+
+    public void setupCluster() throws Exception {
+        brokerEnvs.put("managedLedgerMaxEntriesPerLedger", "10");
+        brokerEnvs.put("brokerDeleteInactivePartitionedTopicMetadataEnabled", "false");
+        brokerEnvs.put("brokerDeleteInactiveTopicsEnabled", "false");
+        this.setupCluster("");
+    }
+
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
+            String clusterName,
+            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+        specBuilder.numBrokers(numBrokers);
+        specBuilder.enableContainerLog(true);
+        return specBuilder;
+    }
+
+    @Test(dataProvider = "ServiceUrls", timeOut = 300_000)
+    public void testPartitionedTopicForceDeletion(Supplier<String> serviceUrl) throws Exception {
+
+        log.info("Creating tenant and namespace");
+
+        final String tenant = "test-partitioned-topic-" + randomName(4);
+        final String namespace = tenant + "/ns1";
+        final String topic = "persistent://" + namespace + "/partitioned-topic";
+        final int numPartitions = numBrokers * 3;
+        final int numKeys = numPartitions * 50;
+        final String subscriptionName = "sub1";
+
+        this.createTenantName(tenant, pulsarCluster.getClusterName(), "admin");
+
+        this.createNamespace(namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-clusters", "--clusters", pulsarCluster.getClusterName(), namespace);
+
+        pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-retention", "--size", "100M", "--time", "100m", namespace);
+
+        this.createPartitionedTopic(topic, numPartitions);
+
+        try (PulsarClient client = PulsarClient.builder().serviceUrl(serviceUrl.get()).build()) {
+
+            log.info("Creating consumer");
+            Consumer<byte[]> consumer = client.newConsumer()
+                    .topic(topic)
+                    .subscriptionName(subscriptionName)
+                    .subscribe();
+
+            log.info("Producing messages");
+            try (Producer<byte[]> producer = client.newProducer()
+                .topic(topic)
+                .create()
+            ) {
+                for (int i = 0; i < numKeys; i++) {
+                    producer.newMessage()
+                        .key("" + i)
+                        .value(("value-" + i).getBytes(UTF_8))
+                        .sendAsync();
+                }
+                producer.flush();
+                log.info("Successfully wrote {} values", numKeys);
+            }
+
+            log.info("Consuming half of the messages");
+            for (int i = 0; i < numKeys / 2; i++) {
+                Message<byte[]> m = consumer.receive(1, TimeUnit.MINUTES);
+                log.info("Read value {}", m.getKey());
+            }
+
+            if (unload) {
+                log.info("Unloading topic");
+                pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                        "unload", topic);
+            }
+
+            ContainerExecResult res;
+            log.info("Deleting the topic");
+            try {
+                res = pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                        "delete-partitioned-topic", "--force", topic);
+                assertNotEquals(0, res.getExitCode());
+            } catch (ContainerExecException e) {
+                log.info("Second delete failed with ContainerExecException, could be ok", e);
+                if (!e.getMessage().contains("with error code 1")) {
+                    fail("Expected different error code");
+                }
+            }
+
+            log.info("Close the consumer and delete the topic again");
+            consumer.close();
+
+            res = pulsarCluster.runAdminCommandOnAnyBroker("topics",
+                    "delete-partitioned-topic", "--force", topic);
+            assertNotEquals(0, res.getExitCode());
+
+            Thread.sleep(5000);
+            // should succeed
+            log.info("Creating the topic again");
+            this.createPartitionedTopic(topic, numBrokers * 2);
+        }
+    }
+
+
+    private ContainerExecResult createTenantName(final String tenantName,
+                                                 final String allowedClusterName,
+                                                 final String adminRoleName) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "tenants", "create", "--allowed-clusters", allowedClusterName,
+            "--admin-roles", adminRoleName, tenantName);
+        assertEquals(0, result.getExitCode());
+        return result;
+    }
+
+    private ContainerExecResult createNamespace(final String ns) throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+                "namespaces",
+                "create",
+                "--clusters",
+                pulsarCluster.getClusterName(), ns);
+        assertEquals(0, result.getExitCode());
+        return result;
+    }
+
+    private ContainerExecResult createPartitionedTopic(final String partitionedTopicName, int numPartitions)
+            throws Exception {
+        ContainerExecResult result = pulsarCluster.runAdminCommandOnAnyBroker(
+            "topics",
+            "create-partitioned-topic",
+            "--partitions", "" + numPartitions,
+            partitionedTopicName);
+        assertEquals(0, result.getExitCode());
+        return result;
+    }
+
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/ClientTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/ClientTestBase.java
index ddfa621303..c71b3f1db4 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/ClientTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/ClientTestBase.java
@@ -1,80 +1,80 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-
-public class ClientTestBase {
-    private static final int RECEIVE_TIMEOUT_SECONDS = 3;
-
-    public void resetCursorCompatibility(String serviceUrl, String serviceHttpUrl, String topicName) throws Exception {
-        final String subName = "my-sub";
-        @Cleanup final PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-        @Cleanup final PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(serviceHttpUrl)
-                .build();
-
-        Message<String> lastMsg = null;
-        {
-            @Cleanup
-            Producer<String> producer = pulsarClient.newProducer(Schema.STRING)
-                    .enableBatching(false).topic(topicName).create();
-            @Cleanup
-            Consumer<String> consumer = pulsarClient.newConsumer(Schema.STRING)
-                    .topic(topicName).subscriptionName(subName).subscribe();
-            for (int i = 0; i < 50; i++) {
-                producer.send("msg" + i);
-            }
-            for (int i = 0; i < 10; i++) {
-                lastMsg = consumer.receive();
-                assertNotNull(lastMsg);
-                consumer.acknowledge(lastMsg);
-            }
-        }
-
-        admin.topics().resetCursor(topicName, subName, lastMsg.getMessageId());
-        {
-            @Cleanup
-            Consumer<String> consumer2 =
-                    pulsarClient.newConsumer(Schema.STRING).topic(topicName).subscriptionName(subName).subscribe();
-            Message<String> message = consumer2.receive(RECEIVE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
-            assertEquals(message.getMessageId(), lastMsg.getMessageId());
-        }
-
-        admin.topics().resetCursorAsync(topicName, subName, lastMsg.getMessageId()).get(3, TimeUnit.SECONDS);
-        {
-            @Cleanup
-            Consumer<String> consumer3 =
-                    pulsarClient.newConsumer(Schema.STRING).topic(topicName).subscriptionName(subName).subscribe();
-            Message<String> message = consumer3.receive(RECEIVE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
-            assertEquals(message.getMessageId(), lastMsg.getMessageId());
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+
+public class ClientTestBase {
+    private static final int RECEIVE_TIMEOUT_SECONDS = 3;
+
+    public void resetCursorCompatibility(String serviceUrl, String serviceHttpUrl, String topicName) throws Exception {
+        final String subName = "my-sub";
+        @Cleanup final PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+        @Cleanup final PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(serviceHttpUrl)
+                .build();
+
+        Message<String> lastMsg = null;
+        {
+            @Cleanup
+            Producer<String> producer = pulsarClient.newProducer(Schema.STRING)
+                    .enableBatching(false).topic(topicName).create();
+            @Cleanup
+            Consumer<String> consumer = pulsarClient.newConsumer(Schema.STRING)
+                    .topic(topicName).subscriptionName(subName).subscribe();
+            for (int i = 0; i < 50; i++) {
+                producer.send("msg" + i);
+            }
+            for (int i = 0; i < 10; i++) {
+                lastMsg = consumer.receive();
+                assertNotNull(lastMsg);
+                consumer.acknowledge(lastMsg);
+            }
+        }
+
+        admin.topics().resetCursor(topicName, subName, lastMsg.getMessageId());
+        {
+            @Cleanup
+            Consumer<String> consumer2 =
+                    pulsarClient.newConsumer(Schema.STRING).topic(topicName).subscriptionName(subName).subscribe();
+            Message<String> message = consumer2.receive(RECEIVE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
+            assertEquals(message.getMessageId(), lastMsg.getMessageId());
+        }
+
+        admin.topics().resetCursorAsync(topicName, subName, lastMsg.getMessageId()).get(3, TimeUnit.SECONDS);
+        {
+            @Cleanup
+            Consumer<String> consumer3 =
+                    pulsarClient.newConsumer(Schema.STRING).topic(topicName).subscriptionName(subName).subscribe();
+            Message<String> message = consumer3.receive(RECEIVE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
+            assertEquals(message.getMessageId(), lastMsg.getMessageId());
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/FunctionRuntimeType.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/FunctionRuntimeType.java
index f772ac2469..69b37b406e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/FunctionRuntimeType.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/FunctionRuntimeType.java
@@ -1,27 +1,27 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-/**
- * Runtime type to run functions.
- */
-public enum FunctionRuntimeType {
-    PROCESS,
-    THREAD
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+/**
+ * Runtime type to run functions.
+ */
+public enum FunctionRuntimeType {
+    PROCESS,
+    THREAD
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarCluster.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarCluster.java
index 92112960f9..f97a89a085 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarCluster.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarCluster.java
@@ -1,763 +1,763 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_HTTPS_PORT;
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_HTTP_PORT;
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_PORT_TLS;
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.CS_PORT;
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.PULSAR_CONTAINERS_LEAVE_RUNNING;
-import static org.apache.pulsar.tests.integration.containers.PulsarContainer.ZK_PORT;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.function.Function;
-import lombok.Cleanup;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.io.IOUtils;
-import org.apache.pulsar.client.impl.auth.AuthenticationTls;
-import org.apache.pulsar.tests.integration.containers.BKContainer;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.CSContainer;
-import org.apache.pulsar.tests.integration.containers.ProxyContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.containers.PulsarInitMetadataContainer;
-import org.apache.pulsar.tests.integration.containers.WorkerContainer;
-import org.apache.pulsar.tests.integration.containers.ZKContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.oxia.OxiaContainer;
-import org.testcontainers.containers.BindMode;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.Network;
-
-/**
- * Pulsar Cluster in containers.
- */
-@Slf4j
-public class PulsarCluster {
-
-    public static final String ADMIN_SCRIPT = "/pulsar/bin/pulsar-admin";
-    public static final String CLIENT_SCRIPT = "/pulsar/bin/pulsar-client";
-    public static final String PULSAR_COMMAND_SCRIPT = "/pulsar/bin/pulsar";
-    public static final String CURL = "/usr/bin/curl";
-
-    /**
-     * Pulsar Cluster Spec.
-     *
-     * @param spec pulsar cluster spec.
-     * @return the built pulsar cluster
-     */
-    public static PulsarCluster forSpec(PulsarClusterSpec spec) {
-        return forSpec(spec, Network.newNetwork());
-    }
-
-    public static PulsarCluster forSpec(PulsarClusterSpec spec, Network network) {
-        checkArgument(network != null, "Network should not be null");
-        CSContainer csContainer = null;
-        if (!spec.enableOxia) {
-            csContainer = new CSContainer(spec.clusterName)
-                    .withNetwork(network)
-                    .withNetworkAliases(CSContainer.NAME);
-        }
-        return new PulsarCluster(spec, network, csContainer, false);
-    }
-
-    public static PulsarCluster forSpec(PulsarClusterSpec spec, CSContainer csContainer) {
-        return new PulsarCluster(spec, csContainer.getNetwork(), csContainer, true);
-    }
-
-    @Getter
-    private final PulsarClusterSpec spec;
-
-    public boolean closeNetworkOnExit = true;
-    @Getter
-    private final String clusterName;
-    private final Network network;
-    private final ZKContainer zkContainer;
-
-    private final OxiaContainer oxiaContainer;
-    private final CSContainer csContainer;
-    private final boolean sharedCsContainer;
-    private final Map<String, BKContainer> bookieContainers;
-    private final Map<String, BrokerContainer> brokerContainers;
-    private final Map<String, WorkerContainer> workerContainers;
-    private final ProxyContainer proxyContainer;
-    private Map<String, GenericContainer<?>> externalServices = Collections.emptyMap();
-    private Map<String, Map<String, String>> externalServiceEnvs;
-    private final Map<String, String> functionWorkerEnvs;
-    private final List<Integer> functionWorkerAdditionalPorts;
-
-    private final String metadataStoreUrl;
-    private final String configurationMetadataStoreUrl;
-
-    private PulsarCluster(PulsarClusterSpec spec, Network network, CSContainer csContainer, boolean sharedCsContainer) {
-        this.spec = spec;
-        this.sharedCsContainer = sharedCsContainer;
-        this.clusterName = spec.clusterName();
-        if (network != null) {
-            this.network = network;
-        } else if (csContainer != null) {
-            this.network = csContainer.getNetwork();
-        } else {
-            this.network = Network.newNetwork();
-        }
-
-        if (spec.enableOxia) {
-            this.zkContainer = null;
-            this.oxiaContainer = new OxiaContainer(clusterName);
-            this.oxiaContainer
-                    .withNetwork(network)
-                    .withNetworkAliases(appendClusterName(OxiaContainer.NAME));
-            metadataStoreUrl = "oxia://" + oxiaContainer.getServiceAddress();
-            configurationMetadataStoreUrl = metadataStoreUrl;
-        } else {
-            this.oxiaContainer = null;
-            this.zkContainer = new ZKContainer(clusterName);
-            this.zkContainer
-                    .withNetwork(network)
-                    .withNetworkAliases(appendClusterName(ZKContainer.NAME))
-                    .withEnv("clusterName", clusterName)
-                    .withEnv("zkServers", appendClusterName(ZKContainer.NAME))
-                    .withEnv("configurationStore", CSContainer.NAME + ":" + CS_PORT)
-                    .withEnv("forceSync", "no")
-                    .withEnv("pulsarNode", appendClusterName("pulsar-broker-0"));
-            metadataStoreUrl = appendClusterName(ZKContainer.NAME);
-            configurationMetadataStoreUrl = CSContainer.NAME + ":" + CS_PORT;
-        }
-
-        this.csContainer = csContainer;
-
-        this.bookieContainers = Maps.newTreeMap();
-        this.brokerContainers = Maps.newTreeMap();
-        this.workerContainers = Maps.newTreeMap();
-
-        this.proxyContainer = new ProxyContainer(clusterName, appendClusterName(ProxyContainer.NAME), spec.enableTls)
-                .withNetwork(network)
-                .withNetworkAliases(appendClusterName("pulsar-proxy"))
-                .withEnv("metadataStoreUrl", metadataStoreUrl)
-                .withEnv("configurationMetadataStoreUrl", configurationMetadataStoreUrl)
-                .withEnv("clusterName", clusterName);
-        // enable mTLS
-        if (spec.enableTls) {
-            proxyContainer
-                    .withEnv("webServicePortTls", String.valueOf(BROKER_HTTPS_PORT))
-                    .withEnv("servicePortTls", String.valueOf(BROKER_PORT_TLS))
-                    .withEnv("forwardAuthorizationCredentials", "true")
-                    .withEnv("tlsRequireTrustedClientCertOnConnect", "true")
-                    .withEnv("tlsAllowInsecureConnection", "false")
-                    .withEnv("tlsCertificateFilePath", "/pulsar/certificate-authority/server-keys/proxy.cert.pem")
-                    .withEnv("tlsKeyFilePath", "/pulsar/certificate-authority/server-keys/proxy.key-pk8.pem")
-                    .withEnv("tlsTrustCertsFilePath", "/pulsar/certificate-authority/certs/ca.cert.pem")
-                    .withEnv("brokerClientAuthenticationPlugin", AuthenticationTls.class.getName())
-                    .withEnv("brokerClientAuthenticationParameters", String.format("tlsCertFile:%s,tlsKeyFile:%s",
-                            "/pulsar/certificate-authority/client-keys/admin.cert.pem",
-                            "/pulsar/certificate-authority/client-keys/admin.key-pk8.pem"))
-                    .withEnv("tlsEnabledWithBroker", "true")
-                    .withEnv("brokerClientTrustCertsFilePath", "/pulsar/certificate-authority/certs/ca.cert.pem")
-                    .withEnv("brokerClientCertificateFilePath",
-                            "/pulsar/certificate-authority/server-keys/proxy.cert.pem")
-                    .withEnv("brokerClientKeyFilePath", "/pulsar/certificate-authority/server-keys/proxy.key-pk8.pem");
-
-        }
-        if (spec.proxyEnvs != null) {
-            spec.proxyEnvs.forEach(this.proxyContainer::withEnv);
-        }
-        if (spec.proxyMountFiles != null) {
-            spec.proxyMountFiles.forEach(this.proxyContainer::withFileSystemBind);
-        }
-        if (spec.proxyAdditionalPorts != null) {
-            spec.proxyAdditionalPorts.forEach(this.proxyContainer::addExposedPort);
-        }
-
-        // create bookies
-        bookieContainers.putAll(
-                runNumContainers("bookie", spec.numBookies(), (name) -> {
-                    BKContainer bookieContainer = new BKContainer(clusterName, name)
-                            .withNetwork(network)
-                            .withNetworkAliases(appendClusterName(name))
-                            .withEnv("metadataServiceUri", "metadata-store:" + metadataStoreUrl)
-                            .withEnv("useHostNameAsBookieID", "true")
-                            // Disable fsyncs for tests since they're slow within the containers
-                            .withEnv("journalSyncData", "false")
-                            .withEnv("journalMaxGroupWaitMSec", "0")
-                            .withEnv("clusterName", clusterName)
-                            .withEnv("PULSAR_PREFIX_diskUsageWarnThreshold", "0.95")
-                            .withEnv("diskUsageThreshold", "0.99")
-                            .withEnv("PULSAR_PREFIX_diskUsageLwmThreshold", "0.97")
-                            .withEnv("nettyMaxFrameSizeBytes", String.valueOf(spec.maxMessageSize))
-                            .withEnv("ledgerDirectories", "data/bookkeeper/" + name + "/ledgers")
-                            .withEnv("journalDirectory", "data/bookkeeper/" + name + "/journal");
-                    if (spec.bookkeeperEnvs != null) {
-                        bookieContainer.withEnv(spec.bookkeeperEnvs);
-                    }
-                    if (spec.bookieAdditionalPorts != null) {
-                        spec.bookieAdditionalPorts.forEach(bookieContainer::addExposedPort);
-                    }
-                    return bookieContainer;
-                })
-        );
-
-        // create brokers
-        brokerContainers.putAll(
-                runNumContainers("broker", spec.numBrokers(), (name) -> {
-                            BrokerContainer brokerContainer =
-                                    new BrokerContainer(clusterName, appendClusterName(name), spec.enableTls)
-                                            .withNetwork(network)
-                                            .withNetworkAliases(appendClusterName(name))
-                                            .withEnv("metadataStoreUrl", metadataStoreUrl)
-                                            .withEnv("configurationMetadataStoreUrl", configurationMetadataStoreUrl)
-                                            .withEnv("clusterName", clusterName)
-                                            .withEnv("brokerServiceCompactionMonitorIntervalInSeconds", "1")
-                                            .withEnv("loadBalancerOverrideBrokerNicSpeedGbps", "1")
-                                            // used in s3 tests
-                                            .withEnv("AWS_ACCESS_KEY_ID", "accesskey").withEnv("AWS_SECRET_KEY",
-                                                    "secretkey")
-                                            .withEnv("maxMessageSize", "" + spec.maxMessageSize);
-                            if (spec.enableTls) {
-                                // enable mTLS
-                                brokerContainer
-                                        .withEnv("webServicePortTls", String.valueOf(BROKER_HTTPS_PORT))
-                                        .withEnv("brokerServicePortTls", String.valueOf(BROKER_PORT_TLS))
-                                        .withEnv("authenticateOriginalAuthData", "true")
-                                        .withEnv("tlsAllowInsecureConnection", "false")
-                                        .withEnv("tlsRequireTrustedClientCertOnConnect", "true")
-                                        .withEnv("tlsTrustCertsFilePath", "/pulsar/certificate-authority/certs/ca"
-                                                + ".cert.pem")
-                                        .withEnv("tlsCertificateFilePath",
-                                                "/pulsar/certificate-authority/server-keys/broker.cert.pem")
-                                        .withEnv("tlsKeyFilePath",
-                                                "/pulsar/certificate-authority/server-keys/broker.key-pk8.pem");
-                            }
-                            if (spec.queryLastMessage) {
-                                brokerContainer.withEnv("bookkeeperExplicitLacIntervalInMills", "10");
-                                brokerContainer.withEnv("bookkeeperUseV2WireProtocol", "false");
-                            }
-                            if (spec.brokerEnvs != null) {
-                                brokerContainer.withEnv(spec.brokerEnvs);
-                            }
-                            if (spec.brokerMountFiles != null) {
-                                spec.brokerMountFiles.forEach(brokerContainer::withFileSystemBind);
-                            }
-                            if (spec.brokerAdditionalPorts() != null) {
-                                spec.brokerAdditionalPorts().forEach(brokerContainer::addExposedPort);
-                            }
-                            return brokerContainer;
-                        }
-                ));
-
-        if (spec.dataContainer != null) {
-            if (!sharedCsContainer && csContainer != null) {
-                csContainer.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE);
-            }
-            if (zkContainer != null) {
-                zkContainer.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE);
-            }
-            proxyContainer.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE);
-
-            bookieContainers.values().forEach(c -> c.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE));
-            brokerContainers.values().forEach(c -> c.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE));
-            workerContainers.values().forEach(c -> c.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE));
-        }
-
-        spec.classPathVolumeMounts.forEach((key, value) -> {
-            if (zkContainer != null) {
-                zkContainer.withClasspathResourceMapping(key, value, BindMode.READ_WRITE);
-            }
-            if (!sharedCsContainer && csContainer != null) {
-                csContainer.withClasspathResourceMapping(key, value, BindMode.READ_WRITE);
-            }
-            proxyContainer.withClasspathResourceMapping(key, value, BindMode.READ_WRITE);
-
-            bookieContainers.values().forEach(c -> c.withClasspathResourceMapping(key, value, BindMode.READ_WRITE));
-            brokerContainers.values().forEach(c -> c.withClasspathResourceMapping(key, value, BindMode.READ_WRITE));
-            workerContainers.values().forEach(c -> c.withClasspathResourceMapping(key, value, BindMode.READ_WRITE));
-        });
-
-        functionWorkerEnvs = spec.functionWorkerEnvs;
-        functionWorkerAdditionalPorts = spec.functionWorkerAdditionalPorts;
-    }
-
-    public String getPlainTextServiceUrl() {
-        return proxyContainer.getPlainTextServiceUrl();
-    }
-
-    public String getHttpServiceUrl() {
-        return proxyContainer.getHttpServiceUrl();
-    }
-
-    public String getAnyBrokersHttpsServiceUrl() {
-        return getAnyBroker().getHttpsServiceUrl();
-    }
-
-    public String getAnyBrokersServiceUrlTls() {
-        return getAnyBroker().getServiceUrlTls();
-    }
-
-    public String getAllBrokersHttpServiceUrl() {
-        String multiUrl = "http://";
-        Iterator<BrokerContainer> brokers = getBrokers().iterator();
-        while (brokers.hasNext()) {
-            BrokerContainer broker = brokers.next();
-            multiUrl += broker.getHost() + ":" + broker.getMappedPort(BROKER_HTTP_PORT);
-            if (brokers.hasNext()) {
-                multiUrl += ",";
-            }
-        }
-        return multiUrl;
-    }
-
-    public String getZKConnString() {
-        return zkContainer.getHost() + ":" + zkContainer.getMappedPort(ZK_PORT);
-    }
-
-    public String getCSConnString() {
-        return csContainer.getHost() + ":" + csContainer.getMappedPort(CS_PORT);
-    }
-
-    public Network getNetwork() {
-        return network;
-    }
-
-    public Map<String, GenericContainer<?>> getExternalServices() {
-        return externalServices;
-    }
-
-    public void start() throws Exception {
-        start(true);
-    }
-
-    public void start(boolean doInit) throws Exception {
-
-        if (!spec.enableOxia) {
-            // start the local zookeeper
-            zkContainer.start();
-            log.info("Successfully started local zookeeper container.");
-
-            // start the configuration store
-            if (!sharedCsContainer) {
-                csContainer.start();
-                log.info("Successfully started configuration store container.");
-            }
-        } else {
-            oxiaContainer.start();
-        }
-
-        if (doInit) {
-            // Run cluster metadata initialization
-            @Cleanup
-            PulsarInitMetadataContainer init = new PulsarInitMetadataContainer(
-                    network,
-                    clusterName,
-                    metadataStoreUrl,
-                    configurationMetadataStoreUrl,
-                    appendClusterName("pulsar-broker-0")
-            );
-            init.initialize();
-        }
-
-        // start bookies
-        bookieContainers.values().forEach(BKContainer::start);
-        log.info("Successfully started {} bookie containers.", bookieContainers.size());
-
-        // start brokers
-        this.startAllBrokers();
-        log.info("Successfully started {} broker containers.", brokerContainers.size());
-
-        // create proxy
-        proxyContainer.start();
-        log.info("Successfully started pulsar proxy.");
-
-        log.info("Pulsar cluster {} is up running:", clusterName);
-        log.info("\tBinary Service Url : {}", getPlainTextServiceUrl());
-        log.info("\tHttp Service Url : {}", getHttpServiceUrl());
-
-        // start external services
-        this.externalServices = spec.externalServices;
-        this.externalServiceEnvs = spec.externalServiceEnvs;
-        if (null != externalServices) {
-            externalServices.entrySet().parallelStream().forEach(service -> {
-                GenericContainer<?> serviceContainer = service.getValue();
-                serviceContainer.withNetwork(network);
-                serviceContainer.withNetworkAliases(service.getKey());
-                if (null != externalServiceEnvs && null != externalServiceEnvs.get(service.getKey())) {
-                    Map<String, String> env =
-                            externalServiceEnvs.getOrDefault(service.getKey(), Collections.emptyMap());
-                    serviceContainer.withEnv(env);
-                }
-                PulsarContainer.configureLeaveContainerRunning(serviceContainer);
-                serviceContainer.start();
-                log.info("Successfully started external service {}.", service.getKey());
-            });
-        }
-    }
-
-    public void startService(String networkAlias,
-                             GenericContainer<?> serviceContainer) {
-        log.info("Starting external service {} ...", networkAlias);
-        serviceContainer.withNetwork(network);
-        serviceContainer.withNetworkAliases(networkAlias);
-        PulsarContainer.configureLeaveContainerRunning(serviceContainer);
-        serviceContainer.start();
-        log.info("Successfully start external service {}", networkAlias);
-    }
-
-    public static void stopService(String networkAlias,
-                                   GenericContainer<?> serviceContainer) {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            logIgnoringStopDueToLeaveRunning();
-            return;
-        }
-        log.info("Stopping external service {} ...", networkAlias);
-        serviceContainer.stop();
-        log.info("Successfully stop external service {}", networkAlias);
-    }
-
-
-    private static <T extends PulsarContainer> Map<String, T> runNumContainers(String serviceName,
-                                                                               int numContainers,
-                                                                               Function<String, T> containerCreator) {
-        Map<String, T> containers = Maps.newTreeMap();
-        for (int i = 0; i < numContainers; i++) {
-            String name = "pulsar-" + serviceName + "-" + i;
-            T container = containerCreator.apply(name);
-            containers.put(name, container);
-        }
-        return containers;
-    }
-
-    public synchronized void stop() {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            logIgnoringStopDueToLeaveRunning();
-            return;
-        }
-
-        stopInParallel(workerContainers.values());
-
-        if (externalServices != null) {
-            stopInParallel(externalServices.values());
-        }
-
-        if (null != proxyContainer) {
-            proxyContainer.stop();
-        }
-
-        stopInParallel(brokerContainers.values());
-
-        stopInParallel(bookieContainers.values());
-
-        if (!sharedCsContainer && null != csContainer) {
-            csContainer.stop();
-        }
-
-        if (null != zkContainer) {
-            zkContainer.stop();
-        }
-
-        if (oxiaContainer != null) {
-            oxiaContainer.stop();
-        }
-
-        if (closeNetworkOnExit) {
-            try {
-                network.close();
-            } catch (Exception e) {
-                log.info("Failed to shutdown network for pulsar cluster {}", clusterName, e);
-            }
-        }
-    }
-
-    private static void stopInParallel(Collection<? extends GenericContainer<?>> containers) {
-        containers.parallelStream()
-                .filter(Objects::nonNull)
-                .forEach(GenericContainer::stop);
-    }
-
-    public synchronized void setupFunctionWorkers(String suffix, FunctionRuntimeType runtimeType,
-                                                  int numFunctionWorkers) {
-        switch (runtimeType) {
-            case THREAD:
-                startFunctionWorkersWithThreadContainerFactory(suffix, numFunctionWorkers);
-                break;
-            case PROCESS:
-                startFunctionWorkersWithProcessContainerFactory(suffix, numFunctionWorkers);
-                break;
-        }
-    }
-
-    private void startFunctionWorkersWithProcessContainerFactory(String suffix, int numFunctionWorkers) {
-        workerContainers.putAll(runNumContainers(
-            "functions-worker-process-" + suffix,
-            numFunctionWorkers,
-            (name) -> createWorkerContainer(name)
-        ));
-        this.startWorkers();
-    }
-
-    private WorkerContainer createWorkerContainer(String name) {
-        String serviceUrl = "pulsar://pulsar-broker-0:" + PulsarContainer.BROKER_PORT;
-        String httpServiceUrl = "http://pulsar-broker-0:" + PulsarContainer.BROKER_HTTP_PORT;
-        return new WorkerContainer(clusterName, name)
-                .withNetwork(network)
-                .withNetworkAliases(name)
-                // worker settings
-                .withEnv("PF_workerId", name)
-                .withEnv("PF_workerHostname", name)
-                .withEnv("PF_workerPort", "" + PulsarContainer.BROKER_HTTP_PORT)
-                .withEnv("PF_pulsarFunctionsCluster", clusterName)
-                .withEnv("PF_pulsarServiceUrl", serviceUrl)
-                .withEnv("PF_pulsarWebServiceUrl", httpServiceUrl)
-                // script
-                .withEnv("clusterName", clusterName)
-                .withEnv("zookeeperServers", ZKContainer.NAME)
-                // bookkeeper tools
-                .withEnv("zkServers", ZKContainer.NAME)
-                .withEnv(functionWorkerEnvs)
-                .withExposedPorts(functionWorkerAdditionalPorts.toArray(new Integer[0]));
-    }
-
-    private void startFunctionWorkersWithThreadContainerFactory(String suffix, int numFunctionWorkers) {
-        workerContainers.putAll(runNumContainers(
-                "functions-worker-thread-" + suffix,
-                numFunctionWorkers,
-                (name) -> createWorkerContainer(name)
-                        .withEnv("PF_functionRuntimeFactoryClassName",
-                                "org.apache.pulsar.functions.runtime.thread.ThreadRuntimeFactory")
-                        .withEnv("PF_functionRuntimeFactoryConfigs_threadGroupName", "pf-container-group")
-        ));
-        this.startWorkers();
-    }
-
-    public synchronized void startWorkers() {
-        // Start workers that have been initialized
-        workerContainers.values().parallelStream().forEach(WorkerContainer::start);
-        log.info("Successfully started {} worker containers.", workerContainers.size());
-    }
-
-    public synchronized void stopWorker(String workerName) {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            logIgnoringStopDueToLeaveRunning();
-            return;
-        }
-        // Stop the named worker.
-        WorkerContainer worker = workerContainers.get(workerName);
-        if (worker == null) {
-            log.warn("Failed to find the worker to stop ({})", workerName);
-            return;
-        }
-        worker.stop();
-        workerContainers.remove(workerName);
-        log.info("Worker {} stopped and removed from the map of worker containers", workerName);
-    }
-
-    public synchronized void stopWorkers() {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            logIgnoringStopDueToLeaveRunning();
-            return;
-        }
-        // Stop workers that have been initialized
-        workerContainers.values().parallelStream().forEach(WorkerContainer::stop);
-        workerContainers.clear();
-    }
-
-    public void startContainers(Map<String, GenericContainer<?>> containers) {
-        containers.forEach((name, container) -> {
-            PulsarContainer.configureLeaveContainerRunning(container);
-            container
-                    .withNetwork(network)
-                    .withNetworkAliases(name)
-                    .start();
-            log.info("Successfully start container {}.", name);
-        });
-    }
-
-    public static void stopContainers(Map<String, GenericContainer<?>> containers) {
-        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
-            logIgnoringStopDueToLeaveRunning();
-            return;
-        }
-        containers.values().parallelStream().forEach(GenericContainer::stop);
-        log.info("Successfully stop containers : {}", containers);
-    }
-
-    private static void logIgnoringStopDueToLeaveRunning() {
-        log.warn("Ignoring stop due to PULSAR_CONTAINERS_LEAVE_RUNNING=true.");
-    }
-
-    public BrokerContainer getAnyBroker() {
-        return getAnyContainer(brokerContainers, "pulsar-broker");
-    }
-
-    public synchronized WorkerContainer getAnyWorker() {
-        return getAnyContainer(workerContainers, "pulsar-functions-worker");
-    }
-
-    public synchronized List<WorkerContainer> getAlWorkers() {
-        return new ArrayList<WorkerContainer>(workerContainers.values());
-    }
-
-    public BrokerContainer getBroker(int index) {
-        return getAnyContainer(brokerContainers, "pulsar-broker", index);
-    }
-
-    public synchronized WorkerContainer getWorker(int index) {
-        return getAnyContainer(workerContainers, "pulsar-functions-worker", index);
-    }
-
-    public synchronized WorkerContainer getWorker(String workerName) {
-        return workerContainers.get(workerName);
-    }
-
-    private <T> T getAnyContainer(Map<String, T> containers, String serviceName) {
-        List<T> containerList = Lists.newArrayList();
-        containerList.addAll(containers.values());
-        Collections.shuffle(containerList);
-        checkArgument(!containerList.isEmpty(), "No " + serviceName + " is alive");
-        return containerList.get(0);
-    }
-
-    private <T> T getAnyContainer(Map<String, T> containers, String serviceName, int index) {
-        checkArgument(!containers.isEmpty(), "No " + serviceName + " is alive");
-        checkArgument((index >= 0 && index < containers.size()), "Index : " + index + " is out range");
-        return containers.get(serviceName.toLowerCase() + "-" + index);
-    }
-
-    public Collection<BrokerContainer> getBrokers() {
-        return brokerContainers.values();
-    }
-
-    public ProxyContainer getProxy() {
-        return proxyContainer;
-    }
-
-    public Collection<BKContainer> getBookies() {
-        return bookieContainers.values();
-    }
-
-    public ZKContainer getZooKeeper() {
-        return zkContainer;
-    }
-
-    public ContainerExecResult runAdminCommandOnAnyBroker(String... commands) throws Exception {
-        return runCommandOnAnyBrokerWithScript(ADMIN_SCRIPT, commands);
-    }
-
-    public ContainerExecResult runPulsarBaseCommandOnAnyBroker(String... commands) throws Exception {
-        return runCommandOnAnyBrokerWithScript(PULSAR_COMMAND_SCRIPT, commands);
-    }
-
-    private ContainerExecResult runCommandOnAnyBrokerWithScript(String scriptType, String... commands)
-            throws Exception {
-        BrokerContainer container = getAnyBroker();
-        String[] cmds = new String[commands.length + 1];
-        cmds[0] = scriptType;
-        System.arraycopy(commands, 0, cmds, 1, commands.length);
-        return container.execCmd(cmds);
-    }
-
-    public void stopAllBrokers() {
-        brokerContainers.values().forEach(BrokerContainer::stop);
-    }
-
-    public void startAllBrokers() {
-        brokerContainers.values().forEach(BrokerContainer::start);
-    }
-
-    public void stopAllBookies() {
-        bookieContainers.values().forEach(BKContainer::stop);
-    }
-
-    public void startAllBookies() {
-        bookieContainers.values().forEach(BKContainer::start);
-    }
-
-    public void stopZooKeeper() {
-        zkContainer.stop();
-    }
-
-    public void startZooKeeper() {
-        zkContainer.start();
-    }
-
-    public ContainerExecResult createNamespace(String nsName) throws Exception {
-        return runAdminCommandOnAnyBroker(
-                "namespaces", "create", "public/" + nsName,
-                "--clusters", clusterName);
-    }
-
-    public ContainerExecResult createPartitionedTopic(String topicName, int partitions) throws Exception {
-        return runAdminCommandOnAnyBroker(
-                "topics", "create-partitioned-topic", topicName,
-                "-p", String.valueOf(partitions));
-    }
-
-    public ContainerExecResult enableDeduplication(String nsName, boolean enabled) throws Exception {
-        return runAdminCommandOnAnyBroker(
-                "namespaces", "set-deduplication", "public/" + nsName,
-                enabled ? "--enable" : "--disable");
-    }
-
-    public String getFunctionLogs(String name) {
-        StringBuilder logs = new StringBuilder();
-        for (WorkerContainer container : getAlWorkers()) {
-            try {
-                String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
-                logs.append(container.<String>copyFileFromContainer(logFile, (inputStream) -> {
-                    return IOUtils.toString(inputStream, "utf-8");
-                }));
-            } catch (Exception e) {
-                log.error("Failed to get function logs from container {}", container.getContainerName(), e);
-            }
-        }
-        return logs.toString();
-    }
-
-    public void dumpFunctionLogs(String name) {
-        for (WorkerContainer container : getAlWorkers()) {
-            log.info("Trying to get function {} logs from container {}", name, container.getContainerName());
-            try {
-                String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
-                String logs = container.<String>copyFileFromContainer(logFile, (inputStream) -> {
-                    return IOUtils.toString(inputStream, "utf-8");
-                });
-                log.info("Function {} logs {}", name, logs);
-            } catch (com.github.dockerjava.api.exception.NotFoundException notFound) {
-                log.info("Cannot download {} logs from {} not found exception {}", name, container.getContainerName(),
-                        notFound.toString());
-            } catch (Throwable err) {
-                log.info("Cannot download {} logs from {}", name, container.getContainerName(), err);
-            }
-        }
-    }
-
-    private String appendClusterName(String name) {
-        return sharedCsContainer ? clusterName + "-" + name : name;
-    }
-
-    public BKContainer getAnyBookie() {
-        return getAnyContainer(bookieContainers, "bookie");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_HTTPS_PORT;
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_HTTP_PORT;
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.BROKER_PORT_TLS;
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.CS_PORT;
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.PULSAR_CONTAINERS_LEAVE_RUNNING;
+import static org.apache.pulsar.tests.integration.containers.PulsarContainer.ZK_PORT;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Function;
+import lombok.Cleanup;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.io.IOUtils;
+import org.apache.pulsar.client.impl.auth.AuthenticationTls;
+import org.apache.pulsar.tests.integration.containers.BKContainer;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.CSContainer;
+import org.apache.pulsar.tests.integration.containers.ProxyContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.containers.PulsarInitMetadataContainer;
+import org.apache.pulsar.tests.integration.containers.WorkerContainer;
+import org.apache.pulsar.tests.integration.containers.ZKContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.oxia.OxiaContainer;
+import org.testcontainers.containers.BindMode;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.Network;
+
+/**
+ * Pulsar Cluster in containers.
+ */
+@Slf4j
+public class PulsarCluster {
+
+    public static final String ADMIN_SCRIPT = "/pulsar/bin/pulsar-admin";
+    public static final String CLIENT_SCRIPT = "/pulsar/bin/pulsar-client";
+    public static final String PULSAR_COMMAND_SCRIPT = "/pulsar/bin/pulsar";
+    public static final String CURL = "/usr/bin/curl";
+
+    /**
+     * Pulsar Cluster Spec.
+     *
+     * @param spec pulsar cluster spec.
+     * @return the built pulsar cluster
+     */
+    public static PulsarCluster forSpec(PulsarClusterSpec spec) {
+        return forSpec(spec, Network.newNetwork());
+    }
+
+    public static PulsarCluster forSpec(PulsarClusterSpec spec, Network network) {
+        checkArgument(network != null, "Network should not be null");
+        CSContainer csContainer = null;
+        if (!spec.enableOxia) {
+            csContainer = new CSContainer(spec.clusterName)
+                    .withNetwork(network)
+                    .withNetworkAliases(CSContainer.NAME);
+        }
+        return new PulsarCluster(spec, network, csContainer, false);
+    }
+
+    public static PulsarCluster forSpec(PulsarClusterSpec spec, CSContainer csContainer) {
+        return new PulsarCluster(spec, csContainer.getNetwork(), csContainer, true);
+    }
+
+    @Getter
+    private final PulsarClusterSpec spec;
+
+    public boolean closeNetworkOnExit = true;
+    @Getter
+    private final String clusterName;
+    private final Network network;
+    private final ZKContainer zkContainer;
+
+    private final OxiaContainer oxiaContainer;
+    private final CSContainer csContainer;
+    private final boolean sharedCsContainer;
+    private final Map<String, BKContainer> bookieContainers;
+    private final Map<String, BrokerContainer> brokerContainers;
+    private final Map<String, WorkerContainer> workerContainers;
+    private final ProxyContainer proxyContainer;
+    private Map<String, GenericContainer<?>> externalServices = Collections.emptyMap();
+    private Map<String, Map<String, String>> externalServiceEnvs;
+    private final Map<String, String> functionWorkerEnvs;
+    private final List<Integer> functionWorkerAdditionalPorts;
+
+    private final String metadataStoreUrl;
+    private final String configurationMetadataStoreUrl;
+
+    private PulsarCluster(PulsarClusterSpec spec, Network network, CSContainer csContainer, boolean sharedCsContainer) {
+        this.spec = spec;
+        this.sharedCsContainer = sharedCsContainer;
+        this.clusterName = spec.clusterName();
+        if (network != null) {
+            this.network = network;
+        } else if (csContainer != null) {
+            this.network = csContainer.getNetwork();
+        } else {
+            this.network = Network.newNetwork();
+        }
+
+        if (spec.enableOxia) {
+            this.zkContainer = null;
+            this.oxiaContainer = new OxiaContainer(clusterName);
+            this.oxiaContainer
+                    .withNetwork(network)
+                    .withNetworkAliases(appendClusterName(OxiaContainer.NAME));
+            metadataStoreUrl = "oxia://" + oxiaContainer.getServiceAddress();
+            configurationMetadataStoreUrl = metadataStoreUrl;
+        } else {
+            this.oxiaContainer = null;
+            this.zkContainer = new ZKContainer(clusterName);
+            this.zkContainer
+                    .withNetwork(network)
+                    .withNetworkAliases(appendClusterName(ZKContainer.NAME))
+                    .withEnv("clusterName", clusterName)
+                    .withEnv("zkServers", appendClusterName(ZKContainer.NAME))
+                    .withEnv("configurationStore", CSContainer.NAME + ":" + CS_PORT)
+                    .withEnv("forceSync", "no")
+                    .withEnv("pulsarNode", appendClusterName("pulsar-broker-0"));
+            metadataStoreUrl = appendClusterName(ZKContainer.NAME);
+            configurationMetadataStoreUrl = CSContainer.NAME + ":" + CS_PORT;
+        }
+
+        this.csContainer = csContainer;
+
+        this.bookieContainers = Maps.newTreeMap();
+        this.brokerContainers = Maps.newTreeMap();
+        this.workerContainers = Maps.newTreeMap();
+
+        this.proxyContainer = new ProxyContainer(clusterName, appendClusterName(ProxyContainer.NAME), spec.enableTls)
+                .withNetwork(network)
+                .withNetworkAliases(appendClusterName("pulsar-proxy"))
+                .withEnv("metadataStoreUrl", metadataStoreUrl)
+                .withEnv("configurationMetadataStoreUrl", configurationMetadataStoreUrl)
+                .withEnv("clusterName", clusterName);
+        // enable mTLS
+        if (spec.enableTls) {
+            proxyContainer
+                    .withEnv("webServicePortTls", String.valueOf(BROKER_HTTPS_PORT))
+                    .withEnv("servicePortTls", String.valueOf(BROKER_PORT_TLS))
+                    .withEnv("forwardAuthorizationCredentials", "true")
+                    .withEnv("tlsRequireTrustedClientCertOnConnect", "true")
+                    .withEnv("tlsAllowInsecureConnection", "false")
+                    .withEnv("tlsCertificateFilePath", "/pulsar/certificate-authority/server-keys/proxy.cert.pem")
+                    .withEnv("tlsKeyFilePath", "/pulsar/certificate-authority/server-keys/proxy.key-pk8.pem")
+                    .withEnv("tlsTrustCertsFilePath", "/pulsar/certificate-authority/certs/ca.cert.pem")
+                    .withEnv("brokerClientAuthenticationPlugin", AuthenticationTls.class.getName())
+                    .withEnv("brokerClientAuthenticationParameters", String.format("tlsCertFile:%s,tlsKeyFile:%s",
+                            "/pulsar/certificate-authority/client-keys/admin.cert.pem",
+                            "/pulsar/certificate-authority/client-keys/admin.key-pk8.pem"))
+                    .withEnv("tlsEnabledWithBroker", "true")
+                    .withEnv("brokerClientTrustCertsFilePath", "/pulsar/certificate-authority/certs/ca.cert.pem")
+                    .withEnv("brokerClientCertificateFilePath",
+                            "/pulsar/certificate-authority/server-keys/proxy.cert.pem")
+                    .withEnv("brokerClientKeyFilePath", "/pulsar/certificate-authority/server-keys/proxy.key-pk8.pem");
+
+        }
+        if (spec.proxyEnvs != null) {
+            spec.proxyEnvs.forEach(this.proxyContainer::withEnv);
+        }
+        if (spec.proxyMountFiles != null) {
+            spec.proxyMountFiles.forEach(this.proxyContainer::withFileSystemBind);
+        }
+        if (spec.proxyAdditionalPorts != null) {
+            spec.proxyAdditionalPorts.forEach(this.proxyContainer::addExposedPort);
+        }
+
+        // create bookies
+        bookieContainers.putAll(
+                runNumContainers("bookie", spec.numBookies(), (name) -> {
+                    BKContainer bookieContainer = new BKContainer(clusterName, name)
+                            .withNetwork(network)
+                            .withNetworkAliases(appendClusterName(name))
+                            .withEnv("metadataServiceUri", "metadata-store:" + metadataStoreUrl)
+                            .withEnv("useHostNameAsBookieID", "true")
+                            // Disable fsyncs for tests since they're slow within the containers
+                            .withEnv("journalSyncData", "false")
+                            .withEnv("journalMaxGroupWaitMSec", "0")
+                            .withEnv("clusterName", clusterName)
+                            .withEnv("PULSAR_PREFIX_diskUsageWarnThreshold", "0.95")
+                            .withEnv("diskUsageThreshold", "0.99")
+                            .withEnv("PULSAR_PREFIX_diskUsageLwmThreshold", "0.97")
+                            .withEnv("nettyMaxFrameSizeBytes", String.valueOf(spec.maxMessageSize))
+                            .withEnv("ledgerDirectories", "data/bookkeeper/" + name + "/ledgers")
+                            .withEnv("journalDirectory", "data/bookkeeper/" + name + "/journal");
+                    if (spec.bookkeeperEnvs != null) {
+                        bookieContainer.withEnv(spec.bookkeeperEnvs);
+                    }
+                    if (spec.bookieAdditionalPorts != null) {
+                        spec.bookieAdditionalPorts.forEach(bookieContainer::addExposedPort);
+                    }
+                    return bookieContainer;
+                })
+        );
+
+        // create brokers
+        brokerContainers.putAll(
+                runNumContainers("broker", spec.numBrokers(), (name) -> {
+                            BrokerContainer brokerContainer =
+                                    new BrokerContainer(clusterName, appendClusterName(name), spec.enableTls)
+                                            .withNetwork(network)
+                                            .withNetworkAliases(appendClusterName(name))
+                                            .withEnv("metadataStoreUrl", metadataStoreUrl)
+                                            .withEnv("configurationMetadataStoreUrl", configurationMetadataStoreUrl)
+                                            .withEnv("clusterName", clusterName)
+                                            .withEnv("brokerServiceCompactionMonitorIntervalInSeconds", "1")
+                                            .withEnv("loadBalancerOverrideBrokerNicSpeedGbps", "1")
+                                            // used in s3 tests
+                                            .withEnv("AWS_ACCESS_KEY_ID", "accesskey").withEnv("AWS_SECRET_KEY",
+                                                    "secretkey")
+                                            .withEnv("maxMessageSize", "" + spec.maxMessageSize);
+                            if (spec.enableTls) {
+                                // enable mTLS
+                                brokerContainer
+                                        .withEnv("webServicePortTls", String.valueOf(BROKER_HTTPS_PORT))
+                                        .withEnv("brokerServicePortTls", String.valueOf(BROKER_PORT_TLS))
+                                        .withEnv("authenticateOriginalAuthData", "true")
+                                        .withEnv("tlsAllowInsecureConnection", "false")
+                                        .withEnv("tlsRequireTrustedClientCertOnConnect", "true")
+                                        .withEnv("tlsTrustCertsFilePath", "/pulsar/certificate-authority/certs/ca"
+                                                + ".cert.pem")
+                                        .withEnv("tlsCertificateFilePath",
+                                                "/pulsar/certificate-authority/server-keys/broker.cert.pem")
+                                        .withEnv("tlsKeyFilePath",
+                                                "/pulsar/certificate-authority/server-keys/broker.key-pk8.pem");
+                            }
+                            if (spec.queryLastMessage) {
+                                brokerContainer.withEnv("bookkeeperExplicitLacIntervalInMills", "10");
+                                brokerContainer.withEnv("bookkeeperUseV2WireProtocol", "false");
+                            }
+                            if (spec.brokerEnvs != null) {
+                                brokerContainer.withEnv(spec.brokerEnvs);
+                            }
+                            if (spec.brokerMountFiles != null) {
+                                spec.brokerMountFiles.forEach(brokerContainer::withFileSystemBind);
+                            }
+                            if (spec.brokerAdditionalPorts() != null) {
+                                spec.brokerAdditionalPorts().forEach(brokerContainer::addExposedPort);
+                            }
+                            return brokerContainer;
+                        }
+                ));
+
+        if (spec.dataContainer != null) {
+            if (!sharedCsContainer && csContainer != null) {
+                csContainer.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE);
+            }
+            if (zkContainer != null) {
+                zkContainer.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE);
+            }
+            proxyContainer.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE);
+
+            bookieContainers.values().forEach(c -> c.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE));
+            brokerContainers.values().forEach(c -> c.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE));
+            workerContainers.values().forEach(c -> c.withVolumesFrom(spec.dataContainer, BindMode.READ_WRITE));
+        }
+
+        spec.classPathVolumeMounts.forEach((key, value) -> {
+            if (zkContainer != null) {
+                zkContainer.withClasspathResourceMapping(key, value, BindMode.READ_WRITE);
+            }
+            if (!sharedCsContainer && csContainer != null) {
+                csContainer.withClasspathResourceMapping(key, value, BindMode.READ_WRITE);
+            }
+            proxyContainer.withClasspathResourceMapping(key, value, BindMode.READ_WRITE);
+
+            bookieContainers.values().forEach(c -> c.withClasspathResourceMapping(key, value, BindMode.READ_WRITE));
+            brokerContainers.values().forEach(c -> c.withClasspathResourceMapping(key, value, BindMode.READ_WRITE));
+            workerContainers.values().forEach(c -> c.withClasspathResourceMapping(key, value, BindMode.READ_WRITE));
+        });
+
+        functionWorkerEnvs = spec.functionWorkerEnvs;
+        functionWorkerAdditionalPorts = spec.functionWorkerAdditionalPorts;
+    }
+
+    public String getPlainTextServiceUrl() {
+        return proxyContainer.getPlainTextServiceUrl();
+    }
+
+    public String getHttpServiceUrl() {
+        return proxyContainer.getHttpServiceUrl();
+    }
+
+    public String getAnyBrokersHttpsServiceUrl() {
+        return getAnyBroker().getHttpsServiceUrl();
+    }
+
+    public String getAnyBrokersServiceUrlTls() {
+        return getAnyBroker().getServiceUrlTls();
+    }
+
+    public String getAllBrokersHttpServiceUrl() {
+        String multiUrl = "http://";
+        Iterator<BrokerContainer> brokers = getBrokers().iterator();
+        while (brokers.hasNext()) {
+            BrokerContainer broker = brokers.next();
+            multiUrl += broker.getHost() + ":" + broker.getMappedPort(BROKER_HTTP_PORT);
+            if (brokers.hasNext()) {
+                multiUrl += ",";
+            }
+        }
+        return multiUrl;
+    }
+
+    public String getZKConnString() {
+        return zkContainer.getHost() + ":" + zkContainer.getMappedPort(ZK_PORT);
+    }
+
+    public String getCSConnString() {
+        return csContainer.getHost() + ":" + csContainer.getMappedPort(CS_PORT);
+    }
+
+    public Network getNetwork() {
+        return network;
+    }
+
+    public Map<String, GenericContainer<?>> getExternalServices() {
+        return externalServices;
+    }
+
+    public void start() throws Exception {
+        start(true);
+    }
+
+    public void start(boolean doInit) throws Exception {
+
+        if (!spec.enableOxia) {
+            // start the local zookeeper
+            zkContainer.start();
+            log.info("Successfully started local zookeeper container.");
+
+            // start the configuration store
+            if (!sharedCsContainer) {
+                csContainer.start();
+                log.info("Successfully started configuration store container.");
+            }
+        } else {
+            oxiaContainer.start();
+        }
+
+        if (doInit) {
+            // Run cluster metadata initialization
+            @Cleanup
+            PulsarInitMetadataContainer init = new PulsarInitMetadataContainer(
+                    network,
+                    clusterName,
+                    metadataStoreUrl,
+                    configurationMetadataStoreUrl,
+                    appendClusterName("pulsar-broker-0")
+            );
+            init.initialize();
+        }
+
+        // start bookies
+        bookieContainers.values().forEach(BKContainer::start);
+        log.info("Successfully started {} bookie containers.", bookieContainers.size());
+
+        // start brokers
+        this.startAllBrokers();
+        log.info("Successfully started {} broker containers.", brokerContainers.size());
+
+        // create proxy
+        proxyContainer.start();
+        log.info("Successfully started pulsar proxy.");
+
+        log.info("Pulsar cluster {} is up running:", clusterName);
+        log.info("\tBinary Service Url : {}", getPlainTextServiceUrl());
+        log.info("\tHttp Service Url : {}", getHttpServiceUrl());
+
+        // start external services
+        this.externalServices = spec.externalServices;
+        this.externalServiceEnvs = spec.externalServiceEnvs;
+        if (null != externalServices) {
+            externalServices.entrySet().parallelStream().forEach(service -> {
+                GenericContainer<?> serviceContainer = service.getValue();
+                serviceContainer.withNetwork(network);
+                serviceContainer.withNetworkAliases(service.getKey());
+                if (null != externalServiceEnvs && null != externalServiceEnvs.get(service.getKey())) {
+                    Map<String, String> env =
+                            externalServiceEnvs.getOrDefault(service.getKey(), Collections.emptyMap());
+                    serviceContainer.withEnv(env);
+                }
+                PulsarContainer.configureLeaveContainerRunning(serviceContainer);
+                serviceContainer.start();
+                log.info("Successfully started external service {}.", service.getKey());
+            });
+        }
+    }
+
+    public void startService(String networkAlias,
+                             GenericContainer<?> serviceContainer) {
+        log.info("Starting external service {} ...", networkAlias);
+        serviceContainer.withNetwork(network);
+        serviceContainer.withNetworkAliases(networkAlias);
+        PulsarContainer.configureLeaveContainerRunning(serviceContainer);
+        serviceContainer.start();
+        log.info("Successfully start external service {}", networkAlias);
+    }
+
+    public static void stopService(String networkAlias,
+                                   GenericContainer<?> serviceContainer) {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            logIgnoringStopDueToLeaveRunning();
+            return;
+        }
+        log.info("Stopping external service {} ...", networkAlias);
+        serviceContainer.stop();
+        log.info("Successfully stop external service {}", networkAlias);
+    }
+
+
+    private static <T extends PulsarContainer> Map<String, T> runNumContainers(String serviceName,
+                                                                               int numContainers,
+                                                                               Function<String, T> containerCreator) {
+        Map<String, T> containers = Maps.newTreeMap();
+        for (int i = 0; i < numContainers; i++) {
+            String name = "pulsar-" + serviceName + "-" + i;
+            T container = containerCreator.apply(name);
+            containers.put(name, container);
+        }
+        return containers;
+    }
+
+    public synchronized void stop() {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            logIgnoringStopDueToLeaveRunning();
+            return;
+        }
+
+        stopInParallel(workerContainers.values());
+
+        if (externalServices != null) {
+            stopInParallel(externalServices.values());
+        }
+
+        if (null != proxyContainer) {
+            proxyContainer.stop();
+        }
+
+        stopInParallel(brokerContainers.values());
+
+        stopInParallel(bookieContainers.values());
+
+        if (!sharedCsContainer && null != csContainer) {
+            csContainer.stop();
+        }
+
+        if (null != zkContainer) {
+            zkContainer.stop();
+        }
+
+        if (oxiaContainer != null) {
+            oxiaContainer.stop();
+        }
+
+        if (closeNetworkOnExit) {
+            try {
+                network.close();
+            } catch (Exception e) {
+                log.info("Failed to shutdown network for pulsar cluster {}", clusterName, e);
+            }
+        }
+    }
+
+    private static void stopInParallel(Collection<? extends GenericContainer<?>> containers) {
+        containers.parallelStream()
+                .filter(Objects::nonNull)
+                .forEach(GenericContainer::stop);
+    }
+
+    public synchronized void setupFunctionWorkers(String suffix, FunctionRuntimeType runtimeType,
+                                                  int numFunctionWorkers) {
+        switch (runtimeType) {
+            case THREAD:
+                startFunctionWorkersWithThreadContainerFactory(suffix, numFunctionWorkers);
+                break;
+            case PROCESS:
+                startFunctionWorkersWithProcessContainerFactory(suffix, numFunctionWorkers);
+                break;
+        }
+    }
+
+    private void startFunctionWorkersWithProcessContainerFactory(String suffix, int numFunctionWorkers) {
+        workerContainers.putAll(runNumContainers(
+            "functions-worker-process-" + suffix,
+            numFunctionWorkers,
+            (name) -> createWorkerContainer(name)
+        ));
+        this.startWorkers();
+    }
+
+    private WorkerContainer createWorkerContainer(String name) {
+        String serviceUrl = "pulsar://pulsar-broker-0:" + PulsarContainer.BROKER_PORT;
+        String httpServiceUrl = "http://pulsar-broker-0:" + PulsarContainer.BROKER_HTTP_PORT;
+        return new WorkerContainer(clusterName, name)
+                .withNetwork(network)
+                .withNetworkAliases(name)
+                // worker settings
+                .withEnv("PF_workerId", name)
+                .withEnv("PF_workerHostname", name)
+                .withEnv("PF_workerPort", "" + PulsarContainer.BROKER_HTTP_PORT)
+                .withEnv("PF_pulsarFunctionsCluster", clusterName)
+                .withEnv("PF_pulsarServiceUrl", serviceUrl)
+                .withEnv("PF_pulsarWebServiceUrl", httpServiceUrl)
+                // script
+                .withEnv("clusterName", clusterName)
+                .withEnv("zookeeperServers", ZKContainer.NAME)
+                // bookkeeper tools
+                .withEnv("zkServers", ZKContainer.NAME)
+                .withEnv(functionWorkerEnvs)
+                .withExposedPorts(functionWorkerAdditionalPorts.toArray(new Integer[0]));
+    }
+
+    private void startFunctionWorkersWithThreadContainerFactory(String suffix, int numFunctionWorkers) {
+        workerContainers.putAll(runNumContainers(
+                "functions-worker-thread-" + suffix,
+                numFunctionWorkers,
+                (name) -> createWorkerContainer(name)
+                        .withEnv("PF_functionRuntimeFactoryClassName",
+                                "org.apache.pulsar.functions.runtime.thread.ThreadRuntimeFactory")
+                        .withEnv("PF_functionRuntimeFactoryConfigs_threadGroupName", "pf-container-group")
+        ));
+        this.startWorkers();
+    }
+
+    public synchronized void startWorkers() {
+        // Start workers that have been initialized
+        workerContainers.values().parallelStream().forEach(WorkerContainer::start);
+        log.info("Successfully started {} worker containers.", workerContainers.size());
+    }
+
+    public synchronized void stopWorker(String workerName) {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            logIgnoringStopDueToLeaveRunning();
+            return;
+        }
+        // Stop the named worker.
+        WorkerContainer worker = workerContainers.get(workerName);
+        if (worker == null) {
+            log.warn("Failed to find the worker to stop ({})", workerName);
+            return;
+        }
+        worker.stop();
+        workerContainers.remove(workerName);
+        log.info("Worker {} stopped and removed from the map of worker containers", workerName);
+    }
+
+    public synchronized void stopWorkers() {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            logIgnoringStopDueToLeaveRunning();
+            return;
+        }
+        // Stop workers that have been initialized
+        workerContainers.values().parallelStream().forEach(WorkerContainer::stop);
+        workerContainers.clear();
+    }
+
+    public void startContainers(Map<String, GenericContainer<?>> containers) {
+        containers.forEach((name, container) -> {
+            PulsarContainer.configureLeaveContainerRunning(container);
+            container
+                    .withNetwork(network)
+                    .withNetworkAliases(name)
+                    .start();
+            log.info("Successfully start container {}.", name);
+        });
+    }
+
+    public static void stopContainers(Map<String, GenericContainer<?>> containers) {
+        if (PULSAR_CONTAINERS_LEAVE_RUNNING) {
+            logIgnoringStopDueToLeaveRunning();
+            return;
+        }
+        containers.values().parallelStream().forEach(GenericContainer::stop);
+        log.info("Successfully stop containers : {}", containers);
+    }
+
+    private static void logIgnoringStopDueToLeaveRunning() {
+        log.warn("Ignoring stop due to PULSAR_CONTAINERS_LEAVE_RUNNING=true.");
+    }
+
+    public BrokerContainer getAnyBroker() {
+        return getAnyContainer(brokerContainers, "pulsar-broker");
+    }
+
+    public synchronized WorkerContainer getAnyWorker() {
+        return getAnyContainer(workerContainers, "pulsar-functions-worker");
+    }
+
+    public synchronized List<WorkerContainer> getAlWorkers() {
+        return new ArrayList<WorkerContainer>(workerContainers.values());
+    }
+
+    public BrokerContainer getBroker(int index) {
+        return getAnyContainer(brokerContainers, "pulsar-broker", index);
+    }
+
+    public synchronized WorkerContainer getWorker(int index) {
+        return getAnyContainer(workerContainers, "pulsar-functions-worker", index);
+    }
+
+    public synchronized WorkerContainer getWorker(String workerName) {
+        return workerContainers.get(workerName);
+    }
+
+    private <T> T getAnyContainer(Map<String, T> containers, String serviceName) {
+        List<T> containerList = Lists.newArrayList();
+        containerList.addAll(containers.values());
+        Collections.shuffle(containerList);
+        checkArgument(!containerList.isEmpty(), "No " + serviceName + " is alive");
+        return containerList.get(0);
+    }
+
+    private <T> T getAnyContainer(Map<String, T> containers, String serviceName, int index) {
+        checkArgument(!containers.isEmpty(), "No " + serviceName + " is alive");
+        checkArgument((index >= 0 && index < containers.size()), "Index : " + index + " is out range");
+        return containers.get(serviceName.toLowerCase() + "-" + index);
+    }
+
+    public Collection<BrokerContainer> getBrokers() {
+        return brokerContainers.values();
+    }
+
+    public ProxyContainer getProxy() {
+        return proxyContainer;
+    }
+
+    public Collection<BKContainer> getBookies() {
+        return bookieContainers.values();
+    }
+
+    public ZKContainer getZooKeeper() {
+        return zkContainer;
+    }
+
+    public ContainerExecResult runAdminCommandOnAnyBroker(String... commands) throws Exception {
+        return runCommandOnAnyBrokerWithScript(ADMIN_SCRIPT, commands);
+    }
+
+    public ContainerExecResult runPulsarBaseCommandOnAnyBroker(String... commands) throws Exception {
+        return runCommandOnAnyBrokerWithScript(PULSAR_COMMAND_SCRIPT, commands);
+    }
+
+    private ContainerExecResult runCommandOnAnyBrokerWithScript(String scriptType, String... commands)
+            throws Exception {
+        BrokerContainer container = getAnyBroker();
+        String[] cmds = new String[commands.length + 1];
+        cmds[0] = scriptType;
+        System.arraycopy(commands, 0, cmds, 1, commands.length);
+        return container.execCmd(cmds);
+    }
+
+    public void stopAllBrokers() {
+        brokerContainers.values().forEach(BrokerContainer::stop);
+    }
+
+    public void startAllBrokers() {
+        brokerContainers.values().forEach(BrokerContainer::start);
+    }
+
+    public void stopAllBookies() {
+        bookieContainers.values().forEach(BKContainer::stop);
+    }
+
+    public void startAllBookies() {
+        bookieContainers.values().forEach(BKContainer::start);
+    }
+
+    public void stopZooKeeper() {
+        zkContainer.stop();
+    }
+
+    public void startZooKeeper() {
+        zkContainer.start();
+    }
+
+    public ContainerExecResult createNamespace(String nsName) throws Exception {
+        return runAdminCommandOnAnyBroker(
+                "namespaces", "create", "public/" + nsName,
+                "--clusters", clusterName);
+    }
+
+    public ContainerExecResult createPartitionedTopic(String topicName, int partitions) throws Exception {
+        return runAdminCommandOnAnyBroker(
+                "topics", "create-partitioned-topic", topicName,
+                "-p", String.valueOf(partitions));
+    }
+
+    public ContainerExecResult enableDeduplication(String nsName, boolean enabled) throws Exception {
+        return runAdminCommandOnAnyBroker(
+                "namespaces", "set-deduplication", "public/" + nsName,
+                enabled ? "--enable" : "--disable");
+    }
+
+    public String getFunctionLogs(String name) {
+        StringBuilder logs = new StringBuilder();
+        for (WorkerContainer container : getAlWorkers()) {
+            try {
+                String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
+                logs.append(container.<String>copyFileFromContainer(logFile, (inputStream) -> {
+                    return IOUtils.toString(inputStream, "utf-8");
+                }));
+            } catch (Exception e) {
+                log.error("Failed to get function logs from container {}", container.getContainerName(), e);
+            }
+        }
+        return logs.toString();
+    }
+
+    public void dumpFunctionLogs(String name) {
+        for (WorkerContainer container : getAlWorkers()) {
+            log.info("Trying to get function {} logs from container {}", name, container.getContainerName());
+            try {
+                String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
+                String logs = container.<String>copyFileFromContainer(logFile, (inputStream) -> {
+                    return IOUtils.toString(inputStream, "utf-8");
+                });
+                log.info("Function {} logs {}", name, logs);
+            } catch (com.github.dockerjava.api.exception.NotFoundException notFound) {
+                log.info("Cannot download {} logs from {} not found exception {}", name, container.getContainerName(),
+                        notFound.toString());
+            } catch (Throwable err) {
+                log.info("Cannot download {} logs from {}", name, container.getContainerName(), err);
+            }
+        }
+    }
+
+    private String appendClusterName(String name) {
+        return sharedCsContainer ? clusterName + "-" + name : name;
+    }
+
+    public BKContainer getAnyBookie() {
+        return getAnyContainer(bookieContainers, "bookie");
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterSpec.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterSpec.java
index 6a2259500b..85d7d8ee29 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterSpec.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterSpec.java
@@ -1,202 +1,202 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-import lombok.Builder;
-import lombok.Builder.Default;
-import lombok.Getter;
-import lombok.Setter;
-import lombok.Singular;
-import lombok.experimental.Accessors;
-import org.apache.pulsar.common.protocol.Commands;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.testcontainers.containers.GenericContainer;
-
-/**
- * Spec to build a pulsar cluster.
- */
-@Builder
-@Accessors(fluent = true)
-@Getter
-@Setter
-public class PulsarClusterSpec {
-
-    /**
-     * Returns the cluster name.
-     *
-     * @return the cluster name.
-     */
-    String clusterName;
-
-    /**
-     * Returns number of bookies.
-     *
-     * @return number of bookies.
-     */
-    @Default
-    int numBookies = 2;
-
-    /**
-     * Returns number of brokers.
-     *
-     * @return number of brokers.
-     */
-    @Default
-    int numBrokers = 2;
-
-    /**
-     * Returns number of proxies.
-     *
-     * @return number of proxies.
-     */
-    @Default
-    int numProxies = 1;
-
-    /**
-     * Returns number of function workers.
-     *
-     * @return number of function workers.
-     */
-    @Default
-    int numFunctionWorkers = 0;
-
-    /**
-     * Allow to query the last message.
-     */
-    @Default
-    boolean queryLastMessage = false;
-
-    /**
-     * Returns the function runtime type.
-     *
-     * @return the function runtime type.
-     */
-    @Default
-    FunctionRuntimeType functionRuntimeType = FunctionRuntimeType.PROCESS;
-
-    /**
-     * Returns the list of external services to start with
-     * this cluster.
-     *
-     * @return the list of external services to start with the cluster.
-     */
-    @Singular
-    Map<String, GenericContainer<?>> externalServices;
-
-    /**
-     * Specify envs for external services.
-     */
-    @Singular
-    Map<String, Map<String, String>> externalServiceEnvs;
-
-    /**
-     * Returns the flag whether to enable/disable container log.
-     *
-     * @return the flag whether to enable/disable container log.
-     */
-    @Default
-    boolean enableContainerLog = false;
-
-    /**
-     * Provide a map of paths (in the classpath) to mount as volumes inside the containers.
-     */
-    @Builder.Default
-    Map<String, String> classPathVolumeMounts = new TreeMap<>();
-
-    /**
-     * Data container.
-     */
-    @Builder.Default
-    GenericContainer<?> dataContainer = null;
-
-    /**
-     * Pulsar Test Image Name.
-     *
-     * @return the version of the pulsar test image to use
-     */
-    @Default
-    String pulsarTestImage = PulsarContainer.DEFAULT_IMAGE_NAME;
-
-    /**
-     * Specify envs for proxy.
-     */
-    Map<String, String> proxyEnvs;
-
-    /**
-     * Specify envs for broker.
-     */
-    Map<String, String> brokerEnvs;
-
-    /**
-     * Specify envs for bookkeeper.
-     */
-    Map<String, String> bookkeeperEnvs;
-
-    /**
-     * Specify envs for function workers.
-     */
-    @Singular
-    Map<String, String> functionWorkerEnvs;
-
-    /**
-     * Specify mount files.
-     */
-    Map<String, String> proxyMountFiles;
-
-    /**
-     * Specify mount files.
-     */
-    Map<String, String> brokerMountFiles;
-
-    @Default
-    int maxMessageSize = Commands.DEFAULT_MAX_MESSAGE_SIZE;
-
-    /**
-     * Additional ports to expose on broker containers.
-     */
-    List<Integer> brokerAdditionalPorts;
-
-    /**
-     * Additional ports to expose on bookie containers.
-     */
-    List<Integer> bookieAdditionalPorts;
-
-    /**
-     * Additional ports to expose on proxy containers.
-     */
-    List<Integer> proxyAdditionalPorts;
-
-    /**
-     * Additional ports to expose on function workers.
-     */
-    @Singular
-    List<Integer> functionWorkerAdditionalPorts;
-
-    /**
-     * Enable TLS for connection.
-     */
-    @Default
-    boolean enableTls = false;
-
-    @Default
-    boolean enableOxia = false;
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import lombok.Builder;
+import lombok.Builder.Default;
+import lombok.Getter;
+import lombok.Setter;
+import lombok.Singular;
+import lombok.experimental.Accessors;
+import org.apache.pulsar.common.protocol.Commands;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.testcontainers.containers.GenericContainer;
+
+/**
+ * Spec to build a pulsar cluster.
+ */
+@Builder
+@Accessors(fluent = true)
+@Getter
+@Setter
+public class PulsarClusterSpec {
+
+    /**
+     * Returns the cluster name.
+     *
+     * @return the cluster name.
+     */
+    String clusterName;
+
+    /**
+     * Returns number of bookies.
+     *
+     * @return number of bookies.
+     */
+    @Default
+    int numBookies = 2;
+
+    /**
+     * Returns number of brokers.
+     *
+     * @return number of brokers.
+     */
+    @Default
+    int numBrokers = 2;
+
+    /**
+     * Returns number of proxies.
+     *
+     * @return number of proxies.
+     */
+    @Default
+    int numProxies = 1;
+
+    /**
+     * Returns number of function workers.
+     *
+     * @return number of function workers.
+     */
+    @Default
+    int numFunctionWorkers = 0;
+
+    /**
+     * Allow to query the last message.
+     */
+    @Default
+    boolean queryLastMessage = false;
+
+    /**
+     * Returns the function runtime type.
+     *
+     * @return the function runtime type.
+     */
+    @Default
+    FunctionRuntimeType functionRuntimeType = FunctionRuntimeType.PROCESS;
+
+    /**
+     * Returns the list of external services to start with
+     * this cluster.
+     *
+     * @return the list of external services to start with the cluster.
+     */
+    @Singular
+    Map<String, GenericContainer<?>> externalServices;
+
+    /**
+     * Specify envs for external services.
+     */
+    @Singular
+    Map<String, Map<String, String>> externalServiceEnvs;
+
+    /**
+     * Returns the flag whether to enable/disable container log.
+     *
+     * @return the flag whether to enable/disable container log.
+     */
+    @Default
+    boolean enableContainerLog = false;
+
+    /**
+     * Provide a map of paths (in the classpath) to mount as volumes inside the containers.
+     */
+    @Builder.Default
+    Map<String, String> classPathVolumeMounts = new TreeMap<>();
+
+    /**
+     * Data container.
+     */
+    @Builder.Default
+    GenericContainer<?> dataContainer = null;
+
+    /**
+     * Pulsar Test Image Name.
+     *
+     * @return the version of the pulsar test image to use
+     */
+    @Default
+    String pulsarTestImage = PulsarContainer.DEFAULT_IMAGE_NAME;
+
+    /**
+     * Specify envs for proxy.
+     */
+    Map<String, String> proxyEnvs;
+
+    /**
+     * Specify envs for broker.
+     */
+    Map<String, String> brokerEnvs;
+
+    /**
+     * Specify envs for bookkeeper.
+     */
+    Map<String, String> bookkeeperEnvs;
+
+    /**
+     * Specify envs for function workers.
+     */
+    @Singular
+    Map<String, String> functionWorkerEnvs;
+
+    /**
+     * Specify mount files.
+     */
+    Map<String, String> proxyMountFiles;
+
+    /**
+     * Specify mount files.
+     */
+    Map<String, String> brokerMountFiles;
+
+    @Default
+    int maxMessageSize = Commands.DEFAULT_MAX_MESSAGE_SIZE;
+
+    /**
+     * Additional ports to expose on broker containers.
+     */
+    List<Integer> brokerAdditionalPorts;
+
+    /**
+     * Additional ports to expose on bookie containers.
+     */
+    List<Integer> bookieAdditionalPorts;
+
+    /**
+     * Additional ports to expose on proxy containers.
+     */
+    List<Integer> proxyAdditionalPorts;
+
+    /**
+     * Additional ports to expose on function workers.
+     */
+    @Singular
+    List<Integer> functionWorkerAdditionalPorts;
+
+    /**
+     * Enable TLS for connection.
+     */
+    @Default
+    boolean enableTls = false;
+
+    @Default
+    boolean enableOxia = false;
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterTestBase.java
index fd4d609e5e..616c5adddd 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarClusterTestBase.java
@@ -1,168 +1,168 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import static java.util.stream.Collectors.joining;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.common.naming.TopicDomain;
-import org.testng.annotations.DataProvider;
-
-@Slf4j
-public abstract class PulsarClusterTestBase extends PulsarTestBase {
-    protected final Map<String, String> brokerEnvs = new HashMap<>();
-    protected final Map<String, String> bookkeeperEnvs = new HashMap<>();
-    protected final Map<String, String> proxyEnvs = new HashMap<>();
-    protected final List<Integer> brokerAdditionalPorts = new LinkedList<>();
-    protected final List<Integer> bookieAdditionalPorts = new LinkedList<>();
-
-    @Override
-    protected final void setup() throws Exception {
-        setupCluster();
-    }
-
-    @Override
-    protected final void cleanup() throws Exception {
-        tearDownCluster();
-    }
-
-    @DataProvider(name = "ServiceUrlAndTopics")
-    public Object[][] serviceUrlAndTopics() {
-        return new Object[][] {
-                // plain text, persistent topic
-                {
-                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
-                        true,
-                },
-                // plain text, non-persistent topic
-                {
-                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
-                        false
-                }
-        };
-    }
-
-    @DataProvider(name = "ServiceUrls")
-    public Object[][] serviceUrls() {
-        return new Object[][] {
-                // plain text
-                {
-                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl())
-                }
-        };
-    }
-
-    @DataProvider(name = "ServiceAndAdminUrls")
-    public Object[][] serviceAndAdminUrls() {
-        return new Object[][] {
-                // plain text
-                {
-                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
-                        stringSupplier(() -> getPulsarCluster().getHttpServiceUrl())
-                }
-        };
-    }
-
-    @DataProvider
-    public Object[][] serviceUrlAndTopicDomain() {
-        return new Object[][] {
-                {
-                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
-                        TopicDomain.persistent
-                },
-                {
-                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
-                        TopicDomain.non_persistent
-                },
-        };
-    }
-
-    protected PulsarAdmin pulsarAdmin;
-
-    protected PulsarCluster pulsarCluster;
-
-    public PulsarCluster getPulsarCluster() {
-        return pulsarCluster;
-    }
-
-    protected static Supplier<String> stringSupplier(Supplier<String> supplier) {
-        return supplier;
-    }
-
-    public void setupCluster() throws Exception {
-        this.setupCluster("");
-    }
-
-    public void setupCluster(String namePrefix) throws Exception {
-        String clusterName = Stream.of(this.getClass().getSimpleName(), namePrefix, randomName(5))
-                .filter(s -> s != null && !s.isEmpty())
-                .collect(joining("-"));
-
-        PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder = PulsarClusterSpec.builder()
-                .clusterName(clusterName)
-                .brokerEnvs(brokerEnvs)
-                .proxyEnvs(proxyEnvs)
-                .brokerAdditionalPorts(brokerAdditionalPorts);
-
-        setupCluster(beforeSetupCluster(clusterName, specBuilder).build());
-    }
-
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
-            String clusterName,
-            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-        return specBuilder;
-    }
-
-    protected void beforeStartCluster() throws Exception {
-        // no-op
-    }
-
-    protected void setupCluster(PulsarClusterSpec spec) throws Exception {
-        setupCluster(spec, true);
-    }
-
-    protected void setupCluster(PulsarClusterSpec spec, boolean doInit) throws Exception {
-        incrementSetupNumber();
-        log.info("Setting up cluster {} with {} bookies, {} brokers",
-                spec.clusterName(), spec.numBookies(), spec.numBrokers());
-
-        pulsarCluster = PulsarCluster.forSpec(spec);
-
-        beforeStartCluster();
-
-        pulsarCluster.start(doInit);
-
-        pulsarAdmin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
-
-        log.info("Cluster {} is setup", spec.clusterName());
-    }
-
-    public void tearDownCluster() throws Exception {
-        markCurrentSetupNumberCleaned();
-        if (null != pulsarCluster) {
-            pulsarCluster.stop();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import static java.util.stream.Collectors.joining;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.common.naming.TopicDomain;
+import org.testng.annotations.DataProvider;
+
+@Slf4j
+public abstract class PulsarClusterTestBase extends PulsarTestBase {
+    protected final Map<String, String> brokerEnvs = new HashMap<>();
+    protected final Map<String, String> bookkeeperEnvs = new HashMap<>();
+    protected final Map<String, String> proxyEnvs = new HashMap<>();
+    protected final List<Integer> brokerAdditionalPorts = new LinkedList<>();
+    protected final List<Integer> bookieAdditionalPorts = new LinkedList<>();
+
+    @Override
+    protected final void setup() throws Exception {
+        setupCluster();
+    }
+
+    @Override
+    protected final void cleanup() throws Exception {
+        tearDownCluster();
+    }
+
+    @DataProvider(name = "ServiceUrlAndTopics")
+    public Object[][] serviceUrlAndTopics() {
+        return new Object[][] {
+                // plain text, persistent topic
+                {
+                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
+                        true,
+                },
+                // plain text, non-persistent topic
+                {
+                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
+                        false
+                }
+        };
+    }
+
+    @DataProvider(name = "ServiceUrls")
+    public Object[][] serviceUrls() {
+        return new Object[][] {
+                // plain text
+                {
+                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl())
+                }
+        };
+    }
+
+    @DataProvider(name = "ServiceAndAdminUrls")
+    public Object[][] serviceAndAdminUrls() {
+        return new Object[][] {
+                // plain text
+                {
+                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
+                        stringSupplier(() -> getPulsarCluster().getHttpServiceUrl())
+                }
+        };
+    }
+
+    @DataProvider
+    public Object[][] serviceUrlAndTopicDomain() {
+        return new Object[][] {
+                {
+                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
+                        TopicDomain.persistent
+                },
+                {
+                        stringSupplier(() -> getPulsarCluster().getPlainTextServiceUrl()),
+                        TopicDomain.non_persistent
+                },
+        };
+    }
+
+    protected PulsarAdmin pulsarAdmin;
+
+    protected PulsarCluster pulsarCluster;
+
+    public PulsarCluster getPulsarCluster() {
+        return pulsarCluster;
+    }
+
+    protected static Supplier<String> stringSupplier(Supplier<String> supplier) {
+        return supplier;
+    }
+
+    public void setupCluster() throws Exception {
+        this.setupCluster("");
+    }
+
+    public void setupCluster(String namePrefix) throws Exception {
+        String clusterName = Stream.of(this.getClass().getSimpleName(), namePrefix, randomName(5))
+                .filter(s -> s != null && !s.isEmpty())
+                .collect(joining("-"));
+
+        PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder = PulsarClusterSpec.builder()
+                .clusterName(clusterName)
+                .brokerEnvs(brokerEnvs)
+                .proxyEnvs(proxyEnvs)
+                .brokerAdditionalPorts(brokerAdditionalPorts);
+
+        setupCluster(beforeSetupCluster(clusterName, specBuilder).build());
+    }
+
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
+            String clusterName,
+            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+        return specBuilder;
+    }
+
+    protected void beforeStartCluster() throws Exception {
+        // no-op
+    }
+
+    protected void setupCluster(PulsarClusterSpec spec) throws Exception {
+        setupCluster(spec, true);
+    }
+
+    protected void setupCluster(PulsarClusterSpec spec, boolean doInit) throws Exception {
+        incrementSetupNumber();
+        log.info("Setting up cluster {} with {} bookies, {} brokers",
+                spec.clusterName(), spec.numBookies(), spec.numBrokers());
+
+        pulsarCluster = PulsarCluster.forSpec(spec);
+
+        beforeStartCluster();
+
+        pulsarCluster.start(doInit);
+
+        pulsarAdmin = PulsarAdmin.builder().serviceHttpUrl(pulsarCluster.getHttpServiceUrl()).build();
+
+        log.info("Cluster {} is setup", spec.clusterName());
+    }
+
+    public void tearDownCluster() throws Exception {
+        markCurrentSetupNumberCleaned();
+        if (null != pulsarCluster) {
+            pulsarCluster.stop();
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoCluster.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoCluster.java
index fa0b74c7fa..31bb787b6e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoCluster.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoCluster.java
@@ -1,82 +1,82 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.tests.integration.containers.CSContainer;
-import org.testcontainers.containers.Network;
-
-@Slf4j
-public class PulsarGeoCluster {
-
-    @Getter
-    private final PulsarClusterSpec[] clusterSpecs;
-
-    @Getter
-    private final CSContainer csContainer;
-
-    @Getter
-    private final PulsarCluster[] clusters;
-
-    /**
-     * Pulsar Cluster Spec.
-     *
-     * @param specs each pulsar cluster spec.
-     * @return the built a pulsar cluster with geo replication
-     */
-    public static PulsarGeoCluster forSpec(PulsarClusterSpec... specs) {
-        return new PulsarGeoCluster(specs);
-    }
-
-    public PulsarGeoCluster(PulsarClusterSpec... clusterSpecs) {
-        this.clusterSpecs = clusterSpecs;
-        this.clusters = new PulsarCluster[clusterSpecs.length];
-
-        this.csContainer = new CSContainer("geo-cluster")
-                .withNetwork(Network.newNetwork())
-                .withNetworkAliases(CSContainer.NAME);
-
-        for (int i = 0; i < this.clusters.length; i++) {
-            clusters[i] = PulsarCluster.forSpec(this.clusterSpecs[i], this.csContainer);
-        }
-    }
-
-    public void start() throws Exception {
-        // start the configuration store
-        this.csContainer.start();
-        log.info("Successfully started configuration store container.");
-
-        for (PulsarCluster cluster : clusters) {
-            cluster.start();
-            log.info("Successfully started all components for cluster {}.", cluster.getClusterName());
-        }
-    }
-
-    public void stop() throws Exception {
-        for (PulsarCluster cluster : clusters) {
-            cluster.stop();
-            log.info("Successfully stopped all components for cluster {}.", cluster.getClusterName());
-        }
-        // stop the configuration store
-        this.csContainer.stop();
-        log.info("Successfully stopped configuration store container.");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.tests.integration.containers.CSContainer;
+import org.testcontainers.containers.Network;
+
+@Slf4j
+public class PulsarGeoCluster {
+
+    @Getter
+    private final PulsarClusterSpec[] clusterSpecs;
+
+    @Getter
+    private final CSContainer csContainer;
+
+    @Getter
+    private final PulsarCluster[] clusters;
+
+    /**
+     * Pulsar Cluster Spec.
+     *
+     * @param specs each pulsar cluster spec.
+     * @return the built a pulsar cluster with geo replication
+     */
+    public static PulsarGeoCluster forSpec(PulsarClusterSpec... specs) {
+        return new PulsarGeoCluster(specs);
+    }
+
+    public PulsarGeoCluster(PulsarClusterSpec... clusterSpecs) {
+        this.clusterSpecs = clusterSpecs;
+        this.clusters = new PulsarCluster[clusterSpecs.length];
+
+        this.csContainer = new CSContainer("geo-cluster")
+                .withNetwork(Network.newNetwork())
+                .withNetworkAliases(CSContainer.NAME);
+
+        for (int i = 0; i < this.clusters.length; i++) {
+            clusters[i] = PulsarCluster.forSpec(this.clusterSpecs[i], this.csContainer);
+        }
+    }
+
+    public void start() throws Exception {
+        // start the configuration store
+        this.csContainer.start();
+        log.info("Successfully started configuration store container.");
+
+        for (PulsarCluster cluster : clusters) {
+            cluster.start();
+            log.info("Successfully started all components for cluster {}.", cluster.getClusterName());
+        }
+    }
+
+    public void stop() throws Exception {
+        for (PulsarCluster cluster : clusters) {
+            cluster.stop();
+            log.info("Successfully stopped all components for cluster {}.", cluster.getClusterName());
+        }
+        // stop the configuration store
+        this.csContainer.stop();
+        log.info("Successfully stopped configuration store container.");
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoClusterTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoClusterTestBase.java
index 2ecfa83fc7..0766b3ee8f 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoClusterTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarGeoClusterTestBase.java
@@ -1,91 +1,91 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import static java.util.stream.Collectors.joining;
-import java.util.stream.Stream;
-import lombok.Getter;
-import lombok.extern.slf4j.Slf4j;
-
-@Slf4j
-public class PulsarGeoClusterTestBase extends PulsarTestBase {
-
-    @Override
-    protected final void setup() throws Exception {
-        setupCluster();
-    }
-
-    @Override
-    protected final void cleanup() throws Exception {
-        tearDownCluster();
-    }
-
-    protected void setupCluster() throws Exception {
-        this.setupCluster("");
-    }
-
-    @Getter
-    private PulsarGeoCluster geoCluster;
-
-    public void setupCluster(String namePrefix) throws Exception {
-        PulsarClusterSpec.PulsarClusterSpecBuilder[] specBuilders = new PulsarClusterSpec.PulsarClusterSpecBuilder[2];
-        for (int i = 0; i < 2; i++) {
-            String clusterName = Stream.of(this.getClass().getSimpleName(), namePrefix, String.valueOf(i),
-                            randomName(5))
-                    .filter(s -> s != null && !s.isEmpty())
-                    .collect(joining("-"));
-            specBuilders[i] = PulsarClusterSpec.builder().clusterName(clusterName);
-        }
-        specBuilders = beforeSetupCluster(specBuilders);
-        PulsarClusterSpec[] specs = new PulsarClusterSpec[2];
-        for (int i = 0; i < specBuilders.length; i++) {
-            specs[i] = specBuilders[i].build();
-        }
-        setupCluster0(specs);
-    }
-
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder[] beforeSetupCluster (
-            PulsarClusterSpec.PulsarClusterSpecBuilder... specBuilder) {
-        return specBuilder;
-    }
-
-    protected void setupCluster0(PulsarClusterSpec... specs) throws Exception {
-        incrementSetupNumber();
-        log.info("Setting up geo cluster with {} local clusters}", specs.length);
-
-        this.geoCluster = PulsarGeoCluster.forSpec(specs);
-
-        beforeStartCluster();
-
-        this.geoCluster.start();
-
-        log.info("Geo Cluster is setup!");
-    }
-
-    protected void beforeStartCluster() throws Exception {
-        // no-op
-    }
-
-    public void tearDownCluster() throws Exception {
-        markCurrentSetupNumberCleaned();
-        if (null != this.geoCluster) {
-            this.geoCluster.stop();
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import static java.util.stream.Collectors.joining;
+import java.util.stream.Stream;
+import lombok.Getter;
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class PulsarGeoClusterTestBase extends PulsarTestBase {
+
+    @Override
+    protected final void setup() throws Exception {
+        setupCluster();
+    }
+
+    @Override
+    protected final void cleanup() throws Exception {
+        tearDownCluster();
+    }
+
+    protected void setupCluster() throws Exception {
+        this.setupCluster("");
+    }
+
+    @Getter
+    private PulsarGeoCluster geoCluster;
+
+    public void setupCluster(String namePrefix) throws Exception {
+        PulsarClusterSpec.PulsarClusterSpecBuilder[] specBuilders = new PulsarClusterSpec.PulsarClusterSpecBuilder[2];
+        for (int i = 0; i < 2; i++) {
+            String clusterName = Stream.of(this.getClass().getSimpleName(), namePrefix, String.valueOf(i),
+                            randomName(5))
+                    .filter(s -> s != null && !s.isEmpty())
+                    .collect(joining("-"));
+            specBuilders[i] = PulsarClusterSpec.builder().clusterName(clusterName);
+        }
+        specBuilders = beforeSetupCluster(specBuilders);
+        PulsarClusterSpec[] specs = new PulsarClusterSpec[2];
+        for (int i = 0; i < specBuilders.length; i++) {
+            specs[i] = specBuilders[i].build();
+        }
+        setupCluster0(specs);
+    }
+
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder[] beforeSetupCluster (
+            PulsarClusterSpec.PulsarClusterSpecBuilder... specBuilder) {
+        return specBuilder;
+    }
+
+    protected void setupCluster0(PulsarClusterSpec... specs) throws Exception {
+        incrementSetupNumber();
+        log.info("Setting up geo cluster with {} local clusters}", specs.length);
+
+        this.geoCluster = PulsarGeoCluster.forSpec(specs);
+
+        beforeStartCluster();
+
+        this.geoCluster.start();
+
+        log.info("Geo Cluster is setup!");
+    }
+
+    protected void beforeStartCluster() throws Exception {
+        // no-op
+    }
+
+    public void tearDownCluster() throws Exception {
+        markCurrentSetupNumberCleaned();
+        if (null != this.geoCluster) {
+            this.geoCluster.stop();
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarStandaloneTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarStandaloneTestBase.java
index 23a17a1b89..b01498bac8 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarStandaloneTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarStandaloneTestBase.java
@@ -1,134 +1,134 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import static org.testng.Assert.assertEquals;
-import java.util.function.Supplier;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.commons.io.IOUtils;
-import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.testcontainers.containers.Network;
-import org.testng.annotations.DataProvider;
-
-/**
- * A test base to run tests on standalone cluster.
- *
- * <p>Ideally we should run all integration tests on both cluster mode and standalone
- * mode. However the apache ci can't really afford to do so. so we run all the integration
- * tests on cluster mode. We only run basic validation and test new features (e.g. state)
- * on standalone.
- */
-@Slf4j
-public abstract class PulsarStandaloneTestBase extends PulsarTestBase {
-
-    @DataProvider(name = "StandaloneServiceUrlAndTopics")
-    public Object[][] serviceUrlAndTopics() {
-        return new Object[][] {
-                // plain text, persistent topic
-                {
-                        stringSupplier(() -> getContainer().getPlainTextServiceUrl()),
-                        true,
-                },
-                // plain text, non-persistent topic
-                {
-                        stringSupplier(() -> getContainer().getPlainTextServiceUrl()),
-                        false
-                }
-        };
-    }
-
-    @DataProvider(name = "StandaloneServiceUrlAndHttpUrl")
-    public Object[][] serviceUrlAndHttpUrl() {
-        return new Object[][] {
-                {
-                        stringSupplier(() -> getContainer().getPlainTextServiceUrl()),
-                        stringSupplier(() -> getContainer().getHttpServiceUrl()),
-                }
-        };
-    }
-
-    protected Network network;
-
-    protected StandaloneContainer container;
-
-    public StandaloneContainer getContainer() {
-        return container;
-    }
-
-    private static Supplier<String> stringSupplier(Supplier<String> supplier) {
-        return supplier;
-    }
-
-    protected void startCluster(final String pulsarImageName) throws Exception {
-        network = Network.newNetwork();
-        String clusterName = PulsarClusterTestBase.randomName(8);
-        container = new StandaloneContainer(clusterName, pulsarImageName)
-            .withNetwork(network)
-            .withNetworkAliases(StandaloneContainer.NAME + "-" + clusterName)
-            .withEnv("PF_stateStorageServiceUrl", "bk://localhost:4181")
-            .withEnv("PULSAR_STANDALONE_USE_ZOOKEEPER", "true");
-        container.start();
-        log.info("Pulsar cluster {} is up running:", clusterName);
-        log.info("\tBinary Service Url : {}", container.getPlainTextServiceUrl());
-        log.info("\tHttp Service Url : {}", container.getHttpServiceUrl());
-
-        // add cluster to public tenant
-        ContainerExecResult result = container.execCmd(
-                "/pulsar/bin/pulsar-admin", "namespaces", "policies", "public/default");
-        assertEquals(0, result.getExitCode());
-        log.info("public/default namespace policies are {}", result.getStdout());
-    }
-
-    protected void stopCluster() throws Exception {
-        if (container != null) {
-            container.stop();
-            container = null;
-        }
-        if (network != null) {
-            network.close();
-            network = null;
-        }
-    }
-
-    protected String getFunctionLogs(String name) {
-        try {
-            String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
-            return container.<String>copyFileFromContainer(logFile, (inputStream) -> {
-                return IOUtils.toString(inputStream, "utf-8");
-            });
-        } catch (Throwable err) {
-            log.info("Cannot get {} logs", name, err);
-            return "";
-        }
-    }
-
-    protected void dumpFunctionLogs(String name) {
-        try {
-            String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
-            String logs = container.<String>copyFileFromContainer(logFile, (inputStream) -> {
-                return IOUtils.toString(inputStream, "utf-8");
-            });
-            log.info("Function {} logs {}", name, logs);
-        } catch (Throwable err) {
-            log.info("Cannot download {} logs", name, err);
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import static org.testng.Assert.assertEquals;
+import java.util.function.Supplier;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.commons.io.IOUtils;
+import org.apache.pulsar.tests.integration.containers.StandaloneContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.testcontainers.containers.Network;
+import org.testng.annotations.DataProvider;
+
+/**
+ * A test base to run tests on standalone cluster.
+ *
+ * <p>Ideally we should run all integration tests on both cluster mode and standalone
+ * mode. However the apache ci can't really afford to do so. so we run all the integration
+ * tests on cluster mode. We only run basic validation and test new features (e.g. state)
+ * on standalone.
+ */
+@Slf4j
+public abstract class PulsarStandaloneTestBase extends PulsarTestBase {
+
+    @DataProvider(name = "StandaloneServiceUrlAndTopics")
+    public Object[][] serviceUrlAndTopics() {
+        return new Object[][] {
+                // plain text, persistent topic
+                {
+                        stringSupplier(() -> getContainer().getPlainTextServiceUrl()),
+                        true,
+                },
+                // plain text, non-persistent topic
+                {
+                        stringSupplier(() -> getContainer().getPlainTextServiceUrl()),
+                        false
+                }
+        };
+    }
+
+    @DataProvider(name = "StandaloneServiceUrlAndHttpUrl")
+    public Object[][] serviceUrlAndHttpUrl() {
+        return new Object[][] {
+                {
+                        stringSupplier(() -> getContainer().getPlainTextServiceUrl()),
+                        stringSupplier(() -> getContainer().getHttpServiceUrl()),
+                }
+        };
+    }
+
+    protected Network network;
+
+    protected StandaloneContainer container;
+
+    public StandaloneContainer getContainer() {
+        return container;
+    }
+
+    private static Supplier<String> stringSupplier(Supplier<String> supplier) {
+        return supplier;
+    }
+
+    protected void startCluster(final String pulsarImageName) throws Exception {
+        network = Network.newNetwork();
+        String clusterName = PulsarClusterTestBase.randomName(8);
+        container = new StandaloneContainer(clusterName, pulsarImageName)
+            .withNetwork(network)
+            .withNetworkAliases(StandaloneContainer.NAME + "-" + clusterName)
+            .withEnv("PF_stateStorageServiceUrl", "bk://localhost:4181")
+            .withEnv("PULSAR_STANDALONE_USE_ZOOKEEPER", "true");
+        container.start();
+        log.info("Pulsar cluster {} is up running:", clusterName);
+        log.info("\tBinary Service Url : {}", container.getPlainTextServiceUrl());
+        log.info("\tHttp Service Url : {}", container.getHttpServiceUrl());
+
+        // add cluster to public tenant
+        ContainerExecResult result = container.execCmd(
+                "/pulsar/bin/pulsar-admin", "namespaces", "policies", "public/default");
+        assertEquals(0, result.getExitCode());
+        log.info("public/default namespace policies are {}", result.getStdout());
+    }
+
+    protected void stopCluster() throws Exception {
+        if (container != null) {
+            container.stop();
+            container = null;
+        }
+        if (network != null) {
+            network.close();
+            network = null;
+        }
+    }
+
+    protected String getFunctionLogs(String name) {
+        try {
+            String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
+            return container.<String>copyFileFromContainer(logFile, (inputStream) -> {
+                return IOUtils.toString(inputStream, "utf-8");
+            });
+        } catch (Throwable err) {
+            log.info("Cannot get {} logs", name, err);
+            return "";
+        }
+    }
+
+    protected void dumpFunctionLogs(String name) {
+        try {
+            String logFile = "/pulsar/logs/functions/public/default/" + name + "/" + name + "-0.log";
+            String logs = container.<String>copyFileFromContainer(logFile, (inputStream) -> {
+                return IOUtils.toString(inputStream, "utf-8");
+            });
+            log.info("Function {} logs {}", name, logs);
+        } catch (Throwable err) {
+            log.info("Cannot download {} logs", name, err);
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarTestBase.java
index 378ad307c2..2002e5d21f 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/topologies/PulsarTestBase.java
@@ -1,196 +1,196 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.topologies;
-
-import static org.testng.Assert.assertEquals;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ThreadLocalRandom;
-import java.util.concurrent.TimeUnit;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.common.util.FutureUtil;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.DataProvider;
-
-public abstract class PulsarTestBase extends TestRetrySupport {
-
-    @DataProvider(name = "TopicDomain")
-    public Object[][] topicDomain() {
-        return new Object[][] {
-                {"persistent"},
-                {"non-persistent"}
-        };
-    }
-
-    public static String randomName() {
-        return randomName(6);
-    }
-
-    public static String randomName(int numChars) {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < numChars; i++) {
-            sb.append((char) (ThreadLocalRandom.current().nextInt(26) + 'a'));
-        }
-        return sb.toString();
-    }
-
-    protected static String generateNamespaceName() {
-        return "ns-" + randomName(8);
-    }
-
-    protected static String generateTopicName(String topicPrefix, boolean isPersistent) {
-        return generateTopicName("default", topicPrefix, isPersistent);
-    }
-
-    protected static String generateTopicName(String namespace, String topicPrefix, boolean isPersistent) {
-        String topicName = new StringBuilder(topicPrefix)
-                .append("-")
-                .append(randomName(8))
-                .append("-")
-                .append(System.currentTimeMillis())
-                .toString();
-        if (isPersistent) {
-            return "persistent://public/" + namespace + "/" + topicName;
-        } else {
-            return "non-persistent://public/" + namespace + "/" + topicName;
-        }
-    }
-
-    protected void testPublishAndConsume(String serviceUrl, boolean isPersistent) throws Exception {
-        String topicName = generateTopicName("testpubconsume", isPersistent);
-
-        int numMessages = 10;
-
-        try (PulsarClient client = PulsarClient.builder()
-            .serviceUrl(serviceUrl)
-            .build()) {
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("my-sub")
-                .subscribe()) {
-
-                try (Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(topicName)
-                    .create()) {
-
-                    for (int i = 0; i < numMessages; i++) {
-                        producer.send("smoke-message-" + i);
-                    }
-                }
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<String> m = consumer.receive();
-                    assertEquals("smoke-message-" + i, m.getValue());
-                }
-            }
-        }
-    }
-
-    protected void testBatchMessagePublishAndConsume(String serviceUrl, boolean isPersistent) throws Exception {
-        String topicName = generateTopicName("test-batch-publish-consume", isPersistent);
-
-        final int numMessages = 10000;
-        try (PulsarClient client = PulsarClient.builder()
-            .serviceUrl(serviceUrl)
-            .build()) {
-
-            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .receiverQueueSize(10000)
-                .subscriptionName("my-sub")
-                .subscribe()) {
-
-                try (Producer<String> producer = client.newProducer(Schema.STRING)
-                    .topic(topicName)
-                    .blockIfQueueFull(true)
-                    .create()) {
-
-                    List<CompletableFuture<MessageId>> futures = new ArrayList<>();
-                    for (int i = 0; i < numMessages; i++) {
-                        futures.add(producer.sendAsync("smoke-message-" + i));
-                    }
-                    // Wait for all messages are publish succeed.
-                    FutureUtil.waitForAll(futures).get();
-                }
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<String> m = consumer.receive();
-                    assertEquals("smoke-message-" + i, m.getValue());
-                }
-            }
-        }
-    }
-
-    protected void testBatchIndexAckDisabled(String serviceUrl) throws Exception {
-        String topicName = generateTopicName("test-batch-index-ack-disabled", true);
-        final int numMessages = 100;
-        try (PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build()) {
-
-            try (Consumer<Integer> consumer = client.newConsumer(Schema.INT32)
-                    .topic(topicName)
-                    .subscriptionName("sub")
-                    .receiverQueueSize(100)
-                    .subscriptionType(SubscriptionType.Shared)
-                    .enableBatchIndexAcknowledgment(false)
-                    .ackTimeout(1, TimeUnit.SECONDS)
-                    .subscribe();) {
-
-                try (Producer<Integer> producer = client.newProducer(Schema.INT32)
-                        .topic(topicName)
-                        .batchingMaxPublishDelay(50, TimeUnit.MILLISECONDS)
-                        .create()) {
-
-                    List<CompletableFuture<MessageId>> futures = new ArrayList<>();
-                    for (int i = 0; i < numMessages; i++) {
-                        futures.add(producer.sendAsync(i));
-                    }
-                    // Wait for all messages are publish succeed.
-                    FutureUtil.waitForAll(futures).get();
-                }
-
-                for (int i = 0; i < numMessages; i++) {
-                    Message<Integer> m = consumer.receive();
-                    if (i % 2 == 0) {
-                        consumer.acknowledge(m);
-                    }
-                }
-
-                Message<Integer> redelivery = consumer.receive(3, TimeUnit.SECONDS);
-                Assert.assertNotNull(redelivery);
-            }
-        }
-    }
-
-    protected ObjectMapper jsonMapper () {
-        return ObjectMapperFactory.getMapper().getObjectMapper();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.topologies;
+
+import static org.testng.Assert.assertEquals;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.common.util.FutureUtil;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.DataProvider;
+
+public abstract class PulsarTestBase extends TestRetrySupport {
+
+    @DataProvider(name = "TopicDomain")
+    public Object[][] topicDomain() {
+        return new Object[][] {
+                {"persistent"},
+                {"non-persistent"}
+        };
+    }
+
+    public static String randomName() {
+        return randomName(6);
+    }
+
+    public static String randomName(int numChars) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < numChars; i++) {
+            sb.append((char) (ThreadLocalRandom.current().nextInt(26) + 'a'));
+        }
+        return sb.toString();
+    }
+
+    protected static String generateNamespaceName() {
+        return "ns-" + randomName(8);
+    }
+
+    protected static String generateTopicName(String topicPrefix, boolean isPersistent) {
+        return generateTopicName("default", topicPrefix, isPersistent);
+    }
+
+    protected static String generateTopicName(String namespace, String topicPrefix, boolean isPersistent) {
+        String topicName = new StringBuilder(topicPrefix)
+                .append("-")
+                .append(randomName(8))
+                .append("-")
+                .append(System.currentTimeMillis())
+                .toString();
+        if (isPersistent) {
+            return "persistent://public/" + namespace + "/" + topicName;
+        } else {
+            return "non-persistent://public/" + namespace + "/" + topicName;
+        }
+    }
+
+    protected void testPublishAndConsume(String serviceUrl, boolean isPersistent) throws Exception {
+        String topicName = generateTopicName("testpubconsume", isPersistent);
+
+        int numMessages = 10;
+
+        try (PulsarClient client = PulsarClient.builder()
+            .serviceUrl(serviceUrl)
+            .build()) {
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("my-sub")
+                .subscribe()) {
+
+                try (Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(topicName)
+                    .create()) {
+
+                    for (int i = 0; i < numMessages; i++) {
+                        producer.send("smoke-message-" + i);
+                    }
+                }
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<String> m = consumer.receive();
+                    assertEquals("smoke-message-" + i, m.getValue());
+                }
+            }
+        }
+    }
+
+    protected void testBatchMessagePublishAndConsume(String serviceUrl, boolean isPersistent) throws Exception {
+        String topicName = generateTopicName("test-batch-publish-consume", isPersistent);
+
+        final int numMessages = 10000;
+        try (PulsarClient client = PulsarClient.builder()
+            .serviceUrl(serviceUrl)
+            .build()) {
+
+            try (Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .receiverQueueSize(10000)
+                .subscriptionName("my-sub")
+                .subscribe()) {
+
+                try (Producer<String> producer = client.newProducer(Schema.STRING)
+                    .topic(topicName)
+                    .blockIfQueueFull(true)
+                    .create()) {
+
+                    List<CompletableFuture<MessageId>> futures = new ArrayList<>();
+                    for (int i = 0; i < numMessages; i++) {
+                        futures.add(producer.sendAsync("smoke-message-" + i));
+                    }
+                    // Wait for all messages are publish succeed.
+                    FutureUtil.waitForAll(futures).get();
+                }
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<String> m = consumer.receive();
+                    assertEquals("smoke-message-" + i, m.getValue());
+                }
+            }
+        }
+    }
+
+    protected void testBatchIndexAckDisabled(String serviceUrl) throws Exception {
+        String topicName = generateTopicName("test-batch-index-ack-disabled", true);
+        final int numMessages = 100;
+        try (PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build()) {
+
+            try (Consumer<Integer> consumer = client.newConsumer(Schema.INT32)
+                    .topic(topicName)
+                    .subscriptionName("sub")
+                    .receiverQueueSize(100)
+                    .subscriptionType(SubscriptionType.Shared)
+                    .enableBatchIndexAcknowledgment(false)
+                    .ackTimeout(1, TimeUnit.SECONDS)
+                    .subscribe();) {
+
+                try (Producer<Integer> producer = client.newProducer(Schema.INT32)
+                        .topic(topicName)
+                        .batchingMaxPublishDelay(50, TimeUnit.MILLISECONDS)
+                        .create()) {
+
+                    List<CompletableFuture<MessageId>> futures = new ArrayList<>();
+                    for (int i = 0; i < numMessages; i++) {
+                        futures.add(producer.sendAsync(i));
+                    }
+                    // Wait for all messages are publish succeed.
+                    FutureUtil.waitForAll(futures).get();
+                }
+
+                for (int i = 0; i < numMessages; i++) {
+                    Message<Integer> m = consumer.receive();
+                    if (i % 2 == 0) {
+                        consumer.acknowledge(m);
+                    }
+                }
+
+                Message<Integer> redelivery = consumer.receive(3, TimeUnit.SECONDS);
+                Assert.assertNotNull(redelivery);
+            }
+        }
+    }
+
+    protected ObjectMapper jsonMapper () {
+        return ObjectMapperFactory.getMapper().getObjectMapper();
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTest.java
index 16d73c89b2..78b4211726 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTest.java
@@ -1,161 +1,161 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.transaction;
-
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.api.transaction.Transaction;
-import org.awaitility.Awaitility;
-import org.testng.Assert;
-import org.testng.annotations.Test;
-
-/**
- * Transaction integration test.
- */
-@Slf4j
-public class TransactionTest extends TransactionTestBase {
-
-    /**
-     * Transfer Business Mock Test
-     *
-     * The `transfer topic` represents the transfer operation, it consist of `from account`, `to account` and amount.
-     * The `balance update topic` represents the account update record, it consist of account and amount.
-     *
-     * The transfer topic consumer receive transfer messages and produce two balance update messages,
-     * one represents `from account` balance update and one represents `to account` balance update.
-     *
-     * example:
-     *
-     * receive messages:
-     * transfer {
-     *     fromAccount: "alice",
-     *     toAccount: "bob",
-     *     amount: 100
-     * }
-     *
-     * produce messages:
-     * fromAccountBalanceUpdate {
-     *     account: "alice"
-     *     amount: -100
-     * }
-     * toAccountBalanceUpdate {
-     *     account: "bob",
-     *     amount: 100
-     * }
-     *
-     * test target:
-     *
-     * 1. The balance update messages count should be double transfer message count.
-     * 2. The balance update messages amount sum should be 0.
-     */
-    @Test(dataProvider = "ServiceUrls")
-    public void transferNormalTest(Supplier<String> serviceUrl) throws Exception {
-        log.info("transfer normal test start.");
-        @Cleanup
-        PulsarClient pulsarClient = PulsarClient.builder().enableTransaction(true).serviceUrl(serviceUrl.get()).build();
-
-        final int transferCount = 20;
-        final String transferTopic = "transfer-" + randomName(6);
-        final String balanceUpdateTopic = "balance-update-" + randomName(6);
-
-        @Cleanup
-        Producer<TransferOperation> transferProducer = pulsarClient
-                .newProducer(Schema.JSON(TransferOperation.class))
-                .topic(transferTopic)
-                .create();
-        log.info("transfer producer create finished");
-
-        prepareTransferData(transferProducer, transferCount);
-
-        @Cleanup
-        Consumer<TransferOperation> transferConsumer = pulsarClient.newConsumer(Schema.JSON(TransferOperation.class))
-                .topic(transferTopic)
-                .subscriptionName("integration-test")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscriptionType(SubscriptionType.Shared)
-                .subscribe();
-        Awaitility.await().until(transferConsumer::isConnected);
-        log.info("transfer consumer create finished");
-
-        @Cleanup
-        Producer<BalanceUpdate> balanceUpdateProducer = pulsarClient.newProducer(Schema.JSON(BalanceUpdate.class))
-                .topic(balanceUpdateTopic)
-                .sendTimeout(0, TimeUnit.SECONDS)
-                .create();
-        log.info("balance update producer create finished");
-
-        @Cleanup
-        Consumer<BalanceUpdate> balanceUpdateConsumer = pulsarClient.newConsumer(Schema.JSON(BalanceUpdate.class))
-                .topic(balanceUpdateTopic)
-                .subscriptionName("integration-test")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscribe();
-        Awaitility.await().until(balanceUpdateConsumer::isConnected);
-        log.info("balance update consumer create finished");
-
-        while (true) {
-            Message<TransferOperation> message = transferConsumer.receive(10, TimeUnit.SECONDS);
-            if (message == null) {
-                break;
-            }
-            TransferOperation transferOperation = message.getValue();
-
-            Transaction transaction = pulsarClient.newTransaction()
-                    .withTransactionTimeout(5, TimeUnit.MINUTES)
-                    .build().get();
-
-            balanceUpdateProducer.newMessage(transaction)
-                    .value(getBalanceUpdate(transferOperation, true)).sendAsync();
-
-            balanceUpdateProducer.newMessage(transaction)
-                    .value(getBalanceUpdate(transferOperation, false)).sendAsync();
-
-            transferConsumer.acknowledgeAsync(message.getMessageId(), transaction);
-
-            transaction.commit().get();
-        }
-
-        int receiveBalanceUpdateCnt = 0;
-        int balanceSum = 0;
-        while (true) {
-            Message<BalanceUpdate> message = balanceUpdateConsumer.receive(10, TimeUnit.SECONDS);
-            if (message == null) {
-                break;
-            }
-            receiveBalanceUpdateCnt++;
-
-            BalanceUpdate balanceUpdate = message.getValue();
-            balanceSum += balanceUpdate.getAmount();
-            log.info("balance account: {}, amount: {}", balanceUpdate.getAccount(), balanceUpdate.getAmount());
-        }
-        Assert.assertEquals(receiveBalanceUpdateCnt, transferCount * 2);
-        Assert.assertEquals(balanceSum, 0);
-        log.info("transfer normal test finish.");
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.transaction;
+
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.api.transaction.Transaction;
+import org.awaitility.Awaitility;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * Transaction integration test.
+ */
+@Slf4j
+public class TransactionTest extends TransactionTestBase {
+
+    /**
+     * Transfer Business Mock Test
+     *
+     * The `transfer topic` represents the transfer operation, it consist of `from account`, `to account` and amount.
+     * The `balance update topic` represents the account update record, it consist of account and amount.
+     *
+     * The transfer topic consumer receive transfer messages and produce two balance update messages,
+     * one represents `from account` balance update and one represents `to account` balance update.
+     *
+     * example:
+     *
+     * receive messages:
+     * transfer {
+     *     fromAccount: "alice",
+     *     toAccount: "bob",
+     *     amount: 100
+     * }
+     *
+     * produce messages:
+     * fromAccountBalanceUpdate {
+     *     account: "alice"
+     *     amount: -100
+     * }
+     * toAccountBalanceUpdate {
+     *     account: "bob",
+     *     amount: 100
+     * }
+     *
+     * test target:
+     *
+     * 1. The balance update messages count should be double transfer message count.
+     * 2. The balance update messages amount sum should be 0.
+     */
+    @Test(dataProvider = "ServiceUrls")
+    public void transferNormalTest(Supplier<String> serviceUrl) throws Exception {
+        log.info("transfer normal test start.");
+        @Cleanup
+        PulsarClient pulsarClient = PulsarClient.builder().enableTransaction(true).serviceUrl(serviceUrl.get()).build();
+
+        final int transferCount = 20;
+        final String transferTopic = "transfer-" + randomName(6);
+        final String balanceUpdateTopic = "balance-update-" + randomName(6);
+
+        @Cleanup
+        Producer<TransferOperation> transferProducer = pulsarClient
+                .newProducer(Schema.JSON(TransferOperation.class))
+                .topic(transferTopic)
+                .create();
+        log.info("transfer producer create finished");
+
+        prepareTransferData(transferProducer, transferCount);
+
+        @Cleanup
+        Consumer<TransferOperation> transferConsumer = pulsarClient.newConsumer(Schema.JSON(TransferOperation.class))
+                .topic(transferTopic)
+                .subscriptionName("integration-test")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscriptionType(SubscriptionType.Shared)
+                .subscribe();
+        Awaitility.await().until(transferConsumer::isConnected);
+        log.info("transfer consumer create finished");
+
+        @Cleanup
+        Producer<BalanceUpdate> balanceUpdateProducer = pulsarClient.newProducer(Schema.JSON(BalanceUpdate.class))
+                .topic(balanceUpdateTopic)
+                .sendTimeout(0, TimeUnit.SECONDS)
+                .create();
+        log.info("balance update producer create finished");
+
+        @Cleanup
+        Consumer<BalanceUpdate> balanceUpdateConsumer = pulsarClient.newConsumer(Schema.JSON(BalanceUpdate.class))
+                .topic(balanceUpdateTopic)
+                .subscriptionName("integration-test")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscribe();
+        Awaitility.await().until(balanceUpdateConsumer::isConnected);
+        log.info("balance update consumer create finished");
+
+        while (true) {
+            Message<TransferOperation> message = transferConsumer.receive(10, TimeUnit.SECONDS);
+            if (message == null) {
+                break;
+            }
+            TransferOperation transferOperation = message.getValue();
+
+            Transaction transaction = pulsarClient.newTransaction()
+                    .withTransactionTimeout(5, TimeUnit.MINUTES)
+                    .build().get();
+
+            balanceUpdateProducer.newMessage(transaction)
+                    .value(getBalanceUpdate(transferOperation, true)).sendAsync();
+
+            balanceUpdateProducer.newMessage(transaction)
+                    .value(getBalanceUpdate(transferOperation, false)).sendAsync();
+
+            transferConsumer.acknowledgeAsync(message.getMessageId(), transaction);
+
+            transaction.commit().get();
+        }
+
+        int receiveBalanceUpdateCnt = 0;
+        int balanceSum = 0;
+        while (true) {
+            Message<BalanceUpdate> message = balanceUpdateConsumer.receive(10, TimeUnit.SECONDS);
+            if (message == null) {
+                break;
+            }
+            receiveBalanceUpdateCnt++;
+
+            BalanceUpdate balanceUpdate = message.getValue();
+            balanceSum += balanceUpdate.getAmount();
+            log.info("balance account: {}, amount: {}", balanceUpdate.getAccount(), balanceUpdate.getAmount());
+        }
+        Assert.assertEquals(receiveBalanceUpdateCnt, transferCount * 2);
+        Assert.assertEquals(balanceSum, 0);
+        log.info("transfer normal test finish.");
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTestBase.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTestBase.java
index d394b79e1a..65eabebae5 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTestBase.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/transaction/TransactionTestBase.java
@@ -1,98 +1,98 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.transaction;
-
-import java.util.concurrent.CompletableFuture;
-import lombok.Data;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.ZKContainer;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-
-/**
- * Transaction test base.
- */
-@Slf4j
-public abstract class TransactionTestBase extends PulsarTestSuite {
-
-    @Override
-    protected void beforeStartCluster() throws Exception {
-        super.beforeStartCluster();
-        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
-            brokerContainer.withEnv("transactionCoordinatorEnabled", "true");
-            brokerContainer.withEnv("transactionBufferProviderClassName",
-                    "org.apache.pulsar.broker.transaction.buffer.impl.TopicTransactionBufferProvider");
-            brokerContainer.withEnv("acknowledgmentAtBatchIndexLevelEnabled", "true");
-        }
-    }
-
-    private void transactionCoordinatorMetadataInitialize() throws Exception {
-        BrokerContainer brokerContainer = pulsarCluster.getBrokers().iterator().next();
-        ContainerExecResult result = brokerContainer.execCmd(
-                "/pulsar/bin/pulsar", "initialize-transaction-coordinator-metadata",
-                "-cs", ZKContainer.NAME,
-                "-c", pulsarCluster.getClusterName());
-    }
-
-    @Override
-    public void setupCluster() throws Exception {
-        super.setupCluster();
-        transactionCoordinatorMetadataInitialize();
-    }
-
-    public void prepareTransferData(Producer<TransferOperation> transferProducer, int messageCnt) {
-        for (int i = 0; i < messageCnt; i++) {
-            TransferOperation transferOperation = new TransferOperation();
-            transferOperation.setFromAccount("alice");
-            transferOperation.setToAccount("Bob");
-            transferOperation.setAmount(100 * i);
-            CompletableFuture<MessageId> completableFuture =
-                    transferProducer.newMessage().value(transferOperation).sendAsync();
-        }
-        log.info("transfer messages produced");
-    }
-
-    public BalanceUpdate getBalanceUpdate(TransferOperation transferOperation, boolean isFromAccount) {
-        BalanceUpdate balanceUpdate = new BalanceUpdate();
-        balanceUpdate.setAccount(transferOperation.getFromAccount());
-        if (isFromAccount) {
-            balanceUpdate.setAmount(-(transferOperation.getAmount()));
-        } else {
-            balanceUpdate.setAmount(transferOperation.getAmount());
-        }
-        return balanceUpdate;
-    }
-
-    @Data
-    public static class TransferOperation {
-        private String fromAccount;
-        private String toAccount;
-        private int amount;
-    }
-
-    @Data
-    public static class BalanceUpdate {
-        private String account;
-        private int amount;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.transaction;
+
+import java.util.concurrent.CompletableFuture;
+import lombok.Data;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.ZKContainer;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+
+/**
+ * Transaction test base.
+ */
+@Slf4j
+public abstract class TransactionTestBase extends PulsarTestSuite {
+
+    @Override
+    protected void beforeStartCluster() throws Exception {
+        super.beforeStartCluster();
+        for (BrokerContainer brokerContainer : pulsarCluster.getBrokers()) {
+            brokerContainer.withEnv("transactionCoordinatorEnabled", "true");
+            brokerContainer.withEnv("transactionBufferProviderClassName",
+                    "org.apache.pulsar.broker.transaction.buffer.impl.TopicTransactionBufferProvider");
+            brokerContainer.withEnv("acknowledgmentAtBatchIndexLevelEnabled", "true");
+        }
+    }
+
+    private void transactionCoordinatorMetadataInitialize() throws Exception {
+        BrokerContainer brokerContainer = pulsarCluster.getBrokers().iterator().next();
+        ContainerExecResult result = brokerContainer.execCmd(
+                "/pulsar/bin/pulsar", "initialize-transaction-coordinator-metadata",
+                "-cs", ZKContainer.NAME,
+                "-c", pulsarCluster.getClusterName());
+    }
+
+    @Override
+    public void setupCluster() throws Exception {
+        super.setupCluster();
+        transactionCoordinatorMetadataInitialize();
+    }
+
+    public void prepareTransferData(Producer<TransferOperation> transferProducer, int messageCnt) {
+        for (int i = 0; i < messageCnt; i++) {
+            TransferOperation transferOperation = new TransferOperation();
+            transferOperation.setFromAccount("alice");
+            transferOperation.setToAccount("Bob");
+            transferOperation.setAmount(100 * i);
+            CompletableFuture<MessageId> completableFuture =
+                    transferProducer.newMessage().value(transferOperation).sendAsync();
+        }
+        log.info("transfer messages produced");
+    }
+
+    public BalanceUpdate getBalanceUpdate(TransferOperation transferOperation, boolean isFromAccount) {
+        BalanceUpdate balanceUpdate = new BalanceUpdate();
+        balanceUpdate.setAccount(transferOperation.getFromAccount());
+        if (isFromAccount) {
+            balanceUpdate.setAmount(-(transferOperation.getAmount()));
+        } else {
+            balanceUpdate.setAmount(transferOperation.getAmount());
+        }
+        return balanceUpdate;
+    }
+
+    @Data
+    public static class TransferOperation {
+        private String fromAccount;
+        private String toAccount;
+        private int amount;
+    }
+
+    @Data
+    public static class BalanceUpdate {
+        private String account;
+        private int amount;
+    }
+
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarUpgradeDowngradeTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarUpgradeDowngradeTest.java
index 09539f32ff..e27865c25d 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarUpgradeDowngradeTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarUpgradeDowngradeTest.java
@@ -1,176 +1,176 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.upgrade;
-
-import static java.util.stream.Collectors.joining;
-import static org.testng.Assert.assertEquals;
-import com.github.dockerjava.api.model.Bind;
-import java.util.stream.Stream;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageId;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionInitialPosition;
-import org.apache.pulsar.tests.integration.containers.PulsarContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.Network;
-import org.testng.annotations.Test;
-
-/**
- * Test upgrading/downgrading Pulsar cluster from major releases.
- */
-@Slf4j
-public class PulsarUpgradeDowngradeTest extends PulsarClusterTestBase {
-
-    @Test(timeOut = 600_000)
-    public void upgradeTest() throws Exception {
-        testUpgradeDowngrade(PulsarContainer.LAST_RELEASE_IMAGE_NAME, PulsarContainer.UPGRADE_TEST_IMAGE_NAME);
-    }
-
-    private void testUpgradeDowngrade(String imageOld, String imageNew) throws Exception {
-        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
-                .filter(s -> !s.isEmpty())
-                .collect(joining("-"));
-        String topicName = generateTopicName("testupdown", true);
-
-        @Cleanup
-        Network network = Network.newNetwork();
-        @Cleanup
-        GenericContainer<?> alpine = new GenericContainer<>(PulsarContainer.ALPINE_IMAGE_NAME)
-                .withExposedPorts(80)
-                .withNetwork(network)
-                .withNetworkAliases("shared-storage")
-                .withEnv("MAGIC_NUMBER", "42")
-                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd
-                    .getHostConfig()
-                    .withBinds(Bind.parse("/pulsar/data:/pulsar/data")))
-                .withCommand("/bin/sh", "-c",
-                        "mkdir -p /pulsar/data && "
-                                + "chmod -R ug+rwx /pulsar/data && "
-                                + "chown -R 10000:0 /pulsar/data && "
-                                + "rm -rf /pulsar/data/* && "
-                                + "while true; do echo \"$MAGIC_NUMBER\" | nc -l -p 80; done");
-        alpine.start();
-
-        PulsarClusterSpec specOld = PulsarClusterSpec.builder()
-                .numBookies(2)
-                .numBrokers(1)
-                .clusterName(clusterName)
-                .dataContainer(alpine)
-                .pulsarTestImage(imageOld)
-                .build();
-
-        PulsarClusterSpec specNew = PulsarClusterSpec.builder()
-                .numBookies(2)
-                .numBrokers(1)
-                .clusterName(clusterName)
-                .dataContainer(alpine)
-                .pulsarTestImage(imageNew)
-                .build();
-
-        log.info("Setting up OLD cluster {} with {} bookies, {} brokers using {}",
-                specOld.clusterName(), specOld.numBookies(), specOld.numBrokers(), imageOld);
-
-        pulsarCluster = PulsarCluster.forSpec(specNew, network);
-        pulsarCluster.closeNetworkOnExit = false;
-        pulsarCluster.start(true);
-
-        try {
-            log.info("setting retention");
-            pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
-                "set-retention", "--size", "100M", "--time", "100m", "public/default");
-
-            publishAndConsume(topicName, pulsarCluster.getPlainTextServiceUrl(), 10, 10);
-        } finally {
-            pulsarCluster.stop();
-        }
-
-        log.info("Upgrading to NEW cluster {} with {} bookies, {} brokers using {}",
-                specNew.clusterName(), specNew.numBookies(), specNew.numBrokers(), imageNew);
-
-        pulsarCluster = PulsarCluster.forSpec(specNew, network);
-        pulsarCluster.closeNetworkOnExit = false;
-        pulsarCluster.start(false);
-
-        try {
-            publishAndConsume(topicName, pulsarCluster.getPlainTextServiceUrl(), 10, 20);
-        } finally {
-            pulsarCluster.stop();
-        }
-
-        log.info("Downgrading to OLD cluster {} with {} bookies, {} brokers using {}",
-                specOld.clusterName(), specOld.numBookies(), specOld.numBrokers(), imageOld);
-
-        pulsarCluster = PulsarCluster.forSpec(specOld, network);
-        pulsarCluster.closeNetworkOnExit = false;
-        pulsarCluster.start(false);
-
-        try {
-            publishAndConsume(topicName, pulsarCluster.getPlainTextServiceUrl(), 10, 30);
-        } finally {
-            pulsarCluster.stop();
-            alpine.stop();
-            network.close();
-        }
-    }
-
-    private void publishAndConsume(String topicName, String serviceUrl, int numProduce, int numConsume)
-            throws Exception {
-        log.info("publishAndConsume: topic name: {}", topicName);
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl)
-                .build();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .create();
-
-        log.info("Publishing {} messages", numProduce);
-        for (int i = numConsume - numProduce; i < numConsume; i++) {
-            log.info("Publishing message: {}", "smoke-message-" + i);
-            producer.send("smoke-message-" + i);
-        }
-
-        @Cleanup
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("my-sub")
-                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
-                .subscribe();
-        consumer.seek(MessageId.earliest);
-
-        log.info("Consuming {} messages", numConsume);
-        for (int i = 0; i < numConsume; i++) {
-            log.info("Waiting for message: {}", i);
-            Message<String> m = consumer.receive();
-            log.info("Received message: {}", m.getValue());
-            assertEquals("smoke-message-" + i, m.getValue());
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.upgrade;
+
+import static java.util.stream.Collectors.joining;
+import static org.testng.Assert.assertEquals;
+import com.github.dockerjava.api.model.Bind;
+import java.util.stream.Stream;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionInitialPosition;
+import org.apache.pulsar.tests.integration.containers.PulsarContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.Network;
+import org.testng.annotations.Test;
+
+/**
+ * Test upgrading/downgrading Pulsar cluster from major releases.
+ */
+@Slf4j
+public class PulsarUpgradeDowngradeTest extends PulsarClusterTestBase {
+
+    @Test(timeOut = 600_000)
+    public void upgradeTest() throws Exception {
+        testUpgradeDowngrade(PulsarContainer.LAST_RELEASE_IMAGE_NAME, PulsarContainer.UPGRADE_TEST_IMAGE_NAME);
+    }
+
+    private void testUpgradeDowngrade(String imageOld, String imageNew) throws Exception {
+        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
+                .filter(s -> !s.isEmpty())
+                .collect(joining("-"));
+        String topicName = generateTopicName("testupdown", true);
+
+        @Cleanup
+        Network network = Network.newNetwork();
+        @Cleanup
+        GenericContainer<?> alpine = new GenericContainer<>(PulsarContainer.ALPINE_IMAGE_NAME)
+                .withExposedPorts(80)
+                .withNetwork(network)
+                .withNetworkAliases("shared-storage")
+                .withEnv("MAGIC_NUMBER", "42")
+                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd
+                    .getHostConfig()
+                    .withBinds(Bind.parse("/pulsar/data:/pulsar/data")))
+                .withCommand("/bin/sh", "-c",
+                        "mkdir -p /pulsar/data && "
+                                + "chmod -R ug+rwx /pulsar/data && "
+                                + "chown -R 10000:0 /pulsar/data && "
+                                + "rm -rf /pulsar/data/* && "
+                                + "while true; do echo \"$MAGIC_NUMBER\" | nc -l -p 80; done");
+        alpine.start();
+
+        PulsarClusterSpec specOld = PulsarClusterSpec.builder()
+                .numBookies(2)
+                .numBrokers(1)
+                .clusterName(clusterName)
+                .dataContainer(alpine)
+                .pulsarTestImage(imageOld)
+                .build();
+
+        PulsarClusterSpec specNew = PulsarClusterSpec.builder()
+                .numBookies(2)
+                .numBrokers(1)
+                .clusterName(clusterName)
+                .dataContainer(alpine)
+                .pulsarTestImage(imageNew)
+                .build();
+
+        log.info("Setting up OLD cluster {} with {} bookies, {} brokers using {}",
+                specOld.clusterName(), specOld.numBookies(), specOld.numBrokers(), imageOld);
+
+        pulsarCluster = PulsarCluster.forSpec(specNew, network);
+        pulsarCluster.closeNetworkOnExit = false;
+        pulsarCluster.start(true);
+
+        try {
+            log.info("setting retention");
+            pulsarCluster.runAdminCommandOnAnyBroker("namespaces",
+                "set-retention", "--size", "100M", "--time", "100m", "public/default");
+
+            publishAndConsume(topicName, pulsarCluster.getPlainTextServiceUrl(), 10, 10);
+        } finally {
+            pulsarCluster.stop();
+        }
+
+        log.info("Upgrading to NEW cluster {} with {} bookies, {} brokers using {}",
+                specNew.clusterName(), specNew.numBookies(), specNew.numBrokers(), imageNew);
+
+        pulsarCluster = PulsarCluster.forSpec(specNew, network);
+        pulsarCluster.closeNetworkOnExit = false;
+        pulsarCluster.start(false);
+
+        try {
+            publishAndConsume(topicName, pulsarCluster.getPlainTextServiceUrl(), 10, 20);
+        } finally {
+            pulsarCluster.stop();
+        }
+
+        log.info("Downgrading to OLD cluster {} with {} bookies, {} brokers using {}",
+                specOld.clusterName(), specOld.numBookies(), specOld.numBrokers(), imageOld);
+
+        pulsarCluster = PulsarCluster.forSpec(specOld, network);
+        pulsarCluster.closeNetworkOnExit = false;
+        pulsarCluster.start(false);
+
+        try {
+            publishAndConsume(topicName, pulsarCluster.getPlainTextServiceUrl(), 10, 30);
+        } finally {
+            pulsarCluster.stop();
+            alpine.stop();
+            network.close();
+        }
+    }
+
+    private void publishAndConsume(String topicName, String serviceUrl, int numProduce, int numConsume)
+            throws Exception {
+        log.info("publishAndConsume: topic name: {}", topicName);
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl)
+                .build();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .create();
+
+        log.info("Publishing {} messages", numProduce);
+        for (int i = numConsume - numProduce; i < numConsume; i++) {
+            log.info("Publishing message: {}", "smoke-message-" + i);
+            producer.send("smoke-message-" + i);
+        }
+
+        @Cleanup
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("my-sub")
+                .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)
+                .subscribe();
+        consumer.seek(MessageId.earliest);
+
+        log.info("Consuming {} messages", numConsume);
+        for (int i = 0; i < numConsume; i++) {
+            log.info("Waiting for message: {}", i);
+            Message<String> m = consumer.receive();
+            log.info("Received message: {}", m.getValue());
+            assertEquals("smoke-message-" + i, m.getValue());
+        }
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarZKDowngradeTest.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarZKDowngradeTest.java
index 22e963675e..6cf992140e 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarZKDowngradeTest.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/upgrade/PulsarZKDowngradeTest.java
@@ -1,114 +1,114 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.upgrade;
-
-import static java.util.stream.Collectors.joining;
-import static org.testng.Assert.assertEquals;
-import com.google.common.collect.ImmutableMap;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
-import lombok.Cleanup;
-import lombok.extern.slf4j.Slf4j;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-/**
- * Test downgrading ZK from 3.5.x to 3.4.x. This is part of the upgrade from Pulsar 2.1.0 to 2.1.1.
- */
-@Slf4j
-public class PulsarZKDowngradeTest extends PulsarClusterTestBase {
-
-    protected static final int ENTRIES_PER_LEDGER = 1024;
-
-    @BeforeClass(alwaysRun = true)
-    @Override
-    public final void setupCluster() throws Exception {
-        incrementSetupNumber();
-
-        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
-                .filter(s -> !s.isEmpty())
-                .collect(joining("-"));
-
-        PulsarClusterSpec spec = PulsarClusterSpec.builder()
-                .numBookies(2)
-                .numBrokers(1)
-                .clusterName(clusterName)
-                .classPathVolumeMounts(
-                        ImmutableMap.<String, String> builder()
-                                .put("zk-3.5-test-data", "/pulsar/data/zookeeper/version-2/version-2")
-                                .build())
-                .build();
-
-        log.info("Setting up cluster {} with {} bookies, {} brokers",
-                spec.clusterName(), spec.numBookies(), spec.numBrokers());
-
-        pulsarCluster = PulsarCluster.forSpec(spec);
-        pulsarCluster.start();
-
-        log.info("Cluster {} is setup", spec.clusterName());
-    }
-
-    @AfterClass(alwaysRun = true)
-    @Override
-    public final void tearDownCluster() throws Exception {
-        super.tearDownCluster();
-    }
-
-    @Test(dataProvider = "ServiceUrlAndTopics")
-    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
-        String topicName = generateTopicName("testpubconsume", isPersistent);
-
-        int numMessages = 10;
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(serviceUrl.get())
-                .build();
-
-        @Cleanup
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(topicName)
-                .subscriptionName("my-sub")
-                .subscribe();
-
-        @Cleanup
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(topicName)
-                .create();
-
-        for (int i = 0; i < numMessages; i++) {
-            producer.send("smoke-message-" + i);
-        }
-
-        for (int i = 0; i < numMessages; i++) {
-            Message<String> m = consumer.receive();
-            assertEquals("smoke-message-" + i, m.getValue());
-        }
-
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.upgrade;
+
+import static java.util.stream.Collectors.joining;
+import static org.testng.Assert.assertEquals;
+import com.google.common.collect.ImmutableMap;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+import lombok.Cleanup;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.tests.integration.topologies.PulsarCluster;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterTestBase;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+/**
+ * Test downgrading ZK from 3.5.x to 3.4.x. This is part of the upgrade from Pulsar 2.1.0 to 2.1.1.
+ */
+@Slf4j
+public class PulsarZKDowngradeTest extends PulsarClusterTestBase {
+
+    protected static final int ENTRIES_PER_LEDGER = 1024;
+
+    @BeforeClass(alwaysRun = true)
+    @Override
+    public final void setupCluster() throws Exception {
+        incrementSetupNumber();
+
+        final String clusterName = Stream.of(this.getClass().getSimpleName(), randomName(5))
+                .filter(s -> !s.isEmpty())
+                .collect(joining("-"));
+
+        PulsarClusterSpec spec = PulsarClusterSpec.builder()
+                .numBookies(2)
+                .numBrokers(1)
+                .clusterName(clusterName)
+                .classPathVolumeMounts(
+                        ImmutableMap.<String, String> builder()
+                                .put("zk-3.5-test-data", "/pulsar/data/zookeeper/version-2/version-2")
+                                .build())
+                .build();
+
+        log.info("Setting up cluster {} with {} bookies, {} brokers",
+                spec.clusterName(), spec.numBookies(), spec.numBrokers());
+
+        pulsarCluster = PulsarCluster.forSpec(spec);
+        pulsarCluster.start();
+
+        log.info("Cluster {} is setup", spec.clusterName());
+    }
+
+    @AfterClass(alwaysRun = true)
+    @Override
+    public final void tearDownCluster() throws Exception {
+        super.tearDownCluster();
+    }
+
+    @Test(dataProvider = "ServiceUrlAndTopics")
+    public void testPublishAndConsume(Supplier<String> serviceUrl, boolean isPersistent) throws Exception {
+        String topicName = generateTopicName("testpubconsume", isPersistent);
+
+        int numMessages = 10;
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(serviceUrl.get())
+                .build();
+
+        @Cleanup
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(topicName)
+                .subscriptionName("my-sub")
+                .subscribe();
+
+        @Cleanup
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(topicName)
+                .create();
+
+        for (int i = 0; i < numMessages; i++) {
+            producer.send("smoke-message-" + i);
+        }
+
+        for (int i = 0; i < numMessages; i++) {
+            Message<String> m = consumer.receive();
+            assertEquals("smoke-message-" + i, m.getValue());
+        }
+
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/utils/DockerUtils.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/utils/DockerUtils.java
index 262ed5b967..49cb33d7ae 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/utils/DockerUtils.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/utils/DockerUtils.java
@@ -1,421 +1,421 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.utils;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import com.github.dockerjava.api.DockerClient;
-import com.github.dockerjava.api.async.ResultCallback;
-import com.github.dockerjava.api.command.InspectContainerResponse;
-import com.github.dockerjava.api.command.InspectExecResponse;
-import com.github.dockerjava.api.exception.NotFoundException;
-import com.github.dockerjava.api.model.ContainerNetwork;
-import com.github.dockerjava.api.model.Frame;
-import com.github.dockerjava.api.model.StreamType;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UncheckedIOException;
-import java.nio.file.Files;
-import java.nio.file.StandardCopyOption;
-import java.util.Map;
-import java.util.Optional;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.zip.GZIPOutputStream;
-import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
-import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
-import org.apache.commons.io.IOUtils;
-import org.apache.pulsar.tests.integration.docker.ContainerExecException;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
-import org.apache.pulsar.tests.integration.docker.ContainerExecResultBytes;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class DockerUtils {
-    private static final Logger LOG = LoggerFactory.getLogger(DockerUtils.class);
-
-    private static File getTargetDirectory(String containerId) {
-        String base = System.getProperty("maven.buildDirectory");
-        if (base == null) {
-            base = "target";
-        }
-        File directory = new File(base + "/container-logs/" + containerId);
-        if (!directory.exists() && !directory.mkdirs()) {
-            LOG.error("Error creating directory for container logs.");
-        }
-        return directory;
-    }
-
-    public static void dumpContainerLogToTarget(DockerClient dockerClient, String containerId) {
-        final String containerName = getContainerName(dockerClient, containerId);
-        File output = getUniqueFileInTargetDirectory(containerName, "docker", ".log");
-        try (OutputStream os = new BufferedOutputStream(new FileOutputStream(output))) {
-            CompletableFuture<Boolean> future = new CompletableFuture<>();
-            dockerClient.logContainerCmd(containerName).withStdOut(true)
-                    .withStdErr(true).withTimestamps(true).exec(new ResultCallback<Frame>() {
-                @Override
-                public void close() {
-                }
-
-                @Override
-                public void onStart(Closeable closeable) {
-                }
-
-                @Override
-                public void onNext(Frame object) {
-                    try {
-                        os.write(object.getPayload());
-                    } catch (IOException e) {
-                        onError(e);
-                    }
-                }
-
-                @Override
-                public void onError(Throwable throwable) {
-                    future.completeExceptionally(throwable);
-                }
-
-                @Override
-                public void onComplete() {
-                    future.complete(true);
-                }
-            });
-            future.get();
-        } catch (RuntimeException | ExecutionException | IOException e) {
-            LOG.error("Error dumping log for {}", containerName, e);
-        } catch (InterruptedException ie) {
-            Thread.currentThread().interrupt();
-            LOG.info("Interrupted dumping log from container {}", containerName, ie);
-        }
-    }
-
-    private static File getUniqueFileInTargetDirectory(String containerName, String prefix, String suffix) {
-        return getUniqueFileInDirectory(getTargetDirectory(containerName), prefix, suffix);
-    }
-
-    private static File getUniqueFileInDirectory(File directory, String prefix, String suffix) {
-        File file = new File(directory, prefix + suffix);
-        int i = 0;
-        while (file.exists()) {
-            LOG.info("{} exists, incrementing", file);
-            file = new File(directory, prefix + "_" + (i++) + suffix);
-        }
-        return file;
-    }
-
-    private static String getContainerName(DockerClient dockerClient, String containerId) {
-        final InspectContainerResponse inspectContainerResponse = dockerClient.inspectContainerCmd(containerId).exec();
-        // docker api returns names prefixed with "/", it's part of it's legacy design,
-        // this removes it to be consistent with what docker ps shows.
-        return inspectContainerResponse.getName().replace("/", "");
-    }
-
-    public static void dumpContainerDirToTargetCompressed(DockerClient dockerClient, String containerId,
-                                                          String path) {
-        final String containerName = getContainerName(dockerClient, containerId);
-        final String baseName = path.replace("/", "-").replaceAll("^-", "");
-        File output = getUniqueFileInTargetDirectory(containerName, baseName, ".tar.gz");
-        try (InputStream dockerStream = dockerClient.copyArchiveFromContainerCmd(containerId, path).exec();
-             OutputStream os = new GZIPOutputStream(new BufferedOutputStream(new FileOutputStream(output)))) {
-            IOUtils.copy(dockerStream, os);
-        } catch (RuntimeException | IOException e) {
-            if (!(e instanceof NotFoundException)) {
-                LOG.error("Error reading dir from container {}", containerName, e);
-            }
-        }
-    }
-
-    public static void dumpContainerLogDirToTarget(DockerClient docker, String containerId,
-                                                   String path) {
-        File targetDirectory = getTargetDirectory(containerId);
-        try (InputStream dockerStream = docker.copyArchiveFromContainerCmd(containerId, path).exec();
-             TarArchiveInputStream stream = new TarArchiveInputStream(dockerStream)) {
-            TarArchiveEntry entry = stream.getNextTarEntry();
-            while (entry != null) {
-                if (entry.isFile()) {
-                    File output = new File(targetDirectory, entry.getName().replace("/", "-"));
-                    Files.copy(stream, output.toPath(), StandardCopyOption.REPLACE_EXISTING);
-                }
-                entry = stream.getNextTarEntry();
-            }
-        } catch (RuntimeException | IOException e) {
-            LOG.error("Error reading logs from container {}", containerId, e);
-        }
-    }
-
-    public static String getContainerIP(DockerClient docker, String containerId) {
-        for (Map.Entry<String, ContainerNetwork> e : docker.inspectContainerCmd(containerId)
-                .exec().getNetworkSettings().getNetworks().entrySet()) {
-            return e.getValue().getIpAddress();
-        }
-        throw new IllegalArgumentException("Container " + containerId + " has no networks");
-    }
-
-    public static ContainerExecResult runCommand(DockerClient docker,
-                                                 String containerId,
-                                                 String... cmd)
-            throws ContainerExecException, ExecutionException, InterruptedException {
-        try {
-            return runCommandAsync(docker, containerId, cmd).get();
-        } catch (ExecutionException e) {
-            if (e.getCause() instanceof ContainerExecException) {
-                throw (ContainerExecException) e.getCause();
-            }
-            throw e;
-        }
-    }
-
-    public static ContainerExecResult runCommandAsUser(String userId,
-                                                       DockerClient docker,
-                                                       String containerId,
-                                                       String... cmd)
-            throws ContainerExecException, ExecutionException, InterruptedException {
-        try {
-            return runCommandAsyncAsUser(userId, docker, containerId, cmd).get();
-        } catch (ExecutionException e) {
-            if (e.getCause() instanceof ContainerExecException) {
-                throw (ContainerExecException) e.getCause();
-            }
-            throw e;
-        }
-    }
-
-    public static CompletableFuture<ContainerExecResult> runCommandAsyncAsUser(String userId,
-                                                                               DockerClient dockerClient,
-                                                                               String containerId,
-                                                                               String... cmd) {
-        String execId = dockerClient.execCreateCmd(containerId)
-                .withCmd(cmd)
-                .withAttachStderr(true)
-                .withAttachStdout(true)
-                .withUser(userId)
-                .exec()
-                .getId();
-        return runCommandAsync(execId, dockerClient, containerId, cmd);
-    }
-
-    public static CompletableFuture<ContainerExecResult> runCommandAsync(DockerClient dockerClient,
-                                                                         String containerId,
-                                                                         String... cmd) {
-        String execId = dockerClient.execCreateCmd(containerId)
-                .withCmd(cmd)
-                .withAttachStderr(true)
-                .withAttachStdout(true)
-                .exec()
-                .getId();
-        return runCommandAsync(execId, dockerClient, containerId, cmd);
-    }
-
-    private static CompletableFuture<ContainerExecResult> runCommandAsync(String execId,
-                                                                          DockerClient dockerClient,
-                                                                          String containerId,
-                                                                          String... cmd) {
-        CompletableFuture<ContainerExecResult> future = new CompletableFuture<>();
-        final String containerName = getContainerName(dockerClient, containerId);
-        String cmdString = String.join(" ", cmd);
-        StringBuilder stdout = new StringBuilder();
-        StringBuilder stderr = new StringBuilder();
-        dockerClient.execStartCmd(execId).withDetach(false)
-                .exec(new ResultCallback<Frame>() {
-                    @Override
-                    public void close() {
-                    }
-
-                    @Override
-                    public void onStart(Closeable closeable) {
-                        LOG.info("DOCKER.exec({}:{}): Executing...", containerName, cmdString);
-                    }
-
-                    @Override
-                    public void onNext(Frame object) {
-                        LOG.info("DOCKER.exec({}:{}): {}", containerName, cmdString, object);
-                        if (StreamType.STDOUT == object.getStreamType()) {
-                            stdout.append(new String(object.getPayload(), UTF_8));
-                        } else if (StreamType.STDERR == object.getStreamType()) {
-                            stderr.append(new String(object.getPayload(), UTF_8));
-                        }
-                    }
-
-                    @Override
-                    public void onError(Throwable throwable) {
-                        future.completeExceptionally(throwable);
-                    }
-
-                    @Override
-                    public void onComplete() {
-                        LOG.info("DOCKER.exec({}:{}): Done", containerName, cmdString);
-
-                        InspectExecResponse resp = waitForExecCmdToFinish(dockerClient, execId);
-                        long retCode = resp.getExitCodeLong();
-                        ContainerExecResult result = ContainerExecResult.of(
-                                retCode,
-                                stdout.toString(),
-                                stderr.toString()
-                        );
-                        LOG.info("DOCKER.exec({}:{}): completed with {}", containerName, cmdString, retCode);
-
-                        if (retCode != 0) {
-                            LOG.error(
-                                    "DOCKER.exec({}:{}): completed with non zero return code: {}\nstdout: {}\nstderr:"
-                                            + " {}",
-                                    containerName, cmdString, result.getExitCode(), result.getStdout(),
-                                    result.getStderr());
-                            future.completeExceptionally(new ContainerExecException(cmdString, containerId, result));
-                        } else {
-                            future.complete(result);
-                        }
-                    }
-                });
-        return future;
-    }
-
-    public static ContainerExecResultBytes runCommandWithRawOutput(DockerClient dockerClient,
-                                                                   String containerId,
-                                                                   String... cmd) throws ContainerExecException {
-        CompletableFuture<Boolean> future = new CompletableFuture<>();
-        String execId = dockerClient.execCreateCmd(containerId)
-                .withCmd(cmd)
-                .withAttachStderr(true)
-                .withAttachStdout(true)
-                .exec()
-                .getId();
-        final String containerName = getContainerName(dockerClient, containerId);
-        String cmdString = String.join(" ", cmd);
-        ByteArrayOutputStream stdout = new ByteArrayOutputStream();
-        ByteArrayOutputStream stderr = new ByteArrayOutputStream();
-        dockerClient.execStartCmd(execId).withDetach(false)
-                .exec(new ResultCallback<Frame>() {
-                    @Override
-                    public void close() {
-                    }
-
-                    @Override
-                    public void onStart(Closeable closeable) {
-                        LOG.info("DOCKER.exec({}:{}): Executing...", containerName, cmdString);
-                    }
-
-                    @Override
-                    public void onNext(Frame object) {
-                        try {
-                            if (StreamType.STDOUT == object.getStreamType()) {
-                                stdout.write(object.getPayload());
-                            } else if (StreamType.STDERR == object.getStreamType()) {
-                                stderr.write(object.getPayload());
-                            }
-                        } catch (IOException e) {
-                            throw new UncheckedIOException(e);
-                        }
-                    }
-
-                    @Override
-                    public void onError(Throwable throwable) {
-                        future.completeExceptionally(throwable);
-                    }
-
-                    @Override
-                    public void onComplete() {
-                        LOG.info("DOCKER.exec({}:{}): Done", containerName, cmdString);
-                        future.complete(true);
-                    }
-                });
-        future.join();
-
-        InspectExecResponse resp = waitForExecCmdToFinish(dockerClient, execId);
-        long retCode = resp.getExitCodeLong();
-
-        ContainerExecResultBytes result = ContainerExecResultBytes.of(
-                retCode,
-                stdout.toByteArray(),
-                stderr.toByteArray());
-        LOG.info("DOCKER.exec({}:{}): completed with {}", containerName, cmdString, retCode);
-
-        if (retCode != 0) {
-            throw new ContainerExecException(cmdString, containerId, null);
-        }
-        return result;
-    }
-
-    public static CompletableFuture<Long> runCommandAsyncWithLogging(DockerClient dockerClient,
-                                                                        String containerId, String... cmd) {
-        CompletableFuture<Long> future = new CompletableFuture<>();
-        String execId = dockerClient.execCreateCmd(containerId)
-                .withCmd(cmd)
-                .withAttachStderr(true)
-                .withAttachStdout(true)
-                .exec()
-                .getId();
-        final String containerName = getContainerName(dockerClient, containerId);
-        String cmdString = String.join(" ", cmd);
-        dockerClient.execStartCmd(execId).withDetach(false)
-                .exec(new ResultCallback<Frame>() {
-                    @Override
-                    public void close() {
-                    }
-
-                    @Override
-                    public void onStart(Closeable closeable) {
-                        LOG.info("DOCKER.exec({}:{}): Executing...", containerName, cmdString);
-                    }
-
-                    @Override
-                    public void onNext(Frame object) {
-                        LOG.info("DOCKER.exec({}:{}): {}", containerName, cmdString, object);
-                    }
-
-                    @Override
-                    public void onError(Throwable throwable) {
-                        future.completeExceptionally(throwable);
-                    }
-
-                    @Override
-                    public void onComplete() {
-                        LOG.info("DOCKER.exec({}:{}): Done", containerName, cmdString);
-                        InspectExecResponse resp = waitForExecCmdToFinish(dockerClient, execId);
-                        long retCode = resp.getExitCodeLong();
-                        LOG.info("DOCKER.exec({}:{}): completed with {}", containerName, cmdString, retCode);
-                        future.complete(retCode);
-                    }
-                });
-        return future;
-    }
-
-    private static InspectExecResponse waitForExecCmdToFinish(DockerClient dockerClient, String execId) {
-        InspectExecResponse resp = dockerClient.inspectExecCmd(execId).exec();
-        while (resp.isRunning()) {
-            try {
-                Thread.sleep(200);
-            } catch (InterruptedException ie) {
-                Thread.currentThread().interrupt();
-                throw new RuntimeException(ie);
-            }
-            resp = dockerClient.inspectExecCmd(execId).exec();
-        }
-        return resp;
-    }
-
-    public static Optional<String> getContainerCluster(DockerClient docker, String containerId) {
-        return Optional.ofNullable(docker.inspectContainerCmd(containerId)
-                .exec().getConfig().getLabels().get("cluster"));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.utils;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import com.github.dockerjava.api.DockerClient;
+import com.github.dockerjava.api.async.ResultCallback;
+import com.github.dockerjava.api.command.InspectContainerResponse;
+import com.github.dockerjava.api.command.InspectExecResponse;
+import com.github.dockerjava.api.exception.NotFoundException;
+import com.github.dockerjava.api.model.ContainerNetwork;
+import com.github.dockerjava.api.model.Frame;
+import com.github.dockerjava.api.model.StreamType;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.UncheckedIOException;
+import java.nio.file.Files;
+import java.nio.file.StandardCopyOption;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.zip.GZIPOutputStream;
+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
+import org.apache.commons.io.IOUtils;
+import org.apache.pulsar.tests.integration.docker.ContainerExecException;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResult;
+import org.apache.pulsar.tests.integration.docker.ContainerExecResultBytes;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DockerUtils {
+    private static final Logger LOG = LoggerFactory.getLogger(DockerUtils.class);
+
+    private static File getTargetDirectory(String containerId) {
+        String base = System.getProperty("maven.buildDirectory");
+        if (base == null) {
+            base = "target";
+        }
+        File directory = new File(base + "/container-logs/" + containerId);
+        if (!directory.exists() && !directory.mkdirs()) {
+            LOG.error("Error creating directory for container logs.");
+        }
+        return directory;
+    }
+
+    public static void dumpContainerLogToTarget(DockerClient dockerClient, String containerId) {
+        final String containerName = getContainerName(dockerClient, containerId);
+        File output = getUniqueFileInTargetDirectory(containerName, "docker", ".log");
+        try (OutputStream os = new BufferedOutputStream(new FileOutputStream(output))) {
+            CompletableFuture<Boolean> future = new CompletableFuture<>();
+            dockerClient.logContainerCmd(containerName).withStdOut(true)
+                    .withStdErr(true).withTimestamps(true).exec(new ResultCallback<Frame>() {
+                @Override
+                public void close() {
+                }
+
+                @Override
+                public void onStart(Closeable closeable) {
+                }
+
+                @Override
+                public void onNext(Frame object) {
+                    try {
+                        os.write(object.getPayload());
+                    } catch (IOException e) {
+                        onError(e);
+                    }
+                }
+
+                @Override
+                public void onError(Throwable throwable) {
+                    future.completeExceptionally(throwable);
+                }
+
+                @Override
+                public void onComplete() {
+                    future.complete(true);
+                }
+            });
+            future.get();
+        } catch (RuntimeException | ExecutionException | IOException e) {
+            LOG.error("Error dumping log for {}", containerName, e);
+        } catch (InterruptedException ie) {
+            Thread.currentThread().interrupt();
+            LOG.info("Interrupted dumping log from container {}", containerName, ie);
+        }
+    }
+
+    private static File getUniqueFileInTargetDirectory(String containerName, String prefix, String suffix) {
+        return getUniqueFileInDirectory(getTargetDirectory(containerName), prefix, suffix);
+    }
+
+    private static File getUniqueFileInDirectory(File directory, String prefix, String suffix) {
+        File file = new File(directory, prefix + suffix);
+        int i = 0;
+        while (file.exists()) {
+            LOG.info("{} exists, incrementing", file);
+            file = new File(directory, prefix + "_" + (i++) + suffix);
+        }
+        return file;
+    }
+
+    private static String getContainerName(DockerClient dockerClient, String containerId) {
+        final InspectContainerResponse inspectContainerResponse = dockerClient.inspectContainerCmd(containerId).exec();
+        // docker api returns names prefixed with "/", it's part of it's legacy design,
+        // this removes it to be consistent with what docker ps shows.
+        return inspectContainerResponse.getName().replace("/", "");
+    }
+
+    public static void dumpContainerDirToTargetCompressed(DockerClient dockerClient, String containerId,
+                                                          String path) {
+        final String containerName = getContainerName(dockerClient, containerId);
+        final String baseName = path.replace("/", "-").replaceAll("^-", "");
+        File output = getUniqueFileInTargetDirectory(containerName, baseName, ".tar.gz");
+        try (InputStream dockerStream = dockerClient.copyArchiveFromContainerCmd(containerId, path).exec();
+             OutputStream os = new GZIPOutputStream(new BufferedOutputStream(new FileOutputStream(output)))) {
+            IOUtils.copy(dockerStream, os);
+        } catch (RuntimeException | IOException e) {
+            if (!(e instanceof NotFoundException)) {
+                LOG.error("Error reading dir from container {}", containerName, e);
+            }
+        }
+    }
+
+    public static void dumpContainerLogDirToTarget(DockerClient docker, String containerId,
+                                                   String path) {
+        File targetDirectory = getTargetDirectory(containerId);
+        try (InputStream dockerStream = docker.copyArchiveFromContainerCmd(containerId, path).exec();
+             TarArchiveInputStream stream = new TarArchiveInputStream(dockerStream)) {
+            TarArchiveEntry entry = stream.getNextTarEntry();
+            while (entry != null) {
+                if (entry.isFile()) {
+                    File output = new File(targetDirectory, entry.getName().replace("/", "-"));
+                    Files.copy(stream, output.toPath(), StandardCopyOption.REPLACE_EXISTING);
+                }
+                entry = stream.getNextTarEntry();
+            }
+        } catch (RuntimeException | IOException e) {
+            LOG.error("Error reading logs from container {}", containerId, e);
+        }
+    }
+
+    public static String getContainerIP(DockerClient docker, String containerId) {
+        for (Map.Entry<String, ContainerNetwork> e : docker.inspectContainerCmd(containerId)
+                .exec().getNetworkSettings().getNetworks().entrySet()) {
+            return e.getValue().getIpAddress();
+        }
+        throw new IllegalArgumentException("Container " + containerId + " has no networks");
+    }
+
+    public static ContainerExecResult runCommand(DockerClient docker,
+                                                 String containerId,
+                                                 String... cmd)
+            throws ContainerExecException, ExecutionException, InterruptedException {
+        try {
+            return runCommandAsync(docker, containerId, cmd).get();
+        } catch (ExecutionException e) {
+            if (e.getCause() instanceof ContainerExecException) {
+                throw (ContainerExecException) e.getCause();
+            }
+            throw e;
+        }
+    }
+
+    public static ContainerExecResult runCommandAsUser(String userId,
+                                                       DockerClient docker,
+                                                       String containerId,
+                                                       String... cmd)
+            throws ContainerExecException, ExecutionException, InterruptedException {
+        try {
+            return runCommandAsyncAsUser(userId, docker, containerId, cmd).get();
+        } catch (ExecutionException e) {
+            if (e.getCause() instanceof ContainerExecException) {
+                throw (ContainerExecException) e.getCause();
+            }
+            throw e;
+        }
+    }
+
+    public static CompletableFuture<ContainerExecResult> runCommandAsyncAsUser(String userId,
+                                                                               DockerClient dockerClient,
+                                                                               String containerId,
+                                                                               String... cmd) {
+        String execId = dockerClient.execCreateCmd(containerId)
+                .withCmd(cmd)
+                .withAttachStderr(true)
+                .withAttachStdout(true)
+                .withUser(userId)
+                .exec()
+                .getId();
+        return runCommandAsync(execId, dockerClient, containerId, cmd);
+    }
+
+    public static CompletableFuture<ContainerExecResult> runCommandAsync(DockerClient dockerClient,
+                                                                         String containerId,
+                                                                         String... cmd) {
+        String execId = dockerClient.execCreateCmd(containerId)
+                .withCmd(cmd)
+                .withAttachStderr(true)
+                .withAttachStdout(true)
+                .exec()
+                .getId();
+        return runCommandAsync(execId, dockerClient, containerId, cmd);
+    }
+
+    private static CompletableFuture<ContainerExecResult> runCommandAsync(String execId,
+                                                                          DockerClient dockerClient,
+                                                                          String containerId,
+                                                                          String... cmd) {
+        CompletableFuture<ContainerExecResult> future = new CompletableFuture<>();
+        final String containerName = getContainerName(dockerClient, containerId);
+        String cmdString = String.join(" ", cmd);
+        StringBuilder stdout = new StringBuilder();
+        StringBuilder stderr = new StringBuilder();
+        dockerClient.execStartCmd(execId).withDetach(false)
+                .exec(new ResultCallback<Frame>() {
+                    @Override
+                    public void close() {
+                    }
+
+                    @Override
+                    public void onStart(Closeable closeable) {
+                        LOG.info("DOCKER.exec({}:{}): Executing...", containerName, cmdString);
+                    }
+
+                    @Override
+                    public void onNext(Frame object) {
+                        LOG.info("DOCKER.exec({}:{}): {}", containerName, cmdString, object);
+                        if (StreamType.STDOUT == object.getStreamType()) {
+                            stdout.append(new String(object.getPayload(), UTF_8));
+                        } else if (StreamType.STDERR == object.getStreamType()) {
+                            stderr.append(new String(object.getPayload(), UTF_8));
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable throwable) {
+                        future.completeExceptionally(throwable);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        LOG.info("DOCKER.exec({}:{}): Done", containerName, cmdString);
+
+                        InspectExecResponse resp = waitForExecCmdToFinish(dockerClient, execId);
+                        long retCode = resp.getExitCodeLong();
+                        ContainerExecResult result = ContainerExecResult.of(
+                                retCode,
+                                stdout.toString(),
+                                stderr.toString()
+                        );
+                        LOG.info("DOCKER.exec({}:{}): completed with {}", containerName, cmdString, retCode);
+
+                        if (retCode != 0) {
+                            LOG.error(
+                                    "DOCKER.exec({}:{}): completed with non zero return code: {}\nstdout: {}\nstderr:"
+                                            + " {}",
+                                    containerName, cmdString, result.getExitCode(), result.getStdout(),
+                                    result.getStderr());
+                            future.completeExceptionally(new ContainerExecException(cmdString, containerId, result));
+                        } else {
+                            future.complete(result);
+                        }
+                    }
+                });
+        return future;
+    }
+
+    public static ContainerExecResultBytes runCommandWithRawOutput(DockerClient dockerClient,
+                                                                   String containerId,
+                                                                   String... cmd) throws ContainerExecException {
+        CompletableFuture<Boolean> future = new CompletableFuture<>();
+        String execId = dockerClient.execCreateCmd(containerId)
+                .withCmd(cmd)
+                .withAttachStderr(true)
+                .withAttachStdout(true)
+                .exec()
+                .getId();
+        final String containerName = getContainerName(dockerClient, containerId);
+        String cmdString = String.join(" ", cmd);
+        ByteArrayOutputStream stdout = new ByteArrayOutputStream();
+        ByteArrayOutputStream stderr = new ByteArrayOutputStream();
+        dockerClient.execStartCmd(execId).withDetach(false)
+                .exec(new ResultCallback<Frame>() {
+                    @Override
+                    public void close() {
+                    }
+
+                    @Override
+                    public void onStart(Closeable closeable) {
+                        LOG.info("DOCKER.exec({}:{}): Executing...", containerName, cmdString);
+                    }
+
+                    @Override
+                    public void onNext(Frame object) {
+                        try {
+                            if (StreamType.STDOUT == object.getStreamType()) {
+                                stdout.write(object.getPayload());
+                            } else if (StreamType.STDERR == object.getStreamType()) {
+                                stderr.write(object.getPayload());
+                            }
+                        } catch (IOException e) {
+                            throw new UncheckedIOException(e);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable throwable) {
+                        future.completeExceptionally(throwable);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        LOG.info("DOCKER.exec({}:{}): Done", containerName, cmdString);
+                        future.complete(true);
+                    }
+                });
+        future.join();
+
+        InspectExecResponse resp = waitForExecCmdToFinish(dockerClient, execId);
+        long retCode = resp.getExitCodeLong();
+
+        ContainerExecResultBytes result = ContainerExecResultBytes.of(
+                retCode,
+                stdout.toByteArray(),
+                stderr.toByteArray());
+        LOG.info("DOCKER.exec({}:{}): completed with {}", containerName, cmdString, retCode);
+
+        if (retCode != 0) {
+            throw new ContainerExecException(cmdString, containerId, null);
+        }
+        return result;
+    }
+
+    public static CompletableFuture<Long> runCommandAsyncWithLogging(DockerClient dockerClient,
+                                                                        String containerId, String... cmd) {
+        CompletableFuture<Long> future = new CompletableFuture<>();
+        String execId = dockerClient.execCreateCmd(containerId)
+                .withCmd(cmd)
+                .withAttachStderr(true)
+                .withAttachStdout(true)
+                .exec()
+                .getId();
+        final String containerName = getContainerName(dockerClient, containerId);
+        String cmdString = String.join(" ", cmd);
+        dockerClient.execStartCmd(execId).withDetach(false)
+                .exec(new ResultCallback<Frame>() {
+                    @Override
+                    public void close() {
+                    }
+
+                    @Override
+                    public void onStart(Closeable closeable) {
+                        LOG.info("DOCKER.exec({}:{}): Executing...", containerName, cmdString);
+                    }
+
+                    @Override
+                    public void onNext(Frame object) {
+                        LOG.info("DOCKER.exec({}:{}): {}", containerName, cmdString, object);
+                    }
+
+                    @Override
+                    public void onError(Throwable throwable) {
+                        future.completeExceptionally(throwable);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        LOG.info("DOCKER.exec({}:{}): Done", containerName, cmdString);
+                        InspectExecResponse resp = waitForExecCmdToFinish(dockerClient, execId);
+                        long retCode = resp.getExitCodeLong();
+                        LOG.info("DOCKER.exec({}:{}): completed with {}", containerName, cmdString, retCode);
+                        future.complete(retCode);
+                    }
+                });
+        return future;
+    }
+
+    private static InspectExecResponse waitForExecCmdToFinish(DockerClient dockerClient, String execId) {
+        InspectExecResponse resp = dockerClient.inspectExecCmd(execId).exec();
+        while (resp.isRunning()) {
+            try {
+                Thread.sleep(200);
+            } catch (InterruptedException ie) {
+                Thread.currentThread().interrupt();
+                throw new RuntimeException(ie);
+            }
+            resp = dockerClient.inspectExecCmd(execId).exec();
+        }
+        return resp;
+    }
+
+    public static Optional<String> getContainerCluster(DockerClient docker, String containerId) {
+        return Optional.ofNullable(docker.inspectContainerCmd(containerId)
+                .exec().getConfig().getLabels().get("cluster"));
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/TestWebSocket.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/TestWebSocket.java
index cf699b3bf6..58fb0f42fd 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/TestWebSocket.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/TestWebSocket.java
@@ -1,74 +1,74 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.websocket;
-
-
-import com.google.common.collect.ImmutableMap;
-import java.util.Collections;
-import java.util.Map;
-import org.apache.pulsar.tests.integration.containers.BrokerContainer;
-import org.apache.pulsar.tests.integration.containers.CSContainer;
-import org.apache.pulsar.tests.integration.containers.WebSocketContainer;
-import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
-import org.testng.annotations.Test;
-
-/**
- * Test cases for websocket.
- */
-public class TestWebSocket extends WebSocketTestSuite {
-
-    public static final String WEBSOCKET = "websocket";
-
-    @Override
-    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
-            String clusterName,
-            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
-
-        Map<String, String> enableWebSocket = Collections.singletonMap("webSocketServiceEnabled", "true");
-        specBuilder.brokerEnvs(enableWebSocket);
-        specBuilder.proxyEnvs(enableWebSocket);
-
-        specBuilder.externalService(WEBSOCKET, new WebSocketContainer(clusterName, WEBSOCKET));
-        specBuilder.externalServiceEnv(WEBSOCKET, ImmutableMap.<String, String>builder()
-                .put("configurationMetadataStoreUrl", CSContainer.NAME + ":" + CSContainer.CS_PORT)
-                .put("webServicePort", "" + WebSocketContainer.BROKER_HTTP_PORT)
-                .put("clusterName", clusterName)
-                .build());
-        return super.beforeSetupCluster(clusterName, specBuilder);
-    }
-
-    @Test
-    public void testExternalService() throws Exception {
-        WebSocketContainer service = (WebSocketContainer) pulsarCluster.getExternalServices().get(WEBSOCKET);
-        testWebSocket(service.getWSUrl());
-    }
-
-    @Test
-    public void testBroker() throws Exception {
-        BrokerContainer broker = pulsarCluster.getAnyBroker();
-        String url = "ws://" + broker.getHost() + ":" + broker.getMappedPort(BrokerContainer.BROKER_HTTP_PORT);
-        testWebSocket(url);
-    }
-
-    @Test
-    public void testProxy() throws Exception {
-        String url = pulsarCluster.getProxy().getHttpServiceUrl().replaceFirst("http", "ws");
-        testWebSocket(url);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.websocket;
+
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Collections;
+import java.util.Map;
+import org.apache.pulsar.tests.integration.containers.BrokerContainer;
+import org.apache.pulsar.tests.integration.containers.CSContainer;
+import org.apache.pulsar.tests.integration.containers.WebSocketContainer;
+import org.apache.pulsar.tests.integration.topologies.PulsarClusterSpec;
+import org.testng.annotations.Test;
+
+/**
+ * Test cases for websocket.
+ */
+public class TestWebSocket extends WebSocketTestSuite {
+
+    public static final String WEBSOCKET = "websocket";
+
+    @Override
+    protected PulsarClusterSpec.PulsarClusterSpecBuilder beforeSetupCluster(
+            String clusterName,
+            PulsarClusterSpec.PulsarClusterSpecBuilder specBuilder) {
+
+        Map<String, String> enableWebSocket = Collections.singletonMap("webSocketServiceEnabled", "true");
+        specBuilder.brokerEnvs(enableWebSocket);
+        specBuilder.proxyEnvs(enableWebSocket);
+
+        specBuilder.externalService(WEBSOCKET, new WebSocketContainer(clusterName, WEBSOCKET));
+        specBuilder.externalServiceEnv(WEBSOCKET, ImmutableMap.<String, String>builder()
+                .put("configurationMetadataStoreUrl", CSContainer.NAME + ":" + CSContainer.CS_PORT)
+                .put("webServicePort", "" + WebSocketContainer.BROKER_HTTP_PORT)
+                .put("clusterName", clusterName)
+                .build());
+        return super.beforeSetupCluster(clusterName, specBuilder);
+    }
+
+    @Test
+    public void testExternalService() throws Exception {
+        WebSocketContainer service = (WebSocketContainer) pulsarCluster.getExternalServices().get(WEBSOCKET);
+        testWebSocket(service.getWSUrl());
+    }
+
+    @Test
+    public void testBroker() throws Exception {
+        BrokerContainer broker = pulsarCluster.getAnyBroker();
+        String url = "ws://" + broker.getHost() + ":" + broker.getMappedPort(BrokerContainer.BROKER_HTTP_PORT);
+        testWebSocket(url);
+    }
+
+    @Test
+    public void testProxy() throws Exception {
+        String url = pulsarCluster.getProxy().getHttpServiceUrl().replaceFirst("http", "ws");
+        testWebSocket(url);
+    }
+}
diff --git a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/WebSocketTestSuite.java b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/WebSocketTestSuite.java
index ae0ad21137..4ae1c73fc6 100644
--- a/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/WebSocketTestSuite.java
+++ b/tests/integration/src/test/java/org/apache/pulsar/tests/integration/websocket/WebSocketTestSuite.java
@@ -1,148 +1,148 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration.websocket;
-
-import com.fasterxml.jackson.core.type.TypeReference;
-import java.io.IOException;
-import java.net.URI;
-import java.util.Collections;
-import java.util.Map;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.common.util.ObjectMapperFactory;
-import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
-import org.eclipse.jetty.client.HttpClient;
-import org.eclipse.jetty.websocket.api.WebSocketAdapter;
-import org.eclipse.jetty.websocket.api.annotations.WebSocket;
-import org.eclipse.jetty.websocket.client.WebSocketClient;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-
-public abstract class WebSocketTestSuite extends PulsarTestSuite {
-    private static final Logger log = LoggerFactory.getLogger(WebSocketTestSuite.class);
-
-    protected void testWebSocket(String url) throws Exception {
-
-        final String tenant = "websocket-test-" + randomName(10);
-        final String namespace = tenant + "/ns1";
-        final String topic = namespace + "/topic-" + randomName(5);
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder()
-                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
-                .build();
-
-        admin.tenants().createTenant(tenant,
-                new TenantInfoImpl(Collections.emptySet(), Collections.singleton(pulsarCluster.getClusterName())));
-
-        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
-
-        log.debug("Using url {}", url);
-
-        @Cleanup
-        WebSocketConsumer consumer = new WebSocketConsumer(url, topic);
-        log.debug("Created ws consumer");
-
-        @Cleanup
-        WebSocketPublisher publisher = new WebSocketPublisher(url, topic);
-        log.debug("Created ws publisher");
-
-        publisher.send("SGVsbG8gV29ybGQ=");
-        log.debug("Sent message through publisher");
-
-        Map<String, Object> response = publisher.getResponse();
-        Assert.assertEquals(response.get("result"), "ok", "Bad response: " + response);
-        log.debug("Publisher received response {}", response);
-
-        String received = consumer.getPayloadFromResponse();
-        log.debug("Consumer received message {} ", received);
-        Assert.assertEquals(received, "SGVsbG8gV29ybGQ=");
-    }
-
-    @WebSocket
-    public static class Client extends WebSocketAdapter implements AutoCloseable {
-        final BlockingQueue<String> incomingMessages = new ArrayBlockingQueue<>(10);
-        private final WebSocketClient client;
-
-        Client(String webSocketUri) throws Exception {
-            HttpClient httpClient = new HttpClient();
-            client = new WebSocketClient(httpClient);
-            client.start();
-            client.connect(this, URI.create(webSocketUri)).get();
-        }
-
-        void sendText(String payload) throws IOException {
-            getSession().getRemote().sendString(payload);
-        }
-
-        @Override
-        public void onWebSocketText(String s) {
-            incomingMessages.add(s);
-        }
-
-        Map<String, Object> getResponse() throws Exception {
-            String response =  incomingMessages.poll(5, TimeUnit.SECONDS);
-            if (response == null) {
-                Assert.fail("Did not get websocket response within timeout");
-            }
-            return ObjectMapperFactory.getMapper().getObjectMapper().readValue(response, new TypeReference<>() {});
-
-        }
-
-        @Override
-        public void close() throws Exception {
-            client.stop();
-        }
-    }
-
-    @WebSocket
-    protected static class WebSocketPublisher extends Client {
-
-        WebSocketPublisher(String url, String topic) throws Exception {
-            super(url + "/ws/v2/producer/persistent/" + topic);
-        }
-
-        void send(String payload) throws IOException {
-            sendText("{\n"
-                    + "  \"payload\": \"" + payload + "\",\n"
-                    + "  \"properties\": {\"key1\": \"value1\", \"key2\": \"value2\"},\n"
-                    + "  \"context\": \"1\"\n"
-                    + "}");
-        }
-    }
-
-    @WebSocket
-    protected static class WebSocketConsumer extends Client {
-
-        WebSocketConsumer(String url, String topic) throws Exception {
-            super(url + "/ws/v2/consumer/persistent/" + topic + "/" + randomName(8));
-        }
-
-        String getPayloadFromResponse() throws Exception {
-            Map<String, Object> response =  getResponse();
-            return String.valueOf(response.get("payload"));
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration.websocket;
+
+import com.fasterxml.jackson.core.type.TypeReference;
+import java.io.IOException;
+import java.net.URI;
+import java.util.Collections;
+import java.util.Map;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.common.util.ObjectMapperFactory;
+import org.apache.pulsar.tests.integration.suites.PulsarTestSuite;
+import org.eclipse.jetty.client.HttpClient;
+import org.eclipse.jetty.websocket.api.WebSocketAdapter;
+import org.eclipse.jetty.websocket.api.annotations.WebSocket;
+import org.eclipse.jetty.websocket.client.WebSocketClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+
+public abstract class WebSocketTestSuite extends PulsarTestSuite {
+    private static final Logger log = LoggerFactory.getLogger(WebSocketTestSuite.class);
+
+    protected void testWebSocket(String url) throws Exception {
+
+        final String tenant = "websocket-test-" + randomName(10);
+        final String namespace = tenant + "/ns1";
+        final String topic = namespace + "/topic-" + randomName(5);
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder()
+                .serviceHttpUrl(pulsarCluster.getHttpServiceUrl())
+                .build();
+
+        admin.tenants().createTenant(tenant,
+                new TenantInfoImpl(Collections.emptySet(), Collections.singleton(pulsarCluster.getClusterName())));
+
+        admin.namespaces().createNamespace(namespace, Collections.singleton(pulsarCluster.getClusterName()));
+
+        log.debug("Using url {}", url);
+
+        @Cleanup
+        WebSocketConsumer consumer = new WebSocketConsumer(url, topic);
+        log.debug("Created ws consumer");
+
+        @Cleanup
+        WebSocketPublisher publisher = new WebSocketPublisher(url, topic);
+        log.debug("Created ws publisher");
+
+        publisher.send("SGVsbG8gV29ybGQ=");
+        log.debug("Sent message through publisher");
+
+        Map<String, Object> response = publisher.getResponse();
+        Assert.assertEquals(response.get("result"), "ok", "Bad response: " + response);
+        log.debug("Publisher received response {}", response);
+
+        String received = consumer.getPayloadFromResponse();
+        log.debug("Consumer received message {} ", received);
+        Assert.assertEquals(received, "SGVsbG8gV29ybGQ=");
+    }
+
+    @WebSocket
+    public static class Client extends WebSocketAdapter implements AutoCloseable {
+        final BlockingQueue<String> incomingMessages = new ArrayBlockingQueue<>(10);
+        private final WebSocketClient client;
+
+        Client(String webSocketUri) throws Exception {
+            HttpClient httpClient = new HttpClient();
+            client = new WebSocketClient(httpClient);
+            client.start();
+            client.connect(this, URI.create(webSocketUri)).get();
+        }
+
+        void sendText(String payload) throws IOException {
+            getSession().getRemote().sendString(payload);
+        }
+
+        @Override
+        public void onWebSocketText(String s) {
+            incomingMessages.add(s);
+        }
+
+        Map<String, Object> getResponse() throws Exception {
+            String response =  incomingMessages.poll(5, TimeUnit.SECONDS);
+            if (response == null) {
+                Assert.fail("Did not get websocket response within timeout");
+            }
+            return ObjectMapperFactory.getMapper().getObjectMapper().readValue(response, new TypeReference<>() {});
+
+        }
+
+        @Override
+        public void close() throws Exception {
+            client.stop();
+        }
+    }
+
+    @WebSocket
+    protected static class WebSocketPublisher extends Client {
+
+        WebSocketPublisher(String url, String topic) throws Exception {
+            super(url + "/ws/v2/producer/persistent/" + topic);
+        }
+
+        void send(String payload) throws IOException {
+            sendText("{\n"
+                    + "  \"payload\": \"" + payload + "\",\n"
+                    + "  \"properties\": {\"key1\": \"value1\", \"key2\": \"value2\"},\n"
+                    + "  \"context\": \"1\"\n"
+                    + "}");
+        }
+    }
+
+    @WebSocket
+    protected static class WebSocketConsumer extends Client {
+
+        WebSocketConsumer(String url, String topic) throws Exception {
+            super(url + "/ws/v2/consumer/persistent/" + topic + "/" + randomName(8));
+        }
+
+        String getPayloadFromResponse() throws Exception {
+            Map<String, Object> response =  getResponse();
+            return String.valueOf(response.get("payload"));
+        }
+    }
+
+}
diff --git a/tests/integration/src/test/resources/containers/otel-collector-config.yaml b/tests/integration/src/test/resources/containers/otel-collector-config.yaml
index 2ba532f3c6..771bdc8c77 100644
--- a/tests/integration/src/test/resources/containers/otel-collector-config.yaml
+++ b/tests/integration/src/test/resources/containers/otel-collector-config.yaml
@@ -1,44 +1,44 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-receivers:
-  otlp:
-    protocols:
-      grpc:
-        endpoint: 0.0.0.0:4317
-
-exporters:
-  prometheus:
-    endpoint: "0.0.0.0:8889"
-
-processors:
-  batch:
-
-extensions:
-  health_check:
-  zpages:
-    endpoint: :55679
-
-service:
-  extensions: [zpages, health_check]
-  pipelines:
-    metrics:
-      receivers: [otlp]
-      processors: [batch]
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+receivers:
+  otlp:
+    protocols:
+      grpc:
+        endpoint: 0.0.0.0:4317
+
+exporters:
+  prometheus:
+    endpoint: "0.0.0.0:8889"
+
+processors:
+  batch:
+
+extensions:
+  health_check:
+  zpages:
+    endpoint: :55679
+
+service:
+  extensions: [zpages, health_check]
+  pipelines:
+    metrics:
+      receivers: [otlp]
+      processors: [batch]
       exporters: [prometheus]
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/kafka-zookeeper.properties b/tests/integration/src/test/resources/kafka-zookeeper.properties
index f7d1f92f22..dbdbd79b33 100644
--- a/tests/integration/src/test/resources/kafka-zookeeper.properties
+++ b/tests/integration/src/test/resources/kafka-zookeeper.properties
@@ -1,36 +1,36 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-clientPort=2181
-dataDir=/var/lib/zookeeper/data
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+clientPort=2181
+dataDir=/var/lib/zookeeper/data
 dataLogDir=/var/lib/zookeeper/log
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-auth.xml b/tests/integration/src/test/resources/pulsar-auth.xml
index 81d2c1361a..2b7f737694 100644
--- a/tests/integration/src/test/resources/pulsar-auth.xml
+++ b/tests/integration/src/test/resources/pulsar-auth.xml
@@ -1,27 +1,27 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Auth Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-auth-test-suite" preserve-order="true" >
-        <classes>
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Auth Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-auth-test-suite" preserve-order="true" >
+        <classes>
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-backwards-compatibility.xml b/tests/integration/src/test/resources/pulsar-backwards-compatibility.xml
index 8fcabbd15f..a26ddcb200 100644
--- a/tests/integration/src/test/resources/pulsar-backwards-compatibility.xml
+++ b/tests/integration/src/test/resources/pulsar-backwards-compatibility.xml
@@ -1,35 +1,35 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Messaging Backwards Compatibility Tests" verbose="2" annotations="JDK">
-    <test name="messaging-backwards-compatibility-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest22" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest23" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest24" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest25" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest22" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest23" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest24" />
-            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest25" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Messaging Backwards Compatibility Tests" verbose="2" annotations="JDK">
+    <test name="messaging-backwards-compatibility-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest22" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest23" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest24" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.SmokeTest25" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest22" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest23" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest24" />
+            <class name="org.apache.pulsar.tests.integration.backwardscompatibility.ClientTest25" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-cli.xml b/tests/integration/src/test/resources/pulsar-cli.xml
index af55aca8a0..febddad3ae 100644
--- a/tests/integration/src/test/resources/pulsar-cli.xml
+++ b/tests/integration/src/test/resources/pulsar-cli.xml
@@ -1,39 +1,39 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar CLI Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-cli-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.cli.ClientToolTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.ClusterMetadataTearDownTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.CLITest" />
-            <class name="org.apache.pulsar.tests.integration.cli.HealthCheckTest" />
-            <class name="org.apache.pulsar.tests.integration.compaction.TestCompaction" />
-            <class name="org.apache.pulsar.tests.integration.cli.AdminMultiHostTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.FunctionsCLITest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.PackagesCliTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.PulsarVersionTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.tenant.TenantTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.PerfToolTest"/>
-            <class name="org.apache.pulsar.tests.integration.cli.topicpolicies.SchemaCompatibilityStrategyTest"/>
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar CLI Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-cli-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.cli.ClientToolTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.ClusterMetadataTearDownTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.CLITest" />
+            <class name="org.apache.pulsar.tests.integration.cli.HealthCheckTest" />
+            <class name="org.apache.pulsar.tests.integration.compaction.TestCompaction" />
+            <class name="org.apache.pulsar.tests.integration.cli.AdminMultiHostTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.FunctionsCLITest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.PackagesCliTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.PulsarVersionTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.tenant.TenantTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.PerfToolTest"/>
+            <class name="org.apache.pulsar.tests.integration.cli.topicpolicies.SchemaCompatibilityStrategyTest"/>
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-function.xml b/tests/integration/src/test/resources/pulsar-function.xml
index 61c7b5b469..e7d430f329 100644
--- a/tests/integration/src/test/resources/pulsar-function.xml
+++ b/tests/integration/src/test/resources/pulsar-function.xml
@@ -1,32 +1,32 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Function Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-function-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.functions.PulsarMetadataStateStoreTest" />
-            <class name="org.apache.pulsar.tests.integration.functions.PulsarBKStateStoreTest" />
-            <class name="org.apache.pulsar.tests.integration.io.PulsarGenericObjectSinkTest"/>
-            <class name="org.apache.pulsar.tests.integration.io.sources.GenericRecordSourceTest" />
-            <class name="org.apache.pulsar.tests.integration.io.sources.PulsarSourcePropertyTest"/>
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Function Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-function-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.functions.PulsarMetadataStateStoreTest" />
+            <class name="org.apache.pulsar.tests.integration.functions.PulsarBKStateStoreTest" />
+            <class name="org.apache.pulsar.tests.integration.io.PulsarGenericObjectSinkTest"/>
+            <class name="org.apache.pulsar.tests.integration.io.sources.GenericRecordSourceTest" />
+            <class name="org.apache.pulsar.tests.integration.io.sources.PulsarSourcePropertyTest"/>
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-io-ora-source.xml b/tests/integration/src/test/resources/pulsar-io-ora-source.xml
index 1c5bb5faf6..7749a32779 100644
--- a/tests/integration/src/test/resources/pulsar-io-ora-source.xml
+++ b/tests/integration/src/test/resources/pulsar-io-ora-source.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar IO Oracle Source Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-function-process-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.io.sources.debezium.PulsarDebeziumOracleSourceTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar IO Oracle Source Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-function-process-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.io.sources.debezium.PulsarDebeziumOracleSourceTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-io-sinks.xml b/tests/integration/src/test/resources/pulsar-io-sinks.xml
index 614c371f3e..6aa2501873 100644
--- a/tests/integration/src/test/resources/pulsar-io-sinks.xml
+++ b/tests/integration/src/test/resources/pulsar-io-sinks.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar IO Sinks Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-function-process-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.io.sinks.PulsarSinksTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar IO Sinks Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-function-process-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.io.sinks.PulsarSinksTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-io-sources.xml b/tests/integration/src/test/resources/pulsar-io-sources.xml
index 3d3b150f66..47f37200ed 100644
--- a/tests/integration/src/test/resources/pulsar-io-sources.xml
+++ b/tests/integration/src/test/resources/pulsar-io-sources.xml
@@ -1,31 +1,31 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar IO Sources Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-function-process-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.io.sources.debezium.PulsarDebeziumSourcesTest" />
-            <class name="org.apache.pulsar.tests.integration.io.sources.BatchSourceTest" />
-            <class name="org.apache.pulsar.tests.integration.io.sources.DataGeneratorSourceTest" />
-            <class name="org.apache.pulsar.tests.integration.io.sources.AvroKafkaSourceTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar IO Sources Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-function-process-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.io.sources.debezium.PulsarDebeziumSourcesTest" />
+            <class name="org.apache.pulsar.tests.integration.io.sources.BatchSourceTest" />
+            <class name="org.apache.pulsar.tests.integration.io.sources.DataGeneratorSourceTest" />
+            <class name="org.apache.pulsar.tests.integration.io.sources.AvroKafkaSourceTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-k8s.xml b/tests/integration/src/test/resources/pulsar-k8s.xml
new file mode 100644
index 0000000000..e6a28427ce
--- /dev/null
+++ b/tests/integration/src/test/resources/pulsar-k8s.xml
@@ -0,0 +1,28 @@
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar k8s Integration Tests" verbose="2" annotations="JDK">
+    <test name="k8s-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.functions.k8s.PulsarFunctionsK8STest" />
+        </classes>
+    </test>
+</suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-loadbalance.xml b/tests/integration/src/test/resources/pulsar-loadbalance.xml
index dfc4536e25..edd5dd2019 100644
--- a/tests/integration/src/test/resources/pulsar-loadbalance.xml
+++ b/tests/integration/src/test/resources/pulsar-loadbalance.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar (LoadBalance) Integration Tests" verbose="2" annotations="JDK">
-    <test name="loadbalance-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.loadbalance.ExtensibleLoadManagerTest"/>
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar (LoadBalance) Integration Tests" verbose="2" annotations="JDK">
+    <test name="loadbalance-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.loadbalance.ExtensibleLoadManagerTest"/>
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-messaging.xml b/tests/integration/src/test/resources/pulsar-messaging.xml
index a34670267d..e41ccc199e 100644
--- a/tests/integration/src/test/resources/pulsar-messaging.xml
+++ b/tests/integration/src/test/resources/pulsar-messaging.xml
@@ -1,37 +1,37 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar (Messaging) Integration Tests" verbose="2" annotations="JDK">
-    <test name="messaging-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.messaging.PersistentTopicMessagingTest" />
-            <class name="org.apache.pulsar.tests.integration.messaging.NonPersistentTopicMessagingTest" />
-            <class name="org.apache.pulsar.tests.integration.messaging.GeoReplicationTest" />
-            <class name="org.apache.pulsar.tests.integration.messaging.DelayMessagingTest" />
-            <class name="org.apache.pulsar.tests.integration.messaging.ReaderMessagingTest" />
-            <class name="org.apache.pulsar.tests.integration.messaging.NonDurableConsumerMessagingTest" />
-            <class name="org.apache.pulsar.tests.integration.messaging.MessagingSmokeTest" />
-            <class name="org.apache.pulsar.tests.integration.admin.AdminTest" />
-
-            <class name="org.apache.pulsar.tests.integration.oxia.OxiaSmokeTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar (Messaging) Integration Tests" verbose="2" annotations="JDK">
+    <test name="messaging-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.messaging.PersistentTopicMessagingTest" />
+            <class name="org.apache.pulsar.tests.integration.messaging.NonPersistentTopicMessagingTest" />
+            <class name="org.apache.pulsar.tests.integration.messaging.GeoReplicationTest" />
+            <class name="org.apache.pulsar.tests.integration.messaging.DelayMessagingTest" />
+            <class name="org.apache.pulsar.tests.integration.messaging.ReaderMessagingTest" />
+            <class name="org.apache.pulsar.tests.integration.messaging.NonDurableConsumerMessagingTest" />
+            <class name="org.apache.pulsar.tests.integration.messaging.MessagingSmokeTest" />
+            <class name="org.apache.pulsar.tests.integration.admin.AdminTest" />
+
+            <class name="org.apache.pulsar.tests.integration.oxia.OxiaSmokeTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-metrics.xml b/tests/integration/src/test/resources/pulsar-metrics.xml
index 1c87f2bdf0..0464217ba7 100644
--- a/tests/integration/src/test/resources/pulsar-metrics.xml
+++ b/tests/integration/src/test/resources/pulsar-metrics.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Metrics Integration Tests" verbose="2" annotations="JDK">
-  <test name="metrics-test-suite" preserve-order="true">
-    <classes>
-      <class name="org.apache.pulsar.tests.integration.metrics.OpenTelemetrySanityTest"/>
-    </classes>
-  </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Metrics Integration Tests" verbose="2" annotations="JDK">
+  <test name="metrics-test-suite" preserve-order="true">
+    <classes>
+      <class name="org.apache.pulsar.tests.integration.metrics.OpenTelemetrySanityTest"/>
+    </classes>
+  </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-plugin.xml b/tests/integration/src/test/resources/pulsar-plugin.xml
index f88b67256e..64bc0eab33 100644
--- a/tests/integration/src/test/resources/pulsar-plugin.xml
+++ b/tests/integration/src/test/resources/pulsar-plugin.xml
@@ -1,31 +1,31 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Plugin Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-plugin-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.plugins.TestProtocolHandlers" />
-            <class name="org.apache.pulsar.tests.integration.plugins.TestAdditionalServlets" />
-            <class name="org.apache.pulsar.tests.integration.plugins.TestBrokerInterceptors" />
-            <class name="org.apache.pulsar.tests.integration.plugins.TestEntryFilters" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Plugin Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-plugin-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.plugins.TestProtocolHandlers" />
+            <class name="org.apache.pulsar.tests.integration.plugins.TestAdditionalServlets" />
+            <class name="org.apache.pulsar.tests.integration.plugins.TestBrokerInterceptors" />
+            <class name="org.apache.pulsar.tests.integration.plugins.TestEntryFilters" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-process.xml b/tests/integration/src/test/resources/pulsar-process.xml
index 8e5258d306..3d67b6aa2a 100644
--- a/tests/integration/src/test/resources/pulsar-process.xml
+++ b/tests/integration/src/test/resources/pulsar-process.xml
@@ -1,32 +1,32 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Function Process Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-function-process-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.functions.go.PulsarFunctionsGoProcessTest" />
-            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarFunctionsJavaProcessTest"/>
-            <class name="org.apache.pulsar.tests.integration.functions.python.PulsarFunctionsPythonProcessTest" />
-
-            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarWorkerRebalanceDrainProcessTest"/>
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Function Process Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-function-process-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.functions.go.PulsarFunctionsGoProcessTest" />
+            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarFunctionsJavaProcessTest"/>
+            <class name="org.apache.pulsar.tests.integration.functions.python.PulsarFunctionsPythonProcessTest" />
+
+            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarWorkerRebalanceDrainProcessTest"/>
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-proxy.xml b/tests/integration/src/test/resources/pulsar-proxy.xml
index ae6f138105..2874ae1b00 100644
--- a/tests/integration/src/test/resources/pulsar-proxy.xml
+++ b/tests/integration/src/test/resources/pulsar-proxy.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar (Proxy) Integration Tests" verbose="2" annotations="JDK">
-    <test name="messaging-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.proxy.TestProxy" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar (Proxy) Integration Tests" verbose="2" annotations="JDK">
+    <test name="messaging-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.proxy.TestProxy" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-python.xml b/tests/integration/src/test/resources/pulsar-python.xml
index a5faa6389e..effd010beb 100644
--- a/tests/integration/src/test/resources/pulsar-python.xml
+++ b/tests/integration/src/test/resources/pulsar-python.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Python Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-python-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.python.PythonSchemaTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Python Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-python-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.python.PythonSchemaTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-schema.xml b/tests/integration/src/test/resources/pulsar-schema.xml
index e07fdf2b2d..60eef163ed 100644
--- a/tests/integration/src/test/resources/pulsar-schema.xml
+++ b/tests/integration/src/test/resources/pulsar-schema.xml
@@ -1,30 +1,30 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Schema Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-schema-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.schema.SchemaTest" />
-            <class name="org.apache.pulsar.tests.integration.schema.JodaTimeTest" />
-            <class name="org.apache.pulsar.tests.integration.python.PythonSchemaTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Schema Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-schema-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.schema.SchemaTest" />
+            <class name="org.apache.pulsar.tests.integration.schema.JodaTimeTest" />
+            <class name="org.apache.pulsar.tests.integration.python.PythonSchemaTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-semantics.xml b/tests/integration/src/test/resources/pulsar-semantics.xml
index 5b5402af46..c5da022582 100644
--- a/tests/integration/src/test/resources/pulsar-semantics.xml
+++ b/tests/integration/src/test/resources/pulsar-semantics.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Semantics Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-semantics-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.semantics.SemanticsTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Semantics Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-semantics-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.semantics.SemanticsTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-standalone.xml b/tests/integration/src/test/resources/pulsar-standalone.xml
index d8892c0746..12be0a6c45 100644
--- a/tests/integration/src/test/resources/pulsar-standalone.xml
+++ b/tests/integration/src/test/resources/pulsar-standalone.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-standalone-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.standalone.SmokeTest" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Standalone Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-standalone-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.standalone.SmokeTest" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-thread.xml b/tests/integration/src/test/resources/pulsar-thread.xml
index cf3da15e8e..0ff2760392 100644
--- a/tests/integration/src/test/resources/pulsar-thread.xml
+++ b/tests/integration/src/test/resources/pulsar-thread.xml
@@ -1,32 +1,32 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar (Thread Function Worker) Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-thread-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.functions.go.PulsarFunctionsGoThreadTest" />
-            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarFunctionsJavaThreadTest" />
-            <class name="org.apache.pulsar.tests.integration.functions.python.PulsarFunctionsPythonThreadTest" />
-
-            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarWorkerRebalanceDrainThreadTest"/>
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar (Thread Function Worker) Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-thread-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.functions.go.PulsarFunctionsGoThreadTest" />
+            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarFunctionsJavaThreadTest" />
+            <class name="org.apache.pulsar.tests.integration.functions.python.PulsarFunctionsPythonThreadTest" />
+
+            <class name="org.apache.pulsar.tests.integration.functions.java.PulsarWorkerRebalanceDrainThreadTest"/>
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar-tls.xml b/tests/integration/src/test/resources/pulsar-tls.xml
index 153d14b62a..ec580c3be6 100644
--- a/tests/integration/src/test/resources/pulsar-tls.xml
+++ b/tests/integration/src/test/resources/pulsar-tls.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar TLS Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-tls" preserve-order="true">
-        <packages>
-            <package name="org.apache.pulsar.tests.integration.tls"/>
-        </packages>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar TLS Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-tls" preserve-order="true">
+        <packages>
+            <package name="org.apache.pulsar.tests.integration.tls"/>
+        </packages>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-transaction.xml b/tests/integration/src/test/resources/pulsar-transaction.xml
index 72c375d000..18e2875e51 100644
--- a/tests/integration/src/test/resources/pulsar-transaction.xml
+++ b/tests/integration/src/test/resources/pulsar-transaction.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Transaction Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-transaction-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.transaction.TransactionTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Transaction Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-transaction-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.transaction.TransactionTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-upgrade.xml b/tests/integration/src/test/resources/pulsar-upgrade.xml
index dc966b160b..f4763b340f 100644
--- a/tests/integration/src/test/resources/pulsar-upgrade.xml
+++ b/tests/integration/src/test/resources/pulsar-upgrade.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Upgrade Integration Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-upgrade-test-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.upgrade.PulsarUpgradeDowngradeTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Upgrade Integration Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-upgrade-test-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.upgrade.PulsarUpgradeDowngradeTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/integration/src/test/resources/pulsar-websocket.xml b/tests/integration/src/test/resources/pulsar-websocket.xml
index 87bf832d4e..24139050ab 100644
--- a/tests/integration/src/test/resources/pulsar-websocket.xml
+++ b/tests/integration/src/test/resources/pulsar-websocket.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="WebSocket Integration Tests" verbose="2" annotations="JDK">
-    <test name="messaging-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.websocket.TestWebSocket" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="WebSocket Integration Tests" verbose="2" annotations="JDK">
+    <test name="messaging-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.websocket.TestWebSocket" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/pulsar.xml b/tests/integration/src/test/resources/pulsar.xml
index aa9a59a6cd..5c45057802 100644
--- a/tests/integration/src/test/resources/pulsar.xml
+++ b/tests/integration/src/test/resources/pulsar.xml
@@ -1,42 +1,42 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Test Suite" parallel="instances" thread-count="1">
-    <suite-files>
-        <suite-file path="./pulsar-cli.xml" />
-        <suite-file path="./pulsar-schema.xml" />
-        <suite-file path="./pulsar-process.xml" />
-        <suite-file path="./pulsar-thread.xml" />
-        <suite-file path="./tiered-jcloud-storage.xml" />
-        <suite-file path="./tiered-filesystem-storage.xml"/>
-        <suite-file path="./pulsar-function.xml" />
-        <suite-file path="./pulsar-messaging.xml" />
-        <suite-file path="./pulsar-loadbalance.xml" />
-        <suite-file path="./pulsar-backwards-compatibility.xml" />
-        <suite-file path="./pulsar-io-sinks.xml" />
-        <suite-file path="./pulsar-io-sources.xml" />
-        <suite-file path="./pulsar-io-ora-source.xml" />
-        <suite-file path="./pulsar-python.xml" />
-        <suite-file path="./pulsar-semantics.xml" />
-        <suite-file path="./pulsar-upgrade.xml" />
-        <suite-file path="./pulsar-metrics.xml" />
-    </suite-files>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Test Suite" parallel="instances" thread-count="1">
+    <suite-files>
+        <suite-file path="./pulsar-cli.xml" />
+        <suite-file path="./pulsar-schema.xml" />
+        <suite-file path="./pulsar-process.xml" />
+        <suite-file path="./pulsar-thread.xml" />
+        <suite-file path="./tiered-jcloud-storage.xml" />
+        <suite-file path="./tiered-filesystem-storage.xml"/>
+        <suite-file path="./pulsar-function.xml" />
+        <suite-file path="./pulsar-messaging.xml" />
+        <suite-file path="./pulsar-loadbalance.xml" />
+        <suite-file path="./pulsar-backwards-compatibility.xml" />
+        <suite-file path="./pulsar-io-sinks.xml" />
+        <suite-file path="./pulsar-io-sources.xml" />
+        <suite-file path="./pulsar-io-ora-source.xml" />
+        <suite-file path="./pulsar-python.xml" />
+        <suite-file path="./pulsar-semantics.xml" />
+        <suite-file path="./pulsar-upgrade.xml" />
+        <suite-file path="./pulsar-metrics.xml" />
+    </suite-files>
+</suite>
diff --git a/tests/integration/src/test/resources/tiered-filesystem-storage.xml b/tests/integration/src/test/resources/tiered-filesystem-storage.xml
index b14077594e..348d6123cc 100644
--- a/tests/integration/src/test/resources/tiered-filesystem-storage.xml
+++ b/tests/integration/src/test/resources/tiered-filesystem-storage.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar (Filesystem Tiered Storage) Integration Tests" verbose="2" annotations="JDK">
-    <test name="tiered-storage-filesystem-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.offload.TestFileSystemOffload" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar (Filesystem Tiered Storage) Integration Tests" verbose="2" annotations="JDK">
+    <test name="tiered-storage-filesystem-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.offload.TestFileSystemOffload" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/integration/src/test/resources/tiered-jcloud-storage.xml b/tests/integration/src/test/resources/tiered-jcloud-storage.xml
index f61f9f5fa1..348c5541bb 100644
--- a/tests/integration/src/test/resources/tiered-jcloud-storage.xml
+++ b/tests/integration/src/test/resources/tiered-jcloud-storage.xml
@@ -1,28 +1,28 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar (Jcloud Tiered Storage) Integration Tests" verbose="2" annotations="JDK">
-    <test name="tiered-storage-jcloud-test-suite" preserve-order="true">
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.offload.TestS3Offload" />
-        </classes>
-    </test>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar (Jcloud Tiered Storage) Integration Tests" verbose="2" annotations="JDK">
+    <test name="tiered-storage-jcloud-test-suite" preserve-order="true">
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.offload.TestS3Offload" />
+        </classes>
+    </test>
 </suite>
\ No newline at end of file
diff --git a/tests/pom.xml b/tests/pom.xml
index 2249c0f9bc..02ed015f14 100644
--- a/tests/pom.xml
+++ b/tests/pom.xml
@@ -1,115 +1,115 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-  <packaging>pom</packaging>
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.apache.pulsar</groupId>
-    <artifactId>pulsar</artifactId>
-    <version>4.1.2</version>
-  </parent>
-  <groupId>org.apache.pulsar.tests</groupId>
-  <artifactId>tests-parent</artifactId>
-  <name>Apache Pulsar :: Tests</name>
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <profiles>
-    <profile>
-      <id>skipIntegrationTests</id>
-      <activation>
-        <property>
-          <name>skipIntegrationTests</name>
-        </property>
-      </activation>
-      <modules />
-    </profile>
-    <profile>
-      <id>integrationTests</id>
-      <activation>
-        <property>
-          <name>integrationTests</name>
-        </property>
-      </activation>
-      <modules>
-        <module>integration</module>
-      </modules>
-    </profile>
-    <profile>
-      <id>ShadeTests</id>
-      <activation>
-        <property>
-          <name>ShadeTests</name>
-        </property>
-      </activation>
-      <modules>
-        <module>pulsar-client-all-shade-test</module>
-        <module>pulsar-client-shade-test</module>
-        <module>pulsar-client-admin-shade-test</module>
-      </modules>
-    </profile>
-    <profile>
-      <id>BackwardsCompatTests</id>
-      <activation>
-        <property>
-          <name>BackwardsCompatTests</name>
-        </property>
-      </activation>
-      <modules>
-        <module>bc_2_0_0</module>
-        <module>bc_2_0_1</module>
-        <module>bc_2_6_0</module>
-      </modules>
-    </profile>
-    <profile>
-      <id>main</id>
-      <activation>
-        <activeByDefault>true</activeByDefault>
-      </activation>
-      <modules>
-        <module>docker-images</module>
-        <module>integration</module>
-        <module>bc_2_0_0</module>
-        <module>bc_2_0_1</module>
-        <module>bc_2_6_0</module>
-        <module>pulsar-client-all-shade-test</module>
-        <module>pulsar-client-shade-test</module>
-        <module>pulsar-client-admin-shade-test</module>
-      </modules>
-    </profile>
-    <profile>
-      <id>docker</id>
-      <modules>
-        <module>docker-images</module>
-      </modules>
-    </profile>
-  </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+  <packaging>pom</packaging>
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.pulsar</groupId>
+    <artifactId>pulsar</artifactId>
+    <version>4.1.2</version>
+  </parent>
+  <groupId>org.apache.pulsar.tests</groupId>
+  <artifactId>tests-parent</artifactId>
+  <name>Apache Pulsar :: Tests</name>
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <profiles>
+    <profile>
+      <id>skipIntegrationTests</id>
+      <activation>
+        <property>
+          <name>skipIntegrationTests</name>
+        </property>
+      </activation>
+      <modules />
+    </profile>
+    <profile>
+      <id>integrationTests</id>
+      <activation>
+        <property>
+          <name>integrationTests</name>
+        </property>
+      </activation>
+      <modules>
+        <module>integration</module>
+      </modules>
+    </profile>
+    <profile>
+      <id>ShadeTests</id>
+      <activation>
+        <property>
+          <name>ShadeTests</name>
+        </property>
+      </activation>
+      <modules>
+        <module>pulsar-client-all-shade-test</module>
+        <module>pulsar-client-shade-test</module>
+        <module>pulsar-client-admin-shade-test</module>
+      </modules>
+    </profile>
+    <profile>
+      <id>BackwardsCompatTests</id>
+      <activation>
+        <property>
+          <name>BackwardsCompatTests</name>
+        </property>
+      </activation>
+      <modules>
+        <module>bc_2_0_0</module>
+        <module>bc_2_0_1</module>
+        <module>bc_2_6_0</module>
+      </modules>
+    </profile>
+    <profile>
+      <id>main</id>
+      <activation>
+        <activeByDefault>true</activeByDefault>
+      </activation>
+      <modules>
+        <module>docker-images</module>
+        <module>integration</module>
+        <module>bc_2_0_0</module>
+        <module>bc_2_0_1</module>
+        <module>bc_2_6_0</module>
+        <module>pulsar-client-all-shade-test</module>
+        <module>pulsar-client-shade-test</module>
+        <module>pulsar-client-admin-shade-test</module>
+      </modules>
+    </profile>
+    <profile>
+      <id>docker</id>
+      <modules>
+        <module>docker-images</module>
+      </modules>
+    </profile>
+  </profiles>
+</project>
diff --git a/tests/pulsar-client-admin-shade-test/pom.xml b/tests/pulsar-client-admin-shade-test/pom.xml
index 026056d7e4..56dcb4a311 100644
--- a/tests/pulsar-client-admin-shade-test/pom.xml
+++ b/tests/pulsar-client-admin-shade-test/pom.xml
@@ -1,123 +1,123 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>org.apache.pulsar.tests</groupId>
-        <artifactId>tests-parent</artifactId>
-        <version>4.1.2</version>
-    </parent>
-
-    <artifactId>pulsar-client-admin-shade-test</artifactId>
-    <packaging>jar</packaging>
-    <name>Apache Pulsar :: Tests :: Pulsar-Client-Admin-Shade Test</name>
-
-    <dependencies>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client-admin</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client-admin-api</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.testcontainers</groupId>
-            <artifactId>testcontainers</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client-messagecrypto-bc</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <configuration>
-                    <!-- only run tests when -DShadeTests is specified //-->
-                    <skipTests>true</skipTests>
-                    <systemPropertyVariables>
-                        <currentVersion>${project.version}</currentVersion>
-                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-                    </systemPropertyVariables>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-    <profiles>
-        <profile>
-            <id>ShadeTests</id>
-            <activation>
-                <property>
-                    <name>ShadeTests</name>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
-                                ${test.additional.args}
-                            </argLine>
-                            <skipTests>false</skipTests>
-                            <suiteXmlFiles>
-                                <file>src/test/resources/pulsar.xml</file>
-                            </suiteXmlFiles>
-                            <forkCount>1</forkCount>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.pulsar.tests</groupId>
+        <artifactId>tests-parent</artifactId>
+        <version>4.1.2</version>
+    </parent>
+
+    <artifactId>pulsar-client-admin-shade-test</artifactId>
+    <packaging>jar</packaging>
+    <name>Apache Pulsar :: Tests :: Pulsar-Client-Admin-Shade Test</name>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client-admin</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client-admin-api</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client-messagecrypto-bc</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>test-jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <!-- only run tests when -DShadeTests is specified //-->
+                    <skipTests>true</skipTests>
+                    <systemPropertyVariables>
+                        <currentVersion>${project.version}</currentVersion>
+                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+                    </systemPropertyVariables>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>
+        <profile>
+            <id>ShadeTests</id>
+            <activation>
+                <property>
+                    <name>ShadeTests</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
+                                ${test.additional.args}
+                            </argLine>
+                            <skipTests>false</skipTests>
+                            <suiteXmlFiles>
+                                <file>src/test/resources/pulsar.xml</file>
+                            </suiteXmlFiles>
+                            <forkCount>1</forkCount>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+</project>
diff --git a/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java b/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
index 365b4cca81..3a849a3ad1 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
+++ b/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-public class PulsarContainer extends GenericContainer<PulsarContainer> {
-
-    public static final int PULSAR_PORT = 6650;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-
-    public PulsarContainer() {
-        this(DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(final String pulsarVersion) {
-        super(pulsarVersion);
-        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
-        withCommand("/pulsar/bin/pulsar standalone");
-        waitingFor(new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS)));
-    }
-
-    public String getPlainTextPulsarBrokerUrl() {
-        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
-    }
-
-    public String getPulsarAdminUrl() {
-        return String.format("http://%s:%s", this.getHost(), this.getMappedPort(BROKER_HTTP_PORT));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+public class PulsarContainer extends GenericContainer<PulsarContainer> {
+
+    public static final int PULSAR_PORT = 6650;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+
+    public PulsarContainer() {
+        this(DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(final String pulsarVersion) {
+        super(pulsarVersion);
+        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
+        withCommand("/pulsar/bin/pulsar standalone");
+        waitingFor(new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS)));
+    }
+
+    public String getPlainTextPulsarBrokerUrl() {
+        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
+    }
+
+    public String getPulsarAdminUrl() {
+        return String.format("http://%s:%s", this.getHost(), this.getMappedPort(BROKER_HTTP_PORT));
+    }
+
+}
diff --git a/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java b/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
index 73b0d63f50..a3662e9c3b 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
+++ b/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
@@ -1,609 +1,609 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import java.io.IOException;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.security.Security;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.CompressionType;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.ConsumerCryptoFailureAction;
-import org.apache.pulsar.client.api.CryptoKeyReader;
-import org.apache.pulsar.client.api.EncryptionKeyInfo;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageRoutingMode;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.impl.MessageImpl;
-import org.apache.pulsar.client.impl.TopicMessageImpl;
-import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;
-import org.apache.pulsar.common.api.EncryptionContext;
-import org.apache.pulsar.common.api.proto.MessageMetadata;
-import org.apache.pulsar.common.api.proto.SingleMessageMetadata;
-import org.apache.pulsar.common.compression.CompressionCodec;
-import org.apache.pulsar.common.compression.CompressionCodecProvider;
-import org.apache.pulsar.common.policies.data.TenantInfoImpl;
-import org.apache.pulsar.common.protocol.Commands;
-import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;
-import org.apache.pulsar.shade.io.netty.buffer.Unpooled;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SimpleProducerConsumerTest extends TestRetrySupport {
-    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);
-
-    private PulsarContainer pulsarContainer;
-    private URI lookupUrl;
-    private PulsarClient pulsarClient;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public void setup() throws Exception {
-        incrementSetupNumber();
-        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
-
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-        pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
-        admin.tenants().createTenant("my-property", new TenantInfoImpl(
-                new HashSet<>(Arrays.asList("appid1", "appid2")), Collections.singleton("standalone")));
-        admin.namespaces().createNamespace("my-property/my-ns");
-        admin.namespaces().setNamespaceReplicationClusters("my-property/my-ns", Collections.singleton("standalone"));
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public void cleanup() throws Exception {
-        markCurrentSetupNumberCleaned();
-        if (pulsarClient != null) {
-            pulsarClient.close();
-            pulsarClient = null;
-        }
-        if (pulsarContainer != null) {
-            pulsarContainer.stop();
-            pulsarContainer.close();
-            pulsarContainer = null;
-        }
-    }
-
-    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {
-        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();
-    }
-
-    @Test
-    public void testRSAEncryption() throws Exception {
-
-        String topicName = "persistent://my-property/my-ns/myrsa-topic1-" + System.currentTimeMillis();
-
-        class EncKeyReader implements CryptoKeyReader {
-
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        final int totalMsg = 10;
-
-        Set<String> messageSet = new HashSet<>();
-        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader()).subscribe();
-        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()
-                .topic(topicName).subscriptionName("my-subscriber-name-normal")
-                .subscribe();
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-        Producer<byte[]> producer2 = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-
-        for (int i = 0; i < totalMsg; i++) {
-            String message = "my-message-" + i;
-            producer.send(message.getBytes());
-        }
-        for (int i = totalMsg; i < totalMsg * 2; i++) {
-            String message = "my-message-" + i;
-            producer2.send(message.getBytes());
-        }
-
-        MessageImpl<byte[]> msg = null;
-
-        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);
-        // should not able to read message using normal message.
-        assertNull(msg);
-
-        for (int i = 0; i < totalMsg * 2; i++) {
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            // verify that encrypted message contains encryption-context
-            msg.getEncryptionCtx()
-                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-            String receivedMessage = new String(msg.getData());
-            log.debug("Received message: [{}]", receivedMessage);
-            String expectedMessage = "my-message-" + i;
-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
-        }
-        // Acknowledge the consumption of all messages at once
-        consumer.acknowledgeCumulative(msg);
-        consumer.close();
-    }
-
-    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,
-                                                     T expectedMessage) {
-        // Make sure that messages are received in order
-        assertEquals(receivedMessage, expectedMessage,
-                "Received message " + receivedMessage + " did not match the expected message " + expectedMessage);
-
-        // Make sure that there are no duplicates
-        assertTrue(messagesReceived.add(receivedMessage), "Received duplicate message " + receivedMessage);
-    }
-
-    @Test
-    public void testRedeliveryOfFailedMessages() throws Exception {
-
-        @Cleanup
-        PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String encryptionKeyName = "client-rsa.pem";
-        final String encryptionKeyVersion = "1.0";
-        Map<String, String> metadata = new HashMap<>();
-        metadata.put("version", encryptionKeyVersion);
-        class EncKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        class InvalidKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {
-                return null;
-            }
-        }
-
-        /*
-         * Redelivery functionality guarantees that customer will get a chance to process the message again.
-         * In case of shared subscription eventually every client will get a chance to process the message,
-         * till one of them acks it.
-         *
-         * For client with Encryption enabled where in cases like a new production rollout or a buggy client
-         * configuration, we might have a mismatch of consumers
-         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).
-         *
-         * In that case eventually all messages should be acked as long as there is a single consumer
-         * who can decrypt the message.
-         *
-         * Consumer 1 - Can decrypt message
-         * Consumer 2 - Has invalid Reader configured.
-         * Consumer 3 - Has no reader configured.
-         *
-         */
-
-        String topicName = "persistent://my-property/my-ns/myrsa-topic2";
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
-                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
-                .cryptoKeyReader(new EncKeyReader()).create();
-
-        @Cleanup
-        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader())
-                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        @Cleanup
-        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new InvalidKeyReader())
-                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        @Cleanup
-        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").subscriptionType(SubscriptionType.Shared)
-                .ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        int numberOfMessages = 100;
-        String message = "my-message";
-        Set<String> messages = new HashSet<>(); // Since messages are in random order
-        for (int i = 0; i < numberOfMessages; i++) {
-            producer.send((message + i).getBytes());
-        }
-
-        // Consuming from consumer 2 and 3
-        // no message should be returned since they can't decrypt the message
-        Message<byte[]> m = consumer2.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-        m = consumer3.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-
-        for (int i = 0; i < numberOfMessages; i++) {
-            // All messages would be received by consumer 1
-            m = consumer1.receive();
-            messages.add(new String(m.getData()));
-            consumer1.acknowledge(m);
-        }
-
-        // Consuming from consumer 2 and 3 again just to be sure
-        // no message should be returned since they can't decrypt the message
-        m = consumer2.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-        m = consumer3.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-
-        // checking if all messages were received
-        for (int i = 0; i < numberOfMessages; i++) {
-            assertTrue(messages.contains((message + i)));
-        }
-
-        consumer1.close();
-        consumer2.close();
-        consumer3.close();
-        newPulsarClient.close();
-        newPulsarClient1.close();
-        newPulsarClient2.close();
-    }
-
-    @Test
-    public void testEncryptionFailure() throws Exception {
-
-        class EncKeyReader implements CryptoKeyReader {
-
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        log.error("Failed to read certificate from {}", certFilePath);
-                    }
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        log.error("Failed to read certificate from {}", certFilePath);
-                    }
-                }
-                return null;
-            }
-        }
-
-        final int totalMsg = 10;
-
-        MessageImpl<byte[]> msg = null;
-        Set<String> messageSet = new HashSet<>();
-        Consumer<byte[]> consumer = pulsarClient.newConsumer()
-                .topic("persistent://my-property/use/myenc-ns/myenc-topic1").subscriptionName("my-subscriber-name")
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        // 1. Invalid key name
-        try {
-            pulsarClient.newProducer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                    .addEncryptionKey("client-non-existant-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-            Assert.fail("Producer creation should not suceed if failing to read key");
-        } catch (Exception e) {
-            // ok
-        }
-
-        // 2. Producer with valid key name
-        Producer<byte[]> producer = pulsarClient.newProducer()
-                .topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .addEncryptionKey("client-rsa.pem")
-                .cryptoKeyReader(new EncKeyReader())
-                .enableBatching(false)
-                .messageRoutingMode(MessageRoutingMode.SinglePartition)
-                .create();
-
-        for (int i = 0; i < totalMsg; i++) {
-            String message = "my-message-" + i;
-            producer.send(message.getBytes());
-        }
-
-        // 3. KeyReder is not set by consumer
-        // Receive should fail since key reader is not setup
-        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-        assertNull(msg, "Receive should have failed with no keyreader");
-
-        // 4. Set consumer config to consume even if decryption fails
-        consumer.close();
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        int msgNum = 0;
-        try {
-            // Receive should proceed and deliver encrypted message
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            String receivedMessage = new String(msg.getData());
-            String expectedMessage = "my-message-" + msgNum++;
-            Assert.assertNotEquals(receivedMessage, expectedMessage, "Received encrypted message " + receivedMessage
-                    + " should not match the expected message " + expectedMessage);
-            consumer.acknowledgeCumulative(msg);
-        } catch (Exception e) {
-            e.printStackTrace();
-            Assert.fail("Failed to receive message even after ConsumerCryptoFailureAction.CONSUME is set.");
-        }
-
-        // 5. Set keyreader and failure action
-        consumer.close();
-        // Set keyreader
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.FAIL)
-                .cryptoKeyReader(new EncKeyReader()).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        for (int i = msgNum; i < totalMsg - 1; i++) {
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            // verify that encrypted message contains encryption-context
-            msg.getEncryptionCtx()
-                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-            String receivedMessage = new String(msg.getData());
-            log.debug("Received message: [{}]", receivedMessage);
-            String expectedMessage = "my-message-" + i;
-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
-        }
-        // Acknowledge the consumption of all messages at once
-        consumer.acknowledgeCumulative(msg);
-        consumer.close();
-
-        // 6. Set consumer config to discard if decryption fails
-        consumer.close();
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.DISCARD)
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        // Receive should proceed and discard encrypted messages
-        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-        assertNull(msg, "Message received even aftet ConsumerCryptoFailureAction.DISCARD is set.");
-    }
-
-    @Test
-    public void testEncryptionConsumerWithoutCryptoReader() throws Exception {
-
-        final String encryptionKeyName = "client-rsa.pem";
-        final String encryptionKeyVersion = "1.0";
-        Map<String, String> metadata = new HashMap<>();
-        metadata.put("version", encryptionKeyVersion);
-        class EncKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic3")
-                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
-                .cryptoKeyReader(new EncKeyReader()).create();
-
-        Consumer<byte[]> consumer =
-                pulsarClient.newConsumer().topicsPattern("persistent://my-property/my-ns/myrsa-topic3")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
-                .subscribe();
-
-        String message = "my-message";
-        producer.send(message.getBytes());
-
-        TopicMessageImpl<byte[]> msg = (TopicMessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-
-        String receivedMessage = decryptMessage(msg, encryptionKeyName, new EncKeyReader());
-        assertEquals(message, receivedMessage);
-
-        consumer.close();
-    }
-
-    private String decryptMessage(TopicMessageImpl<byte[]> msg, String encryptionKeyName, CryptoKeyReader reader)
-            throws Exception {
-        Optional<EncryptionContext> ctx = msg.getEncryptionCtx();
-        assertTrue(ctx.isPresent());
-        EncryptionContext encryptionCtx = ctx
-                .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-
-        Map<String, EncryptionContext.EncryptionKey> keys = encryptionCtx.getKeys();
-        assertEquals(keys.size(), 1);
-        EncryptionContext.EncryptionKey encryptionKey = keys.get(encryptionKeyName);
-        byte[] dataKey = encryptionKey.getKeyValue();
-        Map<String, String> metadata = encryptionKey.getMetadata();
-        String version = metadata.get("version");
-        assertEquals(version, "1.0");
-
-        CompressionType compressionType = encryptionCtx.getCompressionType();
-        int uncompressedSize = encryptionCtx.getUncompressedMessageSize();
-        byte[] encrParam = encryptionCtx.getParam();
-        String encAlgo = encryptionCtx.getAlgorithm();
-        int batchSize = encryptionCtx.getBatchSize().orElse(0);
-
-        ByteBuffer payloadBuf = ByteBuffer.wrap(msg.getData());
-        // try to decrypt use default MessageCryptoBc
-        MessageCryptoBc crypto = new MessageCryptoBc("test", false);
-        MessageMetadata msgMetadata = new MessageMetadata()
-                .setEncryptionParam(encrParam)
-                .setProducerName("test")
-                .setSequenceId(123)
-                .setPublishTime(12333453454L)
-                .setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType))
-                .setUncompressedSize(uncompressedSize);
-
-        if (encAlgo != null) {
-            msgMetadata.setEncryptionAlgo(encAlgo);
-        }
-
-        msgMetadata.addEncryptionKey()
-                .setKey(encryptionKeyName)
-                .setValue(dataKey);
-
-        ByteBuffer decryptedPayload = ByteBuffer.allocate(crypto.getMaxOutputSize(payloadBuf.remaining()));
-        crypto.decrypt(() -> msgMetadata, payloadBuf, decryptedPayload, reader);
-
-        // try to uncompress
-        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);
-        ByteBuf uncompressedPayload = codec.decode(Unpooled.wrappedBuffer(decryptedPayload), uncompressedSize);
-
-        if (batchSize > 0) {
-            SingleMessageMetadata singleMessageMetadata = new SingleMessageMetadata();
-            uncompressedPayload = Commands.deSerializeSingleMessageInBatch(uncompressedPayload,
-                    singleMessageMetadata, 0, batchSize);
-        }
-
-        byte[] data = new byte[uncompressedPayload.readableBytes()];
-        uncompressedPayload.readBytes(data);
-        uncompressedPayload.release();
-        return new String(data);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import java.io.IOException;
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.CompressionType;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerCryptoFailureAction;
+import org.apache.pulsar.client.api.CryptoKeyReader;
+import org.apache.pulsar.client.api.EncryptionKeyInfo;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageRoutingMode;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.impl.MessageImpl;
+import org.apache.pulsar.client.impl.TopicMessageImpl;
+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;
+import org.apache.pulsar.common.api.EncryptionContext;
+import org.apache.pulsar.common.api.proto.MessageMetadata;
+import org.apache.pulsar.common.api.proto.SingleMessageMetadata;
+import org.apache.pulsar.common.compression.CompressionCodec;
+import org.apache.pulsar.common.compression.CompressionCodecProvider;
+import org.apache.pulsar.common.policies.data.TenantInfoImpl;
+import org.apache.pulsar.common.protocol.Commands;
+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;
+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SimpleProducerConsumerTest extends TestRetrySupport {
+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);
+
+    private PulsarContainer pulsarContainer;
+    private URI lookupUrl;
+    private PulsarClient pulsarClient;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public void setup() throws Exception {
+        incrementSetupNumber();
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+        pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
+        admin.tenants().createTenant("my-property", new TenantInfoImpl(
+                new HashSet<>(Arrays.asList("appid1", "appid2")), Collections.singleton("standalone")));
+        admin.namespaces().createNamespace("my-property/my-ns");
+        admin.namespaces().setNamespaceReplicationClusters("my-property/my-ns", Collections.singleton("standalone"));
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public void cleanup() throws Exception {
+        markCurrentSetupNumberCleaned();
+        if (pulsarClient != null) {
+            pulsarClient.close();
+            pulsarClient = null;
+        }
+        if (pulsarContainer != null) {
+            pulsarContainer.stop();
+            pulsarContainer.close();
+            pulsarContainer = null;
+        }
+    }
+
+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {
+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();
+    }
+
+    @Test
+    public void testRSAEncryption() throws Exception {
+
+        String topicName = "persistent://my-property/my-ns/myrsa-topic1-" + System.currentTimeMillis();
+
+        class EncKeyReader implements CryptoKeyReader {
+
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        final int totalMsg = 10;
+
+        Set<String> messageSet = new HashSet<>();
+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader()).subscribe();
+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()
+                .topic(topicName).subscriptionName("my-subscriber-name-normal")
+                .subscribe();
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+
+        for (int i = 0; i < totalMsg; i++) {
+            String message = "my-message-" + i;
+            producer.send(message.getBytes());
+        }
+        for (int i = totalMsg; i < totalMsg * 2; i++) {
+            String message = "my-message-" + i;
+            producer2.send(message.getBytes());
+        }
+
+        MessageImpl<byte[]> msg = null;
+
+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);
+        // should not able to read message using normal message.
+        assertNull(msg);
+
+        for (int i = 0; i < totalMsg * 2; i++) {
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            // verify that encrypted message contains encryption-context
+            msg.getEncryptionCtx()
+                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+            String receivedMessage = new String(msg.getData());
+            log.debug("Received message: [{}]", receivedMessage);
+            String expectedMessage = "my-message-" + i;
+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
+        }
+        // Acknowledge the consumption of all messages at once
+        consumer.acknowledgeCumulative(msg);
+        consumer.close();
+    }
+
+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,
+                                                     T expectedMessage) {
+        // Make sure that messages are received in order
+        assertEquals(receivedMessage, expectedMessage,
+                "Received message " + receivedMessage + " did not match the expected message " + expectedMessage);
+
+        // Make sure that there are no duplicates
+        assertTrue(messagesReceived.add(receivedMessage), "Received duplicate message " + receivedMessage);
+    }
+
+    @Test
+    public void testRedeliveryOfFailedMessages() throws Exception {
+
+        @Cleanup
+        PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String encryptionKeyName = "client-rsa.pem";
+        final String encryptionKeyVersion = "1.0";
+        Map<String, String> metadata = new HashMap<>();
+        metadata.put("version", encryptionKeyVersion);
+        class EncKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        class InvalidKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {
+                return null;
+            }
+        }
+
+        /*
+         * Redelivery functionality guarantees that customer will get a chance to process the message again.
+         * In case of shared subscription eventually every client will get a chance to process the message,
+         * till one of them acks it.
+         *
+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client
+         * configuration, we might have a mismatch of consumers
+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).
+         *
+         * In that case eventually all messages should be acked as long as there is a single consumer
+         * who can decrypt the message.
+         *
+         * Consumer 1 - Can decrypt message
+         * Consumer 2 - Has invalid Reader configured.
+         * Consumer 3 - Has no reader configured.
+         *
+         */
+
+        String topicName = "persistent://my-property/my-ns/myrsa-topic2";
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
+                .cryptoKeyReader(new EncKeyReader()).create();
+
+        @Cleanup
+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader())
+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        @Cleanup
+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new InvalidKeyReader())
+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        @Cleanup
+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").subscriptionType(SubscriptionType.Shared)
+                .ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        int numberOfMessages = 100;
+        String message = "my-message";
+        Set<String> messages = new HashSet<>(); // Since messages are in random order
+        for (int i = 0; i < numberOfMessages; i++) {
+            producer.send((message + i).getBytes());
+        }
+
+        // Consuming from consumer 2 and 3
+        // no message should be returned since they can't decrypt the message
+        Message<byte[]> m = consumer2.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+        m = consumer3.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+
+        for (int i = 0; i < numberOfMessages; i++) {
+            // All messages would be received by consumer 1
+            m = consumer1.receive();
+            messages.add(new String(m.getData()));
+            consumer1.acknowledge(m);
+        }
+
+        // Consuming from consumer 2 and 3 again just to be sure
+        // no message should be returned since they can't decrypt the message
+        m = consumer2.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+        m = consumer3.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+
+        // checking if all messages were received
+        for (int i = 0; i < numberOfMessages; i++) {
+            assertTrue(messages.contains((message + i)));
+        }
+
+        consumer1.close();
+        consumer2.close();
+        consumer3.close();
+        newPulsarClient.close();
+        newPulsarClient1.close();
+        newPulsarClient2.close();
+    }
+
+    @Test
+    public void testEncryptionFailure() throws Exception {
+
+        class EncKeyReader implements CryptoKeyReader {
+
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        log.error("Failed to read certificate from {}", certFilePath);
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        log.error("Failed to read certificate from {}", certFilePath);
+                    }
+                }
+                return null;
+            }
+        }
+
+        final int totalMsg = 10;
+
+        MessageImpl<byte[]> msg = null;
+        Set<String> messageSet = new HashSet<>();
+        Consumer<byte[]> consumer = pulsarClient.newConsumer()
+                .topic("persistent://my-property/use/myenc-ns/myenc-topic1").subscriptionName("my-subscriber-name")
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        // 1. Invalid key name
+        try {
+            pulsarClient.newProducer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                    .addEncryptionKey("client-non-existant-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+            Assert.fail("Producer creation should not suceed if failing to read key");
+        } catch (Exception e) {
+            // ok
+        }
+
+        // 2. Producer with valid key name
+        Producer<byte[]> producer = pulsarClient.newProducer()
+                .topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .addEncryptionKey("client-rsa.pem")
+                .cryptoKeyReader(new EncKeyReader())
+                .enableBatching(false)
+                .messageRoutingMode(MessageRoutingMode.SinglePartition)
+                .create();
+
+        for (int i = 0; i < totalMsg; i++) {
+            String message = "my-message-" + i;
+            producer.send(message.getBytes());
+        }
+
+        // 3. KeyReder is not set by consumer
+        // Receive should fail since key reader is not setup
+        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+        assertNull(msg, "Receive should have failed with no keyreader");
+
+        // 4. Set consumer config to consume even if decryption fails
+        consumer.close();
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        int msgNum = 0;
+        try {
+            // Receive should proceed and deliver encrypted message
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            String receivedMessage = new String(msg.getData());
+            String expectedMessage = "my-message-" + msgNum++;
+            Assert.assertNotEquals(receivedMessage, expectedMessage, "Received encrypted message " + receivedMessage
+                    + " should not match the expected message " + expectedMessage);
+            consumer.acknowledgeCumulative(msg);
+        } catch (Exception e) {
+            e.printStackTrace();
+            Assert.fail("Failed to receive message even after ConsumerCryptoFailureAction.CONSUME is set.");
+        }
+
+        // 5. Set keyreader and failure action
+        consumer.close();
+        // Set keyreader
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.FAIL)
+                .cryptoKeyReader(new EncKeyReader()).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        for (int i = msgNum; i < totalMsg - 1; i++) {
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            // verify that encrypted message contains encryption-context
+            msg.getEncryptionCtx()
+                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+            String receivedMessage = new String(msg.getData());
+            log.debug("Received message: [{}]", receivedMessage);
+            String expectedMessage = "my-message-" + i;
+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
+        }
+        // Acknowledge the consumption of all messages at once
+        consumer.acknowledgeCumulative(msg);
+        consumer.close();
+
+        // 6. Set consumer config to discard if decryption fails
+        consumer.close();
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.DISCARD)
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        // Receive should proceed and discard encrypted messages
+        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+        assertNull(msg, "Message received even aftet ConsumerCryptoFailureAction.DISCARD is set.");
+    }
+
+    @Test
+    public void testEncryptionConsumerWithoutCryptoReader() throws Exception {
+
+        final String encryptionKeyName = "client-rsa.pem";
+        final String encryptionKeyVersion = "1.0";
+        Map<String, String> metadata = new HashMap<>();
+        metadata.put("version", encryptionKeyVersion);
+        class EncKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic3")
+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
+                .cryptoKeyReader(new EncKeyReader()).create();
+
+        Consumer<byte[]> consumer =
+                pulsarClient.newConsumer().topicsPattern("persistent://my-property/my-ns/myrsa-topic3")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
+                .subscribe();
+
+        String message = "my-message";
+        producer.send(message.getBytes());
+
+        TopicMessageImpl<byte[]> msg = (TopicMessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+
+        String receivedMessage = decryptMessage(msg, encryptionKeyName, new EncKeyReader());
+        assertEquals(message, receivedMessage);
+
+        consumer.close();
+    }
+
+    private String decryptMessage(TopicMessageImpl<byte[]> msg, String encryptionKeyName, CryptoKeyReader reader)
+            throws Exception {
+        Optional<EncryptionContext> ctx = msg.getEncryptionCtx();
+        assertTrue(ctx.isPresent());
+        EncryptionContext encryptionCtx = ctx
+                .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+
+        Map<String, EncryptionContext.EncryptionKey> keys = encryptionCtx.getKeys();
+        assertEquals(keys.size(), 1);
+        EncryptionContext.EncryptionKey encryptionKey = keys.get(encryptionKeyName);
+        byte[] dataKey = encryptionKey.getKeyValue();
+        Map<String, String> metadata = encryptionKey.getMetadata();
+        String version = metadata.get("version");
+        assertEquals(version, "1.0");
+
+        CompressionType compressionType = encryptionCtx.getCompressionType();
+        int uncompressedSize = encryptionCtx.getUncompressedMessageSize();
+        byte[] encrParam = encryptionCtx.getParam();
+        String encAlgo = encryptionCtx.getAlgorithm();
+        int batchSize = encryptionCtx.getBatchSize().orElse(0);
+
+        ByteBuffer payloadBuf = ByteBuffer.wrap(msg.getData());
+        // try to decrypt use default MessageCryptoBc
+        MessageCryptoBc crypto = new MessageCryptoBc("test", false);
+        MessageMetadata msgMetadata = new MessageMetadata()
+                .setEncryptionParam(encrParam)
+                .setProducerName("test")
+                .setSequenceId(123)
+                .setPublishTime(12333453454L)
+                .setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType))
+                .setUncompressedSize(uncompressedSize);
+
+        if (encAlgo != null) {
+            msgMetadata.setEncryptionAlgo(encAlgo);
+        }
+
+        msgMetadata.addEncryptionKey()
+                .setKey(encryptionKeyName)
+                .setValue(dataKey);
+
+        ByteBuffer decryptedPayload = ByteBuffer.allocate(crypto.getMaxOutputSize(payloadBuf.remaining()));
+        crypto.decrypt(() -> msgMetadata, payloadBuf, decryptedPayload, reader);
+
+        // try to uncompress
+        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);
+        ByteBuf uncompressedPayload = codec.decode(Unpooled.wrappedBuffer(decryptedPayload), uncompressedSize);
+
+        if (batchSize > 0) {
+            SingleMessageMetadata singleMessageMetadata = new SingleMessageMetadata();
+            uncompressedPayload = Commands.deSerializeSingleMessageInBatch(uncompressedPayload,
+                    singleMessageMetadata, 0, batchSize);
+        }
+
+        byte[] data = new byte[uncompressedPayload.readableBytes()];
+        uncompressedPayload.readBytes(data);
+        uncompressedPayload.release();
+        return new String(data);
+    }
+
+}
diff --git a/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java b/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
index 3531dd7ea0..1053bd33f3 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
+++ b/tests/pulsar-client-admin-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
@@ -1,99 +1,99 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends TestRetrySupport {
-
-    private PulsarContainer pulsarContainer;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup() {
-        incrementSetupNumber();
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-    }
-
-    @Test
-    public void checkClient() throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String inputTopic = "input";
-
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .enableBatching(false)
-                .create();
-
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(inputTopic)
-                .subscriptionName("test-subs")
-                .ackTimeout(10, TimeUnit.SECONDS)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-
-        producer.send("Hello!");
-        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
-
-        Assert.assertEquals(message.getValue(), "Hello!");
-
-    }
-
-    @Test
-    public void checkAdmin() throws PulsarClientException, PulsarAdminException {
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
-        List<String> expectedNamespacesList = new ArrayList<>();
-        expectedNamespacesList.add("public/default");
-        expectedNamespacesList.add("public/functions");
-        Assert.assertEquals(admin.namespaces().getNamespaces("public"), expectedNamespacesList);
-        admin.brokerStats().getLoadReport();
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup(){
-        markCurrentSetupNumberCleaned();
-        pulsarContainer.stop();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends TestRetrySupport {
+
+    private PulsarContainer pulsarContainer;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup() {
+        incrementSetupNumber();
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+    }
+
+    @Test
+    public void checkClient() throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String inputTopic = "input";
+
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .enableBatching(false)
+                .create();
+
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(inputTopic)
+                .subscriptionName("test-subs")
+                .ackTimeout(10, TimeUnit.SECONDS)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+
+        producer.send("Hello!");
+        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
+
+        Assert.assertEquals(message.getValue(), "Hello!");
+
+    }
+
+    @Test
+    public void checkAdmin() throws PulsarClientException, PulsarAdminException {
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
+        List<String> expectedNamespacesList = new ArrayList<>();
+        expectedNamespacesList.add("public/default");
+        expectedNamespacesList.add("public/functions");
+        Assert.assertEquals(admin.namespaces().getNamespaces("public"), expectedNamespacesList);
+        admin.brokerStats().getLoadReport();
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup(){
+        markCurrentSetupNumberCleaned();
+        pulsarContainer.stop();
+    }
+
+}
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.crt b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.crt
index 2d7d156866..03a429d370 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.crt
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.crt
@@ -1,20 +1,20 @@
------BEGIN CERTIFICATE-----
-MIIDVjCCAj4CCQCtw/UnTFDT7DANBgkqhkiG9w0BAQUFADBtMQswCQYDVQQGEwJB
-VTETMBEGA1UECAwKU29tZS1TdGF0ZTEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MSEw
-HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMMBmNsaWVu
-dDAeFw0xNjA2MjAwMTQ1NDZaFw0yNjA2MTgwMTQ1NDZaMG0xCzAJBgNVBAYTAkFV
-MRMwEQYDVQQIDApTb21lLVN0YXRlMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxITAf
-BgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGY2xpZW50
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqQV5F3Au9FWXIYPdWqiX
-Rk5gdVmVkDuuFK4ZoOd8inoJpB3PPkpmpgoVkKQHDFhgx3ODGWIUgo+n6QDsJxY4
-ygHfVeggQgek8iUfteYVsIcHS0bjkhIij/3ihC301FkiqbrV069oLvUXLKcv3zxG
-mdBAiz0k4xGZhFieVRvQCLY9syUUxmQ/3Cv42lDY8a1gTw4CRRx/hCfDvXCKhOT4
-bMwUIDZfHB3JoDh3Thp8FLz0nTrRF75mSQJ/OdcafIm0Xoz2Otp/CSxLS+U1lLvG
-05crWTDe0om7NW4mK4CqGCFq5gUw7eIzaeO7Q5Qez9XGTMzkgIDTMvNYGGEeJhhm
-NQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAKXy4g6hljY5MpO8mbZh+uJHq6NEUs
-4dr7OKDDWc39AROZsGf2eFUmHOjmRSw7VHpguGKI+rFRELVffpg/VvMh5apu+DBf
-jhxtDNceAyh5uugPNUJHXyeikBDYW8bAzUU3DmMldPkTZWcGjurmyhDQ1TtK2YJe
-RMFBXw5aAzdJMNi6OfXDH/ZX32hrb482yghDZj+ndnm0FefmLbFTQRMF8/fIHb1W
-kqNHwIaapZwH6j/MJy/TRFYcJunrBUYT9zVjY46k3GU0ex/Bn7T4pg9gzgFGZJhn
-jQQFKliIC84thCzdlPkrLduLY8tmlDKpLXatbEQ+s1MmNOURm6irPp6g
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDVjCCAj4CCQCtw/UnTFDT7DANBgkqhkiG9w0BAQUFADBtMQswCQYDVQQGEwJB
+VTETMBEGA1UECAwKU29tZS1TdGF0ZTEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MSEw
+HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMMBmNsaWVu
+dDAeFw0xNjA2MjAwMTQ1NDZaFw0yNjA2MTgwMTQ1NDZaMG0xCzAJBgNVBAYTAkFV
+MRMwEQYDVQQIDApTb21lLVN0YXRlMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxITAf
+BgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGY2xpZW50
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqQV5F3Au9FWXIYPdWqiX
+Rk5gdVmVkDuuFK4ZoOd8inoJpB3PPkpmpgoVkKQHDFhgx3ODGWIUgo+n6QDsJxY4
+ygHfVeggQgek8iUfteYVsIcHS0bjkhIij/3ihC301FkiqbrV069oLvUXLKcv3zxG
+mdBAiz0k4xGZhFieVRvQCLY9syUUxmQ/3Cv42lDY8a1gTw4CRRx/hCfDvXCKhOT4
+bMwUIDZfHB3JoDh3Thp8FLz0nTrRF75mSQJ/OdcafIm0Xoz2Otp/CSxLS+U1lLvG
+05crWTDe0om7NW4mK4CqGCFq5gUw7eIzaeO7Q5Qez9XGTMzkgIDTMvNYGGEeJhhm
+NQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAKXy4g6hljY5MpO8mbZh+uJHq6NEUs
+4dr7OKDDWc39AROZsGf2eFUmHOjmRSw7VHpguGKI+rFRELVffpg/VvMh5apu+DBf
+jhxtDNceAyh5uugPNUJHXyeikBDYW8bAzUU3DmMldPkTZWcGjurmyhDQ1TtK2YJe
+RMFBXw5aAzdJMNi6OfXDH/ZX32hrb482yghDZj+ndnm0FefmLbFTQRMF8/fIHb1W
+kqNHwIaapZwH6j/MJy/TRFYcJunrBUYT9zVjY46k3GU0ex/Bn7T4pg9gzgFGZJhn
+jQQFKliIC84thCzdlPkrLduLY8tmlDKpLXatbEQ+s1MmNOURm6irPp6g
+-----END CERTIFICATE-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.csr b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.csr
index e01f33ef07..74604d67d0 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.csr
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.csr
@@ -1,17 +1,17 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx
-FTATBgNVBAcMDERlZmF1bHQgQ2l0eTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMQ8wDQYDVQQDDAZjbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IB
-DwAwggEKAoIBAQCpBXkXcC70VZchg91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+
-SmamChWQpAcMWGDHc4MZYhSCj6fpAOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOS
-EiKP/eKELfTUWSKputXTr2gu9Rcspy/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTG
-ZD/cK/jaUNjxrWBPDgJFHH+EJ8O9cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEX
-vmZJAn851xp8ibRejPY62n8JLEtL5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt
-4jNp47tDlB7P1cZMzOSAgNMy81gYYR4mGGY1AgMBAAGgADANBgkqhkiG9w0BAQUF
-AAOCAQEAk3eueaq/gonBzKH75oWHlqPbMZQFk4NXqx8h24ZfkCzPEFPyDM+jdQxv
-8vDtyWq+fizqAQmGrM7WPHgnTbmZyovfmwuKwtTlkD/8t7XpTmm9fYspbL4WzdP1
-y8/Vug09te+rni+v+kjk5b9IceEy6kLvXuzirE6c4LunAm+thrr5gWmsx1pyDiq7
-W2M15UZrm/paaCg6cVaMFdXCRZP+g1P4NcgDUe2TyFbLlhOJNtX3DJRZWEhrkEYK
-mRz2tJuiuitCzheAgRrFXepRagHKYffNSas1n/2kIc9QpZ8654kxsAzEwL7CnHd/
-SHbMS9dfP+uM6DACwcvngSOBMJ9KMg==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx
+FTATBgNVBAcMDERlZmF1bHQgQ2l0eTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMQ8wDQYDVQQDDAZjbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IB
+DwAwggEKAoIBAQCpBXkXcC70VZchg91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+
+SmamChWQpAcMWGDHc4MZYhSCj6fpAOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOS
+EiKP/eKELfTUWSKputXTr2gu9Rcspy/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTG
+ZD/cK/jaUNjxrWBPDgJFHH+EJ8O9cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEX
+vmZJAn851xp8ibRejPY62n8JLEtL5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt
+4jNp47tDlB7P1cZMzOSAgNMy81gYYR4mGGY1AgMBAAGgADANBgkqhkiG9w0BAQUF
+AAOCAQEAk3eueaq/gonBzKH75oWHlqPbMZQFk4NXqx8h24ZfkCzPEFPyDM+jdQxv
+8vDtyWq+fizqAQmGrM7WPHgnTbmZyovfmwuKwtTlkD/8t7XpTmm9fYspbL4WzdP1
+y8/Vug09te+rni+v+kjk5b9IceEy6kLvXuzirE6c4LunAm+thrr5gWmsx1pyDiq7
+W2M15UZrm/paaCg6cVaMFdXCRZP+g1P4NcgDUe2TyFbLlhOJNtX3DJRZWEhrkEYK
+mRz2tJuiuitCzheAgRrFXepRagHKYffNSas1n/2kIc9QpZ8654kxsAzEwL7CnHd/
+SHbMS9dfP+uM6DACwcvngSOBMJ9KMg==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.key b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.key
index 34fc701c52..2b00929673 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.key
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/client.key
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCpBXkXcC70VZch
-g91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+SmamChWQpAcMWGDHc4MZYhSCj6fp
-AOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOSEiKP/eKELfTUWSKputXTr2gu9Rcs
-py/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTGZD/cK/jaUNjxrWBPDgJFHH+EJ8O9
-cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEXvmZJAn851xp8ibRejPY62n8JLEtL
-5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt4jNp47tDlB7P1cZMzOSAgNMy81gY
-YR4mGGY1AgMBAAECggEAcJj3yVhvv0/BhY8+CCYl2K1f7u1GCLbpSleNNTbhLbMM
-9yrwo/OWnGg9Y4USOPQrTNOz81X2id+/oSZ/K67PGCvVJ3qi+rny9WkrzdbAfkAF
-6O0Jr4arRbeBjkK7Rjc3M1EHH6VLx3R5AsNBzfpuogss5FVQXICd/5+1oscLeLEx
-/Fn+51IEn9FUg5vr7ElG51f+zPxexcWHLNoqGjTEIGGtI8/CfTzD9tBV4sIjf/Nc
-Zzfs9XYrChfcrS0U1zDa+L7c5gYfoN6M08sBiuZlhyyO9wgzPlp+XnsrSFv6hUta
-0scjAbN4bh+orQn6zgFN/sjkQnraWXW7pKFLyTR/IQKBgQDVju4IbhE9XRweNgXi
-s3BuGV+HsuFffEf0904/zCuCUcScGb5WCz5+KtlFJ//YxfocHVZajH+4GdCGbWim
-m+H3XvRpWgfK/aBNOXu5ueLbnPYyPjTrcpKRsomeoiV+Jz1tv5PQElwzCiCzVvQf
-fMyhQT16YIsFQAGJzQMBEHWODQKBgQDKnKps3sKSR3ycUtIxCVXUir7p52qst0Pm
-bPO8JrcRKZP2z8MJB96+DcQFzrxj7t5DDktkYEsFOPPuIeUsYXsY+MKHs4hEQVCz
-hpDJJNQ8s+SV8TLzKpinZEmLIjslLbn2rQrpqybPg84VxqX3qqM8IrXhMf77aGj6
-QHqvQwHWyQKBgQDF1RVO+9++j82ncvY6z22coKath5leIjxqgtqbISFBJUxUK0j2
-Xo4yxLDnbqmE/8m1V7wSP8tlGYzhquLiTM+kn/Mc0Ukc0503TMQABmJQfXRYkOXn
-IwkCLXltWdoPpnwyeeGNRCTjJ0OpvyiBLtRFobE498xxPZzvMdrRlpS/1QKBgQCo
-wmMleUnBQ2/kWQugMnFeLg6kjs+IesFAnYFKN0kGL4aB7j06OWbrEFY0rCS4bA6O
-9coQGjCCchSjRXI4TB2XCCQnmX8nsuuADNZt45Iv2XrM9XEFn3Y0/tBO5j0zU2nw
-r+NGC/uwns050BMPPf7mqNarctQ6HZZK0wgdEQfoGQKBgC+pbkQv9cn68TsiaJ3w
-tvNRTXCIAAH4Vtn9Cp+63ao+kXn94BJqQF99i58kJpG4ol6wbCHUoC6fHgxUh5HB
-JB0HjC2eCMgn4acAQg0sPW6l35KX36yYxtrL7eosB/yBYum0XAwmboNjEhlCZkOs
-YOpSsn61g7xqqrt40Spb5vUn
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCpBXkXcC70VZch
+g91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+SmamChWQpAcMWGDHc4MZYhSCj6fp
+AOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOSEiKP/eKELfTUWSKputXTr2gu9Rcs
+py/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTGZD/cK/jaUNjxrWBPDgJFHH+EJ8O9
+cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEXvmZJAn851xp8ibRejPY62n8JLEtL
+5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt4jNp47tDlB7P1cZMzOSAgNMy81gY
+YR4mGGY1AgMBAAECggEAcJj3yVhvv0/BhY8+CCYl2K1f7u1GCLbpSleNNTbhLbMM
+9yrwo/OWnGg9Y4USOPQrTNOz81X2id+/oSZ/K67PGCvVJ3qi+rny9WkrzdbAfkAF
+6O0Jr4arRbeBjkK7Rjc3M1EHH6VLx3R5AsNBzfpuogss5FVQXICd/5+1oscLeLEx
+/Fn+51IEn9FUg5vr7ElG51f+zPxexcWHLNoqGjTEIGGtI8/CfTzD9tBV4sIjf/Nc
+Zzfs9XYrChfcrS0U1zDa+L7c5gYfoN6M08sBiuZlhyyO9wgzPlp+XnsrSFv6hUta
+0scjAbN4bh+orQn6zgFN/sjkQnraWXW7pKFLyTR/IQKBgQDVju4IbhE9XRweNgXi
+s3BuGV+HsuFffEf0904/zCuCUcScGb5WCz5+KtlFJ//YxfocHVZajH+4GdCGbWim
+m+H3XvRpWgfK/aBNOXu5ueLbnPYyPjTrcpKRsomeoiV+Jz1tv5PQElwzCiCzVvQf
+fMyhQT16YIsFQAGJzQMBEHWODQKBgQDKnKps3sKSR3ycUtIxCVXUir7p52qst0Pm
+bPO8JrcRKZP2z8MJB96+DcQFzrxj7t5DDktkYEsFOPPuIeUsYXsY+MKHs4hEQVCz
+hpDJJNQ8s+SV8TLzKpinZEmLIjslLbn2rQrpqybPg84VxqX3qqM8IrXhMf77aGj6
+QHqvQwHWyQKBgQDF1RVO+9++j82ncvY6z22coKath5leIjxqgtqbISFBJUxUK0j2
+Xo4yxLDnbqmE/8m1V7wSP8tlGYzhquLiTM+kn/Mc0Ukc0503TMQABmJQfXRYkOXn
+IwkCLXltWdoPpnwyeeGNRCTjJ0OpvyiBLtRFobE498xxPZzvMdrRlpS/1QKBgQCo
+wmMleUnBQ2/kWQugMnFeLg6kjs+IesFAnYFKN0kGL4aB7j06OWbrEFY0rCS4bA6O
+9coQGjCCchSjRXI4TB2XCCQnmX8nsuuADNZt45Iv2XrM9XEFn3Y0/tBO5j0zU2nw
+r+NGC/uwns050BMPPf7mqNarctQ6HZZK0wgdEQfoGQKBgC+pbkQv9cn68TsiaJ3w
+tvNRTXCIAAH4Vtn9Cp+63ao+kXn94BJqQF99i58kJpG4ol6wbCHUoC6fHgxUh5HB
+JB0HjC2eCMgn4acAQg0sPW6l35KX36yYxtrL7eosB/yBYum0XAwmboNjEhlCZkOs
+YOpSsn61g7xqqrt40Spb5vUn
+-----END PRIVATE KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
index 58ab3d4ff9..407cf927e5 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
@@ -1,13 +1,13 @@
------BEGIN EC PARAMETERS-----
-MIGXAgEBMBwGByqGSM49AQECEQD////9////////////////MDsEEP////3/////
-//////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2
-eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1
-ow0bkDihFQIBAQ==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MIHYAgEBBBDeu9hc8kOvL3pl+LYSjLq9oIGaMIGXAgEBMBwGByqGSM49AQECEQD/
-///9////////////////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZ
-PCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bP
-Wsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1ow0bkDihFQIBAaEkAyIABOsqPpE8
-cY80pxkog5xw3i2AQ0yfV3MqMusxlOQnigBp
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+MIGXAgEBMBwGByqGSM49AQECEQD////9////////////////MDsEEP////3/////
+//////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2
+eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1
+ow0bkDihFQIBAQ==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MIHYAgEBBBDeu9hc8kOvL3pl+LYSjLq9oIGaMIGXAgEBMBwGByqGSM49AQECEQD/
+///9////////////////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZ
+PCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bP
+Wsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1ow0bkDihFQIBAaEkAyIABOsqPpE8
+cY80pxkog5xw3i2AQ0yfV3MqMusxlOQnigBp
+-----END EC PRIVATE KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
index 3e2831ae8a..992ee841e7 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
@@ -1,29 +1,29 @@
------BEGIN EC PARAMETERS-----
-MIIBwgIBATBNBgcqhkjOPQEBAkIB////////////////////////////////////
-//////////////////////////////////////////////////8wgZ4EQgH/////
-////////////////////////////////////////////////////////////////
-/////////////////ARBUZU+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8Qnh
-Vhk5Uex+k3sWUsC9O7G/BzVz34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5
-MoSqoNpkugSBhQQAxoWOBrcEBOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUte
-d+/nWSj+HcEnov+o3jNIs8GFakKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY
-9URJV5tEaBevvRcnPmYsl+5ymV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlAC
-QgH///////////////////////////////////////////pRhoeDvy+Wa3/MAUj3
-CaXQO7XJuImcR667b7cekThkCQIBAQ==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MIICnQIBAQRCAeNLEp1HefZ1nMl5vvgFMsJCd5ieCWqPT7TXbQkn27A8WkyAGTYC
-GtolyPokOgSjbJh+ofBt/MgvE/nMrqzmkZVtoIIBxjCCAcICAQEwTQYHKoZIzj0B
-AQJCAf//////////////////////////////////////////////////////////
-////////////////////////////MIGeBEIB////////////////////////////
-//////////////////////////////////////////////////////////wEQVGV
-PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
-c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
-BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
-hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
-cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
-///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
-ZAkCAQGhgYkDgYYABAFhUHeaHfIWre/pPmv2a2l891co79dFpg6ixPRg+Y5qe0C7
-src//LT/ZR5rgj8ne+YcaIlwyQRl5OYEd25n799IcgHIBTGyaLB6Td5mW/oWT/Fz
-soufOnUJ7O/kDHjIQ15sczk3rDhe8/mB9zPjKlKTuAl5jBEt6E3yiB44Dtng02xD
-uQ==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+MIIBwgIBATBNBgcqhkjOPQEBAkIB////////////////////////////////////
+//////////////////////////////////////////////////8wgZ4EQgH/////
+////////////////////////////////////////////////////////////////
+/////////////////ARBUZU+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8Qnh
+Vhk5Uex+k3sWUsC9O7G/BzVz34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5
+MoSqoNpkugSBhQQAxoWOBrcEBOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUte
+d+/nWSj+HcEnov+o3jNIs8GFakKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY
+9URJV5tEaBevvRcnPmYsl+5ymV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlAC
+QgH///////////////////////////////////////////pRhoeDvy+Wa3/MAUj3
+CaXQO7XJuImcR667b7cekThkCQIBAQ==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MIICnQIBAQRCAeNLEp1HefZ1nMl5vvgFMsJCd5ieCWqPT7TXbQkn27A8WkyAGTYC
+GtolyPokOgSjbJh+ofBt/MgvE/nMrqzmkZVtoIIBxjCCAcICAQEwTQYHKoZIzj0B
+AQJCAf//////////////////////////////////////////////////////////
+////////////////////////////MIGeBEIB////////////////////////////
+//////////////////////////////////////////////////////////wEQVGV
+PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
+c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
+BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
+hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
+cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
+///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
+ZAkCAQGhgYkDgYYABAFhUHeaHfIWre/pPmv2a2l891co79dFpg6ixPRg+Y5qe0C7
+src//LT/ZR5rgj8ne+YcaIlwyQRl5OYEd25n799IcgHIBTGyaLB6Td5mW/oWT/Fz
+soufOnUJ7O/kDHjIQ15sczk3rDhe8/mB9zPjKlKTuAl5jBEt6E3yiB44Dtng02xD
+uQ==
+-----END EC PRIVATE KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-rsa.pem b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
index a0d589e0e2..1ccfe4e40b 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEAtKWwgqdnTYrOCv+j1MkTWfSH0wCsHZZca9wAW3qP4uuhlBvn
-b10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhURHM4yuXqzCxzuAwkQSo39rzX8PGC
-7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9ER1e5O/uEPAotP933hHQ0J2hMEek
-HqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+cMd8ZbGScPqI9M38bmn3OLxFTn1vt
-hpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs7ppZnRbv8Hc/DFdOKVQIgam6CDdn
-NKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQGQIDAQABAoIBAAaJFAi2C7u3cNrf
-AstY9vVDLoLIvHFZlkBktjKZDYmVIsRb+hSCViwVUrWLL67R6+Iv4eg4DeTOAx00
-8pncXKgZTw2wIb1/QjR/Y/RjlaC8lkdmRWli7udMQCZVsyhuSjW6Pj7vr8YE4woj
-FhNijxEGcf9wWrmMJrzdnTWQiXByo+eTvUQ9BPgPGrRjsMZmTkLyAVJff2DfxO5b
-IWFDYDJcyYAMCIMQu7vys/I50ou6ilb1CO6QM6Z7KpPeOoVFPwtzbh8cf9xM8UNS
-j6J/JmdWhgI34GS3NA68xTQ6PV7zjnhCc+iccm3JKyzGXwaApAZ+Eoce/9j4WKmu
-5B4ziR0CgYEA3l/9OHbl1zmyV+rRxWOIj/i2rTvHzwBnbnPJyuemL5VMFdpGodQ3
-vwHvyQmcECRVRxmXojQ4QuPPHs3qp6wEEFPCWxChLSTxlUc85SOFHWU2O99jV7zI
-7+JOpDK/Mstsx9nHgXduJF+glTFtA3LH8Oqylzu2aFPsprwKuZf94Q8CgYEAz/Zx
-akEG+PEMtP5YS28cX5XfjsIX/V26Fs6/sH16QjUIEddE5T4fCuokxCjSiwUcWhml
-pHEJ5S5xp3VYRfISW3jRW3qstIH1tpZipB6+S0zTuJmLJbA3IiWEg2rtMt7X1uJv
-A/bYOqe0hOPTuXuZdtVZ0nMTKk7GG8O6VkBI7FcCgYEAkDfCmscJgs7JahlBWHmX
-zH9pwem+SPKjIc/4NB6N+dgikx2Pp05hpP/VihUwYIufvs/LNogVYNQrtHepUnrN
-2+TmbHbZgNSv1Ldxt82UfB7y0FutKu6lhmXHyNecho3Fi8sih0V0aiSWmYuHfrAH
-GaiskEZKo1iiZvQXJIx9O2MCgYATBf0r9hTYMtyxtc6H3/sdd01C9thQ8gDy0yjP
-0Tqc0dMSJroDqmIWkoKYew9/bhFA4LW5TCnWkCAPbHmNtG4fdfbYwmkH/hdnA2y0
-jKdlpfp8GXeUFAGHGx17FA3sqFvgKUh0eWEgRHUL7vdQMVFBgJS93o7zQM94fLgP
-6cOB8wKBgFcGV4GjI2Ww9cillaC554MvoSjf8B/+04kXzDOh8iYIIzO9EUil1jjK
-Jvxp4hnLzTKWbux3MEWqurLkYas6GpKBjw+iNOCar6YdqWGVqM3RUx7PTUaZwkKx
-UdP63IfY7iZCIT/QbyHQvIUe2MaiVnH+ulxdkK6Y5e7gxcbckIH4
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEAtKWwgqdnTYrOCv+j1MkTWfSH0wCsHZZca9wAW3qP4uuhlBvn
+b10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhURHM4yuXqzCxzuAwkQSo39rzX8PGC
+7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9ER1e5O/uEPAotP933hHQ0J2hMEek
+HqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+cMd8ZbGScPqI9M38bmn3OLxFTn1vt
+hpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs7ppZnRbv8Hc/DFdOKVQIgam6CDdn
+NKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQGQIDAQABAoIBAAaJFAi2C7u3cNrf
+AstY9vVDLoLIvHFZlkBktjKZDYmVIsRb+hSCViwVUrWLL67R6+Iv4eg4DeTOAx00
+8pncXKgZTw2wIb1/QjR/Y/RjlaC8lkdmRWli7udMQCZVsyhuSjW6Pj7vr8YE4woj
+FhNijxEGcf9wWrmMJrzdnTWQiXByo+eTvUQ9BPgPGrRjsMZmTkLyAVJff2DfxO5b
+IWFDYDJcyYAMCIMQu7vys/I50ou6ilb1CO6QM6Z7KpPeOoVFPwtzbh8cf9xM8UNS
+j6J/JmdWhgI34GS3NA68xTQ6PV7zjnhCc+iccm3JKyzGXwaApAZ+Eoce/9j4WKmu
+5B4ziR0CgYEA3l/9OHbl1zmyV+rRxWOIj/i2rTvHzwBnbnPJyuemL5VMFdpGodQ3
+vwHvyQmcECRVRxmXojQ4QuPPHs3qp6wEEFPCWxChLSTxlUc85SOFHWU2O99jV7zI
+7+JOpDK/Mstsx9nHgXduJF+glTFtA3LH8Oqylzu2aFPsprwKuZf94Q8CgYEAz/Zx
+akEG+PEMtP5YS28cX5XfjsIX/V26Fs6/sH16QjUIEddE5T4fCuokxCjSiwUcWhml
+pHEJ5S5xp3VYRfISW3jRW3qstIH1tpZipB6+S0zTuJmLJbA3IiWEg2rtMt7X1uJv
+A/bYOqe0hOPTuXuZdtVZ0nMTKk7GG8O6VkBI7FcCgYEAkDfCmscJgs7JahlBWHmX
+zH9pwem+SPKjIc/4NB6N+dgikx2Pp05hpP/VihUwYIufvs/LNogVYNQrtHepUnrN
+2+TmbHbZgNSv1Ldxt82UfB7y0FutKu6lhmXHyNecho3Fi8sih0V0aiSWmYuHfrAH
+GaiskEZKo1iiZvQXJIx9O2MCgYATBf0r9hTYMtyxtc6H3/sdd01C9thQ8gDy0yjP
+0Tqc0dMSJroDqmIWkoKYew9/bhFA4LW5TCnWkCAPbHmNtG4fdfbYwmkH/hdnA2y0
+jKdlpfp8GXeUFAGHGx17FA3sqFvgKUh0eWEgRHUL7vdQMVFBgJS93o7zQM94fLgP
+6cOB8wKBgFcGV4GjI2Ww9cillaC554MvoSjf8B/+04kXzDOh8iYIIzO9EUil1jjK
+Jvxp4hnLzTKWbux3MEWqurLkYas6GpKBjw+iNOCar6YdqWGVqM3RUx7PTUaZwkKx
+UdP63IfY7iZCIT/QbyHQvIUe2MaiVnH+ulxdkK6Y5e7gxcbckIH4
+-----END RSA PRIVATE KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
index 5aeb429a3d..757a26fc4c 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
@@ -1,7 +1,7 @@
------BEGIN PUBLIC KEY-----
-MIHKMIGjBgcqhkjOPQIBMIGXAgEBMBwGByqGSM49AQECEQD////9////////////
-////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1N
-aW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd
-7XqDAhEA/////gAAAAB1ow0bkDihFQIBAQMiAATrKj6RPHGPNKcZKIOccN4tgENM
-n1dzKjLrMZTkJ4oAaQ==
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIHKMIGjBgcqhkjOPQIBMIGXAgEBMBwGByqGSM49AQECEQD////9////////////
+////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1N
+aW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd
+7XqDAhEA/////gAAAAB1ow0bkDihFQIBAQMiAATrKj6RPHGPNKcZKIOccN4tgENM
+n1dzKjLrMZTkJ4oAaQ==
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
index 6fc427b1b1..88fa11eb8f 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
@@ -1,9 +1,9 @@
------BEGIN PUBLIC KEY-----
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
-WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
-RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
-ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
-Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
-7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
-GQIDAQAB
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
+WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
+RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
+ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
+Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
+7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
+GQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-rsa.pem b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
index 6fc427b1b1..88fa11eb8f 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
@@ -1,9 +1,9 @@
------BEGIN PUBLIC KEY-----
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
-WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
-RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
-ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
-Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
-7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
-GQIDAQAB
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
+WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
+RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
+ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
+Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
+7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
+GQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.crt b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.crt
index 59b651be2a..1b2c57bc6a 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.crt
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.crt
@@ -1,20 +1,20 @@
------BEGIN CERTIFICATE-----
-MIIDLjCCAhYCCQDn/Yvym+FMsDANBgkqhkiG9w0BAQUFADBZMQswCQYDVQQGEwJB
-VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTYwNjEzMjIyMTQ2WhcN
-MjYwNjExMjIyMTQ2WjBZMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0
-ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDEwls
-b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCs29IuzZvk
-OGUkS/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du99
-8xbgeihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT
-1DepD/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQr
-mTbLzzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J
-92K+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNb
-O9hVS4bqqsw9AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACE0WBuTbHcPtYKv2ZMS
-mYk9jvtAhmWHQ6tNqV8CmS2AsrzZdWglGaqIRsm5slkD2BGeQS+BesTArUuENTmP
-r9kJSecdiiB8aWtLbhoCSH3QR6IW/b5UVl6sR5OIh7SkNTjMSUSDnMEVLNGyKZGS
-gCGVbDf3n5KhOTnwqguELRykynKFt2LVksBia9+88lUtiRHpbyClo/KVWltJlaww
-PT0WEpwqVUcHmwrR3MTzJDEPvIplSgxdaDmFGYS1YKm9T/wQd+t/0DbXMmfJXBbd
-FVUnB6o7qJVU9N2Tbaj9NbCtwz5nTZG4A5kRXWHVjZsn5WzLuS/me3rDXjwlfB2p
-ipY=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDLjCCAhYCCQDn/Yvym+FMsDANBgkqhkiG9w0BAQUFADBZMQswCQYDVQQGEwJB
+VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTYwNjEzMjIyMTQ2WhcN
+MjYwNjExMjIyMTQ2WjBZMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0
+ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDEwls
+b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCs29IuzZvk
+OGUkS/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du99
+8xbgeihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT
+1DepD/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQr
+mTbLzzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J
+92K+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNb
+O9hVS4bqqsw9AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACE0WBuTbHcPtYKv2ZMS
+mYk9jvtAhmWHQ6tNqV8CmS2AsrzZdWglGaqIRsm5slkD2BGeQS+BesTArUuENTmP
+r9kJSecdiiB8aWtLbhoCSH3QR6IW/b5UVl6sR5OIh7SkNTjMSUSDnMEVLNGyKZGS
+gCGVbDf3n5KhOTnwqguELRykynKFt2LVksBia9+88lUtiRHpbyClo/KVWltJlaww
+PT0WEpwqVUcHmwrR3MTzJDEPvIplSgxdaDmFGYS1YKm9T/wQd+t/0DbXMmfJXBbd
+FVUnB6o7qJVU9N2Tbaj9NbCtwz5nTZG4A5kRXWHVjZsn5WzLuS/me3rDXjwlfB2p
+ipY=
+-----END CERTIFICATE-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.csr b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.csr
index 8782222c5a..1206d6e78c 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.csr
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.csr
@@ -1,17 +1,17 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICnjCCAYYCAQAwWTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUx
-ITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAxMJbG9j
-YWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNvSLs2b5Dhl
-JEv8Kis3f4dnrKowko8OEiy23odRgN1BL4dZPfnkYmMCRtcgjh5nLKeAPA7vffMW
-4HooaVlsO6Yy+VVZMt3Irrx8s9QnOmykabPxs1SQcBT9IMx5yvG1DPOlOdshk9Q3
-qQ/2NpVEctIoHVXADIxsHjMKE5omlXMGXsX2LhHn/o8935qZjsD/a26CAPa0K5k2
-y885GwMGV3Zfm0byHnyIyGsyM0zrPLSVq4RWkyVIAYYS4xSME3aUvp/hajrvCfdi
-vj7yoyHid5Jp2ckRyu7onZQJ9IPwyvnKNbF98zkTwlnoNtSvv71R04/dcwETWzvY
-VUuG6qrMPQIDAQABoAAwDQYJKoZIhvcNAQEFBQADggEBAEPHySnpf3E/7tZsiDka
-rqdB/sU7fdqjyV0iy0cuKQkU8WYrsE7bHkqMYc8CiIDfWhIGW5Jnzups2O6eH0Sx
-2BS21ARFiNGC1UfY1HSV2zrTNh3RqQa3YsXzv9vvdQ/gjsqGDuGDIc1yAA+Ytdja
-3rhIzEVqBhiLzg+M2+gW1zs+Kqj0Zo0pLB2uqhdZJmjxBb2FCli50vCVEhqIS3RO
-KTE+AJfxThWIeahFyVaskaEGkS6NVr2JihV0elbKolH19k2UzRTVn7p3Ixh5ojuW
-gtU/90vOy/SDkSRmCWMqgkUKJ2oeImleHdrvwNyrzvrLWRAz6R5yGQJwji9kKpHD
-FK0=
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICnjCCAYYCAQAwWTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUx
+ITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAxMJbG9j
+YWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNvSLs2b5Dhl
+JEv8Kis3f4dnrKowko8OEiy23odRgN1BL4dZPfnkYmMCRtcgjh5nLKeAPA7vffMW
+4HooaVlsO6Yy+VVZMt3Irrx8s9QnOmykabPxs1SQcBT9IMx5yvG1DPOlOdshk9Q3
+qQ/2NpVEctIoHVXADIxsHjMKE5omlXMGXsX2LhHn/o8935qZjsD/a26CAPa0K5k2
+y885GwMGV3Zfm0byHnyIyGsyM0zrPLSVq4RWkyVIAYYS4xSME3aUvp/hajrvCfdi
+vj7yoyHid5Jp2ckRyu7onZQJ9IPwyvnKNbF98zkTwlnoNtSvv71R04/dcwETWzvY
+VUuG6qrMPQIDAQABoAAwDQYJKoZIhvcNAQEFBQADggEBAEPHySnpf3E/7tZsiDka
+rqdB/sU7fdqjyV0iy0cuKQkU8WYrsE7bHkqMYc8CiIDfWhIGW5Jnzups2O6eH0Sx
+2BS21ARFiNGC1UfY1HSV2zrTNh3RqQa3YsXzv9vvdQ/gjsqGDuGDIc1yAA+Ytdja
+3rhIzEVqBhiLzg+M2+gW1zs+Kqj0Zo0pLB2uqhdZJmjxBb2FCli50vCVEhqIS3RO
+KTE+AJfxThWIeahFyVaskaEGkS6NVr2JihV0elbKolH19k2UzRTVn7p3Ixh5ojuW
+gtU/90vOy/SDkSRmCWMqgkUKJ2oeImleHdrvwNyrzvrLWRAz6R5yGQJwji9kKpHD
+FK0=
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.key b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.key
index 6da70f5aec..27b738af8e 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.key
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/certificate/server.key
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCs29IuzZvkOGUk
-S/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du998xbg
-eihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT1Dep
-D/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQrmTbL
-zzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J92K+
-PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNbO9hV
-S4bqqsw9AgMBAAECggEAd/LuDeZFZ/+uR5qmuAhXMZqfWZSbsges5vW6S/6wkvB1
-vGp6heQzFAbKXKgJgjUcuULeXE6s58RYuppqEnin/1hcBOKxy/dUu9Q14H+2XPdo
-u6TPcvaaZ/xYjnr1hNtnHD6yB8zEpxVbLmjSHJxF7Dti9MA9TTfgCrC2LFYKsicD
-/5AQyHuwpHyTL3Iiwv4Qtks/SD2a3fu8lD0yTQwA/hY6/0ieXxXd9tZV5a6GSA0P
-nieol1byfuX7Q5fb8ggPd9u9K1mVZTBRKiE5w+uU4Ic2IkBmZX5ZuRS+vFplpLsY
-YpFPvzFmpNkpK2SdYjJ+V4tkJsFHmOaFRgW/0QB2DQKBgQDeQMSZBQlPUrgRdWHN
-OyvTcrSvXzg5DbaIj39tgdNZ6PYns/thD0n707KGRJOChIyYiiKxLxzLWdPUxqQO
-rNLUV9IkMVc/QZR8RUqGc2BxmPOxAprhzeOhLsyqP/sgtxRHAnLqmkXuHYoxvTZ6
-LFCRCZBpEJrutGxl3s/x+sfkuwKBgQDHGwnSmvArpL8ZY1dV4xKNkxifCBnNmqAl
-TKHPW3odN9nkMECEt1XUIioUUKXUsiAZNp5xa/v1DEyJ4f2T20QKcAGbS18b1M5W
-axIoH3IhyLo74tuo0fthgq5bzypfFOlIjo7F9mpEky/461RWmoNAAlp9+FkDi48C
-KwjAk39/ZwKBgQDXFJqs8sDFsOlMi+nvsHmDERhmNqG0JN8mXKgWk3KzKc09MuHs
-Vd1lBMNZSHfv8NIWtGdKTKty5yUmXm1ZfkoxECPevpkOMCq/8FZksrb8d+YswLae
-Gp9U1nNdtrkSOdo3tdj7y/wsqQ2ZgOB9bvEwyq6j3lvw8U2NcAiQxf44DQKBgBHb
-lPf0uZHQhutKA61KXoGgLdclrNrKAY8W3nRwqfUw6zQSN9cvcl1Cay/DQ/xdtY9N
-XMyjeMezwLGlOU8nnWSqQxqgmfkvDwqlM82xdFUfYcS5RiZQHxHR3L2TSSOaBoph
-buDGhyV7ZhQXV0slNJxrGZ6uxZ0RyVPSdEiBcjAFAoGBAJqZ6uCVHpv/FwZVggu7
-Xb9EIxZnLSmXwaXFpJoMZpRpKb8cSTTJbgSMv3Dq2LcNKYXdNBhgKgPSc/XipXt9
-ZdT36KWipV+PzW691kUiWHtA8/+E0LCi4Y7rlcBMz9PgDNXK4XMMZOVKxDqPcHSJ
-P6y01ku7T2X+abUiJ334Hg6G
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCs29IuzZvkOGUk
+S/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du998xbg
+eihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT1Dep
+D/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQrmTbL
+zzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J92K+
+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNbO9hV
+S4bqqsw9AgMBAAECggEAd/LuDeZFZ/+uR5qmuAhXMZqfWZSbsges5vW6S/6wkvB1
+vGp6heQzFAbKXKgJgjUcuULeXE6s58RYuppqEnin/1hcBOKxy/dUu9Q14H+2XPdo
+u6TPcvaaZ/xYjnr1hNtnHD6yB8zEpxVbLmjSHJxF7Dti9MA9TTfgCrC2LFYKsicD
+/5AQyHuwpHyTL3Iiwv4Qtks/SD2a3fu8lD0yTQwA/hY6/0ieXxXd9tZV5a6GSA0P
+nieol1byfuX7Q5fb8ggPd9u9K1mVZTBRKiE5w+uU4Ic2IkBmZX5ZuRS+vFplpLsY
+YpFPvzFmpNkpK2SdYjJ+V4tkJsFHmOaFRgW/0QB2DQKBgQDeQMSZBQlPUrgRdWHN
+OyvTcrSvXzg5DbaIj39tgdNZ6PYns/thD0n707KGRJOChIyYiiKxLxzLWdPUxqQO
+rNLUV9IkMVc/QZR8RUqGc2BxmPOxAprhzeOhLsyqP/sgtxRHAnLqmkXuHYoxvTZ6
+LFCRCZBpEJrutGxl3s/x+sfkuwKBgQDHGwnSmvArpL8ZY1dV4xKNkxifCBnNmqAl
+TKHPW3odN9nkMECEt1XUIioUUKXUsiAZNp5xa/v1DEyJ4f2T20QKcAGbS18b1M5W
+axIoH3IhyLo74tuo0fthgq5bzypfFOlIjo7F9mpEky/461RWmoNAAlp9+FkDi48C
+KwjAk39/ZwKBgQDXFJqs8sDFsOlMi+nvsHmDERhmNqG0JN8mXKgWk3KzKc09MuHs
+Vd1lBMNZSHfv8NIWtGdKTKty5yUmXm1ZfkoxECPevpkOMCq/8FZksrb8d+YswLae
+Gp9U1nNdtrkSOdo3tdj7y/wsqQ2ZgOB9bvEwyq6j3lvw8U2NcAiQxf44DQKBgBHb
+lPf0uZHQhutKA61KXoGgLdclrNrKAY8W3nRwqfUw6zQSN9cvcl1Cay/DQ/xdtY9N
+XMyjeMezwLGlOU8nnWSqQxqgmfkvDwqlM82xdFUfYcS5RiZQHxHR3L2TSSOaBoph
+buDGhyV7ZhQXV0slNJxrGZ6uxZ0RyVPSdEiBcjAFAoGBAJqZ6uCVHpv/FwZVggu7
+Xb9EIxZnLSmXwaXFpJoMZpRpKb8cSTTJbgSMv3Dq2LcNKYXdNBhgKgPSc/XipXt9
+ZdT36KWipV+PzW691kUiWHtA8/+E0LCi4Y7rlcBMz9PgDNXK4XMMZOVKxDqPcHSJ
+P6y01ku7T2X+abUiJ334Hg6G
+-----END PRIVATE KEY-----
diff --git a/tests/pulsar-client-admin-shade-test/src/test/resources/pulsar.xml b/tests/pulsar-client-admin-shade-test/src/test/resources/pulsar.xml
index d95dd95ae1..d11b9fc137 100644
--- a/tests/pulsar-client-admin-shade-test/src/test/resources/pulsar.xml
+++ b/tests/pulsar-client-admin-shade-test/src/test/resources/pulsar.xml
@@ -1,29 +1,29 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Shade Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-client-admin-shade-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
-            <class name="org.apache.pulsar.tests.integration.SimpleProducerConsumerTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Shade Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-client-admin-shade-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
+            <class name="org.apache.pulsar.tests.integration.SimpleProducerConsumerTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/pulsar-client-all-shade-test/pom.xml b/tests/pulsar-client-all-shade-test/pom.xml
index c65b0f7d7d..d793e94923 100644
--- a/tests/pulsar-client-all-shade-test/pom.xml
+++ b/tests/pulsar-client-all-shade-test/pom.xml
@@ -1,122 +1,122 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>org.apache.pulsar.tests</groupId>
-        <artifactId>tests-parent</artifactId>
-        <version>4.1.2</version>
-    </parent>
-
-    <artifactId>pulsar-client-all-shade-test</artifactId>
-    <packaging>jar</packaging>
-    <name>Apache Pulsar :: Tests :: Pulsar-Client-All-Shade Test</name>
-
-    <dependencies>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client-all</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.testcontainers</groupId>
-            <artifactId>testcontainers</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>bouncy-castle-bc</artifactId>
-            <version>${project.version}</version>
-            <classifier>pkg</classifier>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client-messagecrypto-bc</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <configuration>
-                    <!-- only run tests when -DShadeTests is specified //-->
-                    <skipTests>true</skipTests>
-                    <systemPropertyVariables>
-                        <currentVersion>${project.version}</currentVersion>
-                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-                    </systemPropertyVariables>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-    <profiles>
-        <profile>
-            <id>ShadeTests</id>
-            <activation>
-                <property>
-                    <name>ShadeTests</name>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
-                                ${test.additional.args}
-                            </argLine>
-                            <skipTests>false</skipTests>
-                            <suiteXmlFiles>
-                                <file>src/test/resources/pulsar.xml</file>
-                            </suiteXmlFiles>
-                            <forkCount>1</forkCount>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.pulsar.tests</groupId>
+        <artifactId>tests-parent</artifactId>
+        <version>4.1.2</version>
+    </parent>
+
+    <artifactId>pulsar-client-all-shade-test</artifactId>
+    <packaging>jar</packaging>
+    <name>Apache Pulsar :: Tests :: Pulsar-Client-All-Shade Test</name>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client-all</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>bouncy-castle-bc</artifactId>
+            <version>${project.version}</version>
+            <classifier>pkg</classifier>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client-messagecrypto-bc</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>test-jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <!-- only run tests when -DShadeTests is specified //-->
+                    <skipTests>true</skipTests>
+                    <systemPropertyVariables>
+                        <currentVersion>${project.version}</currentVersion>
+                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+                    </systemPropertyVariables>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>
+        <profile>
+            <id>ShadeTests</id>
+            <activation>
+                <property>
+                    <name>ShadeTests</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
+                                ${test.additional.args}
+                            </argLine>
+                            <skipTests>false</skipTests>
+                            <suiteXmlFiles>
+                                <file>src/test/resources/pulsar.xml</file>
+                            </suiteXmlFiles>
+                            <forkCount>1</forkCount>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+</project>
diff --git a/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java b/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
index 365b4cca81..3a849a3ad1 100644
--- a/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
+++ b/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-public class PulsarContainer extends GenericContainer<PulsarContainer> {
-
-    public static final int PULSAR_PORT = 6650;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-
-    public PulsarContainer() {
-        this(DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(final String pulsarVersion) {
-        super(pulsarVersion);
-        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
-        withCommand("/pulsar/bin/pulsar standalone");
-        waitingFor(new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS)));
-    }
-
-    public String getPlainTextPulsarBrokerUrl() {
-        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
-    }
-
-    public String getPulsarAdminUrl() {
-        return String.format("http://%s:%s", this.getHost(), this.getMappedPort(BROKER_HTTP_PORT));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+public class PulsarContainer extends GenericContainer<PulsarContainer> {
+
+    public static final int PULSAR_PORT = 6650;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+
+    public PulsarContainer() {
+        this(DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(final String pulsarVersion) {
+        super(pulsarVersion);
+        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
+        withCommand("/pulsar/bin/pulsar standalone");
+        waitingFor(new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS)));
+    }
+
+    public String getPlainTextPulsarBrokerUrl() {
+        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
+    }
+
+    public String getPulsarAdminUrl() {
+        return String.format("http://%s:%s", this.getHost(), this.getMappedPort(BROKER_HTTP_PORT));
+    }
+
+}
diff --git a/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java b/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
index e0e8c7f3be..e010defc0d 100644
--- a/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
+++ b/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
@@ -1,608 +1,608 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import java.io.IOException;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.security.Security;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.CompressionType;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.ConsumerCryptoFailureAction;
-import org.apache.pulsar.client.api.CryptoKeyReader;
-import org.apache.pulsar.client.api.EncryptionKeyInfo;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageRoutingMode;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.impl.MessageImpl;
-import org.apache.pulsar.client.impl.TopicMessageImpl;
-import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;
-import org.apache.pulsar.common.api.EncryptionContext;
-import org.apache.pulsar.common.api.proto.MessageMetadata;
-import org.apache.pulsar.common.api.proto.SingleMessageMetadata;
-import org.apache.pulsar.common.compression.CompressionCodec;
-import org.apache.pulsar.common.compression.CompressionCodecProvider;
-import org.apache.pulsar.common.policies.data.TenantInfo;
-import org.apache.pulsar.common.protocol.Commands;
-import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;
-import org.apache.pulsar.shade.io.netty.buffer.Unpooled;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SimpleProducerConsumerTest extends TestRetrySupport {
-    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);
-
-    private PulsarContainer pulsarContainer;
-    private URI lookupUrl;
-    private PulsarClient pulsarClient;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public void setup() throws Exception {
-        incrementSetupNumber();
-        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-        pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
-        admin.tenants().createTenant("my-property",
-                TenantInfo.builder()
-                        .adminRoles(new HashSet<>(Arrays.asList("appid1", "appid2")))
-                        .allowedClusters(Collections.singleton("standalone"))
-                        .build());
-        admin.namespaces().createNamespace("my-property/my-ns");
-        admin.namespaces().setNamespaceReplicationClusters("my-property/my-ns", Collections.singleton("standalone"));
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public void cleanup() throws Exception {
-        markCurrentSetupNumberCleaned();
-        if (pulsarClient != null) {
-            pulsarClient.close();
-            pulsarClient = null;
-        }
-        if (pulsarContainer != null) {
-            pulsarContainer.stop();
-            pulsarContainer.close();
-            pulsarContainer = null;
-        }
-    }
-
-    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {
-        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();
-    }
-
-    @Test
-    public void testRSAEncryption() throws Exception {
-
-        String topicName = "persistent://my-property/my-ns/myrsa-topic1-" + System.currentTimeMillis();
-
-        class EncKeyReader implements CryptoKeyReader {
-
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        final int totalMsg = 10;
-
-        Set<String> messageSet = new HashSet<>();
-        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader()).subscribe();
-        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()
-                .topic(topicName).subscriptionName("my-subscriber-name-normal")
-                .subscribe();
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-        Producer<byte[]> producer2 = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-
-        for (int i = 0; i < totalMsg; i++) {
-            String message = "my-message-" + i;
-            producer.send(message.getBytes());
-        }
-        for (int i = totalMsg; i < totalMsg * 2; i++) {
-            String message = "my-message-" + i;
-            producer2.send(message.getBytes());
-        }
-
-        MessageImpl<byte[]> msg = null;
-
-        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);
-        // should not able to read message using normal message.
-        assertNull(msg);
-
-        for (int i = 0; i < totalMsg * 2; i++) {
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            // verify that encrypted message contains encryption-context
-            msg.getEncryptionCtx()
-                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-            String receivedMessage = new String(msg.getData());
-            log.debug("Received message: [{}]", receivedMessage);
-            String expectedMessage = "my-message-" + i;
-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
-        }
-        // Acknowledge the consumption of all messages at once
-        consumer.acknowledgeCumulative(msg);
-        consumer.close();
-    }
-
-    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,
-                                                     T expectedMessage) {
-        // Make sure that messages are received in order
-        Assert.assertEquals(receivedMessage, expectedMessage,
-                "Received message " + receivedMessage + " did not match the expected message " + expectedMessage);
-
-        // Make sure that there are no duplicates
-        assertTrue(messagesReceived.add(receivedMessage), "Received duplicate message " + receivedMessage);
-    }
-
-    @Test
-    public void testRedeliveryOfFailedMessages() throws Exception {
-
-        @Cleanup
-        PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String encryptionKeyName = "client-rsa.pem";
-        final String encryptionKeyVersion = "1.0";
-        Map<String, String> metadata = new HashMap<>();
-        metadata.put("version", encryptionKeyVersion);
-        class EncKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        class InvalidKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {
-                return null;
-            }
-        }
-
-        /*
-         * Redelivery functionality guarantees that customer will get a chance to process the message again.
-         * In case of shared subscription eventually every client will get a chance to process the message,
-         * till one of them acks it.
-         *
-         * For client with Encryption enabled where in cases like a new production rollout or a buggy client
-         * configuration, we might have a mismatch of consumers
-         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).
-         *
-         * In that case eventually all messages should be acked as long as there is a single consumer
-         * who can decrypt the message.
-         *
-         * Consumer 1 - Can decrypt message
-         * Consumer 2 - Has invalid Reader configured.
-         * Consumer 3 - Has no reader configured.
-         *
-         */
-
-        String topicName = "persistent://my-property/my-ns/myrsa-topic2";
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
-                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
-                .cryptoKeyReader(new EncKeyReader()).create();
-
-        @Cleanup
-        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader())
-                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        @Cleanup
-        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new InvalidKeyReader())
-                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        @Cleanup
-        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").subscriptionType(SubscriptionType.Shared)
-                .ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        int numberOfMessages = 100;
-        String message = "my-message";
-        Set<String> messages = new HashSet<>(); // Since messages are in random order
-        for (int i = 0; i < numberOfMessages; i++) {
-            producer.send((message + i).getBytes());
-        }
-
-        // Consuming from consumer 2 and 3
-        // no message should be returned since they can't decrypt the message
-        Message<byte[]> m = consumer2.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-        m = consumer3.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-
-        for (int i = 0; i < numberOfMessages; i++) {
-            // All messages would be received by consumer 1
-            m = consumer1.receive();
-            messages.add(new String(m.getData()));
-            consumer1.acknowledge(m);
-        }
-
-        // Consuming from consumer 2 and 3 again just to be sure
-        // no message should be returned since they can't decrypt the message
-        m = consumer2.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-        m = consumer3.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-
-        // checking if all messages were received
-        for (int i = 0; i < numberOfMessages; i++) {
-            assertTrue(messages.contains((message + i)));
-        }
-
-        consumer1.close();
-        consumer2.close();
-        consumer3.close();
-    }
-
-    @Test
-    public void testEncryptionFailure() throws Exception {
-
-        class EncKeyReader implements CryptoKeyReader {
-
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        log.error("Failed to read certificate from {}", certFilePath);
-                    }
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        log.error("Failed to read certificate from {}", certFilePath);
-                    }
-                }
-                return null;
-            }
-        }
-
-        final int totalMsg = 10;
-
-        MessageImpl<byte[]> msg = null;
-        Set<String> messageSet = new HashSet<>();
-        Consumer<byte[]> consumer = pulsarClient.newConsumer()
-                .topic("persistent://my-property/use/myenc-ns/myenc-topic1").subscriptionName("my-subscriber-name")
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        // 1. Invalid key name
-        try {
-            pulsarClient.newProducer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                    .addEncryptionKey("client-non-existant-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-            Assert.fail("Producer creation should not suceed if failing to read key");
-        } catch (Exception e) {
-            // ok
-        }
-
-        // 2. Producer with valid key name
-        Producer<byte[]> producer = pulsarClient.newProducer()
-                .topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .addEncryptionKey("client-rsa.pem")
-                .cryptoKeyReader(new EncKeyReader())
-                .enableBatching(false)
-                .messageRoutingMode(MessageRoutingMode.SinglePartition)
-                .create();
-
-        for (int i = 0; i < totalMsg; i++) {
-            String message = "my-message-" + i;
-            producer.send(message.getBytes());
-        }
-
-        // 3. KeyReder is not set by consumer
-        // Receive should fail since key reader is not setup
-        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-        assertNull(msg, "Receive should have failed with no keyreader");
-
-        // 4. Set consumer config to consume even if decryption fails
-        consumer.close();
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        int msgNum = 0;
-        try {
-            // Receive should proceed and deliver encrypted message
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            String receivedMessage = new String(msg.getData());
-            String expectedMessage = "my-message-" + msgNum++;
-            Assert.assertNotEquals(receivedMessage, expectedMessage, "Received encrypted message " + receivedMessage
-                    + " should not match the expected message " + expectedMessage);
-            consumer.acknowledgeCumulative(msg);
-        } catch (Exception e) {
-            e.printStackTrace();
-            Assert.fail("Failed to receive message even after ConsumerCryptoFailureAction.CONSUME is set.");
-        }
-
-        // 5. Set keyreader and failure action
-        consumer.close();
-        // Set keyreader
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.FAIL)
-                .cryptoKeyReader(new EncKeyReader()).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        for (int i = msgNum; i < totalMsg - 1; i++) {
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            // verify that encrypted message contains encryption-context
-            msg.getEncryptionCtx()
-                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-            String receivedMessage = new String(msg.getData());
-            log.debug("Received message: [{}]", receivedMessage);
-            String expectedMessage = "my-message-" + i;
-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
-        }
-        // Acknowledge the consumption of all messages at once
-        consumer.acknowledgeCumulative(msg);
-        consumer.close();
-
-        // 6. Set consumer config to discard if decryption fails
-        consumer.close();
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.DISCARD)
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        // Receive should proceed and discard encrypted messages
-        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-        assertNull(msg, "Message received even aftet ConsumerCryptoFailureAction.DISCARD is set.");
-    }
-
-    @Test(groups = "encryption")
-    public void testEncryptionConsumerWithoutCryptoReader() throws Exception {
-
-        final String encryptionKeyName = "client-rsa.pem";
-        final String encryptionKeyVersion = "1.0";
-        Map<String, String> metadata = new HashMap<>();
-        metadata.put("version", encryptionKeyVersion);
-        class EncKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic3")
-                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
-                .cryptoKeyReader(new EncKeyReader()).create();
-
-        Consumer<byte[]> consumer =
-                pulsarClient.newConsumer().topicsPattern("persistent://my-property/my-ns/myrsa-topic3")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
-                .subscribe();
-
-        String message = "my-message";
-        producer.send(message.getBytes());
-
-        TopicMessageImpl<byte[]> msg = (TopicMessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-
-        String receivedMessage = decryptMessage(msg, encryptionKeyName, new EncKeyReader());
-        assertEquals(message, receivedMessage);
-
-        consumer.close();
-    }
-
-    private String decryptMessage(TopicMessageImpl<byte[]> msg, String encryptionKeyName, CryptoKeyReader reader)
-            throws Exception {
-        Optional<EncryptionContext> ctx = msg.getEncryptionCtx();
-        assertTrue(ctx.isPresent());
-        EncryptionContext encryptionCtx = ctx
-                .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-
-        Map<String, EncryptionContext.EncryptionKey> keys = encryptionCtx.getKeys();
-        assertEquals(keys.size(), 1);
-        EncryptionContext.EncryptionKey encryptionKey = keys.get(encryptionKeyName);
-        byte[] dataKey = encryptionKey.getKeyValue();
-        Map<String, String> metadata = encryptionKey.getMetadata();
-        String version = metadata.get("version");
-        assertEquals(version, "1.0");
-
-        CompressionType compressionType = encryptionCtx.getCompressionType();
-        int uncompressedSize = encryptionCtx.getUncompressedMessageSize();
-        byte[] encrParam = encryptionCtx.getParam();
-        String encAlgo = encryptionCtx.getAlgorithm();
-        int batchSize = encryptionCtx.getBatchSize().orElse(0);
-
-        ByteBuffer payloadBuf = ByteBuffer.wrap(msg.getData());
-        // try to decrypt use default MessageCryptoBc
-        MessageCryptoBc crypto = new MessageCryptoBc("test", false);
-        MessageMetadata msgMetadata = new MessageMetadata()
-                .setEncryptionParam(encrParam)
-                .setProducerName("test")
-                .setSequenceId(123)
-                .setPublishTime(12333453454L)
-                .setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType))
-                .setUncompressedSize(uncompressedSize);
-
-        if (encAlgo != null) {
-            msgMetadata.setEncryptionAlgo(encAlgo);
-        }
-
-        msgMetadata.addEncryptionKey()
-                .setKey(encryptionKeyName)
-                .setValue(dataKey);
-
-        ByteBuffer decryptedPayload = ByteBuffer.allocate(crypto.getMaxOutputSize(payloadBuf.remaining()));
-        crypto.decrypt(() -> msgMetadata, payloadBuf, decryptedPayload, reader);
-
-        // try to uncompress
-        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);
-        ByteBuf uncompressedPayload = codec.decode(Unpooled.wrappedBuffer(decryptedPayload), uncompressedSize);
-
-        if (batchSize > 0) {
-            SingleMessageMetadata singleMessageMetadata = new SingleMessageMetadata();
-            uncompressedPayload = Commands.deSerializeSingleMessageInBatch(uncompressedPayload,
-                    singleMessageMetadata, 0, batchSize);
-        }
-
-        byte[] data = new byte[uncompressedPayload.readableBytes()];
-        uncompressedPayload.readBytes(data);
-        uncompressedPayload.release();
-        return new String(data);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import java.io.IOException;
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.CompressionType;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerCryptoFailureAction;
+import org.apache.pulsar.client.api.CryptoKeyReader;
+import org.apache.pulsar.client.api.EncryptionKeyInfo;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageRoutingMode;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.impl.MessageImpl;
+import org.apache.pulsar.client.impl.TopicMessageImpl;
+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;
+import org.apache.pulsar.common.api.EncryptionContext;
+import org.apache.pulsar.common.api.proto.MessageMetadata;
+import org.apache.pulsar.common.api.proto.SingleMessageMetadata;
+import org.apache.pulsar.common.compression.CompressionCodec;
+import org.apache.pulsar.common.compression.CompressionCodecProvider;
+import org.apache.pulsar.common.policies.data.TenantInfo;
+import org.apache.pulsar.common.protocol.Commands;
+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;
+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SimpleProducerConsumerTest extends TestRetrySupport {
+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);
+
+    private PulsarContainer pulsarContainer;
+    private URI lookupUrl;
+    private PulsarClient pulsarClient;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public void setup() throws Exception {
+        incrementSetupNumber();
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+        pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
+        admin.tenants().createTenant("my-property",
+                TenantInfo.builder()
+                        .adminRoles(new HashSet<>(Arrays.asList("appid1", "appid2")))
+                        .allowedClusters(Collections.singleton("standalone"))
+                        .build());
+        admin.namespaces().createNamespace("my-property/my-ns");
+        admin.namespaces().setNamespaceReplicationClusters("my-property/my-ns", Collections.singleton("standalone"));
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public void cleanup() throws Exception {
+        markCurrentSetupNumberCleaned();
+        if (pulsarClient != null) {
+            pulsarClient.close();
+            pulsarClient = null;
+        }
+        if (pulsarContainer != null) {
+            pulsarContainer.stop();
+            pulsarContainer.close();
+            pulsarContainer = null;
+        }
+    }
+
+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {
+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();
+    }
+
+    @Test
+    public void testRSAEncryption() throws Exception {
+
+        String topicName = "persistent://my-property/my-ns/myrsa-topic1-" + System.currentTimeMillis();
+
+        class EncKeyReader implements CryptoKeyReader {
+
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        final int totalMsg = 10;
+
+        Set<String> messageSet = new HashSet<>();
+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader()).subscribe();
+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()
+                .topic(topicName).subscriptionName("my-subscriber-name-normal")
+                .subscribe();
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+
+        for (int i = 0; i < totalMsg; i++) {
+            String message = "my-message-" + i;
+            producer.send(message.getBytes());
+        }
+        for (int i = totalMsg; i < totalMsg * 2; i++) {
+            String message = "my-message-" + i;
+            producer2.send(message.getBytes());
+        }
+
+        MessageImpl<byte[]> msg = null;
+
+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);
+        // should not able to read message using normal message.
+        assertNull(msg);
+
+        for (int i = 0; i < totalMsg * 2; i++) {
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            // verify that encrypted message contains encryption-context
+            msg.getEncryptionCtx()
+                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+            String receivedMessage = new String(msg.getData());
+            log.debug("Received message: [{}]", receivedMessage);
+            String expectedMessage = "my-message-" + i;
+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
+        }
+        // Acknowledge the consumption of all messages at once
+        consumer.acknowledgeCumulative(msg);
+        consumer.close();
+    }
+
+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,
+                                                     T expectedMessage) {
+        // Make sure that messages are received in order
+        Assert.assertEquals(receivedMessage, expectedMessage,
+                "Received message " + receivedMessage + " did not match the expected message " + expectedMessage);
+
+        // Make sure that there are no duplicates
+        assertTrue(messagesReceived.add(receivedMessage), "Received duplicate message " + receivedMessage);
+    }
+
+    @Test
+    public void testRedeliveryOfFailedMessages() throws Exception {
+
+        @Cleanup
+        PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String encryptionKeyName = "client-rsa.pem";
+        final String encryptionKeyVersion = "1.0";
+        Map<String, String> metadata = new HashMap<>();
+        metadata.put("version", encryptionKeyVersion);
+        class EncKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        class InvalidKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {
+                return null;
+            }
+        }
+
+        /*
+         * Redelivery functionality guarantees that customer will get a chance to process the message again.
+         * In case of shared subscription eventually every client will get a chance to process the message,
+         * till one of them acks it.
+         *
+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client
+         * configuration, we might have a mismatch of consumers
+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).
+         *
+         * In that case eventually all messages should be acked as long as there is a single consumer
+         * who can decrypt the message.
+         *
+         * Consumer 1 - Can decrypt message
+         * Consumer 2 - Has invalid Reader configured.
+         * Consumer 3 - Has no reader configured.
+         *
+         */
+
+        String topicName = "persistent://my-property/my-ns/myrsa-topic2";
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
+                .cryptoKeyReader(new EncKeyReader()).create();
+
+        @Cleanup
+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader())
+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        @Cleanup
+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new InvalidKeyReader())
+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        @Cleanup
+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").subscriptionType(SubscriptionType.Shared)
+                .ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        int numberOfMessages = 100;
+        String message = "my-message";
+        Set<String> messages = new HashSet<>(); // Since messages are in random order
+        for (int i = 0; i < numberOfMessages; i++) {
+            producer.send((message + i).getBytes());
+        }
+
+        // Consuming from consumer 2 and 3
+        // no message should be returned since they can't decrypt the message
+        Message<byte[]> m = consumer2.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+        m = consumer3.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+
+        for (int i = 0; i < numberOfMessages; i++) {
+            // All messages would be received by consumer 1
+            m = consumer1.receive();
+            messages.add(new String(m.getData()));
+            consumer1.acknowledge(m);
+        }
+
+        // Consuming from consumer 2 and 3 again just to be sure
+        // no message should be returned since they can't decrypt the message
+        m = consumer2.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+        m = consumer3.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+
+        // checking if all messages were received
+        for (int i = 0; i < numberOfMessages; i++) {
+            assertTrue(messages.contains((message + i)));
+        }
+
+        consumer1.close();
+        consumer2.close();
+        consumer3.close();
+    }
+
+    @Test
+    public void testEncryptionFailure() throws Exception {
+
+        class EncKeyReader implements CryptoKeyReader {
+
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        log.error("Failed to read certificate from {}", certFilePath);
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        log.error("Failed to read certificate from {}", certFilePath);
+                    }
+                }
+                return null;
+            }
+        }
+
+        final int totalMsg = 10;
+
+        MessageImpl<byte[]> msg = null;
+        Set<String> messageSet = new HashSet<>();
+        Consumer<byte[]> consumer = pulsarClient.newConsumer()
+                .topic("persistent://my-property/use/myenc-ns/myenc-topic1").subscriptionName("my-subscriber-name")
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        // 1. Invalid key name
+        try {
+            pulsarClient.newProducer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                    .addEncryptionKey("client-non-existant-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+            Assert.fail("Producer creation should not suceed if failing to read key");
+        } catch (Exception e) {
+            // ok
+        }
+
+        // 2. Producer with valid key name
+        Producer<byte[]> producer = pulsarClient.newProducer()
+                .topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .addEncryptionKey("client-rsa.pem")
+                .cryptoKeyReader(new EncKeyReader())
+                .enableBatching(false)
+                .messageRoutingMode(MessageRoutingMode.SinglePartition)
+                .create();
+
+        for (int i = 0; i < totalMsg; i++) {
+            String message = "my-message-" + i;
+            producer.send(message.getBytes());
+        }
+
+        // 3. KeyReder is not set by consumer
+        // Receive should fail since key reader is not setup
+        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+        assertNull(msg, "Receive should have failed with no keyreader");
+
+        // 4. Set consumer config to consume even if decryption fails
+        consumer.close();
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        int msgNum = 0;
+        try {
+            // Receive should proceed and deliver encrypted message
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            String receivedMessage = new String(msg.getData());
+            String expectedMessage = "my-message-" + msgNum++;
+            Assert.assertNotEquals(receivedMessage, expectedMessage, "Received encrypted message " + receivedMessage
+                    + " should not match the expected message " + expectedMessage);
+            consumer.acknowledgeCumulative(msg);
+        } catch (Exception e) {
+            e.printStackTrace();
+            Assert.fail("Failed to receive message even after ConsumerCryptoFailureAction.CONSUME is set.");
+        }
+
+        // 5. Set keyreader and failure action
+        consumer.close();
+        // Set keyreader
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.FAIL)
+                .cryptoKeyReader(new EncKeyReader()).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        for (int i = msgNum; i < totalMsg - 1; i++) {
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            // verify that encrypted message contains encryption-context
+            msg.getEncryptionCtx()
+                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+            String receivedMessage = new String(msg.getData());
+            log.debug("Received message: [{}]", receivedMessage);
+            String expectedMessage = "my-message-" + i;
+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
+        }
+        // Acknowledge the consumption of all messages at once
+        consumer.acknowledgeCumulative(msg);
+        consumer.close();
+
+        // 6. Set consumer config to discard if decryption fails
+        consumer.close();
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.DISCARD)
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        // Receive should proceed and discard encrypted messages
+        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+        assertNull(msg, "Message received even aftet ConsumerCryptoFailureAction.DISCARD is set.");
+    }
+
+    @Test(groups = "encryption")
+    public void testEncryptionConsumerWithoutCryptoReader() throws Exception {
+
+        final String encryptionKeyName = "client-rsa.pem";
+        final String encryptionKeyVersion = "1.0";
+        Map<String, String> metadata = new HashMap<>();
+        metadata.put("version", encryptionKeyVersion);
+        class EncKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic3")
+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
+                .cryptoKeyReader(new EncKeyReader()).create();
+
+        Consumer<byte[]> consumer =
+                pulsarClient.newConsumer().topicsPattern("persistent://my-property/my-ns/myrsa-topic3")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
+                .subscribe();
+
+        String message = "my-message";
+        producer.send(message.getBytes());
+
+        TopicMessageImpl<byte[]> msg = (TopicMessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+
+        String receivedMessage = decryptMessage(msg, encryptionKeyName, new EncKeyReader());
+        assertEquals(message, receivedMessage);
+
+        consumer.close();
+    }
+
+    private String decryptMessage(TopicMessageImpl<byte[]> msg, String encryptionKeyName, CryptoKeyReader reader)
+            throws Exception {
+        Optional<EncryptionContext> ctx = msg.getEncryptionCtx();
+        assertTrue(ctx.isPresent());
+        EncryptionContext encryptionCtx = ctx
+                .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+
+        Map<String, EncryptionContext.EncryptionKey> keys = encryptionCtx.getKeys();
+        assertEquals(keys.size(), 1);
+        EncryptionContext.EncryptionKey encryptionKey = keys.get(encryptionKeyName);
+        byte[] dataKey = encryptionKey.getKeyValue();
+        Map<String, String> metadata = encryptionKey.getMetadata();
+        String version = metadata.get("version");
+        assertEquals(version, "1.0");
+
+        CompressionType compressionType = encryptionCtx.getCompressionType();
+        int uncompressedSize = encryptionCtx.getUncompressedMessageSize();
+        byte[] encrParam = encryptionCtx.getParam();
+        String encAlgo = encryptionCtx.getAlgorithm();
+        int batchSize = encryptionCtx.getBatchSize().orElse(0);
+
+        ByteBuffer payloadBuf = ByteBuffer.wrap(msg.getData());
+        // try to decrypt use default MessageCryptoBc
+        MessageCryptoBc crypto = new MessageCryptoBc("test", false);
+        MessageMetadata msgMetadata = new MessageMetadata()
+                .setEncryptionParam(encrParam)
+                .setProducerName("test")
+                .setSequenceId(123)
+                .setPublishTime(12333453454L)
+                .setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType))
+                .setUncompressedSize(uncompressedSize);
+
+        if (encAlgo != null) {
+            msgMetadata.setEncryptionAlgo(encAlgo);
+        }
+
+        msgMetadata.addEncryptionKey()
+                .setKey(encryptionKeyName)
+                .setValue(dataKey);
+
+        ByteBuffer decryptedPayload = ByteBuffer.allocate(crypto.getMaxOutputSize(payloadBuf.remaining()));
+        crypto.decrypt(() -> msgMetadata, payloadBuf, decryptedPayload, reader);
+
+        // try to uncompress
+        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);
+        ByteBuf uncompressedPayload = codec.decode(Unpooled.wrappedBuffer(decryptedPayload), uncompressedSize);
+
+        if (batchSize > 0) {
+            SingleMessageMetadata singleMessageMetadata = new SingleMessageMetadata();
+            uncompressedPayload = Commands.deSerializeSingleMessageInBatch(uncompressedPayload,
+                    singleMessageMetadata, 0, batchSize);
+        }
+
+        byte[] data = new byte[uncompressedPayload.readableBytes()];
+        uncompressedPayload.readBytes(data);
+        uncompressedPayload.release();
+        return new String(data);
+    }
+
+}
diff --git a/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java b/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
index c148880c17..33b6e30f5a 100644
--- a/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
+++ b/tests/pulsar-client-all-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
@@ -1,99 +1,99 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.admin.PulsarAdminException;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends TestRetrySupport {
-
-    private PulsarContainer pulsarContainer;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup(){
-        incrementSetupNumber();
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-    }
-
-    @Test
-    public void checkClient() throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String inputTopic = "input";
-
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .enableBatching(false)
-                .create();
-
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(inputTopic)
-                .subscriptionName("test-subs")
-                .ackTimeout(10, TimeUnit.SECONDS)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-
-        producer.send("Hello!");
-        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
-
-        Assert.assertEquals(message.getValue(), "Hello!");
-
-    }
-
-    @Test
-    public void checkAdmin() throws PulsarClientException, PulsarAdminException {
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
-        List<String> expectedNamespacesList = new ArrayList<>();
-        expectedNamespacesList.add("public/default");
-        expectedNamespacesList.add("public/functions");
-        Assert.assertEquals(admin.namespaces().getNamespaces("public"), expectedNamespacesList);
-        admin.brokerStats().getLoadReport();
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup(){
-        markCurrentSetupNumberCleaned();
-        pulsarContainer.stop();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends TestRetrySupport {
+
+    private PulsarContainer pulsarContainer;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup(){
+        incrementSetupNumber();
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+    }
+
+    @Test
+    public void checkClient() throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String inputTopic = "input";
+
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .enableBatching(false)
+                .create();
+
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(inputTopic)
+                .subscriptionName("test-subs")
+                .ackTimeout(10, TimeUnit.SECONDS)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+
+        producer.send("Hello!");
+        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
+
+        Assert.assertEquals(message.getValue(), "Hello!");
+
+    }
+
+    @Test
+    public void checkAdmin() throws PulsarClientException, PulsarAdminException {
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
+        List<String> expectedNamespacesList = new ArrayList<>();
+        expectedNamespacesList.add("public/default");
+        expectedNamespacesList.add("public/functions");
+        Assert.assertEquals(admin.namespaces().getNamespaces("public"), expectedNamespacesList);
+        admin.brokerStats().getLoadReport();
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup(){
+        markCurrentSetupNumberCleaned();
+        pulsarContainer.stop();
+    }
+
+}
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.crt b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.crt
index 2d7d156866..03a429d370 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.crt
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.crt
@@ -1,20 +1,20 @@
------BEGIN CERTIFICATE-----
-MIIDVjCCAj4CCQCtw/UnTFDT7DANBgkqhkiG9w0BAQUFADBtMQswCQYDVQQGEwJB
-VTETMBEGA1UECAwKU29tZS1TdGF0ZTEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MSEw
-HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMMBmNsaWVu
-dDAeFw0xNjA2MjAwMTQ1NDZaFw0yNjA2MTgwMTQ1NDZaMG0xCzAJBgNVBAYTAkFV
-MRMwEQYDVQQIDApTb21lLVN0YXRlMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxITAf
-BgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGY2xpZW50
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqQV5F3Au9FWXIYPdWqiX
-Rk5gdVmVkDuuFK4ZoOd8inoJpB3PPkpmpgoVkKQHDFhgx3ODGWIUgo+n6QDsJxY4
-ygHfVeggQgek8iUfteYVsIcHS0bjkhIij/3ihC301FkiqbrV069oLvUXLKcv3zxG
-mdBAiz0k4xGZhFieVRvQCLY9syUUxmQ/3Cv42lDY8a1gTw4CRRx/hCfDvXCKhOT4
-bMwUIDZfHB3JoDh3Thp8FLz0nTrRF75mSQJ/OdcafIm0Xoz2Otp/CSxLS+U1lLvG
-05crWTDe0om7NW4mK4CqGCFq5gUw7eIzaeO7Q5Qez9XGTMzkgIDTMvNYGGEeJhhm
-NQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAKXy4g6hljY5MpO8mbZh+uJHq6NEUs
-4dr7OKDDWc39AROZsGf2eFUmHOjmRSw7VHpguGKI+rFRELVffpg/VvMh5apu+DBf
-jhxtDNceAyh5uugPNUJHXyeikBDYW8bAzUU3DmMldPkTZWcGjurmyhDQ1TtK2YJe
-RMFBXw5aAzdJMNi6OfXDH/ZX32hrb482yghDZj+ndnm0FefmLbFTQRMF8/fIHb1W
-kqNHwIaapZwH6j/MJy/TRFYcJunrBUYT9zVjY46k3GU0ex/Bn7T4pg9gzgFGZJhn
-jQQFKliIC84thCzdlPkrLduLY8tmlDKpLXatbEQ+s1MmNOURm6irPp6g
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDVjCCAj4CCQCtw/UnTFDT7DANBgkqhkiG9w0BAQUFADBtMQswCQYDVQQGEwJB
+VTETMBEGA1UECAwKU29tZS1TdGF0ZTEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MSEw
+HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMMBmNsaWVu
+dDAeFw0xNjA2MjAwMTQ1NDZaFw0yNjA2MTgwMTQ1NDZaMG0xCzAJBgNVBAYTAkFV
+MRMwEQYDVQQIDApTb21lLVN0YXRlMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxITAf
+BgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGY2xpZW50
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqQV5F3Au9FWXIYPdWqiX
+Rk5gdVmVkDuuFK4ZoOd8inoJpB3PPkpmpgoVkKQHDFhgx3ODGWIUgo+n6QDsJxY4
+ygHfVeggQgek8iUfteYVsIcHS0bjkhIij/3ihC301FkiqbrV069oLvUXLKcv3zxG
+mdBAiz0k4xGZhFieVRvQCLY9syUUxmQ/3Cv42lDY8a1gTw4CRRx/hCfDvXCKhOT4
+bMwUIDZfHB3JoDh3Thp8FLz0nTrRF75mSQJ/OdcafIm0Xoz2Otp/CSxLS+U1lLvG
+05crWTDe0om7NW4mK4CqGCFq5gUw7eIzaeO7Q5Qez9XGTMzkgIDTMvNYGGEeJhhm
+NQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAKXy4g6hljY5MpO8mbZh+uJHq6NEUs
+4dr7OKDDWc39AROZsGf2eFUmHOjmRSw7VHpguGKI+rFRELVffpg/VvMh5apu+DBf
+jhxtDNceAyh5uugPNUJHXyeikBDYW8bAzUU3DmMldPkTZWcGjurmyhDQ1TtK2YJe
+RMFBXw5aAzdJMNi6OfXDH/ZX32hrb482yghDZj+ndnm0FefmLbFTQRMF8/fIHb1W
+kqNHwIaapZwH6j/MJy/TRFYcJunrBUYT9zVjY46k3GU0ex/Bn7T4pg9gzgFGZJhn
+jQQFKliIC84thCzdlPkrLduLY8tmlDKpLXatbEQ+s1MmNOURm6irPp6g
+-----END CERTIFICATE-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.csr b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.csr
index e01f33ef07..74604d67d0 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.csr
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.csr
@@ -1,17 +1,17 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx
-FTATBgNVBAcMDERlZmF1bHQgQ2l0eTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMQ8wDQYDVQQDDAZjbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IB
-DwAwggEKAoIBAQCpBXkXcC70VZchg91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+
-SmamChWQpAcMWGDHc4MZYhSCj6fpAOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOS
-EiKP/eKELfTUWSKputXTr2gu9Rcspy/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTG
-ZD/cK/jaUNjxrWBPDgJFHH+EJ8O9cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEX
-vmZJAn851xp8ibRejPY62n8JLEtL5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt
-4jNp47tDlB7P1cZMzOSAgNMy81gYYR4mGGY1AgMBAAGgADANBgkqhkiG9w0BAQUF
-AAOCAQEAk3eueaq/gonBzKH75oWHlqPbMZQFk4NXqx8h24ZfkCzPEFPyDM+jdQxv
-8vDtyWq+fizqAQmGrM7WPHgnTbmZyovfmwuKwtTlkD/8t7XpTmm9fYspbL4WzdP1
-y8/Vug09te+rni+v+kjk5b9IceEy6kLvXuzirE6c4LunAm+thrr5gWmsx1pyDiq7
-W2M15UZrm/paaCg6cVaMFdXCRZP+g1P4NcgDUe2TyFbLlhOJNtX3DJRZWEhrkEYK
-mRz2tJuiuitCzheAgRrFXepRagHKYffNSas1n/2kIc9QpZ8654kxsAzEwL7CnHd/
-SHbMS9dfP+uM6DACwcvngSOBMJ9KMg==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx
+FTATBgNVBAcMDERlZmF1bHQgQ2l0eTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMQ8wDQYDVQQDDAZjbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IB
+DwAwggEKAoIBAQCpBXkXcC70VZchg91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+
+SmamChWQpAcMWGDHc4MZYhSCj6fpAOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOS
+EiKP/eKELfTUWSKputXTr2gu9Rcspy/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTG
+ZD/cK/jaUNjxrWBPDgJFHH+EJ8O9cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEX
+vmZJAn851xp8ibRejPY62n8JLEtL5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt
+4jNp47tDlB7P1cZMzOSAgNMy81gYYR4mGGY1AgMBAAGgADANBgkqhkiG9w0BAQUF
+AAOCAQEAk3eueaq/gonBzKH75oWHlqPbMZQFk4NXqx8h24ZfkCzPEFPyDM+jdQxv
+8vDtyWq+fizqAQmGrM7WPHgnTbmZyovfmwuKwtTlkD/8t7XpTmm9fYspbL4WzdP1
+y8/Vug09te+rni+v+kjk5b9IceEy6kLvXuzirE6c4LunAm+thrr5gWmsx1pyDiq7
+W2M15UZrm/paaCg6cVaMFdXCRZP+g1P4NcgDUe2TyFbLlhOJNtX3DJRZWEhrkEYK
+mRz2tJuiuitCzheAgRrFXepRagHKYffNSas1n/2kIc9QpZ8654kxsAzEwL7CnHd/
+SHbMS9dfP+uM6DACwcvngSOBMJ9KMg==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.key b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.key
index 34fc701c52..2b00929673 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.key
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/client.key
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCpBXkXcC70VZch
-g91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+SmamChWQpAcMWGDHc4MZYhSCj6fp
-AOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOSEiKP/eKELfTUWSKputXTr2gu9Rcs
-py/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTGZD/cK/jaUNjxrWBPDgJFHH+EJ8O9
-cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEXvmZJAn851xp8ibRejPY62n8JLEtL
-5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt4jNp47tDlB7P1cZMzOSAgNMy81gY
-YR4mGGY1AgMBAAECggEAcJj3yVhvv0/BhY8+CCYl2K1f7u1GCLbpSleNNTbhLbMM
-9yrwo/OWnGg9Y4USOPQrTNOz81X2id+/oSZ/K67PGCvVJ3qi+rny9WkrzdbAfkAF
-6O0Jr4arRbeBjkK7Rjc3M1EHH6VLx3R5AsNBzfpuogss5FVQXICd/5+1oscLeLEx
-/Fn+51IEn9FUg5vr7ElG51f+zPxexcWHLNoqGjTEIGGtI8/CfTzD9tBV4sIjf/Nc
-Zzfs9XYrChfcrS0U1zDa+L7c5gYfoN6M08sBiuZlhyyO9wgzPlp+XnsrSFv6hUta
-0scjAbN4bh+orQn6zgFN/sjkQnraWXW7pKFLyTR/IQKBgQDVju4IbhE9XRweNgXi
-s3BuGV+HsuFffEf0904/zCuCUcScGb5WCz5+KtlFJ//YxfocHVZajH+4GdCGbWim
-m+H3XvRpWgfK/aBNOXu5ueLbnPYyPjTrcpKRsomeoiV+Jz1tv5PQElwzCiCzVvQf
-fMyhQT16YIsFQAGJzQMBEHWODQKBgQDKnKps3sKSR3ycUtIxCVXUir7p52qst0Pm
-bPO8JrcRKZP2z8MJB96+DcQFzrxj7t5DDktkYEsFOPPuIeUsYXsY+MKHs4hEQVCz
-hpDJJNQ8s+SV8TLzKpinZEmLIjslLbn2rQrpqybPg84VxqX3qqM8IrXhMf77aGj6
-QHqvQwHWyQKBgQDF1RVO+9++j82ncvY6z22coKath5leIjxqgtqbISFBJUxUK0j2
-Xo4yxLDnbqmE/8m1V7wSP8tlGYzhquLiTM+kn/Mc0Ukc0503TMQABmJQfXRYkOXn
-IwkCLXltWdoPpnwyeeGNRCTjJ0OpvyiBLtRFobE498xxPZzvMdrRlpS/1QKBgQCo
-wmMleUnBQ2/kWQugMnFeLg6kjs+IesFAnYFKN0kGL4aB7j06OWbrEFY0rCS4bA6O
-9coQGjCCchSjRXI4TB2XCCQnmX8nsuuADNZt45Iv2XrM9XEFn3Y0/tBO5j0zU2nw
-r+NGC/uwns050BMPPf7mqNarctQ6HZZK0wgdEQfoGQKBgC+pbkQv9cn68TsiaJ3w
-tvNRTXCIAAH4Vtn9Cp+63ao+kXn94BJqQF99i58kJpG4ol6wbCHUoC6fHgxUh5HB
-JB0HjC2eCMgn4acAQg0sPW6l35KX36yYxtrL7eosB/yBYum0XAwmboNjEhlCZkOs
-YOpSsn61g7xqqrt40Spb5vUn
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCpBXkXcC70VZch
+g91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+SmamChWQpAcMWGDHc4MZYhSCj6fp
+AOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOSEiKP/eKELfTUWSKputXTr2gu9Rcs
+py/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTGZD/cK/jaUNjxrWBPDgJFHH+EJ8O9
+cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEXvmZJAn851xp8ibRejPY62n8JLEtL
+5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt4jNp47tDlB7P1cZMzOSAgNMy81gY
+YR4mGGY1AgMBAAECggEAcJj3yVhvv0/BhY8+CCYl2K1f7u1GCLbpSleNNTbhLbMM
+9yrwo/OWnGg9Y4USOPQrTNOz81X2id+/oSZ/K67PGCvVJ3qi+rny9WkrzdbAfkAF
+6O0Jr4arRbeBjkK7Rjc3M1EHH6VLx3R5AsNBzfpuogss5FVQXICd/5+1oscLeLEx
+/Fn+51IEn9FUg5vr7ElG51f+zPxexcWHLNoqGjTEIGGtI8/CfTzD9tBV4sIjf/Nc
+Zzfs9XYrChfcrS0U1zDa+L7c5gYfoN6M08sBiuZlhyyO9wgzPlp+XnsrSFv6hUta
+0scjAbN4bh+orQn6zgFN/sjkQnraWXW7pKFLyTR/IQKBgQDVju4IbhE9XRweNgXi
+s3BuGV+HsuFffEf0904/zCuCUcScGb5WCz5+KtlFJ//YxfocHVZajH+4GdCGbWim
+m+H3XvRpWgfK/aBNOXu5ueLbnPYyPjTrcpKRsomeoiV+Jz1tv5PQElwzCiCzVvQf
+fMyhQT16YIsFQAGJzQMBEHWODQKBgQDKnKps3sKSR3ycUtIxCVXUir7p52qst0Pm
+bPO8JrcRKZP2z8MJB96+DcQFzrxj7t5DDktkYEsFOPPuIeUsYXsY+MKHs4hEQVCz
+hpDJJNQ8s+SV8TLzKpinZEmLIjslLbn2rQrpqybPg84VxqX3qqM8IrXhMf77aGj6
+QHqvQwHWyQKBgQDF1RVO+9++j82ncvY6z22coKath5leIjxqgtqbISFBJUxUK0j2
+Xo4yxLDnbqmE/8m1V7wSP8tlGYzhquLiTM+kn/Mc0Ukc0503TMQABmJQfXRYkOXn
+IwkCLXltWdoPpnwyeeGNRCTjJ0OpvyiBLtRFobE498xxPZzvMdrRlpS/1QKBgQCo
+wmMleUnBQ2/kWQugMnFeLg6kjs+IesFAnYFKN0kGL4aB7j06OWbrEFY0rCS4bA6O
+9coQGjCCchSjRXI4TB2XCCQnmX8nsuuADNZt45Iv2XrM9XEFn3Y0/tBO5j0zU2nw
+r+NGC/uwns050BMPPf7mqNarctQ6HZZK0wgdEQfoGQKBgC+pbkQv9cn68TsiaJ3w
+tvNRTXCIAAH4Vtn9Cp+63ao+kXn94BJqQF99i58kJpG4ol6wbCHUoC6fHgxUh5HB
+JB0HjC2eCMgn4acAQg0sPW6l35KX36yYxtrL7eosB/yBYum0XAwmboNjEhlCZkOs
+YOpSsn61g7xqqrt40Spb5vUn
+-----END PRIVATE KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
index 58ab3d4ff9..407cf927e5 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
@@ -1,13 +1,13 @@
------BEGIN EC PARAMETERS-----
-MIGXAgEBMBwGByqGSM49AQECEQD////9////////////////MDsEEP////3/////
-//////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2
-eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1
-ow0bkDihFQIBAQ==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MIHYAgEBBBDeu9hc8kOvL3pl+LYSjLq9oIGaMIGXAgEBMBwGByqGSM49AQECEQD/
-///9////////////////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZ
-PCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bP
-Wsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1ow0bkDihFQIBAaEkAyIABOsqPpE8
-cY80pxkog5xw3i2AQ0yfV3MqMusxlOQnigBp
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+MIGXAgEBMBwGByqGSM49AQECEQD////9////////////////MDsEEP////3/////
+//////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2
+eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1
+ow0bkDihFQIBAQ==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MIHYAgEBBBDeu9hc8kOvL3pl+LYSjLq9oIGaMIGXAgEBMBwGByqGSM49AQECEQD/
+///9////////////////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZ
+PCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bP
+Wsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1ow0bkDihFQIBAaEkAyIABOsqPpE8
+cY80pxkog5xw3i2AQ0yfV3MqMusxlOQnigBp
+-----END EC PRIVATE KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
index 3e2831ae8a..992ee841e7 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
@@ -1,29 +1,29 @@
------BEGIN EC PARAMETERS-----
-MIIBwgIBATBNBgcqhkjOPQEBAkIB////////////////////////////////////
-//////////////////////////////////////////////////8wgZ4EQgH/////
-////////////////////////////////////////////////////////////////
-/////////////////ARBUZU+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8Qnh
-Vhk5Uex+k3sWUsC9O7G/BzVz34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5
-MoSqoNpkugSBhQQAxoWOBrcEBOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUte
-d+/nWSj+HcEnov+o3jNIs8GFakKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY
-9URJV5tEaBevvRcnPmYsl+5ymV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlAC
-QgH///////////////////////////////////////////pRhoeDvy+Wa3/MAUj3
-CaXQO7XJuImcR667b7cekThkCQIBAQ==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MIICnQIBAQRCAeNLEp1HefZ1nMl5vvgFMsJCd5ieCWqPT7TXbQkn27A8WkyAGTYC
-GtolyPokOgSjbJh+ofBt/MgvE/nMrqzmkZVtoIIBxjCCAcICAQEwTQYHKoZIzj0B
-AQJCAf//////////////////////////////////////////////////////////
-////////////////////////////MIGeBEIB////////////////////////////
-//////////////////////////////////////////////////////////wEQVGV
-PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
-c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
-BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
-hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
-cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
-///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
-ZAkCAQGhgYkDgYYABAFhUHeaHfIWre/pPmv2a2l891co79dFpg6ixPRg+Y5qe0C7
-src//LT/ZR5rgj8ne+YcaIlwyQRl5OYEd25n799IcgHIBTGyaLB6Td5mW/oWT/Fz
-soufOnUJ7O/kDHjIQ15sczk3rDhe8/mB9zPjKlKTuAl5jBEt6E3yiB44Dtng02xD
-uQ==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+MIIBwgIBATBNBgcqhkjOPQEBAkIB////////////////////////////////////
+//////////////////////////////////////////////////8wgZ4EQgH/////
+////////////////////////////////////////////////////////////////
+/////////////////ARBUZU+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8Qnh
+Vhk5Uex+k3sWUsC9O7G/BzVz34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5
+MoSqoNpkugSBhQQAxoWOBrcEBOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUte
+d+/nWSj+HcEnov+o3jNIs8GFakKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY
+9URJV5tEaBevvRcnPmYsl+5ymV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlAC
+QgH///////////////////////////////////////////pRhoeDvy+Wa3/MAUj3
+CaXQO7XJuImcR667b7cekThkCQIBAQ==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MIICnQIBAQRCAeNLEp1HefZ1nMl5vvgFMsJCd5ieCWqPT7TXbQkn27A8WkyAGTYC
+GtolyPokOgSjbJh+ofBt/MgvE/nMrqzmkZVtoIIBxjCCAcICAQEwTQYHKoZIzj0B
+AQJCAf//////////////////////////////////////////////////////////
+////////////////////////////MIGeBEIB////////////////////////////
+//////////////////////////////////////////////////////////wEQVGV
+PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
+c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
+BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
+hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
+cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
+///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
+ZAkCAQGhgYkDgYYABAFhUHeaHfIWre/pPmv2a2l891co79dFpg6ixPRg+Y5qe0C7
+src//LT/ZR5rgj8ne+YcaIlwyQRl5OYEd25n799IcgHIBTGyaLB6Td5mW/oWT/Fz
+soufOnUJ7O/kDHjIQ15sczk3rDhe8/mB9zPjKlKTuAl5jBEt6E3yiB44Dtng02xD
+uQ==
+-----END EC PRIVATE KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-rsa.pem b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
index a0d589e0e2..1ccfe4e40b 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEAtKWwgqdnTYrOCv+j1MkTWfSH0wCsHZZca9wAW3qP4uuhlBvn
-b10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhURHM4yuXqzCxzuAwkQSo39rzX8PGC
-7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9ER1e5O/uEPAotP933hHQ0J2hMEek
-HqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+cMd8ZbGScPqI9M38bmn3OLxFTn1vt
-hpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs7ppZnRbv8Hc/DFdOKVQIgam6CDdn
-NKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQGQIDAQABAoIBAAaJFAi2C7u3cNrf
-AstY9vVDLoLIvHFZlkBktjKZDYmVIsRb+hSCViwVUrWLL67R6+Iv4eg4DeTOAx00
-8pncXKgZTw2wIb1/QjR/Y/RjlaC8lkdmRWli7udMQCZVsyhuSjW6Pj7vr8YE4woj
-FhNijxEGcf9wWrmMJrzdnTWQiXByo+eTvUQ9BPgPGrRjsMZmTkLyAVJff2DfxO5b
-IWFDYDJcyYAMCIMQu7vys/I50ou6ilb1CO6QM6Z7KpPeOoVFPwtzbh8cf9xM8UNS
-j6J/JmdWhgI34GS3NA68xTQ6PV7zjnhCc+iccm3JKyzGXwaApAZ+Eoce/9j4WKmu
-5B4ziR0CgYEA3l/9OHbl1zmyV+rRxWOIj/i2rTvHzwBnbnPJyuemL5VMFdpGodQ3
-vwHvyQmcECRVRxmXojQ4QuPPHs3qp6wEEFPCWxChLSTxlUc85SOFHWU2O99jV7zI
-7+JOpDK/Mstsx9nHgXduJF+glTFtA3LH8Oqylzu2aFPsprwKuZf94Q8CgYEAz/Zx
-akEG+PEMtP5YS28cX5XfjsIX/V26Fs6/sH16QjUIEddE5T4fCuokxCjSiwUcWhml
-pHEJ5S5xp3VYRfISW3jRW3qstIH1tpZipB6+S0zTuJmLJbA3IiWEg2rtMt7X1uJv
-A/bYOqe0hOPTuXuZdtVZ0nMTKk7GG8O6VkBI7FcCgYEAkDfCmscJgs7JahlBWHmX
-zH9pwem+SPKjIc/4NB6N+dgikx2Pp05hpP/VihUwYIufvs/LNogVYNQrtHepUnrN
-2+TmbHbZgNSv1Ldxt82UfB7y0FutKu6lhmXHyNecho3Fi8sih0V0aiSWmYuHfrAH
-GaiskEZKo1iiZvQXJIx9O2MCgYATBf0r9hTYMtyxtc6H3/sdd01C9thQ8gDy0yjP
-0Tqc0dMSJroDqmIWkoKYew9/bhFA4LW5TCnWkCAPbHmNtG4fdfbYwmkH/hdnA2y0
-jKdlpfp8GXeUFAGHGx17FA3sqFvgKUh0eWEgRHUL7vdQMVFBgJS93o7zQM94fLgP
-6cOB8wKBgFcGV4GjI2Ww9cillaC554MvoSjf8B/+04kXzDOh8iYIIzO9EUil1jjK
-Jvxp4hnLzTKWbux3MEWqurLkYas6GpKBjw+iNOCar6YdqWGVqM3RUx7PTUaZwkKx
-UdP63IfY7iZCIT/QbyHQvIUe2MaiVnH+ulxdkK6Y5e7gxcbckIH4
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEAtKWwgqdnTYrOCv+j1MkTWfSH0wCsHZZca9wAW3qP4uuhlBvn
+b10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhURHM4yuXqzCxzuAwkQSo39rzX8PGC
+7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9ER1e5O/uEPAotP933hHQ0J2hMEek
+HqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+cMd8ZbGScPqI9M38bmn3OLxFTn1vt
+hpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs7ppZnRbv8Hc/DFdOKVQIgam6CDdn
+NKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQGQIDAQABAoIBAAaJFAi2C7u3cNrf
+AstY9vVDLoLIvHFZlkBktjKZDYmVIsRb+hSCViwVUrWLL67R6+Iv4eg4DeTOAx00
+8pncXKgZTw2wIb1/QjR/Y/RjlaC8lkdmRWli7udMQCZVsyhuSjW6Pj7vr8YE4woj
+FhNijxEGcf9wWrmMJrzdnTWQiXByo+eTvUQ9BPgPGrRjsMZmTkLyAVJff2DfxO5b
+IWFDYDJcyYAMCIMQu7vys/I50ou6ilb1CO6QM6Z7KpPeOoVFPwtzbh8cf9xM8UNS
+j6J/JmdWhgI34GS3NA68xTQ6PV7zjnhCc+iccm3JKyzGXwaApAZ+Eoce/9j4WKmu
+5B4ziR0CgYEA3l/9OHbl1zmyV+rRxWOIj/i2rTvHzwBnbnPJyuemL5VMFdpGodQ3
+vwHvyQmcECRVRxmXojQ4QuPPHs3qp6wEEFPCWxChLSTxlUc85SOFHWU2O99jV7zI
+7+JOpDK/Mstsx9nHgXduJF+glTFtA3LH8Oqylzu2aFPsprwKuZf94Q8CgYEAz/Zx
+akEG+PEMtP5YS28cX5XfjsIX/V26Fs6/sH16QjUIEddE5T4fCuokxCjSiwUcWhml
+pHEJ5S5xp3VYRfISW3jRW3qstIH1tpZipB6+S0zTuJmLJbA3IiWEg2rtMt7X1uJv
+A/bYOqe0hOPTuXuZdtVZ0nMTKk7GG8O6VkBI7FcCgYEAkDfCmscJgs7JahlBWHmX
+zH9pwem+SPKjIc/4NB6N+dgikx2Pp05hpP/VihUwYIufvs/LNogVYNQrtHepUnrN
+2+TmbHbZgNSv1Ldxt82UfB7y0FutKu6lhmXHyNecho3Fi8sih0V0aiSWmYuHfrAH
+GaiskEZKo1iiZvQXJIx9O2MCgYATBf0r9hTYMtyxtc6H3/sdd01C9thQ8gDy0yjP
+0Tqc0dMSJroDqmIWkoKYew9/bhFA4LW5TCnWkCAPbHmNtG4fdfbYwmkH/hdnA2y0
+jKdlpfp8GXeUFAGHGx17FA3sqFvgKUh0eWEgRHUL7vdQMVFBgJS93o7zQM94fLgP
+6cOB8wKBgFcGV4GjI2Ww9cillaC554MvoSjf8B/+04kXzDOh8iYIIzO9EUil1jjK
+Jvxp4hnLzTKWbux3MEWqurLkYas6GpKBjw+iNOCar6YdqWGVqM3RUx7PTUaZwkKx
+UdP63IfY7iZCIT/QbyHQvIUe2MaiVnH+ulxdkK6Y5e7gxcbckIH4
+-----END RSA PRIVATE KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
index 5aeb429a3d..757a26fc4c 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
@@ -1,7 +1,7 @@
------BEGIN PUBLIC KEY-----
-MIHKMIGjBgcqhkjOPQIBMIGXAgEBMBwGByqGSM49AQECEQD////9////////////
-////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1N
-aW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd
-7XqDAhEA/////gAAAAB1ow0bkDihFQIBAQMiAATrKj6RPHGPNKcZKIOccN4tgENM
-n1dzKjLrMZTkJ4oAaQ==
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIHKMIGjBgcqhkjOPQIBMIGXAgEBMBwGByqGSM49AQECEQD////9////////////
+////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1N
+aW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd
+7XqDAhEA/////gAAAAB1ow0bkDihFQIBAQMiAATrKj6RPHGPNKcZKIOccN4tgENM
+n1dzKjLrMZTkJ4oAaQ==
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
index 6fc427b1b1..88fa11eb8f 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
@@ -1,9 +1,9 @@
------BEGIN PUBLIC KEY-----
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
-WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
-RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
-ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
-Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
-7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
-GQIDAQAB
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
+WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
+RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
+ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
+Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
+7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
+GQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-rsa.pem b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
index 6fc427b1b1..88fa11eb8f 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
@@ -1,9 +1,9 @@
------BEGIN PUBLIC KEY-----
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
-WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
-RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
-ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
-Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
-7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
-GQIDAQAB
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
+WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
+RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
+ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
+Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
+7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
+GQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.crt b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.crt
index 59b651be2a..1b2c57bc6a 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.crt
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.crt
@@ -1,20 +1,20 @@
------BEGIN CERTIFICATE-----
-MIIDLjCCAhYCCQDn/Yvym+FMsDANBgkqhkiG9w0BAQUFADBZMQswCQYDVQQGEwJB
-VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTYwNjEzMjIyMTQ2WhcN
-MjYwNjExMjIyMTQ2WjBZMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0
-ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDEwls
-b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCs29IuzZvk
-OGUkS/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du99
-8xbgeihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT
-1DepD/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQr
-mTbLzzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J
-92K+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNb
-O9hVS4bqqsw9AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACE0WBuTbHcPtYKv2ZMS
-mYk9jvtAhmWHQ6tNqV8CmS2AsrzZdWglGaqIRsm5slkD2BGeQS+BesTArUuENTmP
-r9kJSecdiiB8aWtLbhoCSH3QR6IW/b5UVl6sR5OIh7SkNTjMSUSDnMEVLNGyKZGS
-gCGVbDf3n5KhOTnwqguELRykynKFt2LVksBia9+88lUtiRHpbyClo/KVWltJlaww
-PT0WEpwqVUcHmwrR3MTzJDEPvIplSgxdaDmFGYS1YKm9T/wQd+t/0DbXMmfJXBbd
-FVUnB6o7qJVU9N2Tbaj9NbCtwz5nTZG4A5kRXWHVjZsn5WzLuS/me3rDXjwlfB2p
-ipY=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDLjCCAhYCCQDn/Yvym+FMsDANBgkqhkiG9w0BAQUFADBZMQswCQYDVQQGEwJB
+VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTYwNjEzMjIyMTQ2WhcN
+MjYwNjExMjIyMTQ2WjBZMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0
+ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDEwls
+b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCs29IuzZvk
+OGUkS/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du99
+8xbgeihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT
+1DepD/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQr
+mTbLzzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J
+92K+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNb
+O9hVS4bqqsw9AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACE0WBuTbHcPtYKv2ZMS
+mYk9jvtAhmWHQ6tNqV8CmS2AsrzZdWglGaqIRsm5slkD2BGeQS+BesTArUuENTmP
+r9kJSecdiiB8aWtLbhoCSH3QR6IW/b5UVl6sR5OIh7SkNTjMSUSDnMEVLNGyKZGS
+gCGVbDf3n5KhOTnwqguELRykynKFt2LVksBia9+88lUtiRHpbyClo/KVWltJlaww
+PT0WEpwqVUcHmwrR3MTzJDEPvIplSgxdaDmFGYS1YKm9T/wQd+t/0DbXMmfJXBbd
+FVUnB6o7qJVU9N2Tbaj9NbCtwz5nTZG4A5kRXWHVjZsn5WzLuS/me3rDXjwlfB2p
+ipY=
+-----END CERTIFICATE-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.csr b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.csr
index 8782222c5a..1206d6e78c 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.csr
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.csr
@@ -1,17 +1,17 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICnjCCAYYCAQAwWTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUx
-ITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAxMJbG9j
-YWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNvSLs2b5Dhl
-JEv8Kis3f4dnrKowko8OEiy23odRgN1BL4dZPfnkYmMCRtcgjh5nLKeAPA7vffMW
-4HooaVlsO6Yy+VVZMt3Irrx8s9QnOmykabPxs1SQcBT9IMx5yvG1DPOlOdshk9Q3
-qQ/2NpVEctIoHVXADIxsHjMKE5omlXMGXsX2LhHn/o8935qZjsD/a26CAPa0K5k2
-y885GwMGV3Zfm0byHnyIyGsyM0zrPLSVq4RWkyVIAYYS4xSME3aUvp/hajrvCfdi
-vj7yoyHid5Jp2ckRyu7onZQJ9IPwyvnKNbF98zkTwlnoNtSvv71R04/dcwETWzvY
-VUuG6qrMPQIDAQABoAAwDQYJKoZIhvcNAQEFBQADggEBAEPHySnpf3E/7tZsiDka
-rqdB/sU7fdqjyV0iy0cuKQkU8WYrsE7bHkqMYc8CiIDfWhIGW5Jnzups2O6eH0Sx
-2BS21ARFiNGC1UfY1HSV2zrTNh3RqQa3YsXzv9vvdQ/gjsqGDuGDIc1yAA+Ytdja
-3rhIzEVqBhiLzg+M2+gW1zs+Kqj0Zo0pLB2uqhdZJmjxBb2FCli50vCVEhqIS3RO
-KTE+AJfxThWIeahFyVaskaEGkS6NVr2JihV0elbKolH19k2UzRTVn7p3Ixh5ojuW
-gtU/90vOy/SDkSRmCWMqgkUKJ2oeImleHdrvwNyrzvrLWRAz6R5yGQJwji9kKpHD
-FK0=
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICnjCCAYYCAQAwWTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUx
+ITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAxMJbG9j
+YWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNvSLs2b5Dhl
+JEv8Kis3f4dnrKowko8OEiy23odRgN1BL4dZPfnkYmMCRtcgjh5nLKeAPA7vffMW
+4HooaVlsO6Yy+VVZMt3Irrx8s9QnOmykabPxs1SQcBT9IMx5yvG1DPOlOdshk9Q3
+qQ/2NpVEctIoHVXADIxsHjMKE5omlXMGXsX2LhHn/o8935qZjsD/a26CAPa0K5k2
+y885GwMGV3Zfm0byHnyIyGsyM0zrPLSVq4RWkyVIAYYS4xSME3aUvp/hajrvCfdi
+vj7yoyHid5Jp2ckRyu7onZQJ9IPwyvnKNbF98zkTwlnoNtSvv71R04/dcwETWzvY
+VUuG6qrMPQIDAQABoAAwDQYJKoZIhvcNAQEFBQADggEBAEPHySnpf3E/7tZsiDka
+rqdB/sU7fdqjyV0iy0cuKQkU8WYrsE7bHkqMYc8CiIDfWhIGW5Jnzups2O6eH0Sx
+2BS21ARFiNGC1UfY1HSV2zrTNh3RqQa3YsXzv9vvdQ/gjsqGDuGDIc1yAA+Ytdja
+3rhIzEVqBhiLzg+M2+gW1zs+Kqj0Zo0pLB2uqhdZJmjxBb2FCli50vCVEhqIS3RO
+KTE+AJfxThWIeahFyVaskaEGkS6NVr2JihV0elbKolH19k2UzRTVn7p3Ixh5ojuW
+gtU/90vOy/SDkSRmCWMqgkUKJ2oeImleHdrvwNyrzvrLWRAz6R5yGQJwji9kKpHD
+FK0=
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.key b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.key
index 6da70f5aec..27b738af8e 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.key
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/certificate/server.key
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCs29IuzZvkOGUk
-S/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du998xbg
-eihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT1Dep
-D/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQrmTbL
-zzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J92K+
-PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNbO9hV
-S4bqqsw9AgMBAAECggEAd/LuDeZFZ/+uR5qmuAhXMZqfWZSbsges5vW6S/6wkvB1
-vGp6heQzFAbKXKgJgjUcuULeXE6s58RYuppqEnin/1hcBOKxy/dUu9Q14H+2XPdo
-u6TPcvaaZ/xYjnr1hNtnHD6yB8zEpxVbLmjSHJxF7Dti9MA9TTfgCrC2LFYKsicD
-/5AQyHuwpHyTL3Iiwv4Qtks/SD2a3fu8lD0yTQwA/hY6/0ieXxXd9tZV5a6GSA0P
-nieol1byfuX7Q5fb8ggPd9u9K1mVZTBRKiE5w+uU4Ic2IkBmZX5ZuRS+vFplpLsY
-YpFPvzFmpNkpK2SdYjJ+V4tkJsFHmOaFRgW/0QB2DQKBgQDeQMSZBQlPUrgRdWHN
-OyvTcrSvXzg5DbaIj39tgdNZ6PYns/thD0n707KGRJOChIyYiiKxLxzLWdPUxqQO
-rNLUV9IkMVc/QZR8RUqGc2BxmPOxAprhzeOhLsyqP/sgtxRHAnLqmkXuHYoxvTZ6
-LFCRCZBpEJrutGxl3s/x+sfkuwKBgQDHGwnSmvArpL8ZY1dV4xKNkxifCBnNmqAl
-TKHPW3odN9nkMECEt1XUIioUUKXUsiAZNp5xa/v1DEyJ4f2T20QKcAGbS18b1M5W
-axIoH3IhyLo74tuo0fthgq5bzypfFOlIjo7F9mpEky/461RWmoNAAlp9+FkDi48C
-KwjAk39/ZwKBgQDXFJqs8sDFsOlMi+nvsHmDERhmNqG0JN8mXKgWk3KzKc09MuHs
-Vd1lBMNZSHfv8NIWtGdKTKty5yUmXm1ZfkoxECPevpkOMCq/8FZksrb8d+YswLae
-Gp9U1nNdtrkSOdo3tdj7y/wsqQ2ZgOB9bvEwyq6j3lvw8U2NcAiQxf44DQKBgBHb
-lPf0uZHQhutKA61KXoGgLdclrNrKAY8W3nRwqfUw6zQSN9cvcl1Cay/DQ/xdtY9N
-XMyjeMezwLGlOU8nnWSqQxqgmfkvDwqlM82xdFUfYcS5RiZQHxHR3L2TSSOaBoph
-buDGhyV7ZhQXV0slNJxrGZ6uxZ0RyVPSdEiBcjAFAoGBAJqZ6uCVHpv/FwZVggu7
-Xb9EIxZnLSmXwaXFpJoMZpRpKb8cSTTJbgSMv3Dq2LcNKYXdNBhgKgPSc/XipXt9
-ZdT36KWipV+PzW691kUiWHtA8/+E0LCi4Y7rlcBMz9PgDNXK4XMMZOVKxDqPcHSJ
-P6y01ku7T2X+abUiJ334Hg6G
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCs29IuzZvkOGUk
+S/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du998xbg
+eihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT1Dep
+D/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQrmTbL
+zzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J92K+
+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNbO9hV
+S4bqqsw9AgMBAAECggEAd/LuDeZFZ/+uR5qmuAhXMZqfWZSbsges5vW6S/6wkvB1
+vGp6heQzFAbKXKgJgjUcuULeXE6s58RYuppqEnin/1hcBOKxy/dUu9Q14H+2XPdo
+u6TPcvaaZ/xYjnr1hNtnHD6yB8zEpxVbLmjSHJxF7Dti9MA9TTfgCrC2LFYKsicD
+/5AQyHuwpHyTL3Iiwv4Qtks/SD2a3fu8lD0yTQwA/hY6/0ieXxXd9tZV5a6GSA0P
+nieol1byfuX7Q5fb8ggPd9u9K1mVZTBRKiE5w+uU4Ic2IkBmZX5ZuRS+vFplpLsY
+YpFPvzFmpNkpK2SdYjJ+V4tkJsFHmOaFRgW/0QB2DQKBgQDeQMSZBQlPUrgRdWHN
+OyvTcrSvXzg5DbaIj39tgdNZ6PYns/thD0n707KGRJOChIyYiiKxLxzLWdPUxqQO
+rNLUV9IkMVc/QZR8RUqGc2BxmPOxAprhzeOhLsyqP/sgtxRHAnLqmkXuHYoxvTZ6
+LFCRCZBpEJrutGxl3s/x+sfkuwKBgQDHGwnSmvArpL8ZY1dV4xKNkxifCBnNmqAl
+TKHPW3odN9nkMECEt1XUIioUUKXUsiAZNp5xa/v1DEyJ4f2T20QKcAGbS18b1M5W
+axIoH3IhyLo74tuo0fthgq5bzypfFOlIjo7F9mpEky/461RWmoNAAlp9+FkDi48C
+KwjAk39/ZwKBgQDXFJqs8sDFsOlMi+nvsHmDERhmNqG0JN8mXKgWk3KzKc09MuHs
+Vd1lBMNZSHfv8NIWtGdKTKty5yUmXm1ZfkoxECPevpkOMCq/8FZksrb8d+YswLae
+Gp9U1nNdtrkSOdo3tdj7y/wsqQ2ZgOB9bvEwyq6j3lvw8U2NcAiQxf44DQKBgBHb
+lPf0uZHQhutKA61KXoGgLdclrNrKAY8W3nRwqfUw6zQSN9cvcl1Cay/DQ/xdtY9N
+XMyjeMezwLGlOU8nnWSqQxqgmfkvDwqlM82xdFUfYcS5RiZQHxHR3L2TSSOaBoph
+buDGhyV7ZhQXV0slNJxrGZ6uxZ0RyVPSdEiBcjAFAoGBAJqZ6uCVHpv/FwZVggu7
+Xb9EIxZnLSmXwaXFpJoMZpRpKb8cSTTJbgSMv3Dq2LcNKYXdNBhgKgPSc/XipXt9
+ZdT36KWipV+PzW691kUiWHtA8/+E0LCi4Y7rlcBMz9PgDNXK4XMMZOVKxDqPcHSJ
+P6y01ku7T2X+abUiJ334Hg6G
+-----END PRIVATE KEY-----
diff --git a/tests/pulsar-client-all-shade-test/src/test/resources/pulsar.xml b/tests/pulsar-client-all-shade-test/src/test/resources/pulsar.xml
index 5c725f80ea..1e50060ab6 100644
--- a/tests/pulsar-client-all-shade-test/src/test/resources/pulsar.xml
+++ b/tests/pulsar-client-all-shade-test/src/test/resources/pulsar.xml
@@ -1,29 +1,29 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Shade Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-client-all-shade-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
-            <class name="org.apache.pulsar.tests.integration.SimpleProducerConsumerTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Shade Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-client-all-shade-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
+            <class name="org.apache.pulsar.tests.integration.SimpleProducerConsumerTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/pulsar-client-shade-test/pom.xml b/tests/pulsar-client-shade-test/pom.xml
index 7859d69b00..afeca55358 100644
--- a/tests/pulsar-client-shade-test/pom.xml
+++ b/tests/pulsar-client-shade-test/pom.xml
@@ -1,117 +1,117 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <parent>
-        <groupId>org.apache.pulsar.tests</groupId>
-        <artifactId>tests-parent</artifactId>
-        <version>4.1.2</version>
-    </parent>
-
-    <artifactId>pulsar-client-shade-test</artifactId>
-    <packaging>jar</packaging>
-    <name>Apache Pulsar :: Tests :: Pulsar-Client-Shade Test</name>
-
-    <dependencies>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.pulsar</groupId>
-            <artifactId>pulsar-client-admin</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.testcontainers</groupId>
-            <artifactId>testcontainers</artifactId>
-            <scope>test</scope>
-        </dependency>
-
-    </dependencies>
-
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <configuration>
-                    <!-- only run tests when -DShadeTests is specified //-->
-                    <skipTests>true</skipTests>
-                    <systemPropertyVariables>
-                        <currentVersion>${project.version}</currentVersion>
-                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
-                    </systemPropertyVariables>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-
-    <profiles>
-        <profile>
-            <id>ShadeTests</id>
-            <activation>
-                <property>
-                    <name>ShadeTests</name>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
-                                ${test.additional.args}
-                            </argLine>
-                            <skipTests>false</skipTests>
-                            <suiteXmlFiles>
-                                <file>src/test/resources/pulsar.xml</file>
-                            </suiteXmlFiles>
-                            <forkCount>1</forkCount>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.pulsar.tests</groupId>
+        <artifactId>tests-parent</artifactId>
+        <version>4.1.2</version>
+    </parent>
+
+    <artifactId>pulsar-client-shade-test</artifactId>
+    <packaging>jar</packaging>
+    <name>Apache Pulsar :: Tests :: Pulsar-Client-Shade Test</name>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.pulsar</groupId>
+            <artifactId>pulsar-client-admin</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>test-jar</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <!-- only run tests when -DShadeTests is specified //-->
+                    <skipTests>true</skipTests>
+                    <systemPropertyVariables>
+                        <currentVersion>${project.version}</currentVersion>
+                        <maven.buildDirectory>${project.build.directory}</maven.buildDirectory>
+                    </systemPropertyVariables>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <profiles>
+        <profile>
+            <id>ShadeTests</id>
+            <activation>
+                <property>
+                    <name>ShadeTests</name>
+                </property>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <argLine>${testJacocoAgentArgument} -XX:+ExitOnOutOfMemoryError -Xmx2G -XX:MaxDirectMemorySize=8G
+                                ${test.additional.args}
+                            </argLine>
+                            <skipTests>false</skipTests>
+                            <suiteXmlFiles>
+                                <file>src/test/resources/pulsar.xml</file>
+                            </suiteXmlFiles>
+                            <forkCount>1</forkCount>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
+</project>
diff --git a/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java b/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
index 365b4cca81..3a849a3ad1 100644
--- a/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
+++ b/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/PulsarContainer.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static java.time.temporal.ChronoUnit.SECONDS;
-import java.time.Duration;
-import org.testcontainers.containers.GenericContainer;
-import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
-
-public class PulsarContainer extends GenericContainer<PulsarContainer> {
-
-    public static final int PULSAR_PORT = 6650;
-    public static final int BROKER_HTTP_PORT = 8080;
-    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
-            "apachepulsar/pulsar-test-latest-version:latest");
-
-    public PulsarContainer() {
-        this(DEFAULT_IMAGE_NAME);
-    }
-
-    public PulsarContainer(final String pulsarVersion) {
-        super(pulsarVersion);
-        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
-        withCommand("/pulsar/bin/pulsar standalone");
-        waitingFor(new HttpWaitStrategy()
-                .forPort(BROKER_HTTP_PORT)
-                .forStatusCode(200)
-                .forPath("/admin/v2/namespaces/public/default")
-                .withStartupTimeout(Duration.of(300, SECONDS)));
-    }
-
-    public String getPlainTextPulsarBrokerUrl() {
-        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
-    }
-
-    public String getPulsarAdminUrl() {
-        return String.format("http://%s:%s", this.getHost(), this.getMappedPort(BROKER_HTTP_PORT));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static java.time.temporal.ChronoUnit.SECONDS;
+import java.time.Duration;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+public class PulsarContainer extends GenericContainer<PulsarContainer> {
+
+    public static final int PULSAR_PORT = 6650;
+    public static final int BROKER_HTTP_PORT = 8080;
+    public static final String DEFAULT_IMAGE_NAME = System.getenv().getOrDefault("PULSAR_TEST_IMAGE_NAME",
+            "apachepulsar/pulsar-test-latest-version:latest");
+
+    public PulsarContainer() {
+        this(DEFAULT_IMAGE_NAME);
+    }
+
+    public PulsarContainer(final String pulsarVersion) {
+        super(pulsarVersion);
+        withExposedPorts(BROKER_HTTP_PORT, PULSAR_PORT);
+        withCommand("/pulsar/bin/pulsar standalone");
+        waitingFor(new HttpWaitStrategy()
+                .forPort(BROKER_HTTP_PORT)
+                .forStatusCode(200)
+                .forPath("/admin/v2/namespaces/public/default")
+                .withStartupTimeout(Duration.of(300, SECONDS)));
+    }
+
+    public String getPlainTextPulsarBrokerUrl() {
+        return String.format("pulsar://%s:%s", this.getHost(), this.getMappedPort(PULSAR_PORT));
+    }
+
+    public String getPulsarAdminUrl() {
+        return String.format("http://%s:%s", this.getHost(), this.getMappedPort(BROKER_HTTP_PORT));
+    }
+
+}
diff --git a/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java b/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
index 24c8d0869a..4d5d579d4c 100644
--- a/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
+++ b/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SimpleProducerConsumerTest.java
@@ -1,606 +1,606 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.assertTrue;
-import java.io.IOException;
-import java.net.URI;
-import java.nio.ByteBuffer;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.security.Security;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.admin.PulsarAdmin;
-import org.apache.pulsar.client.api.CompressionType;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.ConsumerCryptoFailureAction;
-import org.apache.pulsar.client.api.CryptoKeyReader;
-import org.apache.pulsar.client.api.EncryptionKeyInfo;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.MessageRoutingMode;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.client.impl.MessageImpl;
-import org.apache.pulsar.client.impl.TopicMessageImpl;
-import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;
-import org.apache.pulsar.common.api.EncryptionContext;
-import org.apache.pulsar.common.api.proto.MessageMetadata;
-import org.apache.pulsar.common.api.proto.SingleMessageMetadata;
-import org.apache.pulsar.common.compression.CompressionCodec;
-import org.apache.pulsar.common.compression.CompressionCodecProvider;
-import org.apache.pulsar.common.policies.data.TenantInfo;
-import org.apache.pulsar.common.protocol.Commands;
-import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;
-import org.apache.pulsar.shade.io.netty.buffer.Unpooled;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SimpleProducerConsumerTest extends TestRetrySupport {
-    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);
-
-    private PulsarContainer pulsarContainer;
-    private URI lookupUrl;
-    private PulsarClient pulsarClient;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public void setup() throws Exception {
-        incrementSetupNumber();
-        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-        pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());
-
-        @Cleanup
-        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
-        admin.tenants().createTenant("my-property",
-                TenantInfo.builder().adminRoles(new HashSet<>(Arrays.asList("appid1", "appid2")))
-                .allowedClusters(Collections.singleton("standalone")).build());
-        admin.namespaces().createNamespace("my-property/my-ns");
-        admin.namespaces().setNamespaceReplicationClusters("my-property/my-ns", Collections.singleton("standalone"));
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public void cleanup() throws Exception {
-        markCurrentSetupNumberCleaned();
-        if (pulsarClient != null) {
-            pulsarClient.close();
-            pulsarClient = null;
-        }
-        if (pulsarContainer != null) {
-            pulsarContainer.stop();
-            pulsarContainer.close();
-            pulsarContainer = null;
-        }
-    }
-
-    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {
-        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();
-    }
-
-    @Test
-    public void testRSAEncryption() throws Exception {
-
-        String topicName = "persistent://my-property/my-ns/myrsa-topic1-" + System.currentTimeMillis();
-
-        class EncKeyReader implements CryptoKeyReader {
-
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        final int totalMsg = 10;
-
-        Set<String> messageSet = new HashSet<>();
-        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader()).subscribe();
-        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()
-                .topic(topicName).subscriptionName("my-subscriber-name-normal")
-                .subscribe();
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-        Producer<byte[]> producer2 = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
-                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-
-        for (int i = 0; i < totalMsg; i++) {
-            String message = "my-message-" + i;
-            producer.send(message.getBytes());
-        }
-        for (int i = totalMsg; i < totalMsg * 2; i++) {
-            String message = "my-message-" + i;
-            producer2.send(message.getBytes());
-        }
-
-        MessageImpl<byte[]> msg = null;
-
-        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);
-        // should not able to read message using normal message.
-        assertNull(msg);
-
-        for (int i = 0; i < totalMsg * 2; i++) {
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            // verify that encrypted message contains encryption-context
-            msg.getEncryptionCtx()
-                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-            String receivedMessage = new String(msg.getData());
-            log.debug("Received message: [{}]", receivedMessage);
-            String expectedMessage = "my-message-" + i;
-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
-        }
-        // Acknowledge the consumption of all messages at once
-        consumer.acknowledgeCumulative(msg);
-        consumer.close();
-    }
-
-    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,
-                                                     T expectedMessage) {
-        // Make sure that messages are received in order
-        assertEquals(receivedMessage, expectedMessage,
-                "Received message " + receivedMessage + " did not match the expected message " + expectedMessage);
-
-        // Make sure that there are no duplicates
-        assertTrue(messagesReceived.add(receivedMessage), "Received duplicate message " + receivedMessage);
-    }
-
-    @Test
-    public void testRedeliveryOfFailedMessages() throws Exception {
-
-        @Cleanup
-        PulsarClient pulsarClient = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String encryptionKeyName = "client-rsa.pem";
-        final String encryptionKeyVersion = "1.0";
-        Map<String, String> metadata = new HashMap<>();
-        metadata.put("version", encryptionKeyVersion);
-        class EncKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        class InvalidKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {
-                return null;
-            }
-        }
-
-        /*
-         * Redelivery functionality guarantees that customer will get a chance to process the message again.
-         * In case of shared subscription eventually every client will get a chance to process the message,
-         * till one of them acks it.
-         *
-         * For client with Encryption enabled where in cases like a new production rollout or a buggy client
-         * configuration, we might have a mismatch of consumers
-         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).
-         *
-         * In that case eventually all messages should be acked as long as there is a single consumer
-         * who can decrypt the message.
-         *
-         * Consumer 1 - Can decrypt message
-         * Consumer 2 - Has invalid Reader configured.
-         * Consumer 3 - Has no reader configured.
-         *
-         */
-
-        String topicName = "persistent://my-property/my-ns/myrsa-topic2";
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
-                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
-                .cryptoKeyReader(new EncKeyReader()).create();
-
-        @Cleanup
-        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader())
-                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        @Cleanup
-        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").cryptoKeyReader(new InvalidKeyReader())
-                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        @Cleanup
-        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
-        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)
-                .subscriptionName("my-subscriber-name").subscriptionType(SubscriptionType.Shared)
-                .ackTimeout(1, TimeUnit.SECONDS).subscribe();
-
-        int numberOfMessages = 100;
-        String message = "my-message";
-        Set<String> messages = new HashSet<>(); // Since messages are in random order
-        for (int i = 0; i < numberOfMessages; i++) {
-            producer.send((message + i).getBytes());
-        }
-
-        // Consuming from consumer 2 and 3
-        // no message should be returned since they can't decrypt the message
-        Message<byte[]> m = consumer2.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-        m = consumer3.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-
-        for (int i = 0; i < numberOfMessages; i++) {
-            // All messages would be received by consumer 1
-            m = consumer1.receive();
-            messages.add(new String(m.getData()));
-            consumer1.acknowledge(m);
-        }
-
-        // Consuming from consumer 2 and 3 again just to be sure
-        // no message should be returned since they can't decrypt the message
-        m = consumer2.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-        m = consumer3.receive(3, TimeUnit.SECONDS);
-        assertNull(m);
-
-        // checking if all messages were received
-        for (int i = 0; i < numberOfMessages; i++) {
-            assertTrue(messages.contains((message + i)));
-        }
-
-        consumer1.close();
-        consumer2.close();
-        consumer3.close();
-    }
-
-    @Test
-    public void testEncryptionFailure() throws Exception {
-
-        class EncKeyReader implements CryptoKeyReader {
-
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        log.error("Failed to read certificate from {}", certFilePath);
-                    }
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        return keyInfo;
-                    } catch (IOException e) {
-                        log.error("Failed to read certificate from {}", certFilePath);
-                    }
-                }
-                return null;
-            }
-        }
-
-        final int totalMsg = 10;
-
-        MessageImpl<byte[]> msg = null;
-        Set<String> messageSet = new HashSet<>();
-        Consumer<byte[]> consumer = pulsarClient.newConsumer()
-                .topic("persistent://my-property/use/myenc-ns/myenc-topic1").subscriptionName("my-subscriber-name")
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        // 1. Invalid key name
-        try {
-            pulsarClient.newProducer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                    .addEncryptionKey("client-non-existant-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
-            Assert.fail("Producer creation should not suceed if failing to read key");
-        } catch (Exception e) {
-            // ok
-        }
-
-        // 2. Producer with valid key name
-        Producer<byte[]> producer = pulsarClient.newProducer()
-                .topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .addEncryptionKey("client-rsa.pem")
-                .cryptoKeyReader(new EncKeyReader())
-                .enableBatching(false)
-                .messageRoutingMode(MessageRoutingMode.SinglePartition)
-                .create();
-
-        for (int i = 0; i < totalMsg; i++) {
-            String message = "my-message-" + i;
-            producer.send(message.getBytes());
-        }
-
-        // 3. KeyReder is not set by consumer
-        // Receive should fail since key reader is not setup
-        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-        assertNull(msg, "Receive should have failed with no keyreader");
-
-        // 4. Set consumer config to consume even if decryption fails
-        consumer.close();
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        int msgNum = 0;
-        try {
-            // Receive should proceed and deliver encrypted message
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            String receivedMessage = new String(msg.getData());
-            String expectedMessage = "my-message-" + msgNum++;
-            Assert.assertNotEquals(receivedMessage, expectedMessage, "Received encrypted message " + receivedMessage
-                    + " should not match the expected message " + expectedMessage);
-            consumer.acknowledgeCumulative(msg);
-        } catch (Exception e) {
-            e.printStackTrace();
-            Assert.fail("Failed to receive message even after ConsumerCryptoFailureAction.CONSUME is set.");
-        }
-
-        // 5. Set keyreader and failure action
-        consumer.close();
-        // Set keyreader
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.FAIL)
-                .cryptoKeyReader(new EncKeyReader()).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        for (int i = msgNum; i < totalMsg - 1; i++) {
-            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-            // verify that encrypted message contains encryption-context
-            msg.getEncryptionCtx()
-                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-            String receivedMessage = new String(msg.getData());
-            log.debug("Received message: [{}]", receivedMessage);
-            String expectedMessage = "my-message-" + i;
-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
-        }
-        // Acknowledge the consumption of all messages at once
-        consumer.acknowledgeCumulative(msg);
-        consumer.close();
-
-        // 6. Set consumer config to discard if decryption fails
-        consumer.close();
-        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.DISCARD)
-                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
-
-        // Receive should proceed and discard encrypted messages
-        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-        assertNull(msg, "Message received even aftet ConsumerCryptoFailureAction.DISCARD is set.");
-    }
-
-    @Test
-    public void testEncryptionConsumerWithoutCryptoReader() throws Exception {
-
-        final String encryptionKeyName = "client-rsa.pem";
-        final String encryptionKeyVersion = "1.0";
-        Map<String, String> metadata = new HashMap<>();
-        metadata.put("version", encryptionKeyVersion);
-        class EncKeyReader implements CryptoKeyReader {
-            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
-
-            @Override
-            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-
-            @Override
-            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
-                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
-                if (Files.isReadable(Paths.get(certFilePath))) {
-                    try {
-                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
-                        keyInfo.setMetadata(metadata);
-                        return keyInfo;
-                    } catch (IOException e) {
-                        Assert.fail("Failed to read certificate from " + certFilePath);
-                    }
-                } else {
-                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
-                }
-                return null;
-            }
-        }
-
-        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic3")
-                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
-                .cryptoKeyReader(new EncKeyReader()).create();
-
-        Consumer<byte[]> consumer =
-                pulsarClient.newConsumer().topicsPattern("persistent://my-property/my-ns/myrsa-topic3")
-                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
-                .subscribe();
-
-        String message = "my-message";
-        producer.send(message.getBytes());
-
-        TopicMessageImpl<byte[]> msg = (TopicMessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
-
-        String receivedMessage = decryptMessage(msg, encryptionKeyName, new EncKeyReader());
-        assertEquals(message, receivedMessage);
-
-        consumer.close();
-    }
-
-    private String decryptMessage(TopicMessageImpl<byte[]> msg, String encryptionKeyName, CryptoKeyReader reader)
-            throws Exception {
-        Optional<EncryptionContext> ctx = msg.getEncryptionCtx();
-        assertTrue(ctx.isPresent());
-        EncryptionContext encryptionCtx = ctx
-                .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
-
-        Map<String, EncryptionContext.EncryptionKey> keys = encryptionCtx.getKeys();
-        assertEquals(keys.size(), 1);
-        EncryptionContext.EncryptionKey encryptionKey = keys.get(encryptionKeyName);
-        byte[] dataKey = encryptionKey.getKeyValue();
-        Map<String, String> metadata = encryptionKey.getMetadata();
-        String version = metadata.get("version");
-        assertEquals(version, "1.0");
-
-        CompressionType compressionType = encryptionCtx.getCompressionType();
-        int uncompressedSize = encryptionCtx.getUncompressedMessageSize();
-        byte[] encrParam = encryptionCtx.getParam();
-        String encAlgo = encryptionCtx.getAlgorithm();
-        int batchSize = encryptionCtx.getBatchSize().orElse(0);
-
-        ByteBuffer payloadBuf = ByteBuffer.wrap(msg.getData());
-        // try to decrypt use default MessageCryptoBc
-        MessageCryptoBc crypto = new MessageCryptoBc("test", false);
-        MessageMetadata msgMetadata = new MessageMetadata()
-                .setEncryptionParam(encrParam)
-                .setProducerName("test")
-                .setSequenceId(123)
-                .setPublishTime(12333453454L)
-                .setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType))
-                .setUncompressedSize(uncompressedSize);
-
-        if (encAlgo != null) {
-            msgMetadata.setEncryptionAlgo(encAlgo);
-        }
-
-        msgMetadata.addEncryptionKey()
-            .setKey(encryptionKeyName)
-            .setValue(dataKey);
-
-        ByteBuffer decryptedPayload = ByteBuffer.allocate(crypto.getMaxOutputSize(payloadBuf.remaining()));
-        crypto.decrypt(() -> msgMetadata, payloadBuf, decryptedPayload, reader);
-
-        // try to uncompress
-        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);
-        ByteBuf uncompressedPayload = codec.decode(Unpooled.wrappedBuffer(decryptedPayload), uncompressedSize);
-
-        if (batchSize > 0) {
-            SingleMessageMetadata singleMessageMetadata = new SingleMessageMetadata();
-            uncompressedPayload = Commands.deSerializeSingleMessageInBatch(uncompressedPayload,
-                    singleMessageMetadata, 0, batchSize);
-        }
-
-        byte[] data = new byte[uncompressedPayload.readableBytes()];
-        uncompressedPayload.readBytes(data);
-        uncompressedPayload.release();
-        return new String(data);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import java.io.IOException;
+import java.net.URI;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.api.CompressionType;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerCryptoFailureAction;
+import org.apache.pulsar.client.api.CryptoKeyReader;
+import org.apache.pulsar.client.api.EncryptionKeyInfo;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageRoutingMode;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.client.impl.MessageImpl;
+import org.apache.pulsar.client.impl.TopicMessageImpl;
+import org.apache.pulsar.client.impl.crypto.MessageCryptoBc;
+import org.apache.pulsar.common.api.EncryptionContext;
+import org.apache.pulsar.common.api.proto.MessageMetadata;
+import org.apache.pulsar.common.api.proto.SingleMessageMetadata;
+import org.apache.pulsar.common.compression.CompressionCodec;
+import org.apache.pulsar.common.compression.CompressionCodecProvider;
+import org.apache.pulsar.common.policies.data.TenantInfo;
+import org.apache.pulsar.common.protocol.Commands;
+import org.apache.pulsar.shade.io.netty.buffer.ByteBuf;
+import org.apache.pulsar.shade.io.netty.buffer.Unpooled;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SimpleProducerConsumerTest extends TestRetrySupport {
+    private static final Logger log = LoggerFactory.getLogger(SimpleProducerConsumerTest.class);
+
+    private PulsarContainer pulsarContainer;
+    private URI lookupUrl;
+    private PulsarClient pulsarClient;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public void setup() throws Exception {
+        incrementSetupNumber();
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+        pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+        lookupUrl = new URI(pulsarContainer.getPlainTextPulsarBrokerUrl());
+
+        @Cleanup
+        PulsarAdmin admin = PulsarAdmin.builder().serviceHttpUrl(pulsarContainer.getPulsarAdminUrl()).build();
+        admin.tenants().createTenant("my-property",
+                TenantInfo.builder().adminRoles(new HashSet<>(Arrays.asList("appid1", "appid2")))
+                .allowedClusters(Collections.singleton("standalone")).build());
+        admin.namespaces().createNamespace("my-property/my-ns");
+        admin.namespaces().setNamespaceReplicationClusters("my-property/my-ns", Collections.singleton("standalone"));
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public void cleanup() throws Exception {
+        markCurrentSetupNumberCleaned();
+        if (pulsarClient != null) {
+            pulsarClient.close();
+            pulsarClient = null;
+        }
+        if (pulsarContainer != null) {
+            pulsarContainer.stop();
+            pulsarContainer.close();
+            pulsarContainer = null;
+        }
+    }
+
+    private PulsarClient newPulsarClient(String url, int intervalInSecs) throws PulsarClientException {
+        return PulsarClient.builder().serviceUrl(url).statsInterval(intervalInSecs, TimeUnit.SECONDS).build();
+    }
+
+    @Test
+    public void testRSAEncryption() throws Exception {
+
+        String topicName = "persistent://my-property/my-ns/myrsa-topic1-" + System.currentTimeMillis();
+
+        class EncKeyReader implements CryptoKeyReader {
+
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        final int totalMsg = 10;
+
+        Set<String> messageSet = new HashSet<>();
+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader()).subscribe();
+        Consumer<byte[]> normalConsumer = pulsarClient.newConsumer()
+                .topic(topicName).subscriptionName("my-subscriber-name-normal")
+                .subscribe();
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+        Producer<byte[]> producer2 = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic1")
+                .addEncryptionKey("client-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+
+        for (int i = 0; i < totalMsg; i++) {
+            String message = "my-message-" + i;
+            producer.send(message.getBytes());
+        }
+        for (int i = totalMsg; i < totalMsg * 2; i++) {
+            String message = "my-message-" + i;
+            producer2.send(message.getBytes());
+        }
+
+        MessageImpl<byte[]> msg = null;
+
+        msg = (MessageImpl<byte[]>) normalConsumer.receive(500, TimeUnit.MILLISECONDS);
+        // should not able to read message using normal message.
+        assertNull(msg);
+
+        for (int i = 0; i < totalMsg * 2; i++) {
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            // verify that encrypted message contains encryption-context
+            msg.getEncryptionCtx()
+                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+            String receivedMessage = new String(msg.getData());
+            log.debug("Received message: [{}]", receivedMessage);
+            String expectedMessage = "my-message-" + i;
+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
+        }
+        // Acknowledge the consumption of all messages at once
+        consumer.acknowledgeCumulative(msg);
+        consumer.close();
+    }
+
+    protected <T> void testMessageOrderAndDuplicates(Set<T> messagesReceived, T receivedMessage,
+                                                     T expectedMessage) {
+        // Make sure that messages are received in order
+        assertEquals(receivedMessage, expectedMessage,
+                "Received message " + receivedMessage + " did not match the expected message " + expectedMessage);
+
+        // Make sure that there are no duplicates
+        assertTrue(messagesReceived.add(receivedMessage), "Received duplicate message " + receivedMessage);
+    }
+
+    @Test
+    public void testRedeliveryOfFailedMessages() throws Exception {
+
+        @Cleanup
+        PulsarClient pulsarClient = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String encryptionKeyName = "client-rsa.pem";
+        final String encryptionKeyVersion = "1.0";
+        Map<String, String> metadata = new HashMap<>();
+        metadata.put("version", encryptionKeyVersion);
+        class EncKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        class InvalidKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> metadata) {
+                return null;
+            }
+        }
+
+        /*
+         * Redelivery functionality guarantees that customer will get a chance to process the message again.
+         * In case of shared subscription eventually every client will get a chance to process the message,
+         * till one of them acks it.
+         *
+         * For client with Encryption enabled where in cases like a new production rollout or a buggy client
+         * configuration, we might have a mismatch of consumers
+         * - few which can decrypt, few which can't (due to errors or cryptoReader not configured).
+         *
+         * In that case eventually all messages should be acked as long as there is a single consumer
+         * who can decrypt the message.
+         *
+         * Consumer 1 - Can decrypt message
+         * Consumer 2 - Has invalid Reader configured.
+         * Consumer 3 - Has no reader configured.
+         *
+         */
+
+        String topicName = "persistent://my-property/my-ns/myrsa-topic2";
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)
+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
+                .cryptoKeyReader(new EncKeyReader()).create();
+
+        @Cleanup
+        PulsarClient newPulsarClient = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer1 = newPulsarClient.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new EncKeyReader())
+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        @Cleanup
+        PulsarClient newPulsarClient1 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer2 = newPulsarClient1.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").cryptoKeyReader(new InvalidKeyReader())
+                .subscriptionType(SubscriptionType.Shared).ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        @Cleanup
+        PulsarClient newPulsarClient2 = newPulsarClient(lookupUrl.toString(), 0); // Creates new client connection
+        Consumer<byte[]> consumer3 = newPulsarClient2.newConsumer().topicsPattern(topicName)
+                .subscriptionName("my-subscriber-name").subscriptionType(SubscriptionType.Shared)
+                .ackTimeout(1, TimeUnit.SECONDS).subscribe();
+
+        int numberOfMessages = 100;
+        String message = "my-message";
+        Set<String> messages = new HashSet<>(); // Since messages are in random order
+        for (int i = 0; i < numberOfMessages; i++) {
+            producer.send((message + i).getBytes());
+        }
+
+        // Consuming from consumer 2 and 3
+        // no message should be returned since they can't decrypt the message
+        Message<byte[]> m = consumer2.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+        m = consumer3.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+
+        for (int i = 0; i < numberOfMessages; i++) {
+            // All messages would be received by consumer 1
+            m = consumer1.receive();
+            messages.add(new String(m.getData()));
+            consumer1.acknowledge(m);
+        }
+
+        // Consuming from consumer 2 and 3 again just to be sure
+        // no message should be returned since they can't decrypt the message
+        m = consumer2.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+        m = consumer3.receive(3, TimeUnit.SECONDS);
+        assertNull(m);
+
+        // checking if all messages were received
+        for (int i = 0; i < numberOfMessages; i++) {
+            assertTrue(messages.contains((message + i)));
+        }
+
+        consumer1.close();
+        consumer2.close();
+        consumer3.close();
+    }
+
+    @Test
+    public void testEncryptionFailure() throws Exception {
+
+        class EncKeyReader implements CryptoKeyReader {
+
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        log.error("Failed to read certificate from {}", certFilePath);
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        return keyInfo;
+                    } catch (IOException e) {
+                        log.error("Failed to read certificate from {}", certFilePath);
+                    }
+                }
+                return null;
+            }
+        }
+
+        final int totalMsg = 10;
+
+        MessageImpl<byte[]> msg = null;
+        Set<String> messageSet = new HashSet<>();
+        Consumer<byte[]> consumer = pulsarClient.newConsumer()
+                .topic("persistent://my-property/use/myenc-ns/myenc-topic1").subscriptionName("my-subscriber-name")
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        // 1. Invalid key name
+        try {
+            pulsarClient.newProducer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                    .addEncryptionKey("client-non-existant-rsa.pem").cryptoKeyReader(new EncKeyReader()).create();
+            Assert.fail("Producer creation should not suceed if failing to read key");
+        } catch (Exception e) {
+            // ok
+        }
+
+        // 2. Producer with valid key name
+        Producer<byte[]> producer = pulsarClient.newProducer()
+                .topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .addEncryptionKey("client-rsa.pem")
+                .cryptoKeyReader(new EncKeyReader())
+                .enableBatching(false)
+                .messageRoutingMode(MessageRoutingMode.SinglePartition)
+                .create();
+
+        for (int i = 0; i < totalMsg; i++) {
+            String message = "my-message-" + i;
+            producer.send(message.getBytes());
+        }
+
+        // 3. KeyReder is not set by consumer
+        // Receive should fail since key reader is not setup
+        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+        assertNull(msg, "Receive should have failed with no keyreader");
+
+        // 4. Set consumer config to consume even if decryption fails
+        consumer.close();
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        int msgNum = 0;
+        try {
+            // Receive should proceed and deliver encrypted message
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            String receivedMessage = new String(msg.getData());
+            String expectedMessage = "my-message-" + msgNum++;
+            Assert.assertNotEquals(receivedMessage, expectedMessage, "Received encrypted message " + receivedMessage
+                    + " should not match the expected message " + expectedMessage);
+            consumer.acknowledgeCumulative(msg);
+        } catch (Exception e) {
+            e.printStackTrace();
+            Assert.fail("Failed to receive message even after ConsumerCryptoFailureAction.CONSUME is set.");
+        }
+
+        // 5. Set keyreader and failure action
+        consumer.close();
+        // Set keyreader
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.FAIL)
+                .cryptoKeyReader(new EncKeyReader()).acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        for (int i = msgNum; i < totalMsg - 1; i++) {
+            msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+            // verify that encrypted message contains encryption-context
+            msg.getEncryptionCtx()
+                    .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+            String receivedMessage = new String(msg.getData());
+            log.debug("Received message: [{}]", receivedMessage);
+            String expectedMessage = "my-message-" + i;
+            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);
+        }
+        // Acknowledge the consumption of all messages at once
+        consumer.acknowledgeCumulative(msg);
+        consumer.close();
+
+        // 6. Set consumer config to discard if decryption fails
+        consumer.close();
+        consumer = pulsarClient.newConsumer().topic("persistent://my-property/use/myenc-ns/myenc-topic1")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.DISCARD)
+                .acknowledgmentGroupTime(0, TimeUnit.SECONDS).subscribe();
+
+        // Receive should proceed and discard encrypted messages
+        msg = (MessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+        assertNull(msg, "Message received even aftet ConsumerCryptoFailureAction.DISCARD is set.");
+    }
+
+    @Test
+    public void testEncryptionConsumerWithoutCryptoReader() throws Exception {
+
+        final String encryptionKeyName = "client-rsa.pem";
+        final String encryptionKeyVersion = "1.0";
+        Map<String, String> metadata = new HashMap<>();
+        metadata.put("version", encryptionKeyVersion);
+        class EncKeyReader implements CryptoKeyReader {
+            EncryptionKeyInfo keyInfo = new EncryptionKeyInfo();
+
+            @Override
+            public EncryptionKeyInfo getPublicKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/public-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+
+            @Override
+            public EncryptionKeyInfo getPrivateKey(String keyName, Map<String, String> keyMeta) {
+                String certFilePath = "./src/test/resources/certificate/private-key." + keyName;
+                if (Files.isReadable(Paths.get(certFilePath))) {
+                    try {
+                        keyInfo.setKey(Files.readAllBytes(Paths.get(certFilePath)));
+                        keyInfo.setMetadata(metadata);
+                        return keyInfo;
+                    } catch (IOException e) {
+                        Assert.fail("Failed to read certificate from " + certFilePath);
+                    }
+                } else {
+                    Assert.fail("Certificate file " + certFilePath + " is not present or not readable.");
+                }
+                return null;
+            }
+        }
+
+        Producer<byte[]> producer = pulsarClient.newProducer().topic("persistent://my-property/my-ns/myrsa-topic3")
+                .addEncryptionKey(encryptionKeyName).compressionType(CompressionType.LZ4)
+                .cryptoKeyReader(new EncKeyReader()).create();
+
+        Consumer<byte[]> consumer =
+                pulsarClient.newConsumer().topicsPattern("persistent://my-property/my-ns/myrsa-topic3")
+                .subscriptionName("my-subscriber-name").cryptoFailureAction(ConsumerCryptoFailureAction.CONSUME)
+                .subscribe();
+
+        String message = "my-message";
+        producer.send(message.getBytes());
+
+        TopicMessageImpl<byte[]> msg = (TopicMessageImpl<byte[]>) consumer.receive(5, TimeUnit.SECONDS);
+
+        String receivedMessage = decryptMessage(msg, encryptionKeyName, new EncKeyReader());
+        assertEquals(message, receivedMessage);
+
+        consumer.close();
+    }
+
+    private String decryptMessage(TopicMessageImpl<byte[]> msg, String encryptionKeyName, CryptoKeyReader reader)
+            throws Exception {
+        Optional<EncryptionContext> ctx = msg.getEncryptionCtx();
+        assertTrue(ctx.isPresent());
+        EncryptionContext encryptionCtx = ctx
+                .orElseThrow(() -> new IllegalStateException("encryption-ctx not present for encrypted message"));
+
+        Map<String, EncryptionContext.EncryptionKey> keys = encryptionCtx.getKeys();
+        assertEquals(keys.size(), 1);
+        EncryptionContext.EncryptionKey encryptionKey = keys.get(encryptionKeyName);
+        byte[] dataKey = encryptionKey.getKeyValue();
+        Map<String, String> metadata = encryptionKey.getMetadata();
+        String version = metadata.get("version");
+        assertEquals(version, "1.0");
+
+        CompressionType compressionType = encryptionCtx.getCompressionType();
+        int uncompressedSize = encryptionCtx.getUncompressedMessageSize();
+        byte[] encrParam = encryptionCtx.getParam();
+        String encAlgo = encryptionCtx.getAlgorithm();
+        int batchSize = encryptionCtx.getBatchSize().orElse(0);
+
+        ByteBuffer payloadBuf = ByteBuffer.wrap(msg.getData());
+        // try to decrypt use default MessageCryptoBc
+        MessageCryptoBc crypto = new MessageCryptoBc("test", false);
+        MessageMetadata msgMetadata = new MessageMetadata()
+                .setEncryptionParam(encrParam)
+                .setProducerName("test")
+                .setSequenceId(123)
+                .setPublishTime(12333453454L)
+                .setCompression(CompressionCodecProvider.convertToWireProtocol(compressionType))
+                .setUncompressedSize(uncompressedSize);
+
+        if (encAlgo != null) {
+            msgMetadata.setEncryptionAlgo(encAlgo);
+        }
+
+        msgMetadata.addEncryptionKey()
+            .setKey(encryptionKeyName)
+            .setValue(dataKey);
+
+        ByteBuffer decryptedPayload = ByteBuffer.allocate(crypto.getMaxOutputSize(payloadBuf.remaining()));
+        crypto.decrypt(() -> msgMetadata, payloadBuf, decryptedPayload, reader);
+
+        // try to uncompress
+        CompressionCodec codec = CompressionCodecProvider.getCompressionCodec(compressionType);
+        ByteBuf uncompressedPayload = codec.decode(Unpooled.wrappedBuffer(decryptedPayload), uncompressedSize);
+
+        if (batchSize > 0) {
+            SingleMessageMetadata singleMessageMetadata = new SingleMessageMetadata();
+            uncompressedPayload = Commands.deSerializeSingleMessageInBatch(uncompressedPayload,
+                    singleMessageMetadata, 0, batchSize);
+        }
+
+        byte[] data = new byte[uncompressedPayload.readableBytes()];
+        uncompressedPayload.readBytes(data);
+        uncompressedPayload.release();
+        return new String(data);
+    }
+
+}
diff --git a/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java b/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
index e67788fc7d..82a9cce7e8 100644
--- a/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
+++ b/tests/pulsar-client-shade-test/src/test/java/org/apache/pulsar/tests/integration/SmokeTest.java
@@ -1,84 +1,84 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.pulsar.tests.integration;
-
-import java.util.concurrent.TimeUnit;
-import lombok.Cleanup;
-import org.apache.pulsar.client.api.Consumer;
-import org.apache.pulsar.client.api.Message;
-import org.apache.pulsar.client.api.Producer;
-import org.apache.pulsar.client.api.PulsarClient;
-import org.apache.pulsar.client.api.PulsarClientException;
-import org.apache.pulsar.client.api.Schema;
-import org.apache.pulsar.client.api.SubscriptionType;
-import org.apache.pulsar.tests.TestRetrySupport;
-import org.testng.Assert;
-import org.testng.annotations.AfterClass;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-public class SmokeTest extends TestRetrySupport {
-
-    private PulsarContainer pulsarContainer;
-
-    @Override
-    @BeforeClass(alwaysRun = true)
-    public final void setup(){
-        incrementSetupNumber();
-        pulsarContainer = new PulsarContainer();
-        pulsarContainer.start();
-    }
-
-    @Test
-    public void checkClient() throws PulsarClientException {
-
-        @Cleanup
-        PulsarClient client = PulsarClient.builder()
-                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
-                .build();
-
-        final String inputTopic = "input";
-
-        Producer<String> producer = client.newProducer(Schema.STRING)
-                .topic(inputTopic)
-                .enableBatching(false)
-                .create();
-
-        Consumer<String> consumer = client.newConsumer(Schema.STRING)
-                .topic(inputTopic)
-                .subscriptionName("test-subs")
-                .ackTimeout(10, TimeUnit.SECONDS)
-                .subscriptionType(SubscriptionType.Exclusive)
-                .subscribe();
-
-        producer.send("Hello!");
-        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
-
-        Assert.assertEquals(message.getValue(), "Hello!");
-
-    }
-
-    @Override
-    @AfterClass(alwaysRun = true)
-    public final void cleanup(){
-        markCurrentSetupNumberCleaned();
-        pulsarContainer.stop();
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.pulsar.tests.integration;
+
+import java.util.concurrent.TimeUnit;
+import lombok.Cleanup;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.apache.pulsar.tests.TestRetrySupport;
+import org.testng.Assert;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends TestRetrySupport {
+
+    private PulsarContainer pulsarContainer;
+
+    @Override
+    @BeforeClass(alwaysRun = true)
+    public final void setup(){
+        incrementSetupNumber();
+        pulsarContainer = new PulsarContainer();
+        pulsarContainer.start();
+    }
+
+    @Test
+    public void checkClient() throws PulsarClientException {
+
+        @Cleanup
+        PulsarClient client = PulsarClient.builder()
+                .serviceUrl(pulsarContainer.getPlainTextPulsarBrokerUrl())
+                .build();
+
+        final String inputTopic = "input";
+
+        Producer<String> producer = client.newProducer(Schema.STRING)
+                .topic(inputTopic)
+                .enableBatching(false)
+                .create();
+
+        Consumer<String> consumer = client.newConsumer(Schema.STRING)
+                .topic(inputTopic)
+                .subscriptionName("test-subs")
+                .ackTimeout(10, TimeUnit.SECONDS)
+                .subscriptionType(SubscriptionType.Exclusive)
+                .subscribe();
+
+        producer.send("Hello!");
+        Message<String> message = consumer.receive(10, TimeUnit.SECONDS);
+
+        Assert.assertEquals(message.getValue(), "Hello!");
+
+    }
+
+    @Override
+    @AfterClass(alwaysRun = true)
+    public final void cleanup(){
+        markCurrentSetupNumberCleaned();
+        pulsarContainer.stop();
+    }
+
+}
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/client.crt b/tests/pulsar-client-shade-test/src/test/resources/certificate/client.crt
index 2d7d156866..03a429d370 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/client.crt
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/client.crt
@@ -1,20 +1,20 @@
------BEGIN CERTIFICATE-----
-MIIDVjCCAj4CCQCtw/UnTFDT7DANBgkqhkiG9w0BAQUFADBtMQswCQYDVQQGEwJB
-VTETMBEGA1UECAwKU29tZS1TdGF0ZTEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MSEw
-HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMMBmNsaWVu
-dDAeFw0xNjA2MjAwMTQ1NDZaFw0yNjA2MTgwMTQ1NDZaMG0xCzAJBgNVBAYTAkFV
-MRMwEQYDVQQIDApTb21lLVN0YXRlMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxITAf
-BgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGY2xpZW50
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqQV5F3Au9FWXIYPdWqiX
-Rk5gdVmVkDuuFK4ZoOd8inoJpB3PPkpmpgoVkKQHDFhgx3ODGWIUgo+n6QDsJxY4
-ygHfVeggQgek8iUfteYVsIcHS0bjkhIij/3ihC301FkiqbrV069oLvUXLKcv3zxG
-mdBAiz0k4xGZhFieVRvQCLY9syUUxmQ/3Cv42lDY8a1gTw4CRRx/hCfDvXCKhOT4
-bMwUIDZfHB3JoDh3Thp8FLz0nTrRF75mSQJ/OdcafIm0Xoz2Otp/CSxLS+U1lLvG
-05crWTDe0om7NW4mK4CqGCFq5gUw7eIzaeO7Q5Qez9XGTMzkgIDTMvNYGGEeJhhm
-NQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAKXy4g6hljY5MpO8mbZh+uJHq6NEUs
-4dr7OKDDWc39AROZsGf2eFUmHOjmRSw7VHpguGKI+rFRELVffpg/VvMh5apu+DBf
-jhxtDNceAyh5uugPNUJHXyeikBDYW8bAzUU3DmMldPkTZWcGjurmyhDQ1TtK2YJe
-RMFBXw5aAzdJMNi6OfXDH/ZX32hrb482yghDZj+ndnm0FefmLbFTQRMF8/fIHb1W
-kqNHwIaapZwH6j/MJy/TRFYcJunrBUYT9zVjY46k3GU0ex/Bn7T4pg9gzgFGZJhn
-jQQFKliIC84thCzdlPkrLduLY8tmlDKpLXatbEQ+s1MmNOURm6irPp6g
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDVjCCAj4CCQCtw/UnTFDT7DANBgkqhkiG9w0BAQUFADBtMQswCQYDVQQGEwJB
+VTETMBEGA1UECAwKU29tZS1TdGF0ZTEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MSEw
+HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxDzANBgNVBAMMBmNsaWVu
+dDAeFw0xNjA2MjAwMTQ1NDZaFw0yNjA2MTgwMTQ1NDZaMG0xCzAJBgNVBAYTAkFV
+MRMwEQYDVQQIDApTb21lLVN0YXRlMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxITAf
+BgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDEPMA0GA1UEAwwGY2xpZW50
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqQV5F3Au9FWXIYPdWqiX
+Rk5gdVmVkDuuFK4ZoOd8inoJpB3PPkpmpgoVkKQHDFhgx3ODGWIUgo+n6QDsJxY4
+ygHfVeggQgek8iUfteYVsIcHS0bjkhIij/3ihC301FkiqbrV069oLvUXLKcv3zxG
+mdBAiz0k4xGZhFieVRvQCLY9syUUxmQ/3Cv42lDY8a1gTw4CRRx/hCfDvXCKhOT4
+bMwUIDZfHB3JoDh3Thp8FLz0nTrRF75mSQJ/OdcafIm0Xoz2Otp/CSxLS+U1lLvG
+05crWTDe0om7NW4mK4CqGCFq5gUw7eIzaeO7Q5Qez9XGTMzkgIDTMvNYGGEeJhhm
+NQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQAKXy4g6hljY5MpO8mbZh+uJHq6NEUs
+4dr7OKDDWc39AROZsGf2eFUmHOjmRSw7VHpguGKI+rFRELVffpg/VvMh5apu+DBf
+jhxtDNceAyh5uugPNUJHXyeikBDYW8bAzUU3DmMldPkTZWcGjurmyhDQ1TtK2YJe
+RMFBXw5aAzdJMNi6OfXDH/ZX32hrb482yghDZj+ndnm0FefmLbFTQRMF8/fIHb1W
+kqNHwIaapZwH6j/MJy/TRFYcJunrBUYT9zVjY46k3GU0ex/Bn7T4pg9gzgFGZJhn
+jQQFKliIC84thCzdlPkrLduLY8tmlDKpLXatbEQ+s1MmNOURm6irPp6g
+-----END CERTIFICATE-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/client.csr b/tests/pulsar-client-shade-test/src/test/resources/certificate/client.csr
index e01f33ef07..74604d67d0 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/client.csr
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/client.csr
@@ -1,17 +1,17 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx
-FTATBgNVBAcMDERlZmF1bHQgQ2l0eTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMQ8wDQYDVQQDDAZjbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IB
-DwAwggEKAoIBAQCpBXkXcC70VZchg91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+
-SmamChWQpAcMWGDHc4MZYhSCj6fpAOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOS
-EiKP/eKELfTUWSKputXTr2gu9Rcspy/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTG
-ZD/cK/jaUNjxrWBPDgJFHH+EJ8O9cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEX
-vmZJAn851xp8ibRejPY62n8JLEtL5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt
-4jNp47tDlB7P1cZMzOSAgNMy81gYYR4mGGY1AgMBAAGgADANBgkqhkiG9w0BAQUF
-AAOCAQEAk3eueaq/gonBzKH75oWHlqPbMZQFk4NXqx8h24ZfkCzPEFPyDM+jdQxv
-8vDtyWq+fizqAQmGrM7WPHgnTbmZyovfmwuKwtTlkD/8t7XpTmm9fYspbL4WzdP1
-y8/Vug09te+rni+v+kjk5b9IceEy6kLvXuzirE6c4LunAm+thrr5gWmsx1pyDiq7
-W2M15UZrm/paaCg6cVaMFdXCRZP+g1P4NcgDUe2TyFbLlhOJNtX3DJRZWEhrkEYK
-mRz2tJuiuitCzheAgRrFXepRagHKYffNSas1n/2kIc9QpZ8654kxsAzEwL7CnHd/
-SHbMS9dfP+uM6DACwcvngSOBMJ9KMg==
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICsjCCAZoCAQAwbTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx
+FTATBgNVBAcMDERlZmF1bHQgQ2l0eTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMQ8wDQYDVQQDDAZjbGllbnQwggEiMA0GCSqGSIb3DQEBAQUAA4IB
+DwAwggEKAoIBAQCpBXkXcC70VZchg91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+
+SmamChWQpAcMWGDHc4MZYhSCj6fpAOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOS
+EiKP/eKELfTUWSKputXTr2gu9Rcspy/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTG
+ZD/cK/jaUNjxrWBPDgJFHH+EJ8O9cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEX
+vmZJAn851xp8ibRejPY62n8JLEtL5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt
+4jNp47tDlB7P1cZMzOSAgNMy81gYYR4mGGY1AgMBAAGgADANBgkqhkiG9w0BAQUF
+AAOCAQEAk3eueaq/gonBzKH75oWHlqPbMZQFk4NXqx8h24ZfkCzPEFPyDM+jdQxv
+8vDtyWq+fizqAQmGrM7WPHgnTbmZyovfmwuKwtTlkD/8t7XpTmm9fYspbL4WzdP1
+y8/Vug09te+rni+v+kjk5b9IceEy6kLvXuzirE6c4LunAm+thrr5gWmsx1pyDiq7
+W2M15UZrm/paaCg6cVaMFdXCRZP+g1P4NcgDUe2TyFbLlhOJNtX3DJRZWEhrkEYK
+mRz2tJuiuitCzheAgRrFXepRagHKYffNSas1n/2kIc9QpZ8654kxsAzEwL7CnHd/
+SHbMS9dfP+uM6DACwcvngSOBMJ9KMg==
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/client.key b/tests/pulsar-client-shade-test/src/test/resources/certificate/client.key
index 34fc701c52..2b00929673 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/client.key
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/client.key
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCpBXkXcC70VZch
-g91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+SmamChWQpAcMWGDHc4MZYhSCj6fp
-AOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOSEiKP/eKELfTUWSKputXTr2gu9Rcs
-py/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTGZD/cK/jaUNjxrWBPDgJFHH+EJ8O9
-cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEXvmZJAn851xp8ibRejPY62n8JLEtL
-5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt4jNp47tDlB7P1cZMzOSAgNMy81gY
-YR4mGGY1AgMBAAECggEAcJj3yVhvv0/BhY8+CCYl2K1f7u1GCLbpSleNNTbhLbMM
-9yrwo/OWnGg9Y4USOPQrTNOz81X2id+/oSZ/K67PGCvVJ3qi+rny9WkrzdbAfkAF
-6O0Jr4arRbeBjkK7Rjc3M1EHH6VLx3R5AsNBzfpuogss5FVQXICd/5+1oscLeLEx
-/Fn+51IEn9FUg5vr7ElG51f+zPxexcWHLNoqGjTEIGGtI8/CfTzD9tBV4sIjf/Nc
-Zzfs9XYrChfcrS0U1zDa+L7c5gYfoN6M08sBiuZlhyyO9wgzPlp+XnsrSFv6hUta
-0scjAbN4bh+orQn6zgFN/sjkQnraWXW7pKFLyTR/IQKBgQDVju4IbhE9XRweNgXi
-s3BuGV+HsuFffEf0904/zCuCUcScGb5WCz5+KtlFJ//YxfocHVZajH+4GdCGbWim
-m+H3XvRpWgfK/aBNOXu5ueLbnPYyPjTrcpKRsomeoiV+Jz1tv5PQElwzCiCzVvQf
-fMyhQT16YIsFQAGJzQMBEHWODQKBgQDKnKps3sKSR3ycUtIxCVXUir7p52qst0Pm
-bPO8JrcRKZP2z8MJB96+DcQFzrxj7t5DDktkYEsFOPPuIeUsYXsY+MKHs4hEQVCz
-hpDJJNQ8s+SV8TLzKpinZEmLIjslLbn2rQrpqybPg84VxqX3qqM8IrXhMf77aGj6
-QHqvQwHWyQKBgQDF1RVO+9++j82ncvY6z22coKath5leIjxqgtqbISFBJUxUK0j2
-Xo4yxLDnbqmE/8m1V7wSP8tlGYzhquLiTM+kn/Mc0Ukc0503TMQABmJQfXRYkOXn
-IwkCLXltWdoPpnwyeeGNRCTjJ0OpvyiBLtRFobE498xxPZzvMdrRlpS/1QKBgQCo
-wmMleUnBQ2/kWQugMnFeLg6kjs+IesFAnYFKN0kGL4aB7j06OWbrEFY0rCS4bA6O
-9coQGjCCchSjRXI4TB2XCCQnmX8nsuuADNZt45Iv2XrM9XEFn3Y0/tBO5j0zU2nw
-r+NGC/uwns050BMPPf7mqNarctQ6HZZK0wgdEQfoGQKBgC+pbkQv9cn68TsiaJ3w
-tvNRTXCIAAH4Vtn9Cp+63ao+kXn94BJqQF99i58kJpG4ol6wbCHUoC6fHgxUh5HB
-JB0HjC2eCMgn4acAQg0sPW6l35KX36yYxtrL7eosB/yBYum0XAwmboNjEhlCZkOs
-YOpSsn61g7xqqrt40Spb5vUn
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCpBXkXcC70VZch
+g91aqJdGTmB1WZWQO64Urhmg53yKegmkHc8+SmamChWQpAcMWGDHc4MZYhSCj6fp
+AOwnFjjKAd9V6CBCB6TyJR+15hWwhwdLRuOSEiKP/eKELfTUWSKputXTr2gu9Rcs
+py/fPEaZ0ECLPSTjEZmEWJ5VG9AItj2zJRTGZD/cK/jaUNjxrWBPDgJFHH+EJ8O9
+cIqE5PhszBQgNl8cHcmgOHdOGnwUvPSdOtEXvmZJAn851xp8ibRejPY62n8JLEtL
+5TWUu8bTlytZMN7Sibs1biYrgKoYIWrmBTDt4jNp47tDlB7P1cZMzOSAgNMy81gY
+YR4mGGY1AgMBAAECggEAcJj3yVhvv0/BhY8+CCYl2K1f7u1GCLbpSleNNTbhLbMM
+9yrwo/OWnGg9Y4USOPQrTNOz81X2id+/oSZ/K67PGCvVJ3qi+rny9WkrzdbAfkAF
+6O0Jr4arRbeBjkK7Rjc3M1EHH6VLx3R5AsNBzfpuogss5FVQXICd/5+1oscLeLEx
+/Fn+51IEn9FUg5vr7ElG51f+zPxexcWHLNoqGjTEIGGtI8/CfTzD9tBV4sIjf/Nc
+Zzfs9XYrChfcrS0U1zDa+L7c5gYfoN6M08sBiuZlhyyO9wgzPlp+XnsrSFv6hUta
+0scjAbN4bh+orQn6zgFN/sjkQnraWXW7pKFLyTR/IQKBgQDVju4IbhE9XRweNgXi
+s3BuGV+HsuFffEf0904/zCuCUcScGb5WCz5+KtlFJ//YxfocHVZajH+4GdCGbWim
+m+H3XvRpWgfK/aBNOXu5ueLbnPYyPjTrcpKRsomeoiV+Jz1tv5PQElwzCiCzVvQf
+fMyhQT16YIsFQAGJzQMBEHWODQKBgQDKnKps3sKSR3ycUtIxCVXUir7p52qst0Pm
+bPO8JrcRKZP2z8MJB96+DcQFzrxj7t5DDktkYEsFOPPuIeUsYXsY+MKHs4hEQVCz
+hpDJJNQ8s+SV8TLzKpinZEmLIjslLbn2rQrpqybPg84VxqX3qqM8IrXhMf77aGj6
+QHqvQwHWyQKBgQDF1RVO+9++j82ncvY6z22coKath5leIjxqgtqbISFBJUxUK0j2
+Xo4yxLDnbqmE/8m1V7wSP8tlGYzhquLiTM+kn/Mc0Ukc0503TMQABmJQfXRYkOXn
+IwkCLXltWdoPpnwyeeGNRCTjJ0OpvyiBLtRFobE498xxPZzvMdrRlpS/1QKBgQCo
+wmMleUnBQ2/kWQugMnFeLg6kjs+IesFAnYFKN0kGL4aB7j06OWbrEFY0rCS4bA6O
+9coQGjCCchSjRXI4TB2XCCQnmX8nsuuADNZt45Iv2XrM9XEFn3Y0/tBO5j0zU2nw
+r+NGC/uwns050BMPPf7mqNarctQ6HZZK0wgdEQfoGQKBgC+pbkQv9cn68TsiaJ3w
+tvNRTXCIAAH4Vtn9Cp+63ao+kXn94BJqQF99i58kJpG4ol6wbCHUoC6fHgxUh5HB
+JB0HjC2eCMgn4acAQg0sPW6l35KX36yYxtrL7eosB/yBYum0XAwmboNjEhlCZkOs
+YOpSsn61g7xqqrt40Spb5vUn
+-----END PRIVATE KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem b/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
index 58ab3d4ff9..407cf927e5 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-ecdsa.pem
@@ -1,13 +1,13 @@
------BEGIN EC PARAMETERS-----
-MIGXAgEBMBwGByqGSM49AQECEQD////9////////////////MDsEEP////3/////
-//////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2
-eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1
-ow0bkDihFQIBAQ==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MIHYAgEBBBDeu9hc8kOvL3pl+LYSjLq9oIGaMIGXAgEBMBwGByqGSM49AQECEQD/
-///9////////////////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZ
-PCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bP
-Wsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1ow0bkDihFQIBAaEkAyIABOsqPpE8
-cY80pxkog5xw3i2AQ0yfV3MqMusxlOQnigBp
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+MIGXAgEBMBwGByqGSM49AQECEQD////9////////////////MDsEEP////3/////
+//////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2
+eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1
+ow0bkDihFQIBAQ==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MIHYAgEBBBDeu9hc8kOvL3pl+LYSjLq9oIGaMIGXAgEBMBwGByqGSM49AQECEQD/
+///9////////////////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZ
+PCzuXtMDFQAADg1NaW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bP
+Wsg5W6/rE8AtopLd7XqDAhEA/////gAAAAB1ow0bkDihFQIBAaEkAyIABOsqPpE8
+cY80pxkog5xw3i2AQ0yfV3MqMusxlOQnigBp
+-----END EC PRIVATE KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem b/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
index 3e2831ae8a..992ee841e7 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-mismatch-rsa.pem
@@ -1,29 +1,29 @@
------BEGIN EC PARAMETERS-----
-MIIBwgIBATBNBgcqhkjOPQEBAkIB////////////////////////////////////
-//////////////////////////////////////////////////8wgZ4EQgH/////
-////////////////////////////////////////////////////////////////
-/////////////////ARBUZU+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8Qnh
-Vhk5Uex+k3sWUsC9O7G/BzVz34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5
-MoSqoNpkugSBhQQAxoWOBrcEBOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUte
-d+/nWSj+HcEnov+o3jNIs8GFakKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY
-9URJV5tEaBevvRcnPmYsl+5ymV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlAC
-QgH///////////////////////////////////////////pRhoeDvy+Wa3/MAUj3
-CaXQO7XJuImcR667b7cekThkCQIBAQ==
------END EC PARAMETERS-----
------BEGIN EC PRIVATE KEY-----
-MIICnQIBAQRCAeNLEp1HefZ1nMl5vvgFMsJCd5ieCWqPT7TXbQkn27A8WkyAGTYC
-GtolyPokOgSjbJh+ofBt/MgvE/nMrqzmkZVtoIIBxjCCAcICAQEwTQYHKoZIzj0B
-AQJCAf//////////////////////////////////////////////////////////
-////////////////////////////MIGeBEIB////////////////////////////
-//////////////////////////////////////////////////////////wEQVGV
-PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
-c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
-BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
-hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
-cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
-///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
-ZAkCAQGhgYkDgYYABAFhUHeaHfIWre/pPmv2a2l891co79dFpg6ixPRg+Y5qe0C7
-src//LT/ZR5rgj8ne+YcaIlwyQRl5OYEd25n799IcgHIBTGyaLB6Td5mW/oWT/Fz
-soufOnUJ7O/kDHjIQ15sczk3rDhe8/mB9zPjKlKTuAl5jBEt6E3yiB44Dtng02xD
-uQ==
------END EC PRIVATE KEY-----
+-----BEGIN EC PARAMETERS-----
+MIIBwgIBATBNBgcqhkjOPQEBAkIB////////////////////////////////////
+//////////////////////////////////////////////////8wgZ4EQgH/////
+////////////////////////////////////////////////////////////////
+/////////////////ARBUZU+uWGOHJofkpohoLaFQO6i2nJbmbMV87i0iZGO8Qnh
+Vhk5Uex+k3sWUsC9O7G/BzVz34g9LDTx70Uf1GtQPwADFQDQnogAKRy4U5bMZxc5
+MoSqoNpkugSBhQQAxoWOBrcEBOnNnj7LZiOVtEKcZIE5BT+1Ifgor2BrTT26oUte
+d+/nWSj+HcEnov+o3jNIs8GFakKb+X5+McLlvWYBGDkpaniaO8AEXIpftCx9G9mY
+9URJV5tEaBevvRcnPmYsl+5ymV70JkDFULkBP60HYTU8cIaicsJAiL6Udp/RZlAC
+QgH///////////////////////////////////////////pRhoeDvy+Wa3/MAUj3
+CaXQO7XJuImcR667b7cekThkCQIBAQ==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MIICnQIBAQRCAeNLEp1HefZ1nMl5vvgFMsJCd5ieCWqPT7TXbQkn27A8WkyAGTYC
+GtolyPokOgSjbJh+ofBt/MgvE/nMrqzmkZVtoIIBxjCCAcICAQEwTQYHKoZIzj0B
+AQJCAf//////////////////////////////////////////////////////////
+////////////////////////////MIGeBEIB////////////////////////////
+//////////////////////////////////////////////////////////wEQVGV
+PrlhjhyaH5KaIaC2hUDuotpyW5mzFfO4tImRjvEJ4VYZOVHsfpN7FlLAvTuxvwc1
+c9+IPSw08e9FH9RrUD8AAxUA0J6IACkcuFOWzGcXOTKEqqDaZLoEgYUEAMaFjga3
+BATpzZ4+y2YjlbRCnGSBOQU/tSH4KK9ga009uqFLXnfv51ko/h3BJ6L/qN4zSLPB
+hWpCm/l+fjHC5b1mARg5KWp4mjvABFyKX7QsfRvZmPVESVebRGgXr70XJz5mLJfu
+cple9CZAxVC5AT+tB2E1PHCGonLCQIi+lHaf0WZQAkIB////////////////////
+///////////////////////6UYaHg78vlmt/zAFI9wml0Du1ybiJnEeuu2+3HpE4
+ZAkCAQGhgYkDgYYABAFhUHeaHfIWre/pPmv2a2l891co79dFpg6ixPRg+Y5qe0C7
+src//LT/ZR5rgj8ne+YcaIlwyQRl5OYEd25n799IcgHIBTGyaLB6Td5mW/oWT/Fz
+soufOnUJ7O/kDHjIQ15sczk3rDhe8/mB9zPjKlKTuAl5jBEt6E3yiB44Dtng02xD
+uQ==
+-----END EC PRIVATE KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-rsa.pem b/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
index a0d589e0e2..1ccfe4e40b 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/private-key.client-rsa.pem
@@ -1,27 +1,27 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEowIBAAKCAQEAtKWwgqdnTYrOCv+j1MkTWfSH0wCsHZZca9wAW3qP4uuhlBvn
-b10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhURHM4yuXqzCxzuAwkQSo39rzX8PGC
-7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9ER1e5O/uEPAotP933hHQ0J2hMEek
-HqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+cMd8ZbGScPqI9M38bmn3OLxFTn1vt
-hpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs7ppZnRbv8Hc/DFdOKVQIgam6CDdn
-NKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQGQIDAQABAoIBAAaJFAi2C7u3cNrf
-AstY9vVDLoLIvHFZlkBktjKZDYmVIsRb+hSCViwVUrWLL67R6+Iv4eg4DeTOAx00
-8pncXKgZTw2wIb1/QjR/Y/RjlaC8lkdmRWli7udMQCZVsyhuSjW6Pj7vr8YE4woj
-FhNijxEGcf9wWrmMJrzdnTWQiXByo+eTvUQ9BPgPGrRjsMZmTkLyAVJff2DfxO5b
-IWFDYDJcyYAMCIMQu7vys/I50ou6ilb1CO6QM6Z7KpPeOoVFPwtzbh8cf9xM8UNS
-j6J/JmdWhgI34GS3NA68xTQ6PV7zjnhCc+iccm3JKyzGXwaApAZ+Eoce/9j4WKmu
-5B4ziR0CgYEA3l/9OHbl1zmyV+rRxWOIj/i2rTvHzwBnbnPJyuemL5VMFdpGodQ3
-vwHvyQmcECRVRxmXojQ4QuPPHs3qp6wEEFPCWxChLSTxlUc85SOFHWU2O99jV7zI
-7+JOpDK/Mstsx9nHgXduJF+glTFtA3LH8Oqylzu2aFPsprwKuZf94Q8CgYEAz/Zx
-akEG+PEMtP5YS28cX5XfjsIX/V26Fs6/sH16QjUIEddE5T4fCuokxCjSiwUcWhml
-pHEJ5S5xp3VYRfISW3jRW3qstIH1tpZipB6+S0zTuJmLJbA3IiWEg2rtMt7X1uJv
-A/bYOqe0hOPTuXuZdtVZ0nMTKk7GG8O6VkBI7FcCgYEAkDfCmscJgs7JahlBWHmX
-zH9pwem+SPKjIc/4NB6N+dgikx2Pp05hpP/VihUwYIufvs/LNogVYNQrtHepUnrN
-2+TmbHbZgNSv1Ldxt82UfB7y0FutKu6lhmXHyNecho3Fi8sih0V0aiSWmYuHfrAH
-GaiskEZKo1iiZvQXJIx9O2MCgYATBf0r9hTYMtyxtc6H3/sdd01C9thQ8gDy0yjP
-0Tqc0dMSJroDqmIWkoKYew9/bhFA4LW5TCnWkCAPbHmNtG4fdfbYwmkH/hdnA2y0
-jKdlpfp8GXeUFAGHGx17FA3sqFvgKUh0eWEgRHUL7vdQMVFBgJS93o7zQM94fLgP
-6cOB8wKBgFcGV4GjI2Ww9cillaC554MvoSjf8B/+04kXzDOh8iYIIzO9EUil1jjK
-Jvxp4hnLzTKWbux3MEWqurLkYas6GpKBjw+iNOCar6YdqWGVqM3RUx7PTUaZwkKx
-UdP63IfY7iZCIT/QbyHQvIUe2MaiVnH+ulxdkK6Y5e7gxcbckIH4
------END RSA PRIVATE KEY-----
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEAtKWwgqdnTYrOCv+j1MkTWfSH0wCsHZZca9wAW3qP4uuhlBvn
+b10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhURHM4yuXqzCxzuAwkQSo39rzX8PGC
+7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9ER1e5O/uEPAotP933hHQ0J2hMEek
+HqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+cMd8ZbGScPqI9M38bmn3OLxFTn1vt
+hpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs7ppZnRbv8Hc/DFdOKVQIgam6CDdn
+NKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQGQIDAQABAoIBAAaJFAi2C7u3cNrf
+AstY9vVDLoLIvHFZlkBktjKZDYmVIsRb+hSCViwVUrWLL67R6+Iv4eg4DeTOAx00
+8pncXKgZTw2wIb1/QjR/Y/RjlaC8lkdmRWli7udMQCZVsyhuSjW6Pj7vr8YE4woj
+FhNijxEGcf9wWrmMJrzdnTWQiXByo+eTvUQ9BPgPGrRjsMZmTkLyAVJff2DfxO5b
+IWFDYDJcyYAMCIMQu7vys/I50ou6ilb1CO6QM6Z7KpPeOoVFPwtzbh8cf9xM8UNS
+j6J/JmdWhgI34GS3NA68xTQ6PV7zjnhCc+iccm3JKyzGXwaApAZ+Eoce/9j4WKmu
+5B4ziR0CgYEA3l/9OHbl1zmyV+rRxWOIj/i2rTvHzwBnbnPJyuemL5VMFdpGodQ3
+vwHvyQmcECRVRxmXojQ4QuPPHs3qp6wEEFPCWxChLSTxlUc85SOFHWU2O99jV7zI
+7+JOpDK/Mstsx9nHgXduJF+glTFtA3LH8Oqylzu2aFPsprwKuZf94Q8CgYEAz/Zx
+akEG+PEMtP5YS28cX5XfjsIX/V26Fs6/sH16QjUIEddE5T4fCuokxCjSiwUcWhml
+pHEJ5S5xp3VYRfISW3jRW3qstIH1tpZipB6+S0zTuJmLJbA3IiWEg2rtMt7X1uJv
+A/bYOqe0hOPTuXuZdtVZ0nMTKk7GG8O6VkBI7FcCgYEAkDfCmscJgs7JahlBWHmX
+zH9pwem+SPKjIc/4NB6N+dgikx2Pp05hpP/VihUwYIufvs/LNogVYNQrtHepUnrN
+2+TmbHbZgNSv1Ldxt82UfB7y0FutKu6lhmXHyNecho3Fi8sih0V0aiSWmYuHfrAH
+GaiskEZKo1iiZvQXJIx9O2MCgYATBf0r9hTYMtyxtc6H3/sdd01C9thQ8gDy0yjP
+0Tqc0dMSJroDqmIWkoKYew9/bhFA4LW5TCnWkCAPbHmNtG4fdfbYwmkH/hdnA2y0
+jKdlpfp8GXeUFAGHGx17FA3sqFvgKUh0eWEgRHUL7vdQMVFBgJS93o7zQM94fLgP
+6cOB8wKBgFcGV4GjI2Ww9cillaC554MvoSjf8B/+04kXzDOh8iYIIzO9EUil1jjK
+Jvxp4hnLzTKWbux3MEWqurLkYas6GpKBjw+iNOCar6YdqWGVqM3RUx7PTUaZwkKx
+UdP63IfY7iZCIT/QbyHQvIUe2MaiVnH+ulxdkK6Y5e7gxcbckIH4
+-----END RSA PRIVATE KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem b/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
index 5aeb429a3d..757a26fc4c 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-ecdsa.pem
@@ -1,7 +1,7 @@
------BEGIN PUBLIC KEY-----
-MIHKMIGjBgcqhkjOPQIBMIGXAgEBMBwGByqGSM49AQECEQD////9////////////
-////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1N
-aW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd
-7XqDAhEA/////gAAAAB1ow0bkDihFQIBAQMiAATrKj6RPHGPNKcZKIOccN4tgENM
-n1dzKjLrMZTkJ4oAaQ==
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIHKMIGjBgcqhkjOPQIBMIGXAgEBMBwGByqGSM49AQECEQD////9////////////
+////MDsEEP////3///////////////wEEOh1ecEQefQ92CSZPCzuXtMDFQAADg1N
+aW5naHVhUXUMwDpEc9A2eQQhBBYf91KLiZstDChgfKUsW4bPWsg5W6/rE8AtopLd
+7XqDAhEA/////gAAAAB1ow0bkDihFQIBAQMiAATrKj6RPHGPNKcZKIOccN4tgENM
+n1dzKjLrMZTkJ4oAaQ==
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem b/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
index 6fc427b1b1..88fa11eb8f 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-mismatch-rsa.pem
@@ -1,9 +1,9 @@
------BEGIN PUBLIC KEY-----
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
-WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
-RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
-ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
-Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
-7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
-GQIDAQAB
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
+WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
+RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
+ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
+Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
+7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
+GQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-rsa.pem b/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
index 6fc427b1b1..88fa11eb8f 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/public-key.client-rsa.pem
@@ -1,9 +1,9 @@
------BEGIN PUBLIC KEY-----
-MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
-WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
-RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
-ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
-Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
-7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
-GQIDAQAB
------END PUBLIC KEY-----
+-----BEGIN PUBLIC KEY-----
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtKWwgqdnTYrOCv+j1MkT
+WfSH0wCsHZZca9wAW3qP4uuhlBvnb10JcFf5ZjzP9BSXK+tHmI8uoN368vEv6yhU
+RHM4yuXqzCxzuAwkQSo39rzX8PGC7qdjCN7LDJ3MnqiBIrUsSaEP1wrNsB1kI+o9
+ER1e5O/uEPAotP933hHQ0J2hMEekHqL7sBlJ98h6NmsicEaUkardk0TOXrlkjC+c
+Md8ZbGScPqI9M38bmn3OLxFTn1vthpvnXLvCmG4M+6xtYtD+npcVPZw1i1R90fMs
+7ppZnRbv8Hc/DFdOKVQIgam6CDdnNKgW7c7IBMrP0AEm37HTu0LSOjP2OHXlvvlQ
+GQIDAQAB
+-----END PUBLIC KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/server.crt b/tests/pulsar-client-shade-test/src/test/resources/certificate/server.crt
index 59b651be2a..1b2c57bc6a 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/server.crt
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/server.crt
@@ -1,20 +1,20 @@
------BEGIN CERTIFICATE-----
-MIIDLjCCAhYCCQDn/Yvym+FMsDANBgkqhkiG9w0BAQUFADBZMQswCQYDVQQGEwJB
-VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
-cyBQdHkgTHRkMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTYwNjEzMjIyMTQ2WhcN
-MjYwNjExMjIyMTQ2WjBZMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0
-ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDEwls
-b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCs29IuzZvk
-OGUkS/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du99
-8xbgeihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT
-1DepD/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQr
-mTbLzzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J
-92K+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNb
-O9hVS4bqqsw9AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACE0WBuTbHcPtYKv2ZMS
-mYk9jvtAhmWHQ6tNqV8CmS2AsrzZdWglGaqIRsm5slkD2BGeQS+BesTArUuENTmP
-r9kJSecdiiB8aWtLbhoCSH3QR6IW/b5UVl6sR5OIh7SkNTjMSUSDnMEVLNGyKZGS
-gCGVbDf3n5KhOTnwqguELRykynKFt2LVksBia9+88lUtiRHpbyClo/KVWltJlaww
-PT0WEpwqVUcHmwrR3MTzJDEPvIplSgxdaDmFGYS1YKm9T/wQd+t/0DbXMmfJXBbd
-FVUnB6o7qJVU9N2Tbaj9NbCtwz5nTZG4A5kRXWHVjZsn5WzLuS/me3rDXjwlfB2p
-ipY=
------END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIDLjCCAhYCCQDn/Yvym+FMsDANBgkqhkiG9w0BAQUFADBZMQswCQYDVQQGEwJB
+VTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTYwNjEzMjIyMTQ2WhcN
+MjYwNjExMjIyMTQ2WjBZMQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0
+ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDEwls
+b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCs29IuzZvk
+OGUkS/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du99
+8xbgeihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT
+1DepD/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQr
+mTbLzzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J
+92K+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNb
+O9hVS4bqqsw9AgMBAAEwDQYJKoZIhvcNAQEFBQADggEBACE0WBuTbHcPtYKv2ZMS
+mYk9jvtAhmWHQ6tNqV8CmS2AsrzZdWglGaqIRsm5slkD2BGeQS+BesTArUuENTmP
+r9kJSecdiiB8aWtLbhoCSH3QR6IW/b5UVl6sR5OIh7SkNTjMSUSDnMEVLNGyKZGS
+gCGVbDf3n5KhOTnwqguELRykynKFt2LVksBia9+88lUtiRHpbyClo/KVWltJlaww
+PT0WEpwqVUcHmwrR3MTzJDEPvIplSgxdaDmFGYS1YKm9T/wQd+t/0DbXMmfJXBbd
+FVUnB6o7qJVU9N2Tbaj9NbCtwz5nTZG4A5kRXWHVjZsn5WzLuS/me3rDXjwlfB2p
+ipY=
+-----END CERTIFICATE-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/server.csr b/tests/pulsar-client-shade-test/src/test/resources/certificate/server.csr
index 8782222c5a..1206d6e78c 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/server.csr
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/server.csr
@@ -1,17 +1,17 @@
------BEGIN CERTIFICATE REQUEST-----
-MIICnjCCAYYCAQAwWTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUx
-ITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAxMJbG9j
-YWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNvSLs2b5Dhl
-JEv8Kis3f4dnrKowko8OEiy23odRgN1BL4dZPfnkYmMCRtcgjh5nLKeAPA7vffMW
-4HooaVlsO6Yy+VVZMt3Irrx8s9QnOmykabPxs1SQcBT9IMx5yvG1DPOlOdshk9Q3
-qQ/2NpVEctIoHVXADIxsHjMKE5omlXMGXsX2LhHn/o8935qZjsD/a26CAPa0K5k2
-y885GwMGV3Zfm0byHnyIyGsyM0zrPLSVq4RWkyVIAYYS4xSME3aUvp/hajrvCfdi
-vj7yoyHid5Jp2ckRyu7onZQJ9IPwyvnKNbF98zkTwlnoNtSvv71R04/dcwETWzvY
-VUuG6qrMPQIDAQABoAAwDQYJKoZIhvcNAQEFBQADggEBAEPHySnpf3E/7tZsiDka
-rqdB/sU7fdqjyV0iy0cuKQkU8WYrsE7bHkqMYc8CiIDfWhIGW5Jnzups2O6eH0Sx
-2BS21ARFiNGC1UfY1HSV2zrTNh3RqQa3YsXzv9vvdQ/gjsqGDuGDIc1yAA+Ytdja
-3rhIzEVqBhiLzg+M2+gW1zs+Kqj0Zo0pLB2uqhdZJmjxBb2FCli50vCVEhqIS3RO
-KTE+AJfxThWIeahFyVaskaEGkS6NVr2JihV0elbKolH19k2UzRTVn7p3Ixh5ojuW
-gtU/90vOy/SDkSRmCWMqgkUKJ2oeImleHdrvwNyrzvrLWRAz6R5yGQJwji9kKpHD
-FK0=
------END CERTIFICATE REQUEST-----
+-----BEGIN CERTIFICATE REQUEST-----
+MIICnjCCAYYCAQAwWTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUx
+ITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAxMJbG9j
+YWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArNvSLs2b5Dhl
+JEv8Kis3f4dnrKowko8OEiy23odRgN1BL4dZPfnkYmMCRtcgjh5nLKeAPA7vffMW
+4HooaVlsO6Yy+VVZMt3Irrx8s9QnOmykabPxs1SQcBT9IMx5yvG1DPOlOdshk9Q3
+qQ/2NpVEctIoHVXADIxsHjMKE5omlXMGXsX2LhHn/o8935qZjsD/a26CAPa0K5k2
+y885GwMGV3Zfm0byHnyIyGsyM0zrPLSVq4RWkyVIAYYS4xSME3aUvp/hajrvCfdi
+vj7yoyHid5Jp2ckRyu7onZQJ9IPwyvnKNbF98zkTwlnoNtSvv71R04/dcwETWzvY
+VUuG6qrMPQIDAQABoAAwDQYJKoZIhvcNAQEFBQADggEBAEPHySnpf3E/7tZsiDka
+rqdB/sU7fdqjyV0iy0cuKQkU8WYrsE7bHkqMYc8CiIDfWhIGW5Jnzups2O6eH0Sx
+2BS21ARFiNGC1UfY1HSV2zrTNh3RqQa3YsXzv9vvdQ/gjsqGDuGDIc1yAA+Ytdja
+3rhIzEVqBhiLzg+M2+gW1zs+Kqj0Zo0pLB2uqhdZJmjxBb2FCli50vCVEhqIS3RO
+KTE+AJfxThWIeahFyVaskaEGkS6NVr2JihV0elbKolH19k2UzRTVn7p3Ixh5ojuW
+gtU/90vOy/SDkSRmCWMqgkUKJ2oeImleHdrvwNyrzvrLWRAz6R5yGQJwji9kKpHD
+FK0=
+-----END CERTIFICATE REQUEST-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/certificate/server.key b/tests/pulsar-client-shade-test/src/test/resources/certificate/server.key
index 6da70f5aec..27b738af8e 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/certificate/server.key
+++ b/tests/pulsar-client-shade-test/src/test/resources/certificate/server.key
@@ -1,28 +1,28 @@
------BEGIN PRIVATE KEY-----
-MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCs29IuzZvkOGUk
-S/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du998xbg
-eihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT1Dep
-D/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQrmTbL
-zzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J92K+
-PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNbO9hV
-S4bqqsw9AgMBAAECggEAd/LuDeZFZ/+uR5qmuAhXMZqfWZSbsges5vW6S/6wkvB1
-vGp6heQzFAbKXKgJgjUcuULeXE6s58RYuppqEnin/1hcBOKxy/dUu9Q14H+2XPdo
-u6TPcvaaZ/xYjnr1hNtnHD6yB8zEpxVbLmjSHJxF7Dti9MA9TTfgCrC2LFYKsicD
-/5AQyHuwpHyTL3Iiwv4Qtks/SD2a3fu8lD0yTQwA/hY6/0ieXxXd9tZV5a6GSA0P
-nieol1byfuX7Q5fb8ggPd9u9K1mVZTBRKiE5w+uU4Ic2IkBmZX5ZuRS+vFplpLsY
-YpFPvzFmpNkpK2SdYjJ+V4tkJsFHmOaFRgW/0QB2DQKBgQDeQMSZBQlPUrgRdWHN
-OyvTcrSvXzg5DbaIj39tgdNZ6PYns/thD0n707KGRJOChIyYiiKxLxzLWdPUxqQO
-rNLUV9IkMVc/QZR8RUqGc2BxmPOxAprhzeOhLsyqP/sgtxRHAnLqmkXuHYoxvTZ6
-LFCRCZBpEJrutGxl3s/x+sfkuwKBgQDHGwnSmvArpL8ZY1dV4xKNkxifCBnNmqAl
-TKHPW3odN9nkMECEt1XUIioUUKXUsiAZNp5xa/v1DEyJ4f2T20QKcAGbS18b1M5W
-axIoH3IhyLo74tuo0fthgq5bzypfFOlIjo7F9mpEky/461RWmoNAAlp9+FkDi48C
-KwjAk39/ZwKBgQDXFJqs8sDFsOlMi+nvsHmDERhmNqG0JN8mXKgWk3KzKc09MuHs
-Vd1lBMNZSHfv8NIWtGdKTKty5yUmXm1ZfkoxECPevpkOMCq/8FZksrb8d+YswLae
-Gp9U1nNdtrkSOdo3tdj7y/wsqQ2ZgOB9bvEwyq6j3lvw8U2NcAiQxf44DQKBgBHb
-lPf0uZHQhutKA61KXoGgLdclrNrKAY8W3nRwqfUw6zQSN9cvcl1Cay/DQ/xdtY9N
-XMyjeMezwLGlOU8nnWSqQxqgmfkvDwqlM82xdFUfYcS5RiZQHxHR3L2TSSOaBoph
-buDGhyV7ZhQXV0slNJxrGZ6uxZ0RyVPSdEiBcjAFAoGBAJqZ6uCVHpv/FwZVggu7
-Xb9EIxZnLSmXwaXFpJoMZpRpKb8cSTTJbgSMv3Dq2LcNKYXdNBhgKgPSc/XipXt9
-ZdT36KWipV+PzW691kUiWHtA8/+E0LCi4Y7rlcBMz9PgDNXK4XMMZOVKxDqPcHSJ
-P6y01ku7T2X+abUiJ334Hg6G
------END PRIVATE KEY-----
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCs29IuzZvkOGUk
+S/wqKzd/h2esqjCSjw4SLLbeh1GA3UEvh1k9+eRiYwJG1yCOHmcsp4A8Du998xbg
+eihpWWw7pjL5VVky3ciuvHyz1Cc6bKRps/GzVJBwFP0gzHnK8bUM86U52yGT1Dep
+D/Y2lURy0igdVcAMjGweMwoTmiaVcwZexfYuEef+jz3fmpmOwP9rboIA9rQrmTbL
+zzkbAwZXdl+bRvIefIjIazIzTOs8tJWrhFaTJUgBhhLjFIwTdpS+n+FqOu8J92K+
+PvKjIeJ3kmnZyRHK7uidlAn0g/DK+co1sX3zORPCWeg21K+/vVHTj91zARNbO9hV
+S4bqqsw9AgMBAAECggEAd/LuDeZFZ/+uR5qmuAhXMZqfWZSbsges5vW6S/6wkvB1
+vGp6heQzFAbKXKgJgjUcuULeXE6s58RYuppqEnin/1hcBOKxy/dUu9Q14H+2XPdo
+u6TPcvaaZ/xYjnr1hNtnHD6yB8zEpxVbLmjSHJxF7Dti9MA9TTfgCrC2LFYKsicD
+/5AQyHuwpHyTL3Iiwv4Qtks/SD2a3fu8lD0yTQwA/hY6/0ieXxXd9tZV5a6GSA0P
+nieol1byfuX7Q5fb8ggPd9u9K1mVZTBRKiE5w+uU4Ic2IkBmZX5ZuRS+vFplpLsY
+YpFPvzFmpNkpK2SdYjJ+V4tkJsFHmOaFRgW/0QB2DQKBgQDeQMSZBQlPUrgRdWHN
+OyvTcrSvXzg5DbaIj39tgdNZ6PYns/thD0n707KGRJOChIyYiiKxLxzLWdPUxqQO
+rNLUV9IkMVc/QZR8RUqGc2BxmPOxAprhzeOhLsyqP/sgtxRHAnLqmkXuHYoxvTZ6
+LFCRCZBpEJrutGxl3s/x+sfkuwKBgQDHGwnSmvArpL8ZY1dV4xKNkxifCBnNmqAl
+TKHPW3odN9nkMECEt1XUIioUUKXUsiAZNp5xa/v1DEyJ4f2T20QKcAGbS18b1M5W
+axIoH3IhyLo74tuo0fthgq5bzypfFOlIjo7F9mpEky/461RWmoNAAlp9+FkDi48C
+KwjAk39/ZwKBgQDXFJqs8sDFsOlMi+nvsHmDERhmNqG0JN8mXKgWk3KzKc09MuHs
+Vd1lBMNZSHfv8NIWtGdKTKty5yUmXm1ZfkoxECPevpkOMCq/8FZksrb8d+YswLae
+Gp9U1nNdtrkSOdo3tdj7y/wsqQ2ZgOB9bvEwyq6j3lvw8U2NcAiQxf44DQKBgBHb
+lPf0uZHQhutKA61KXoGgLdclrNrKAY8W3nRwqfUw6zQSN9cvcl1Cay/DQ/xdtY9N
+XMyjeMezwLGlOU8nnWSqQxqgmfkvDwqlM82xdFUfYcS5RiZQHxHR3L2TSSOaBoph
+buDGhyV7ZhQXV0slNJxrGZ6uxZ0RyVPSdEiBcjAFAoGBAJqZ6uCVHpv/FwZVggu7
+Xb9EIxZnLSmXwaXFpJoMZpRpKb8cSTTJbgSMv3Dq2LcNKYXdNBhgKgPSc/XipXt9
+ZdT36KWipV+PzW691kUiWHtA8/+E0LCi4Y7rlcBMz9PgDNXK4XMMZOVKxDqPcHSJ
+P6y01ku7T2X+abUiJ334Hg6G
+-----END PRIVATE KEY-----
diff --git a/tests/pulsar-client-shade-test/src/test/resources/pulsar.xml b/tests/pulsar-client-shade-test/src/test/resources/pulsar.xml
index 6132ad05f6..13e4f54117 100644
--- a/tests/pulsar-client-shade-test/src/test/resources/pulsar.xml
+++ b/tests/pulsar-client-shade-test/src/test/resources/pulsar.xml
@@ -1,29 +1,29 @@
-<!--
-
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-
--->
-<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
-<suite name="Pulsar Shade Tests" verbose="2" annotations="JDK">
-    <test name="pulsar-client-shade-suite" preserve-order="true" >
-        <classes>
-            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
-            <class name="org.apache.pulsar.tests.integration.SimpleProducerConsumerTest" />
-        </classes>
-    </test>
-</suite>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+
+-->
+<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd" >
+<suite name="Pulsar Shade Tests" verbose="2" annotations="JDK">
+    <test name="pulsar-client-shade-suite" preserve-order="true" >
+        <classes>
+            <class name="org.apache.pulsar.tests.integration.SmokeTest" />
+            <class name="org.apache.pulsar.tests.integration.SimpleProducerConsumerTest" />
+        </classes>
+    </test>
+</suite>
diff --git a/tests/scripts/post-integ-tests.sh b/tests/scripts/post-integ-tests.sh
index 8af7ab8b91..edda864521 100755
--- a/tests/scripts/post-integ-tests.sh
+++ b/tests/scripts/post-integ-tests.sh
@@ -1,22 +1,22 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-set -ex
-kill $(cat docker-log.pid) || true
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+set -ex
+kill $(cat docker-log.pid) || true
diff --git a/tests/scripts/pre-integ-tests.sh b/tests/scripts/pre-integ-tests.sh
index f8ba1bdc70..4197302082 100755
--- a/tests/scripts/pre-integ-tests.sh
+++ b/tests/scripts/pre-integ-tests.sh
@@ -1,34 +1,34 @@
-#!/usr/bin/env bash
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-set -ex
-id
-ulimit -a
-pwd
-df -h
-ps -eo euser,pid,ppid,pgid,start,pcpu,pmem,cmd
-docker system prune -f
-docker system events > docker.debug-info & echo $! > docker-log.pid
-docker pull apachepulsar/s3mock:latest
-docker pull alpine/socat:latest
-docker pull cassandra:3
-docker pull confluentinc/cp-kafka:4.0.0
-docker pull debezium/example-mysql:3.0.0.Final
-docker pull mysql:9.1.0
+#!/usr/bin/env bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+set -ex
+id
+ulimit -a
+pwd
+df -h
+ps -eo euser,pid,ppid,pgid,start,pcpu,pmem,cmd
+docker system prune -f
+docker system events > docker.debug-info & echo $! > docker-log.pid
+docker pull apachepulsar/s3mock:latest
+docker pull alpine/socat:latest
+docker pull cassandra:3
+docker pull confluentinc/cp-kafka:4.0.0
+docker pull debezium/example-mysql:3.0.0.Final
+docker pull mysql:9.1.0
