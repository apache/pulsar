From: HelgiSaga <bglegb@gmail.com>
Date: Tue, 21 Jan 2026 12:30:00 +0300
Subject: [PATCH] debian: Update testmocks and mock Zookeeper/BookKeeper classes

Description: Update testmocks and mock Zookeeper/BookKeeper classes
Author: HelgiSaga <bglegb@gmail.com>
Forwarded: no
Last-Update: 2026-01-21

diff --git a/testmocks/pom.xml b/testmocks/pom.xml index ee99bb6d26..76ab9a40a3 100644 --- a/testmocks/pom.xml +++ b/testmocks/pom.xml @@ -1,96 +1,96 @@ -<!-- - -    Licensed to the Apache Software Foundation (ASF) under one -    or more contributor license agreements.  See the NOTICE file -    distributed with this work for additional information -    regarding copyright ownership.  The ASF licenses this file -    to you under the Apache License, Version 2.0 (the -    "License"); you may not use this file except in compliance -    with the License.  You may obtain a copy of the License at - -      http://www.apache.org/licenses/LICENSE-2.0 - -    Unless required by applicable law or agreed to in writing, -    software distributed under the License is distributed on an -    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -    KIND, either express or implied.  See the License for the -    specific language governing permissions and limitations -    under the License. - ---> -<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" -         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"> -  <modelVersion>4.0.0</modelVersion> - -  <parent> -    <artifactId>pulsar</artifactId> -    <groupId>org.apache.pulsar</groupId> -    <version>4.1.2</version> -  </parent> - -  <artifactId>testmocks</artifactId> -  <packaging>jar</packaging> -  <name>Pulsar Test Mocks</name> - -  <dependencies> - -    <dependency> -      <groupId>org.apache.zookeeper</groupId> -      <artifactId>zookeeper</artifactId> -      <exclusions> -        <exclusion> -          <groupId>ch.qos.logback</groupId> -          <artifactId>logback-core</artifactId> -        </exclusion> -        <exclusion> -          <groupId>ch.qos.logback</groupId> -          <artifactId>logback-classic</artifactId> -        </exclusion> -        <exclusion> -          <groupId>io.netty</groupId> -          <artifactId>netty-tcnative</artifactId> -        </exclusion> -      </exclusions> -    </dependency> - -    <dependency> -      <groupId>org.apache.bookkeeper</groupId> -      <artifactId>bookkeeper-server</artifactId> -    </dependency> - -    <dependency> -      <groupId>org.apache.commons</groupId> -      <artifactId>commons-lang3</artifactId> -    </dependency> - -    <dependency> -      <groupId>org.testng</groupId> -      <artifactId>testng</artifactId> -    </dependency> - -    <dependency> -      <groupId>org.objenesis</groupId> -      <artifactId>objenesis</artifactId> -    </dependency> - -  </dependencies> - -  <build> -    <plugins> -      <plugin> -        <groupId>org.apache.maven.plugins</groupId> -        <artifactId>maven-checkstyle-plugin</artifactId> -        <executions> -          <execution> -            <id>checkstyle</id> -            <phase>verify</phase> -            <goals> -              <goal>check</goal> -            </goals> -          </execution> -        </executions> -      </plugin> -    </plugins> -  </build> - -</project> +<!-- + +    Licensed to the Apache Software Foundation (ASF) under one +    or more contributor license agreements.  See the NOTICE file +    distributed with this work for additional information +    regarding copyright ownership.  The ASF licenses this file +    to you under the Apache License, Version 2.0 (the +    "License"); you may not use this file except in compliance +    with the License.  You may obtain a copy of the License at + +      http://www.apache.org/licenses/LICENSE-2.0 + +    Unless required by applicable law or agreed to in writing, +    software distributed under the License is distributed on an +    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY +    KIND, either express or implied.  See the License for the +    specific language governing permissions and limitations +    under the License. + +--> +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" +         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"> +  <modelVersion>4.0.0</modelVersion> + +  <parent> +    <artifactId>pulsar</artifactId> +    <groupId>org.apache.pulsar</groupId> +    <version>4.1.2</version> +  </parent> + +  <artifactId>testmocks</artifactId> +  <packaging>jar</packaging> +  <name>Pulsar Test Mocks</name> + +  <dependencies> + +    <dependency> +      <groupId>org.apache.zookeeper</groupId> +      <artifactId>zookeeper</artifactId> +      <exclusions> +        <exclusion> +          <groupId>ch.qos.logback</groupId> +          <artifactId>logback-core</artifactId> +        </exclusion> +        <exclusion> +          <groupId>ch.qos.logback</groupId> +          <artifactId>logback-classic</artifactId> +        </exclusion> +        <exclusion> +          <groupId>io.netty</groupId> +          <artifactId>netty-tcnative</artifactId> +        </exclusion> +      </exclusions> +    </dependency> + +    <dependency> +      <groupId>org.apache.bookkeeper</groupId> +      <artifactId>bookkeeper-server</artifactId> +    </dependency> + +    <dependency> +      <groupId>org.apache.commons</groupId> +      <artifactId>commons-lang3</artifactId> +    </dependency> + +    <dependency> +      <groupId>org.testng</groupId> +      <artifactId>testng</artifactId> +    </dependency> + +    <dependency> +      <groupId>org.objenesis</groupId> +      <artifactId>objenesis</artifactId> +    </dependency> + +  </dependencies> + +  <build> +    <plugins> +      <plugin> +        <groupId>org.apache.maven.plugins</groupId> +        <artifactId>maven-checkstyle-plugin</artifactId> +        <executions> +          <execution> +            <id>checkstyle</id> +            <phase>verify</phase> +            <goals> +              <goal>check</goal> +            </goals> +          </execution> +        </executions> +      </plugin> +    </plugins> +  </build> + +</project> diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/BookKeeperTestClient.java b/testmocks/src/main/java/org/apache/bookkeeper/client/BookKeeperTestClient.java index 6aa949d752..0de74ab8af 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/BookKeeperTestClient.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/BookKeeperTestClient.java @@ -1,152 +1,152 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import io.netty.buffer.UnpooledByteBufAllocator; -import java.io.IOException; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.Future; -import lombok.extern.slf4j.Slf4j; -import org.apache.bookkeeper.common.concurrent.FutureUtils; -import org.apache.bookkeeper.conf.ClientConfiguration; -import org.apache.bookkeeper.discover.RegistrationClient.RegistrationListener; -import org.apache.bookkeeper.meta.zk.ZKMetadataClientDriver; -import org.apache.bookkeeper.net.BookieId; -import org.apache.bookkeeper.proto.BookieClient; -import org.apache.bookkeeper.stats.NullStatsLogger; -import org.apache.zookeeper.ZooKeeper; - -/** - * Test BookKeeperClient which allows access to members we don't - * wish to expose in the public API. - */ -@Slf4j -public class BookKeeperTestClient extends BookKeeper { -    TestStatsProvider statsProvider; - -    public BookKeeperTestClient(ClientConfiguration conf, TestStatsProvider statsProvider) -            throws IOException, InterruptedException, BKException { -        super(conf, null, null, new UnpooledByteBufAllocator(false), -                statsProvider == null ? NullStatsLogger.INSTANCE : statsProvider.getStatsLogger(""), -                null, null, null); -        this.statsProvider = statsProvider; -    } - -    public BookKeeperTestClient(ClientConfiguration conf, ZooKeeper zkc) -            throws IOException, InterruptedException, BKException { -        super(conf, zkc, null, new UnpooledByteBufAllocator(false), -                NullStatsLogger.INSTANCE, null, null, null); -    } - -    public BookKeeperTestClient(ClientConfiguration conf) -            throws InterruptedException, BKException, IOException { -        this(conf, (TestStatsProvider) null); -    } - -    public ZooKeeper getZkHandle() { -        return ((ZKMetadataClientDriver) metadataDriver).getZk(); -    } - -    public ClientConfiguration getConf() { -        return super.getConf(); -    } - -    public BookieClient getBookieClient() { -        return bookieClient; -    } - -    public Future<?> waitForReadOnlyBookie(BookieId id) -            throws Exception { -        return waitForBookieInSet(id, false); -    } - -    public Future<?> waitForWritableBookie(BookieId id) -            throws Exception { -        return waitForBookieInSet(id, true); -    } - -    /** -     * Wait for bookie to appear in either the writable set of bookies, -     * or the read only set of bookies. Also ensure that it doesn't exist -     * in the other set before completing. -     */ -    private Future<?> waitForBookieInSet(BookieId id, -                                         boolean writable) throws Exception { -        log.info("Wait for {} to become {}", -                id, writable ? "writable" : "readonly"); - -        CompletableFuture<Void> readOnlyFuture = new CompletableFuture<>(); -        CompletableFuture<Void> writableFuture = new CompletableFuture<>(); - -        RegistrationListener readOnlyListener = (bookies) -> { -            boolean containsId = bookies.getValue().contains(id); -            if ((!writable && containsId) || (writable && !containsId)) { -                readOnlyFuture.complete(null); -            } -        }; -        RegistrationListener writableListener = (bookies) -> { -            boolean containsId = bookies.getValue().contains(id); -            if ((writable && containsId) || (!writable && !containsId)) { -                writableFuture.complete(null); -            } -        }; - -        getMetadataClientDriver().getRegistrationClient().watchWritableBookies(writableListener); -        getMetadataClientDriver().getRegistrationClient().watchReadOnlyBookies(readOnlyListener); - -        if (writable) { -            return writableFuture -                    .thenCompose(ignored -> getMetadataClientDriver().getRegistrationClient().getReadOnlyBookies()) -                    .thenCompose(readonlyBookies -> { -                        if (readonlyBookies.getValue().contains(id)) { -                            // if the bookie still shows up at readonly path, wait for it to disappear -                            return readOnlyFuture; -                        } else { -                            return FutureUtils.Void(); -                        } -                    }); -        } else { -            return readOnlyFuture -                    .thenCompose(ignored -> getMetadataClientDriver().getRegistrationClient().getWritableBookies()) -                    .thenCompose(writableBookies -> { -                        if (writableBookies.getValue().contains(id)) { -                            // if the bookie still shows up at writable path, wait for it to disappear -                            return writableFuture; -                        } else { -                            return FutureUtils.Void(); -                        } -                    }); -        } -    } - -    /** -     * Force a read to zookeeper to get list of bookies. -     * -     * @throws InterruptedException -     * @throws BKException -     */ -    public void readBookiesBlocking() throws InterruptedException, BKException { -        bookieWatcher.initialBlockingBookieRead(); -    } - -    public TestStatsProvider getTestStatsProvider() { -        return statsProvider; -    } -} - +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import io.netty.buffer.UnpooledByteBufAllocator; +import java.io.IOException; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.Future; +import lombok.extern.slf4j.Slf4j; +import org.apache.bookkeeper.common.concurrent.FutureUtils; +import org.apache.bookkeeper.conf.ClientConfiguration; +import org.apache.bookkeeper.discover.RegistrationClient.RegistrationListener; +import org.apache.bookkeeper.meta.zk.ZKMetadataClientDriver; +import org.apache.bookkeeper.net.BookieId; +import org.apache.bookkeeper.proto.BookieClient; +import org.apache.bookkeeper.stats.NullStatsLogger; +import org.apache.zookeeper.ZooKeeper; + +/** + * Test BookKeeperClient which allows access to members we don't + * wish to expose in the public API. + */ +@Slf4j +public class BookKeeperTestClient extends BookKeeper { +    TestStatsProvider statsProvider; + +    public BookKeeperTestClient(ClientConfiguration conf, TestStatsProvider statsProvider) +            throws IOException, InterruptedException, BKException { +        super(conf, null, null, new UnpooledByteBufAllocator(false), +                statsProvider == null ? NullStatsLogger.INSTANCE : statsProvider.getStatsLogger(""), +                null, null, null); +        this.statsProvider = statsProvider; +    } + +    public BookKeeperTestClient(ClientConfiguration conf, ZooKeeper zkc) +            throws IOException, InterruptedException, BKException { +        super(conf, zkc, null, new UnpooledByteBufAllocator(false), +                NullStatsLogger.INSTANCE, null, null, null); +    } + +    public BookKeeperTestClient(ClientConfiguration conf) +            throws InterruptedException, BKException, IOException { +        this(conf, (TestStatsProvider) null); +    } + +    public ZooKeeper getZkHandle() { +        return ((ZKMetadataClientDriver) metadataDriver).getZk(); +    } + +    public ClientConfiguration getConf() { +        return super.getConf(); +    } + +    public BookieClient getBookieClient() { +        return bookieClient; +    } + +    public Future<?> waitForReadOnlyBookie(BookieId id) +            throws Exception { +        return waitForBookieInSet(id, false); +    } + +    public Future<?> waitForWritableBookie(BookieId id) +            throws Exception { +        return waitForBookieInSet(id, true); +    } + +    /** +     * Wait for bookie to appear in either the writable set of bookies, +     * or the read only set of bookies. Also ensure that it doesn't exist +     * in the other set before completing. +     */ +    private Future<?> waitForBookieInSet(BookieId id, +                                         boolean writable) throws Exception { +        log.info("Wait for {} to become {}", +                id, writable ? "writable" : "readonly"); + +        CompletableFuture<Void> readOnlyFuture = new CompletableFuture<>(); +        CompletableFuture<Void> writableFuture = new CompletableFuture<>(); + +        RegistrationListener readOnlyListener = (bookies) -> { +            boolean containsId = bookies.getValue().contains(id); +            if ((!writable && containsId) || (writable && !containsId)) { +                readOnlyFuture.complete(null); +            } +        }; +        RegistrationListener writableListener = (bookies) -> { +            boolean containsId = bookies.getValue().contains(id); +            if ((writable && containsId) || (!writable && !containsId)) { +                writableFuture.complete(null); +            } +        }; + +        getMetadataClientDriver().getRegistrationClient().watchWritableBookies(writableListener); +        getMetadataClientDriver().getRegistrationClient().watchReadOnlyBookies(readOnlyListener); + +        if (writable) { +            return writableFuture +                    .thenCompose(ignored -> getMetadataClientDriver().getRegistrationClient().getReadOnlyBookies()) +                    .thenCompose(readonlyBookies -> { +                        if (readonlyBookies.getValue().contains(id)) { +                            // if the bookie still shows up at readonly path, wait for it to disappear +                            return readOnlyFuture; +                        } else { +                            return FutureUtils.Void(); +                        } +                    }); +        } else { +            return readOnlyFuture +                    .thenCompose(ignored -> getMetadataClientDriver().getRegistrationClient().getWritableBookies()) +                    .thenCompose(writableBookies -> { +                        if (writableBookies.getValue().contains(id)) { +                            // if the bookie still shows up at writable path, wait for it to disappear +                            return writableFuture; +                        } else { +                            return FutureUtils.Void(); +                        } +                    }); +        } +    } + +    /** +     * Force a read to zookeeper to get list of bookies. +     * +     * @throws InterruptedException +     * @throws BKException +     */ +    public void readBookiesBlocking() throws InterruptedException, BKException { +        bookieWatcher.initialBlockingBookieRead(); +    } + +    public TestStatsProvider getTestStatsProvider() { +        return statsProvider; +    } +} + diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeper.java b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeper.java index 9a19515937..af7dc4429b 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeper.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeper.java @@ -1,549 +1,549 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import static com.google.common.base.Preconditions.checkArgument; -import com.google.common.collect.Lists; -import io.netty.util.concurrent.DefaultThreadFactory; -import io.netty.util.concurrent.FastThreadLocal; -import java.util.ArrayList; -import java.util.Arrays; -import java.util.Collection; -import java.util.Collections; -import java.util.HashSet; -import java.util.List; -import java.util.Map; -import java.util.Optional; -import java.util.Queue; -import java.util.Set; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.ConcurrentHashMap; -import java.util.concurrent.ConcurrentLinkedQueue; -import java.util.concurrent.ExecutionException; -import java.util.concurrent.ExecutorService; -import java.util.concurrent.Executors; -import java.util.concurrent.ScheduledExecutorService; -import java.util.concurrent.TimeUnit; -import java.util.concurrent.atomic.AtomicLong; -import lombok.Getter; -import lombok.Setter; -import org.apache.bookkeeper.client.AsyncCallback.CreateCallback; -import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback; -import org.apache.bookkeeper.client.AsyncCallback.OpenCallback; -import org.apache.bookkeeper.client.api.DeleteBuilder; -import org.apache.bookkeeper.client.api.LedgerEntries; -import org.apache.bookkeeper.client.api.OpenBuilder; -import org.apache.bookkeeper.client.api.ReadHandle; -import org.apache.bookkeeper.client.impl.OpenBuilderBase; -import org.apache.bookkeeper.common.concurrent.FutureUtils; -import org.apache.bookkeeper.common.util.OrderedExecutor; -import org.apache.bookkeeper.conf.ClientConfiguration; -import org.apache.bookkeeper.discover.RegistrationClient; -import org.apache.bookkeeper.meta.LayoutManager; -import org.apache.bookkeeper.meta.LedgerManagerFactory; -import org.apache.bookkeeper.meta.MetadataClientDriver; -import org.apache.bookkeeper.meta.exceptions.MetadataException; -import org.apache.bookkeeper.net.BookieId; -import org.apache.bookkeeper.net.BookieSocketAddress; -import org.apache.bookkeeper.stats.StatsLogger; -import org.apache.bookkeeper.versioning.LongVersion; -import org.apache.bookkeeper.versioning.Versioned; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * Mocked version of BookKeeper client that keeps all ledgers data in memory. - * - * <p>This mocked client is meant to be used in unit tests for applications using the BookKeeper API. - */ -public class PulsarMockBookKeeper extends BookKeeper { - -    final OrderedExecutor orderedExecutor; -    final ExecutorService executor; -    final ScheduledExecutorService scheduler; -    private volatile long defaultAddEntryDelayMillis = 1L; -    private volatile long defaultReadEntriesDelayMillis = 1L; - -    @Override -    public ClientConfiguration getConf() { -        return super.getConf(); -    } - -    final Map<Long, PulsarMockLedgerHandle> ledgers = new ConcurrentHashMap<>(); -    final AtomicLong sequence = new AtomicLong(3); - -    CompletableFuture<Void> defaultResponse = CompletableFuture.completedFuture(null); -    private static final List<BookieId> ensemble = Collections.unmodifiableList(Lists.newArrayList( -            new BookieSocketAddress("192.0.2.1", 1234).toBookieId(), -            new BookieSocketAddress("192.0.2.2", 1234).toBookieId(), -            new BookieSocketAddress("192.0.2.3", 1234).toBookieId())); - -    public static Collection<BookieId> getMockEnsemble() { -        return ensemble; -    } - -    final Queue<Long> addEntryDelaysMillis = new ConcurrentLinkedQueue<>(); -    final Queue<Long> addEntryResponseDelaysMillis = new ConcurrentLinkedQueue<>(); -    final List<CompletableFuture<Void>> failures = new ArrayList<>(); -    final List<CompletableFuture<Void>> addEntryFailures = new ArrayList<>(); -    @Setter -    @Getter -    private volatile PulsarMockReadHandleInterceptor readHandleInterceptor; - -    public PulsarMockBookKeeper(OrderedExecutor orderedExecutor) throws Exception { -        this.orderedExecutor = orderedExecutor; -        this.executor = orderedExecutor.chooseThread(); -        scheduler = Executors.newScheduledThreadPool(1, new DefaultThreadFactory("mock-bk-scheduler")); -    } - -    @Override -    public OrderedExecutor getMainWorkerPool() { -        return orderedExecutor; -    } - -    @Override -    public LedgerHandle createLedger(DigestType digestType, byte[] passwd) -            throws BKException, InterruptedException { -        return createLedger(3, 2, digestType, passwd); -    } - -    @Override -    public LedgerHandle createLedger(int ensSize, int qSize, DigestType digestType, byte[] passwd) -            throws BKException, InterruptedException { -        return createLedger(ensSize, qSize, qSize, digestType, passwd); -    } - -    @Override -    public void asyncCreateLedger(int ensSize, int writeQuorumSize, int ackQuorumSize, final DigestType digestType, -            final byte[] passwd, final CreateCallback cb, final Object ctx, Map<String, byte[]> properties) { -        getProgrammedFailure().thenComposeAsync((res) -> { -                try { -                    long id = sequence.getAndIncrement(); -                    log.info("Creating ledger {}", id); -                    PulsarMockLedgerHandle lh = -                            new PulsarMockLedgerHandle(PulsarMockBookKeeper.this, id, digestType, passwd); -                    ledgers.put(id, lh); -                    return FutureUtils.value(lh); -                } catch (Throwable t) { -                    return FutureUtils.exception(t); -                } -            }, executor).whenCompleteAsync((lh, exception) -> { -                    if (exception != null) { -                        cb.createComplete(getExceptionCode(exception), null, ctx); -                    } else { -                        cb.createComplete(BKException.Code.OK, lh, ctx); -                    } -                }, executor); -    } - -    @Override -    public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, -            byte[] passwd) throws BKException, InterruptedException { -        checkProgrammedFail(); - -        try { -            long id = sequence.getAndIncrement(); -            log.info("Creating ledger {}", id); -            PulsarMockLedgerHandle lh = new PulsarMockLedgerHandle(this, id, digestType, passwd); -            ledgers.put(id, lh); -            return lh; -        } catch (Throwable t) { -            log.error("Exception:", t); -            return null; -        } -    } - -    @Override -    public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType, byte[] passwd, CreateCallback cb, -            Object ctx) { -        asyncCreateLedger(ensSize, qSize, qSize, digestType, passwd, cb, ctx, Collections.emptyMap()); -    } - -    @Override -    public void asyncOpenLedger(long lId, DigestType digestType, byte[] passwd, OpenCallback cb, Object ctx) { -        getProgrammedFailure().thenComposeAsync((res) -> { -                PulsarMockLedgerHandle lh = ledgers.get(lId); -                if (lh == null) { -                    return FutureUtils.exception(new BKException.BKNoSuchLedgerExistsException()); -                } else if (lh.digest != digestType) { -                    return FutureUtils.exception(new BKException.BKDigestMatchException()); -                } else if (!Arrays.equals(lh.passwd, passwd)) { -                    return FutureUtils.exception(new BKException.BKUnauthorizedAccessException()); -                } else { -                    return FutureUtils.value(lh); -                } -            }, executor).whenCompleteAsync((ledger, exception) -> { -                    if (exception != null) { -                        cb.openComplete(getExceptionCode(exception), null, ctx); -                    } else { -                        cb.openComplete(BKException.Code.OK, ledger, ctx); -                    } -                }, executor); -    } - -    @Override -    public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte[] passwd, OpenCallback cb, Object ctx) { -        asyncOpenLedger(lId, digestType, passwd, cb, ctx); -    } - -    @Override -    public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) { -        getProgrammedFailure().thenComposeAsync((res) -> { -                if (ledgers.containsKey(lId)) { -                    ledgers.remove(lId); -                    return FutureUtils.value(null); -                } else { -                    return FutureUtils.exception(new BKException.BKNoSuchLedgerExistsException()); -                } -            }, executor).whenCompleteAsync((res, exception) -> { -                    if (exception != null) { -                        cb.deleteComplete(getExceptionCode(exception), ctx); -                    } else { -                        cb.deleteComplete(BKException.Code.OK, ctx); -                    } -                }, executor); -    } - -    @Override -    public void deleteLedger(long lId) throws InterruptedException, BKException { -        checkProgrammedFail(); - -        if (!ledgers.containsKey(lId)) { -            throw BKException.create(BKException.Code.NoSuchLedgerExistsException); -        } - -        ledgers.remove(lId); -    } - -    @Override -    public void close() throws InterruptedException, BKException { -        shutdown(); -    } - - - -    @Override -    public OpenBuilder newOpenLedgerOp() { -        return new OpenBuilderBase() { -            @Override -            public CompletableFuture<ReadHandle> execute() { -                return getProgrammedFailure().thenCompose( -                        (res) -> { -                            int rc = validate(); -                            if (rc != BKException.Code.OK) { -                                return FutureUtils.exception(BKException.create(rc)); -                            } - -                            PulsarMockLedgerHandle lh = ledgers.get(ledgerId); -                            if (lh == null) { -                                return FutureUtils.exception(new BKException.BKNoSuchLedgerExistsException()); -                            } else if (lh.digest != DigestType.fromApiDigestType(digestType)) { -                                return FutureUtils.exception(new BKException.BKDigestMatchException()); -                            } else if (!Arrays.equals(lh.passwd, password)) { -                                return FutureUtils.exception(new BKException.BKUnauthorizedAccessException()); -                            } else { -                                return FutureUtils.value(new PulsarMockReadHandle(PulsarMockBookKeeper.this, ledgerId, -                                        lh.getLedgerMetadata(), lh.entries, -                                        PulsarMockBookKeeper.this::getReadHandleInterceptor, lh.totalLengthCounter)); -                            } -                        }); -            } -        }; -    } - -    @Override -    public DeleteBuilder newDeleteLedgerOp() { -        return new DeleteBuilder() { -            private long ledgerId; - -            @Override -            public CompletableFuture<Void> execute() { -                CompletableFuture<Void> future = new CompletableFuture<>(); -                asyncDeleteLedger(ledgerId, (res, ctx) -> { -                    if (res == BKException.Code.OK) { -                        future.complete(null); -                    } else { -                        future.completeExceptionally(BKException.create(res)); -                    } -                }, null); -                return future; -            } - -            @Override -            public DeleteBuilder withLedgerId(long ledgerId) { -                this.ledgerId = ledgerId; -                return this; -            } -        }; -    } - -    public void shutdown() { -        try { -            super.close(); -        } catch (Exception e) { -        } -        synchronized (this) { -            defaultResponse = FutureUtils.exception(new BKException.BKClientClosedException()); -        } -        for (PulsarMockLedgerHandle ledger : ledgers.values()) { -            ledger.entries.clear(); -            ledger.totalLengthCounter.set(0); -        } -        scheduler.shutdown(); -        ledgers.clear(); -    } - -    public Set<Long> getLedgers() { -        return ledgers.keySet(); -    } - -    public Map<Long, PulsarMockLedgerHandle> getLedgerMap() { -        return ledgers; -    } - -    void checkProgrammedFail() throws BKException, InterruptedException { -        try { -            getProgrammedFailure().get(); -        } catch (ExecutionException ee) { -            if (ee.getCause() instanceof BKException) { -                throw (BKException) ee.getCause(); -            } else { -                throw new BKException.BKUnexpectedConditionException(); -            } -        } -    } - -    synchronized boolean checkReturnEmptyLedger() { -        boolean shouldFailNow = (emptyLedgerAfter == 0); -        --emptyLedgerAfter; -        return shouldFailNow; -    } - -    synchronized CompletableFuture<Void> getAddEntryFailure() { -        if (!addEntryFailures.isEmpty()){ -            return addEntryFailures.remove(0); -        } -        return failures.isEmpty() ? defaultResponse : failures.remove(0); -    } - -    synchronized CompletableFuture<Void> getProgrammedFailure() { -        return failures.isEmpty() ? defaultResponse : failures.remove(0); -    } - -    public void delay(long millis) { -        CompletableFuture<Void> delayFuture = new CompletableFuture<>(); -        scheduler.schedule(() -> { -            delayFuture.complete(null); -        }, millis, TimeUnit.MILLISECONDS); -        failures.add(delayFuture); -    } - - -    public void failNow(int rc) { -        failAfter(0, rc); -    } - -    public void failAfter(int steps, int rc) { -        promiseAfter(steps, failures).completeExceptionally(BKException.create(rc)); -    } - -    public void addEntryFailAfter(int steps, int rc) { -        promiseAfter(steps, addEntryFailures).completeExceptionally(BKException.create(rc)); -    } - -    private int emptyLedgerAfter = -1; - -    /** -     * After N times, make a ledger to appear to be empty. -     */ -    public synchronized void returnEmptyLedgerAfter(int steps) { -        emptyLedgerAfter = steps; -    } - -    public synchronized CompletableFuture<Void> promiseAfter(int steps) { -        return promiseAfter(steps, failures); -    } - -    public synchronized CompletableFuture<Void> promiseAfter(int steps, List<CompletableFuture<Void>> failures) { -        while (failures.size() <= steps) { -            failures.add(defaultResponse); -        } -        CompletableFuture<Void> promise = new CompletableFuture<>(); -        failures.set(steps, promise); -        return promise; -    } - -    public synchronized void addEntryDelay(long delay, TimeUnit unit) { -        addEntryDelaysMillis.add(unit.toMillis(delay)); -    } - -    public synchronized void addEntryResponseDelay(long delay, TimeUnit unit) { -        checkArgument(delay >= 0, "The delay time must not be negative."); -        addEntryResponseDelaysMillis.add(unit.toMillis(delay)); -    } - -    static int getExceptionCode(Throwable t) { -        if (t instanceof BKException) { -            return ((BKException) t).getCode(); -        } else if (t.getCause() != null) { -            return getExceptionCode(t.getCause()); -        } else { -            return BKException.Code.UnexpectedConditionException; -        } -    } - -    private final RegistrationClient mockRegistrationClient = new RegistrationClient() { -        @Override -        public void close() { - -        } - -        @Override -        public CompletableFuture<Versioned<Set<BookieId>>> getWritableBookies() { -            return getAllBookies(); -        } - -        @Override -        public CompletableFuture<Versioned<Set<BookieId>>> getAllBookies() { -            return CompletableFuture.completedFuture(new Versioned<>(new HashSet<>(ensemble), new LongVersion(0))); -        } - -        @Override -        public CompletableFuture<Versioned<Set<BookieId>>> getReadOnlyBookies() { -            return CompletableFuture.completedFuture(new Versioned<>(new HashSet<>(), new LongVersion(0))); -        } - -        @Override -        public CompletableFuture<Void> watchWritableBookies(RegistrationListener listener) { -            return defaultResponse; -        } - -        @Override -        public void unwatchWritableBookies(RegistrationListener listener) { - -        } - -        @Override -        public CompletableFuture<Void> watchReadOnlyBookies(RegistrationListener listener) { -            return defaultResponse; -        } - -        @Override -        public void unwatchReadOnlyBookies(RegistrationListener listener) { - -        } -    }; - -    private final MetadataClientDriver metadataClientDriver = new MetadataClientDriver() { -        @Override -        public MetadataClientDriver initialize(ClientConfiguration conf, ScheduledExecutorService scheduler, -                                               StatsLogger statsLogger, Optional<Object> ctx) throws MetadataException { -            return this; -        } - -        @Override -        public String getScheme() { -            return "mock"; -        } - -        @Override -        public RegistrationClient getRegistrationClient() { -            return mockRegistrationClient; -        } - -        @Override -        public LedgerManagerFactory getLedgerManagerFactory() throws MetadataException { -            return null; -        } - -        @Override -        public LayoutManager getLayoutManager() { -            return null; -        } - -        @Override -        public void close() { - -        } - -        @Override -        public void setSessionStateListener(SessionStateListener sessionStateListener) { - -        } -    }; - -    @Override -    public MetadataClientDriver getMetadataClientDriver() { -        return metadataClientDriver; -    } - -    public long getReadEntriesDelayMillis() { -        return defaultReadEntriesDelayMillis; -    } - -    public long getNextAddEntryDelayMillis() { -        Long delay = addEntryDelaysMillis.poll(); -        if (delay != null) { -            return delay; -        } -        return defaultAddEntryDelayMillis; -    } - -    public long getNextAddEntryResponseDelayMillis() { -        Long delay = addEntryResponseDelaysMillis.poll(); -        if (delay != null) { -            return delay; -        } -        return 0; -    } - -    public void setDefaultAddEntryDelayMillis(long defaultAddEntryDelayMillis) { -        this.defaultAddEntryDelayMillis = defaultAddEntryDelayMillis; -    } - -    public void setDefaultReadEntriesDelayMillis(long defaultReadEntriesDelayMillis) { -        this.defaultReadEntriesDelayMillis = defaultReadEntriesDelayMillis; -    } - -    private final FastThreadLocal<PulsarMockBookKeeperReadEvent> readEventThreadLocal = new FastThreadLocal<>() { -        @Override -        protected PulsarMockBookKeeperReadEvent initialValue() throws Exception { -            return new PulsarMockBookKeeperReadEvent(); -        } -    }; - -    /** -     * A PulsarMockReadHandleInterceptor implementation that creates custom Java Flight Recorder events -     * for each Pulsar MockBookKeeper read. -     * This is useful when profiling a test with JFR recording or with Async Profiler and its jfrsync option. -     */ -    @Getter -    PulsarMockReadHandleInterceptor jfrReadHandleInterceptor = -            (long ledgerId, long firstEntry, long lastEntry, LedgerEntries entries) -> { -                PulsarMockBookKeeperReadEvent event = readEventThreadLocal.get(); -                event.maybeApplyAndCommit(ledgerId, firstEntry, lastEntry); -                return CompletableFuture.completedFuture(entries); -            }; - -    public void useJfrReadHandleInterceptor() { -        setReadHandleInterceptor(jfrReadHandleInterceptor); -    } - -    private static final Logger log = LoggerFactory.getLogger(PulsarMockBookKeeper.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import static com.google.common.base.Preconditions.checkArgument; +import com.google.common.collect.Lists; +import io.netty.util.concurrent.DefaultThreadFactory; +import io.netty.util.concurrent.FastThreadLocal; +import java.util.ArrayList; +import java.util.Arrays; +import java.util.Collection; +import java.util.Collections; +import java.util.HashSet; +import java.util.List; +import java.util.Map; +import java.util.Optional; +import java.util.Queue; +import java.util.Set; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.ConcurrentHashMap; +import java.util.concurrent.ConcurrentLinkedQueue; +import java.util.concurrent.ExecutionException; +import java.util.concurrent.ExecutorService; +import java.util.concurrent.Executors; +import java.util.concurrent.ScheduledExecutorService; +import java.util.concurrent.TimeUnit; +import java.util.concurrent.atomic.AtomicLong; +import lombok.Getter; +import lombok.Setter; +import org.apache.bookkeeper.client.AsyncCallback.CreateCallback; +import org.apache.bookkeeper.client.AsyncCallback.DeleteCallback; +import org.apache.bookkeeper.client.AsyncCallback.OpenCallback; +import org.apache.bookkeeper.client.api.DeleteBuilder; +import org.apache.bookkeeper.client.api.LedgerEntries; +import org.apache.bookkeeper.client.api.OpenBuilder; +import org.apache.bookkeeper.client.api.ReadHandle; +import org.apache.bookkeeper.client.impl.OpenBuilderBase; +import org.apache.bookkeeper.common.concurrent.FutureUtils; +import org.apache.bookkeeper.common.util.OrderedExecutor; +import org.apache.bookkeeper.conf.ClientConfiguration; +import org.apache.bookkeeper.discover.RegistrationClient; +import org.apache.bookkeeper.meta.LayoutManager; +import org.apache.bookkeeper.meta.LedgerManagerFactory; +import org.apache.bookkeeper.meta.MetadataClientDriver; +import org.apache.bookkeeper.meta.exceptions.MetadataException; +import org.apache.bookkeeper.net.BookieId; +import org.apache.bookkeeper.net.BookieSocketAddress; +import org.apache.bookkeeper.stats.StatsLogger; +import org.apache.bookkeeper.versioning.LongVersion; +import org.apache.bookkeeper.versioning.Versioned; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * Mocked version of BookKeeper client that keeps all ledgers data in memory. + * + * <p>This mocked client is meant to be used in unit tests for applications using the BookKeeper API. + */ +public class PulsarMockBookKeeper extends BookKeeper { + +    final OrderedExecutor orderedExecutor; +    final ExecutorService executor; +    final ScheduledExecutorService scheduler; +    private volatile long defaultAddEntryDelayMillis = 1L; +    private volatile long defaultReadEntriesDelayMillis = 1L; + +    @Override +    public ClientConfiguration getConf() { +        return super.getConf(); +    } + +    final Map<Long, PulsarMockLedgerHandle> ledgers = new ConcurrentHashMap<>(); +    final AtomicLong sequence = new AtomicLong(3); + +    CompletableFuture<Void> defaultResponse = CompletableFuture.completedFuture(null); +    private static final List<BookieId> ensemble = Collections.unmodifiableList(Lists.newArrayList( +            new BookieSocketAddress("192.0.2.1", 1234).toBookieId(), +            new BookieSocketAddress("192.0.2.2", 1234).toBookieId(), +            new BookieSocketAddress("192.0.2.3", 1234).toBookieId())); + +    public static Collection<BookieId> getMockEnsemble() { +        return ensemble; +    } + +    final Queue<Long> addEntryDelaysMillis = new ConcurrentLinkedQueue<>(); +    final Queue<Long> addEntryResponseDelaysMillis = new ConcurrentLinkedQueue<>(); +    final List<CompletableFuture<Void>> failures = new ArrayList<>(); +    final List<CompletableFuture<Void>> addEntryFailures = new ArrayList<>(); +    @Setter +    @Getter +    private volatile PulsarMockReadHandleInterceptor readHandleInterceptor; + +    public PulsarMockBookKeeper(OrderedExecutor orderedExecutor) throws Exception { +        this.orderedExecutor = orderedExecutor; +        this.executor = orderedExecutor.chooseThread(); +        scheduler = Executors.newScheduledThreadPool(1, new DefaultThreadFactory("mock-bk-scheduler")); +    } + +    @Override +    public OrderedExecutor getMainWorkerPool() { +        return orderedExecutor; +    } + +    @Override +    public LedgerHandle createLedger(DigestType digestType, byte[] passwd) +            throws BKException, InterruptedException { +        return createLedger(3, 2, digestType, passwd); +    } + +    @Override +    public LedgerHandle createLedger(int ensSize, int qSize, DigestType digestType, byte[] passwd) +            throws BKException, InterruptedException { +        return createLedger(ensSize, qSize, qSize, digestType, passwd); +    } + +    @Override +    public void asyncCreateLedger(int ensSize, int writeQuorumSize, int ackQuorumSize, final DigestType digestType, +            final byte[] passwd, final CreateCallback cb, final Object ctx, Map<String, byte[]> properties) { +        getProgrammedFailure().thenComposeAsync((res) -> { +                try { +                    long id = sequence.getAndIncrement(); +                    log.info("Creating ledger {}", id); +                    PulsarMockLedgerHandle lh = +                            new PulsarMockLedgerHandle(PulsarMockBookKeeper.this, id, digestType, passwd); +                    ledgers.put(id, lh); +                    return FutureUtils.value(lh); +                } catch (Throwable t) { +                    return FutureUtils.exception(t); +                } +            }, executor).whenCompleteAsync((lh, exception) -> { +                    if (exception != null) { +                        cb.createComplete(getExceptionCode(exception), null, ctx); +                    } else { +                        cb.createComplete(BKException.Code.OK, lh, ctx); +                    } +                }, executor); +    } + +    @Override +    public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, +            byte[] passwd) throws BKException, InterruptedException { +        checkProgrammedFail(); + +        try { +            long id = sequence.getAndIncrement(); +            log.info("Creating ledger {}", id); +            PulsarMockLedgerHandle lh = new PulsarMockLedgerHandle(this, id, digestType, passwd); +            ledgers.put(id, lh); +            return lh; +        } catch (Throwable t) { +            log.error("Exception:", t); +            return null; +        } +    } + +    @Override +    public void asyncCreateLedger(int ensSize, int qSize, DigestType digestType, byte[] passwd, CreateCallback cb, +            Object ctx) { +        asyncCreateLedger(ensSize, qSize, qSize, digestType, passwd, cb, ctx, Collections.emptyMap()); +    } + +    @Override +    public void asyncOpenLedger(long lId, DigestType digestType, byte[] passwd, OpenCallback cb, Object ctx) { +        getProgrammedFailure().thenComposeAsync((res) -> { +                PulsarMockLedgerHandle lh = ledgers.get(lId); +                if (lh == null) { +                    return FutureUtils.exception(new BKException.BKNoSuchLedgerExistsException()); +                } else if (lh.digest != digestType) { +                    return FutureUtils.exception(new BKException.BKDigestMatchException()); +                } else if (!Arrays.equals(lh.passwd, passwd)) { +                    return FutureUtils.exception(new BKException.BKUnauthorizedAccessException()); +                } else { +                    return FutureUtils.value(lh); +                } +            }, executor).whenCompleteAsync((ledger, exception) -> { +                    if (exception != null) { +                        cb.openComplete(getExceptionCode(exception), null, ctx); +                    } else { +                        cb.openComplete(BKException.Code.OK, ledger, ctx); +                    } +                }, executor); +    } + +    @Override +    public void asyncOpenLedgerNoRecovery(long lId, DigestType digestType, byte[] passwd, OpenCallback cb, Object ctx) { +        asyncOpenLedger(lId, digestType, passwd, cb, ctx); +    } + +    @Override +    public void asyncDeleteLedger(long lId, DeleteCallback cb, Object ctx) { +        getProgrammedFailure().thenComposeAsync((res) -> { +                if (ledgers.containsKey(lId)) { +                    ledgers.remove(lId); +                    return FutureUtils.value(null); +                } else { +                    return FutureUtils.exception(new BKException.BKNoSuchLedgerExistsException()); +                } +            }, executor).whenCompleteAsync((res, exception) -> { +                    if (exception != null) { +                        cb.deleteComplete(getExceptionCode(exception), ctx); +                    } else { +                        cb.deleteComplete(BKException.Code.OK, ctx); +                    } +                }, executor); +    } + +    @Override +    public void deleteLedger(long lId) throws InterruptedException, BKException { +        checkProgrammedFail(); + +        if (!ledgers.containsKey(lId)) { +            throw BKException.create(BKException.Code.NoSuchLedgerExistsException); +        } + +        ledgers.remove(lId); +    } + +    @Override +    public void close() throws InterruptedException, BKException { +        shutdown(); +    } + + + +    @Override +    public OpenBuilder newOpenLedgerOp() { +        return new OpenBuilderBase() { +            @Override +            public CompletableFuture<ReadHandle> execute() { +                return getProgrammedFailure().thenCompose( +                        (res) -> { +                            int rc = validate(); +                            if (rc != BKException.Code.OK) { +                                return FutureUtils.exception(BKException.create(rc)); +                            } + +                            PulsarMockLedgerHandle lh = ledgers.get(ledgerId); +                            if (lh == null) { +                                return FutureUtils.exception(new BKException.BKNoSuchLedgerExistsException()); +                            } else if (lh.digest != DigestType.fromApiDigestType(digestType)) { +                                return FutureUtils.exception(new BKException.BKDigestMatchException()); +                            } else if (!Arrays.equals(lh.passwd, password)) { +                                return FutureUtils.exception(new BKException.BKUnauthorizedAccessException()); +                            } else { +                                return FutureUtils.value(new PulsarMockReadHandle(PulsarMockBookKeeper.this, ledgerId, +                                        lh.getLedgerMetadata(), lh.entries, +                                        PulsarMockBookKeeper.this::getReadHandleInterceptor, lh.totalLengthCounter)); +                            } +                        }); +            } +        }; +    } + +    @Override +    public DeleteBuilder newDeleteLedgerOp() { +        return new DeleteBuilder() { +            private long ledgerId; + +            @Override +            public CompletableFuture<Void> execute() { +                CompletableFuture<Void> future = new CompletableFuture<>(); +                asyncDeleteLedger(ledgerId, (res, ctx) -> { +                    if (res == BKException.Code.OK) { +                        future.complete(null); +                    } else { +                        future.completeExceptionally(BKException.create(res)); +                    } +                }, null); +                return future; +            } + +            @Override +            public DeleteBuilder withLedgerId(long ledgerId) { +                this.ledgerId = ledgerId; +                return this; +            } +        }; +    } + +    public void shutdown() { +        try { +            super.close(); +        } catch (Exception e) { +        } +        synchronized (this) { +            defaultResponse = FutureUtils.exception(new BKException.BKClientClosedException()); +        } +        for (PulsarMockLedgerHandle ledger : ledgers.values()) { +            ledger.entries.clear(); +            ledger.totalLengthCounter.set(0); +        } +        scheduler.shutdown(); +        ledgers.clear(); +    } + +    public Set<Long> getLedgers() { +        return ledgers.keySet(); +    } + +    public Map<Long, PulsarMockLedgerHandle> getLedgerMap() { +        return ledgers; +    } + +    void checkProgrammedFail() throws BKException, InterruptedException { +        try { +            getProgrammedFailure().get(); +        } catch (ExecutionException ee) { +            if (ee.getCause() instanceof BKException) { +                throw (BKException) ee.getCause(); +            } else { +                throw new BKException.BKUnexpectedConditionException(); +            } +        } +    } + +    synchronized boolean checkReturnEmptyLedger() { +        boolean shouldFailNow = (emptyLedgerAfter == 0); +        --emptyLedgerAfter; +        return shouldFailNow; +    } + +    synchronized CompletableFuture<Void> getAddEntryFailure() { +        if (!addEntryFailures.isEmpty()){ +            return addEntryFailures.remove(0); +        } +        return failures.isEmpty() ? defaultResponse : failures.remove(0); +    } + +    synchronized CompletableFuture<Void> getProgrammedFailure() { +        return failures.isEmpty() ? defaultResponse : failures.remove(0); +    } + +    public void delay(long millis) { +        CompletableFuture<Void> delayFuture = new CompletableFuture<>(); +        scheduler.schedule(() -> { +            delayFuture.complete(null); +        }, millis, TimeUnit.MILLISECONDS); +        failures.add(delayFuture); +    } + + +    public void failNow(int rc) { +        failAfter(0, rc); +    } + +    public void failAfter(int steps, int rc) { +        promiseAfter(steps, failures).completeExceptionally(BKException.create(rc)); +    } + +    public void addEntryFailAfter(int steps, int rc) { +        promiseAfter(steps, addEntryFailures).completeExceptionally(BKException.create(rc)); +    } + +    private int emptyLedgerAfter = -1; + +    /** +     * After N times, make a ledger to appear to be empty. +     */ +    public synchronized void returnEmptyLedgerAfter(int steps) { +        emptyLedgerAfter = steps; +    } + +    public synchronized CompletableFuture<Void> promiseAfter(int steps) { +        return promiseAfter(steps, failures); +    } + +    public synchronized CompletableFuture<Void> promiseAfter(int steps, List<CompletableFuture<Void>> failures) { +        while (failures.size() <= steps) { +            failures.add(defaultResponse); +        } +        CompletableFuture<Void> promise = new CompletableFuture<>(); +        failures.set(steps, promise); +        return promise; +    } + +    public synchronized void addEntryDelay(long delay, TimeUnit unit) { +        addEntryDelaysMillis.add(unit.toMillis(delay)); +    } + +    public synchronized void addEntryResponseDelay(long delay, TimeUnit unit) { +        checkArgument(delay >= 0, "The delay time must not be negative."); +        addEntryResponseDelaysMillis.add(unit.toMillis(delay)); +    } + +    static int getExceptionCode(Throwable t) { +        if (t instanceof BKException) { +            return ((BKException) t).getCode(); +        } else if (t.getCause() != null) { +            return getExceptionCode(t.getCause()); +        } else { +            return BKException.Code.UnexpectedConditionException; +        } +    } + +    private final RegistrationClient mockRegistrationClient = new RegistrationClient() { +        @Override +        public void close() { + +        } + +        @Override +        public CompletableFuture<Versioned<Set<BookieId>>> getWritableBookies() { +            return getAllBookies(); +        } + +        @Override +        public CompletableFuture<Versioned<Set<BookieId>>> getAllBookies() { +            return CompletableFuture.completedFuture(new Versioned<>(new HashSet<>(ensemble), new LongVersion(0))); +        } + +        @Override +        public CompletableFuture<Versioned<Set<BookieId>>> getReadOnlyBookies() { +            return CompletableFuture.completedFuture(new Versioned<>(new HashSet<>(), new LongVersion(0))); +        } + +        @Override +        public CompletableFuture<Void> watchWritableBookies(RegistrationListener listener) { +            return defaultResponse; +        } + +        @Override +        public void unwatchWritableBookies(RegistrationListener listener) { + +        } + +        @Override +        public CompletableFuture<Void> watchReadOnlyBookies(RegistrationListener listener) { +            return defaultResponse; +        } + +        @Override +        public void unwatchReadOnlyBookies(RegistrationListener listener) { + +        } +    }; + +    private final MetadataClientDriver metadataClientDriver = new MetadataClientDriver() { +        @Override +        public MetadataClientDriver initialize(ClientConfiguration conf, ScheduledExecutorService scheduler, +                                               StatsLogger statsLogger, Optional<Object> ctx) throws MetadataException { +            return this; +        } + +        @Override +        public String getScheme() { +            return "mock"; +        } + +        @Override +        public RegistrationClient getRegistrationClient() { +            return mockRegistrationClient; +        } + +        @Override +        public LedgerManagerFactory getLedgerManagerFactory() throws MetadataException { +            return null; +        } + +        @Override +        public LayoutManager getLayoutManager() { +            return null; +        } + +        @Override +        public void close() { + +        } + +        @Override +        public void setSessionStateListener(SessionStateListener sessionStateListener) { + +        } +    }; + +    @Override +    public MetadataClientDriver getMetadataClientDriver() { +        return metadataClientDriver; +    } + +    public long getReadEntriesDelayMillis() { +        return defaultReadEntriesDelayMillis; +    } + +    public long getNextAddEntryDelayMillis() { +        Long delay = addEntryDelaysMillis.poll(); +        if (delay != null) { +            return delay; +        } +        return defaultAddEntryDelayMillis; +    } + +    public long getNextAddEntryResponseDelayMillis() { +        Long delay = addEntryResponseDelaysMillis.poll(); +        if (delay != null) { +            return delay; +        } +        return 0; +    } + +    public void setDefaultAddEntryDelayMillis(long defaultAddEntryDelayMillis) { +        this.defaultAddEntryDelayMillis = defaultAddEntryDelayMillis; +    } + +    public void setDefaultReadEntriesDelayMillis(long defaultReadEntriesDelayMillis) { +        this.defaultReadEntriesDelayMillis = defaultReadEntriesDelayMillis; +    } + +    private final FastThreadLocal<PulsarMockBookKeeperReadEvent> readEventThreadLocal = new FastThreadLocal<>() { +        @Override +        protected PulsarMockBookKeeperReadEvent initialValue() throws Exception { +            return new PulsarMockBookKeeperReadEvent(); +        } +    }; + +    /** +     * A PulsarMockReadHandleInterceptor implementation that creates custom Java Flight Recorder events +     * for each Pulsar MockBookKeeper read. +     * This is useful when profiling a test with JFR recording or with Async Profiler and its jfrsync option. +     */ +    @Getter +    PulsarMockReadHandleInterceptor jfrReadHandleInterceptor = +            (long ledgerId, long firstEntry, long lastEntry, LedgerEntries entries) -> { +                PulsarMockBookKeeperReadEvent event = readEventThreadLocal.get(); +                event.maybeApplyAndCommit(ledgerId, firstEntry, lastEntry); +                return CompletableFuture.completedFuture(entries); +            }; + +    public void useJfrReadHandleInterceptor() { +        setReadHandleInterceptor(jfrReadHandleInterceptor); +    } + +    private static final Logger log = LoggerFactory.getLogger(PulsarMockBookKeeper.class); +} diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeperReadEvent.java b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeperReadEvent.java index 3de27f7423..2808690dfb 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeperReadEvent.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockBookKeeperReadEvent.java @@ -1,55 +1,55 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import jdk.jfr.Category; -import jdk.jfr.Description; -import jdk.jfr.Event; -import jdk.jfr.Label; - -@Label("Pulsar MockBookKeeper read event") -@Description("Records a read event made to Pulsar MockBookKeeper") -@Category("Application") -public class PulsarMockBookKeeperReadEvent extends Event { -    @Label("LedgerId") -    private long ledgerId; -    @Label("FirstEntry") -    private long firstEntry; -    @Label("LastEntry") -    private long lastEntry; -    @Label("NumberOfEntries") -    private int numberOfEntries; - -    /** -     * Creates a new custom Java Flight Recorder event for a Pulsar MockBookKeeper read. -     * This is useful when profiling a test with JFR recording or with Async Profiler and its jfrsync option. -     * @param ledgerId ledger id -     * @param firstEntry first entry to read -     * @param lastEntry last entry to read -     */ -    public void maybeApplyAndCommit(long ledgerId, long firstEntry, long lastEntry) { -        if (shouldCommit()) { -            this.ledgerId = ledgerId; -            this.firstEntry = firstEntry; -            this.lastEntry = lastEntry; -            this.numberOfEntries = (int) (lastEntry - firstEntry + 1); -            commit(); -        } -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import jdk.jfr.Category; +import jdk.jfr.Description; +import jdk.jfr.Event; +import jdk.jfr.Label; + +@Label("Pulsar MockBookKeeper read event") +@Description("Records a read event made to Pulsar MockBookKeeper") +@Category("Application") +public class PulsarMockBookKeeperReadEvent extends Event { +    @Label("LedgerId") +    private long ledgerId; +    @Label("FirstEntry") +    private long firstEntry; +    @Label("LastEntry") +    private long lastEntry; +    @Label("NumberOfEntries") +    private int numberOfEntries; + +    /** +     * Creates a new custom Java Flight Recorder event for a Pulsar MockBookKeeper read. +     * This is useful when profiling a test with JFR recording or with Async Profiler and its jfrsync option. +     * @param ledgerId ledger id +     * @param firstEntry first entry to read +     * @param lastEntry last entry to read +     */ +    public void maybeApplyAndCommit(long ledgerId, long firstEntry, long lastEntry) { +        if (shouldCommit()) { +            this.ledgerId = ledgerId; +            this.firstEntry = firstEntry; +            this.lastEntry = lastEntry; +            this.numberOfEntries = (int) (lastEntry - firstEntry + 1); +            commit(); +        } +    } +} diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockLedgerHandle.java b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockLedgerHandle.java index 74dab3ebbf..9e42656fef 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockLedgerHandle.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockLedgerHandle.java @@ -1,289 +1,289 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import com.google.common.annotations.VisibleForTesting; -import io.netty.buffer.ByteBuf; -import io.netty.buffer.Unpooled; -import java.security.GeneralSecurityException; -import java.util.ArrayDeque; -import java.util.ArrayList; -import java.util.Arrays; -import java.util.Collections; -import java.util.Enumeration; -import java.util.List; -import java.util.Queue; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.atomic.AtomicLong; -import lombok.Getter; -import org.apache.bookkeeper.client.AsyncCallback.AddCallback; -import org.apache.bookkeeper.client.AsyncCallback.CloseCallback; -import org.apache.bookkeeper.client.AsyncCallback.ReadCallback; -import org.apache.bookkeeper.client.BookKeeper.DigestType; -import org.apache.bookkeeper.client.api.LastConfirmedAndEntry; -import org.apache.bookkeeper.client.api.LedgerEntries; -import org.apache.bookkeeper.client.api.LedgerMetadata; -import org.apache.bookkeeper.client.api.ReadHandle; -import org.apache.bookkeeper.client.api.WriteFlag; -import org.apache.bookkeeper.client.impl.LedgerEntryImpl; -import org.apache.bookkeeper.common.concurrent.FutureUtils; -import org.apache.bookkeeper.net.BookieId; -import org.apache.bookkeeper.versioning.LongVersion; -import org.apache.bookkeeper.versioning.Versioned; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * Mock BK {@link LedgerHandle}. Used by {@link PulsarMockBookKeeper}. - */ -public class PulsarMockLedgerHandle extends LedgerHandle { - -    final List<LedgerEntryImpl> entries = Collections.synchronizedList(new ArrayList<>()); -    final PulsarMockBookKeeper bk; -    final long id; -    final DigestType digest; -    final byte[] passwd; -    final ReadHandle readHandle; -    long lastEntry = -1; -    @VisibleForTesting -    @Getter -    boolean fenced = false; -    // Count for total length of the entries -    final AtomicLong totalLengthCounter = new AtomicLong(0); - -    public PulsarMockLedgerHandle(PulsarMockBookKeeper bk, long id, -                           DigestType digest, byte[] passwd) throws GeneralSecurityException { -        super(bk.getClientCtx(), id, new Versioned<>(createMetadata(id, digest, passwd), new LongVersion(0L)), -              digest, passwd, WriteFlag.NONE); -        this.bk = bk; -        this.id = id; -        this.digest = digest; -        this.passwd = Arrays.copyOf(passwd, passwd.length); - -        readHandle = new PulsarMockReadHandle(bk, id, getLedgerMetadata(), entries, -                bk::getReadHandleInterceptor, totalLengthCounter); -    } - -    @Override -    public void asyncClose(CloseCallback cb, Object ctx) { -        bk.getProgrammedFailure().thenComposeAsync((res) -> { -            fenced = true; - -            Versioned<LedgerMetadata> current = getVersionedLedgerMetadata(); -            Versioned<LedgerMetadata> newMetadata = new Versioned<>( -                    LedgerMetadataBuilder.from(current.getValue()) -                            .withClosedState().withLastEntryId(getLastAddConfirmed()) -                            .withLength(getLength()).build(), -                    new LongVersion(((LongVersion) current.getVersion()).getLongVersion() + 1)); -            setLedgerMetadata(current, newMetadata); -            return FutureUtils.value(null); -        }, bk.executor).whenCompleteAsync((res, exception) -> { -            if (exception != null) { -                cb.closeComplete(PulsarMockBookKeeper.getExceptionCode(exception), null, ctx); -            } else { -                cb.closeComplete(BKException.Code.OK, this, ctx); -            } -        }, bk.executor); -    } - -    @Override -    public void asyncReadEntries(final long firstEntry, final long lastEntry, final ReadCallback cb, final Object ctx) { -        bk.getProgrammedFailure().thenComposeAsync((res) -> { -                if (log.isDebugEnabled()) { -                    log.debug("readEntries: first={} last={} total={}", firstEntry, lastEntry, entries.size()); -                } -                final Queue<LedgerEntry> seq = new ArrayDeque<LedgerEntry>(); -                long entryId = firstEntry; -                while (entryId <= lastEntry && entryId < entries.size()) { -                    seq.add(new LedgerEntry(entries.get((int) entryId++).duplicate())); -                } - -                if (log.isDebugEnabled()) { -                    log.debug("Entries read: {}", seq); -                } - -                long readEntriesDelay = bk.getReadEntriesDelayMillis(); -                if (readEntriesDelay > 0) { -                    try { -                        Thread.sleep(readEntriesDelay); -                    } catch (InterruptedException e) { -                        // ignore -                    } -                } - -                Enumeration<LedgerEntry> entries = new Enumeration<LedgerEntry>() { -                        @Override -                        public boolean hasMoreElements() { -                            return !seq.isEmpty(); -                        } - -                        @Override -                        public LedgerEntry nextElement() { -                            return seq.remove(); -                        } -                    }; -                return FutureUtils.value(entries); -            }).whenCompleteAsync((res, exception) -> { -                    if (exception != null) { -                        cb.readComplete(PulsarMockBookKeeper.getExceptionCode(exception), -                                PulsarMockLedgerHandle.this, null, ctx); -                    } else { -                        cb.readComplete(BKException.Code.OK, PulsarMockLedgerHandle.this, res, ctx); -                    } -                }, bk.executor); -    } - -    @Override -    public long addEntry(byte[] data) throws InterruptedException, BKException { -        try { -            bk.checkProgrammedFail(); -        } catch (BKException e) { -            fenced = true; -            throw e; -        } - -        if (fenced) { -            throw BKException.create(BKException.Code.LedgerFencedException); -        } - -        lastEntry = entries.size(); -        totalLengthCounter.addAndGet(data.length); -        entries.add(LedgerEntryImpl.create(ledgerId, lastEntry, data.length, Unpooled.wrappedBuffer(data))); -        return lastEntry; -    } - -    @Override -    public void asyncAddEntry(final byte[] data, final AddCallback cb, final Object ctx) { -        asyncAddEntry(data, 0, data.length, cb, ctx); -    } - -    @Override -    public void asyncAddEntry(final byte[] data, final int offset, final int length, final AddCallback cb, -            final Object ctx) { -        asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx); -    } - -    @Override -    public void asyncAddEntry(final ByteBuf data, final AddCallback cb, final Object ctx) { -        bk.getAddEntryFailure().thenComposeAsync((res) -> { -                long delayMillis = bk.getNextAddEntryDelayMillis(); -                if (delayMillis > 0) { -                    try { -                        Thread.sleep(delayMillis); -                    } catch (InterruptedException e) { -                    } -                } - -                if (fenced) { -                    return FutureUtils.exception(new BKException.BKLedgerFencedException()); -                } else { -                    lastEntry = entries.size(); -                    byte[] storedData = new byte[data.readableBytes()]; -                    data.readBytes(storedData); -                    totalLengthCounter.addAndGet(storedData.length); -                    entries.add(LedgerEntryImpl.create(ledgerId, lastEntry, -                                                       storedData.length, Unpooled.wrappedBuffer(storedData))); -                    return FutureUtils.value(lastEntry); -                } - -            }, bk.executor).whenCompleteAsync((entryId, exception) -> { -                    data.release(); -                    if (exception != null) { -                        fenced = true; -                        cb.addComplete(PulsarMockBookKeeper.getExceptionCode(exception), -                                       PulsarMockLedgerHandle.this, LedgerHandle.INVALID_ENTRY_ID, ctx); -                    } else { -                        long responseDelayMillis = bk.getNextAddEntryResponseDelayMillis(); -                        if (responseDelayMillis > 0) { -                            try { -                                Thread.sleep(responseDelayMillis); -                            } catch (InterruptedException e) { -                            } -                        } -                        cb.addComplete(BKException.Code.OK, PulsarMockLedgerHandle.this, entryId, ctx); -                    } -                }, bk.executor); -    } - -    @Override -    public long getId() { -        return ledgerId; -    } - -    @Override -    public long getLastAddConfirmed() { -        if (bk.checkReturnEmptyLedger()) { -            return -1; -        } else { -            return lastEntry; -        } -    } - -    @Override -    public long getLength() { -        return totalLengthCounter.get(); -    } - - -    // ReadHandle interface -    @Override -    public CompletableFuture<LedgerEntries> readAsync(long firstEntry, long lastEntry) { -        return readHandle.readAsync(firstEntry, lastEntry); -    } - -    @Override -    public CompletableFuture<LedgerEntries> readUnconfirmedAsync(long firstEntry, long lastEntry) { -        return readHandle.readUnconfirmedAsync(firstEntry, lastEntry); -    } - -    @Override -    public CompletableFuture<Long> readLastAddConfirmedAsync() { -        return readHandle.readLastAddConfirmedAsync(); -    } - -    @Override -    public CompletableFuture<Long> tryReadLastAddConfirmedAsync() { -        return readHandle.tryReadLastAddConfirmedAsync(); -    } - -    @Override -    public boolean isClosed() { -        return readHandle.isClosed(); -    } - -    @Override -    public CompletableFuture<LastConfirmedAndEntry> readLastAddConfirmedAndEntryAsync(long entryId, -                                                                                      long timeOutInMillis, -                                                                                      boolean parallel) { -        return readHandle.readLastAddConfirmedAndEntryAsync(entryId, timeOutInMillis, parallel); -    } - -    private static LedgerMetadata createMetadata(long id, DigestType digest, byte[] passwd) { -        List<BookieId> ensemble = new ArrayList<>(PulsarMockBookKeeper.getMockEnsemble()); -        return LedgerMetadataBuilder.create() -            .withDigestType(digest.toApiDigestType()) -            .withPassword(passwd) -            .withId(id) -            .newEnsembleEntry(0L, ensemble) -            .build(); -    } - -    private static final Logger log = LoggerFactory.getLogger(PulsarMockLedgerHandle.class); - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import com.google.common.annotations.VisibleForTesting; +import io.netty.buffer.ByteBuf; +import io.netty.buffer.Unpooled; +import java.security.GeneralSecurityException; +import java.util.ArrayDeque; +import java.util.ArrayList; +import java.util.Arrays; +import java.util.Collections; +import java.util.Enumeration; +import java.util.List; +import java.util.Queue; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.atomic.AtomicLong; +import lombok.Getter; +import org.apache.bookkeeper.client.AsyncCallback.AddCallback; +import org.apache.bookkeeper.client.AsyncCallback.CloseCallback; +import org.apache.bookkeeper.client.AsyncCallback.ReadCallback; +import org.apache.bookkeeper.client.BookKeeper.DigestType; +import org.apache.bookkeeper.client.api.LastConfirmedAndEntry; +import org.apache.bookkeeper.client.api.LedgerEntries; +import org.apache.bookkeeper.client.api.LedgerMetadata; +import org.apache.bookkeeper.client.api.ReadHandle; +import org.apache.bookkeeper.client.api.WriteFlag; +import org.apache.bookkeeper.client.impl.LedgerEntryImpl; +import org.apache.bookkeeper.common.concurrent.FutureUtils; +import org.apache.bookkeeper.net.BookieId; +import org.apache.bookkeeper.versioning.LongVersion; +import org.apache.bookkeeper.versioning.Versioned; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * Mock BK {@link LedgerHandle}. Used by {@link PulsarMockBookKeeper}. + */ +public class PulsarMockLedgerHandle extends LedgerHandle { + +    final List<LedgerEntryImpl> entries = Collections.synchronizedList(new ArrayList<>()); +    final PulsarMockBookKeeper bk; +    final long id; +    final DigestType digest; +    final byte[] passwd; +    final ReadHandle readHandle; +    long lastEntry = -1; +    @VisibleForTesting +    @Getter +    boolean fenced = false; +    // Count for total length of the entries +    final AtomicLong totalLengthCounter = new AtomicLong(0); + +    public PulsarMockLedgerHandle(PulsarMockBookKeeper bk, long id, +                           DigestType digest, byte[] passwd) throws GeneralSecurityException { +        super(bk.getClientCtx(), id, new Versioned<>(createMetadata(id, digest, passwd), new LongVersion(0L)), +              digest, passwd, WriteFlag.NONE); +        this.bk = bk; +        this.id = id; +        this.digest = digest; +        this.passwd = Arrays.copyOf(passwd, passwd.length); + +        readHandle = new PulsarMockReadHandle(bk, id, getLedgerMetadata(), entries, +                bk::getReadHandleInterceptor, totalLengthCounter); +    } + +    @Override +    public void asyncClose(CloseCallback cb, Object ctx) { +        bk.getProgrammedFailure().thenComposeAsync((res) -> { +            fenced = true; + +            Versioned<LedgerMetadata> current = getVersionedLedgerMetadata(); +            Versioned<LedgerMetadata> newMetadata = new Versioned<>( +                    LedgerMetadataBuilder.from(current.getValue()) +                            .withClosedState().withLastEntryId(getLastAddConfirmed()) +                            .withLength(getLength()).build(), +                    new LongVersion(((LongVersion) current.getVersion()).getLongVersion() + 1)); +            setLedgerMetadata(current, newMetadata); +            return FutureUtils.value(null); +        }, bk.executor).whenCompleteAsync((res, exception) -> { +            if (exception != null) { +                cb.closeComplete(PulsarMockBookKeeper.getExceptionCode(exception), null, ctx); +            } else { +                cb.closeComplete(BKException.Code.OK, this, ctx); +            } +        }, bk.executor); +    } + +    @Override +    public void asyncReadEntries(final long firstEntry, final long lastEntry, final ReadCallback cb, final Object ctx) { +        bk.getProgrammedFailure().thenComposeAsync((res) -> { +                if (log.isDebugEnabled()) { +                    log.debug("readEntries: first={} last={} total={}", firstEntry, lastEntry, entries.size()); +                } +                final Queue<LedgerEntry> seq = new ArrayDeque<LedgerEntry>(); +                long entryId = firstEntry; +                while (entryId <= lastEntry && entryId < entries.size()) { +                    seq.add(new LedgerEntry(entries.get((int) entryId++).duplicate())); +                } + +                if (log.isDebugEnabled()) { +                    log.debug("Entries read: {}", seq); +                } + +                long readEntriesDelay = bk.getReadEntriesDelayMillis(); +                if (readEntriesDelay > 0) { +                    try { +                        Thread.sleep(readEntriesDelay); +                    } catch (InterruptedException e) { +                        // ignore +                    } +                } + +                Enumeration<LedgerEntry> entries = new Enumeration<LedgerEntry>() { +                        @Override +                        public boolean hasMoreElements() { +                            return !seq.isEmpty(); +                        } + +                        @Override +                        public LedgerEntry nextElement() { +                            return seq.remove(); +                        } +                    }; +                return FutureUtils.value(entries); +            }).whenCompleteAsync((res, exception) -> { +                    if (exception != null) { +                        cb.readComplete(PulsarMockBookKeeper.getExceptionCode(exception), +                                PulsarMockLedgerHandle.this, null, ctx); +                    } else { +                        cb.readComplete(BKException.Code.OK, PulsarMockLedgerHandle.this, res, ctx); +                    } +                }, bk.executor); +    } + +    @Override +    public long addEntry(byte[] data) throws InterruptedException, BKException { +        try { +            bk.checkProgrammedFail(); +        } catch (BKException e) { +            fenced = true; +            throw e; +        } + +        if (fenced) { +            throw BKException.create(BKException.Code.LedgerFencedException); +        } + +        lastEntry = entries.size(); +        totalLengthCounter.addAndGet(data.length); +        entries.add(LedgerEntryImpl.create(ledgerId, lastEntry, data.length, Unpooled.wrappedBuffer(data))); +        return lastEntry; +    } + +    @Override +    public void asyncAddEntry(final byte[] data, final AddCallback cb, final Object ctx) { +        asyncAddEntry(data, 0, data.length, cb, ctx); +    } + +    @Override +    public void asyncAddEntry(final byte[] data, final int offset, final int length, final AddCallback cb, +            final Object ctx) { +        asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx); +    } + +    @Override +    public void asyncAddEntry(final ByteBuf data, final AddCallback cb, final Object ctx) { +        bk.getAddEntryFailure().thenComposeAsync((res) -> { +                long delayMillis = bk.getNextAddEntryDelayMillis(); +                if (delayMillis > 0) { +                    try { +                        Thread.sleep(delayMillis); +                    } catch (InterruptedException e) { +                    } +                } + +                if (fenced) { +                    return FutureUtils.exception(new BKException.BKLedgerFencedException()); +                } else { +                    lastEntry = entries.size(); +                    byte[] storedData = new byte[data.readableBytes()]; +                    data.readBytes(storedData); +                    totalLengthCounter.addAndGet(storedData.length); +                    entries.add(LedgerEntryImpl.create(ledgerId, lastEntry, +                                                       storedData.length, Unpooled.wrappedBuffer(storedData))); +                    return FutureUtils.value(lastEntry); +                } + +            }, bk.executor).whenCompleteAsync((entryId, exception) -> { +                    data.release(); +                    if (exception != null) { +                        fenced = true; +                        cb.addComplete(PulsarMockBookKeeper.getExceptionCode(exception), +                                       PulsarMockLedgerHandle.this, LedgerHandle.INVALID_ENTRY_ID, ctx); +                    } else { +                        long responseDelayMillis = bk.getNextAddEntryResponseDelayMillis(); +                        if (responseDelayMillis > 0) { +                            try { +                                Thread.sleep(responseDelayMillis); +                            } catch (InterruptedException e) { +                            } +                        } +                        cb.addComplete(BKException.Code.OK, PulsarMockLedgerHandle.this, entryId, ctx); +                    } +                }, bk.executor); +    } + +    @Override +    public long getId() { +        return ledgerId; +    } + +    @Override +    public long getLastAddConfirmed() { +        if (bk.checkReturnEmptyLedger()) { +            return -1; +        } else { +            return lastEntry; +        } +    } + +    @Override +    public long getLength() { +        return totalLengthCounter.get(); +    } + + +    // ReadHandle interface +    @Override +    public CompletableFuture<LedgerEntries> readAsync(long firstEntry, long lastEntry) { +        return readHandle.readAsync(firstEntry, lastEntry); +    } + +    @Override +    public CompletableFuture<LedgerEntries> readUnconfirmedAsync(long firstEntry, long lastEntry) { +        return readHandle.readUnconfirmedAsync(firstEntry, lastEntry); +    } + +    @Override +    public CompletableFuture<Long> readLastAddConfirmedAsync() { +        return readHandle.readLastAddConfirmedAsync(); +    } + +    @Override +    public CompletableFuture<Long> tryReadLastAddConfirmedAsync() { +        return readHandle.tryReadLastAddConfirmedAsync(); +    } + +    @Override +    public boolean isClosed() { +        return readHandle.isClosed(); +    } + +    @Override +    public CompletableFuture<LastConfirmedAndEntry> readLastAddConfirmedAndEntryAsync(long entryId, +                                                                                      long timeOutInMillis, +                                                                                      boolean parallel) { +        return readHandle.readLastAddConfirmedAndEntryAsync(entryId, timeOutInMillis, parallel); +    } + +    private static LedgerMetadata createMetadata(long id, DigestType digest, byte[] passwd) { +        List<BookieId> ensemble = new ArrayList<>(PulsarMockBookKeeper.getMockEnsemble()); +        return LedgerMetadataBuilder.create() +            .withDigestType(digest.toApiDigestType()) +            .withPassword(passwd) +            .withId(id) +            .newEnsembleEntry(0L, ensemble) +            .build(); +    } + +    private static final Logger log = LoggerFactory.getLogger(PulsarMockLedgerHandle.class); + +} diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandle.java b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandle.java index 62d84dbfc4..d2bd0a410f 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandle.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandle.java @@ -1,138 +1,138 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import java.util.ArrayList; -import java.util.List; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.atomic.AtomicLong; -import java.util.function.Supplier; -import lombok.extern.slf4j.Slf4j; -import org.apache.bookkeeper.client.api.LastConfirmedAndEntry; -import org.apache.bookkeeper.client.api.LedgerEntries; -import org.apache.bookkeeper.client.api.LedgerEntry; -import org.apache.bookkeeper.client.api.LedgerMetadata; -import org.apache.bookkeeper.client.api.ReadHandle; -import org.apache.bookkeeper.client.impl.LedgerEntriesImpl; -import org.apache.bookkeeper.client.impl.LedgerEntryImpl; -import org.apache.bookkeeper.common.concurrent.FutureUtils; - -/** - * Mock implementation of ReadHandle. - */ -@Slf4j -class PulsarMockReadHandle implements ReadHandle { -    private final PulsarMockBookKeeper bk; -    private final long ledgerId; -    private final LedgerMetadata metadata; -    private final List<LedgerEntryImpl> entries; -    private final Supplier<PulsarMockReadHandleInterceptor> readHandleInterceptorSupplier; -    private final AtomicLong totalLengthCounter; - -    PulsarMockReadHandle(PulsarMockBookKeeper bk, long ledgerId, LedgerMetadata metadata, -                         List<LedgerEntryImpl> entries, -                         Supplier<PulsarMockReadHandleInterceptor> readHandleInterceptorSupplier, -                         AtomicLong totalLengthCounter) { -        this.bk = bk; -        this.ledgerId = ledgerId; -        this.metadata = metadata; -        this.entries = entries; -        this.readHandleInterceptorSupplier = readHandleInterceptorSupplier; -        this.totalLengthCounter = totalLengthCounter; -    } - -    @Override -    public CompletableFuture<LedgerEntries> readAsync(long firstEntry, long lastEntry) { -        return bk.getProgrammedFailure().thenComposeAsync((res) -> { -            log.debug("readEntries: first={} last={} total={}", firstEntry, lastEntry, entries.size()); -            List<LedgerEntry> seq = new ArrayList<>(); -            long entryId = firstEntry; -            while (entryId <= lastEntry && entryId < entries.size()) { -                seq.add(entries.get((int) entryId++).duplicate()); -            } -            log.debug("Entries read: {}", seq); -            LedgerEntriesImpl ledgerEntries = LedgerEntriesImpl.create(seq); -            PulsarMockReadHandleInterceptor pulsarMockReadHandleInterceptor = readHandleInterceptorSupplier.get(); -            if (pulsarMockReadHandleInterceptor != null) { -                return pulsarMockReadHandleInterceptor.interceptReadAsync(ledgerId, firstEntry, lastEntry, -                        ledgerEntries); -            } -            return FutureUtils.value(ledgerEntries); -        }); -    } - -    @Override -    public CompletableFuture<LedgerEntries> readUnconfirmedAsync(long firstEntry, long lastEntry) { -        return readAsync(firstEntry, lastEntry); -    } - -    @Override -    public CompletableFuture<Long> readLastAddConfirmedAsync() { -        return CompletableFuture.completedFuture(getLastAddConfirmed()); -    } - -    @Override -    public CompletableFuture<Long> tryReadLastAddConfirmedAsync() { -        return readLastAddConfirmedAsync(); -    } - -    @Override -    public long getLastAddConfirmed() { -        if (entries.isEmpty()) { -            return -1; -        } else { -            return entries.get(entries.size() - 1).getEntryId(); -        } -    } - -    @Override -    public long getLength() { -        return totalLengthCounter.get(); -    } - -    @Override -    public boolean isClosed() { -        return metadata.isClosed(); -    } - -    @Override -    public CompletableFuture<LastConfirmedAndEntry> readLastAddConfirmedAndEntryAsync(long entryId, -                                                                                      long timeOutInMillis, -                                                                                      boolean parallel) { -        CompletableFuture<LastConfirmedAndEntry> promise = new CompletableFuture<>(); -        promise.completeExceptionally(new UnsupportedOperationException("Long poll not implemented")); -        return promise; -    } - -    // Handle interface -    @Override -    public long getId() { -        return ledgerId; -    } - -    @Override -    public CompletableFuture<Void> closeAsync() { -        return CompletableFuture.completedFuture(null); -    } - -    @Override -    public LedgerMetadata getLedgerMetadata() { -        return metadata; -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import java.util.ArrayList; +import java.util.List; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.atomic.AtomicLong; +import java.util.function.Supplier; +import lombok.extern.slf4j.Slf4j; +import org.apache.bookkeeper.client.api.LastConfirmedAndEntry; +import org.apache.bookkeeper.client.api.LedgerEntries; +import org.apache.bookkeeper.client.api.LedgerEntry; +import org.apache.bookkeeper.client.api.LedgerMetadata; +import org.apache.bookkeeper.client.api.ReadHandle; +import org.apache.bookkeeper.client.impl.LedgerEntriesImpl; +import org.apache.bookkeeper.client.impl.LedgerEntryImpl; +import org.apache.bookkeeper.common.concurrent.FutureUtils; + +/** + * Mock implementation of ReadHandle. + */ +@Slf4j +class PulsarMockReadHandle implements ReadHandle { +    private final PulsarMockBookKeeper bk; +    private final long ledgerId; +    private final LedgerMetadata metadata; +    private final List<LedgerEntryImpl> entries; +    private final Supplier<PulsarMockReadHandleInterceptor> readHandleInterceptorSupplier; +    private final AtomicLong totalLengthCounter; + +    PulsarMockReadHandle(PulsarMockBookKeeper bk, long ledgerId, LedgerMetadata metadata, +                         List<LedgerEntryImpl> entries, +                         Supplier<PulsarMockReadHandleInterceptor> readHandleInterceptorSupplier, +                         AtomicLong totalLengthCounter) { +        this.bk = bk; +        this.ledgerId = ledgerId; +        this.metadata = metadata; +        this.entries = entries; +        this.readHandleInterceptorSupplier = readHandleInterceptorSupplier; +        this.totalLengthCounter = totalLengthCounter; +    } + +    @Override +    public CompletableFuture<LedgerEntries> readAsync(long firstEntry, long lastEntry) { +        return bk.getProgrammedFailure().thenComposeAsync((res) -> { +            log.debug("readEntries: first={} last={} total={}", firstEntry, lastEntry, entries.size()); +            List<LedgerEntry> seq = new ArrayList<>(); +            long entryId = firstEntry; +            while (entryId <= lastEntry && entryId < entries.size()) { +                seq.add(entries.get((int) entryId++).duplicate()); +            } +            log.debug("Entries read: {}", seq); +            LedgerEntriesImpl ledgerEntries = LedgerEntriesImpl.create(seq); +            PulsarMockReadHandleInterceptor pulsarMockReadHandleInterceptor = readHandleInterceptorSupplier.get(); +            if (pulsarMockReadHandleInterceptor != null) { +                return pulsarMockReadHandleInterceptor.interceptReadAsync(ledgerId, firstEntry, lastEntry, +                        ledgerEntries); +            } +            return FutureUtils.value(ledgerEntries); +        }); +    } + +    @Override +    public CompletableFuture<LedgerEntries> readUnconfirmedAsync(long firstEntry, long lastEntry) { +        return readAsync(firstEntry, lastEntry); +    } + +    @Override +    public CompletableFuture<Long> readLastAddConfirmedAsync() { +        return CompletableFuture.completedFuture(getLastAddConfirmed()); +    } + +    @Override +    public CompletableFuture<Long> tryReadLastAddConfirmedAsync() { +        return readLastAddConfirmedAsync(); +    } + +    @Override +    public long getLastAddConfirmed() { +        if (entries.isEmpty()) { +            return -1; +        } else { +            return entries.get(entries.size() - 1).getEntryId(); +        } +    } + +    @Override +    public long getLength() { +        return totalLengthCounter.get(); +    } + +    @Override +    public boolean isClosed() { +        return metadata.isClosed(); +    } + +    @Override +    public CompletableFuture<LastConfirmedAndEntry> readLastAddConfirmedAndEntryAsync(long entryId, +                                                                                      long timeOutInMillis, +                                                                                      boolean parallel) { +        CompletableFuture<LastConfirmedAndEntry> promise = new CompletableFuture<>(); +        promise.completeExceptionally(new UnsupportedOperationException("Long poll not implemented")); +        return promise; +    } + +    // Handle interface +    @Override +    public long getId() { +        return ledgerId; +    } + +    @Override +    public CompletableFuture<Void> closeAsync() { +        return CompletableFuture.completedFuture(null); +    } + +    @Override +    public LedgerMetadata getLedgerMetadata() { +        return metadata; +    } +} diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandleInterceptor.java b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandleInterceptor.java index acee87b0f7..6d832d48d9 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandleInterceptor.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/PulsarMockReadHandleInterceptor.java @@ -1,40 +1,40 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import java.util.concurrent.CompletableFuture; -import org.apache.bookkeeper.client.api.LedgerEntries; - -/** - * Interceptor interface for intercepting read handle readAsync operations. - * This is useful for testing purposes, for example for introducing delays. - */ -public interface PulsarMockReadHandleInterceptor { -    /** -     * Intercepts the readAsync operation on a read handle. -     * -     * @param ledgerId ledger id -     * @param firstEntry first entry to read -     * @param lastEntry  last entry to read -     * @param entries    entries that would be returned by the read operation -     * @return CompletableFuture that will complete with the entries to return -     */ -    CompletableFuture<LedgerEntries> interceptReadAsync(long ledgerId, long firstEntry, long lastEntry, -                                                        LedgerEntries entries); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import java.util.concurrent.CompletableFuture; +import org.apache.bookkeeper.client.api.LedgerEntries; + +/** + * Interceptor interface for intercepting read handle readAsync operations. + * This is useful for testing purposes, for example for introducing delays. + */ +public interface PulsarMockReadHandleInterceptor { +    /** +     * Intercepts the readAsync operation on a read handle. +     * +     * @param ledgerId ledger id +     * @param firstEntry first entry to read +     * @param lastEntry  last entry to read +     * @param entries    entries that would be returned by the read operation +     * @return CompletableFuture that will complete with the entries to return +     */ +    CompletableFuture<LedgerEntries> interceptReadAsync(long ledgerId, long firstEntry, long lastEntry, +                                                        LedgerEntries entries); +} diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/TestStatsProvider.java b/testmocks/src/main/java/org/apache/bookkeeper/client/TestStatsProvider.java index 43a39bf4f8..715bc9db64 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/TestStatsProvider.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/TestStatsProvider.java @@ -1,292 +1,292 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; - -import java.util.Map; -import java.util.concurrent.ConcurrentHashMap; -import java.util.concurrent.TimeUnit; -import java.util.concurrent.atomic.AtomicLong; -import java.util.function.BiConsumer; -import org.apache.bookkeeper.stats.Counter; -import org.apache.bookkeeper.stats.Gauge; -import org.apache.bookkeeper.stats.OpStatsData; -import org.apache.bookkeeper.stats.OpStatsLogger; -import org.apache.bookkeeper.stats.StatsLogger; -import org.apache.bookkeeper.stats.StatsProvider; -import org.apache.commons.configuration2.Configuration; -import org.apache.commons.lang3.StringUtils; - -/** - * Simple in-memory stat provider for use in unit tests. - */ -public class TestStatsProvider implements StatsProvider { -    /** -     * In-memory counter. -     */ -    public class TestCounter implements Counter { -        private AtomicLong val = new AtomicLong(0); -        private AtomicLong max = new AtomicLong(0); - -        @Override -        public void clear() { -            val.set(0); -        } - -        @Override -        public void inc() { -            updateMax(val.incrementAndGet()); -        } - -        @Override -        public void dec() { -            val.decrementAndGet(); -        } - -        @Override -        public void addCount(long delta) { -            updateMax(val.addAndGet(delta)); -        } - -        @Override -        public void addLatency(long eventLatency, TimeUnit unit) { -            long valueMillis = unit.toMillis(eventLatency); -            updateMax(val.addAndGet(valueMillis)); -        } - -        @Override -        public Long get() { -            return val.get(); -        } - -        private void updateMax(long newVal) { -            while (true) { -                long curMax = max.get(); -                if (curMax > newVal) { -                    break; -                } -                if (max.compareAndSet(curMax, newVal)) { -                    break; -                } -            } -        } - -        public Long getMax() { -            return max.get(); -        } -    } - -    /** -     * In-memory StatsLogger. -     */ -    public class TestOpStatsLogger implements OpStatsLogger { -        private long successCount; -        private long successValue; - -        private long failureCount; -        private long failureValue; - -        TestOpStatsLogger() { -            clear(); -        } - -        @Override -        public void registerFailedEvent(long eventLatency, TimeUnit unit) { -            registerFailedValue(TimeUnit.NANOSECONDS.convert(eventLatency, unit)); -        } - -        @Override -        public void registerSuccessfulEvent(long eventLatency, TimeUnit unit) { -            registerSuccessfulValue(TimeUnit.NANOSECONDS.convert(eventLatency, unit)); -        } - -        @Override -        public synchronized void registerSuccessfulValue(long value) { -            successCount++; -            successValue += value; -        } - -        @Override -        public synchronized void registerFailedValue(long value) { -            failureCount++; -            failureValue += value; -        } - -        @Override -        public OpStatsData toOpStatsData() { -            // Not supported at this time -            return null; -        } - -        @Override -        public synchronized void clear() { -            successCount = 0; -            successValue = 0; -            failureCount = 0; -            failureValue = 0; -        } - -        public synchronized double getSuccessAverage() { -            if (successCount == 0) { -                return 0; -            } -            return successValue / (double) successCount; -        } - -        public synchronized long getSuccessCount() { -            return successCount; -        } -    } - -    /** -     * In-memory Logger. -     */ -    public class TestStatsLogger implements StatsLogger { -        private String path; - -        TestStatsLogger(String path) { -            this.path = path; -        } - -        private String getSubPath(String name) { -            if (path.isEmpty()) { -                return name; -            } else { -                return path + "." + name; -            } -        } - -        @Override -        public OpStatsLogger getOpStatsLogger(String name) { -            return TestStatsProvider.this.getOrCreateOpStatsLogger(getSubPath(name)); -        } - -        @Override -        public Counter getCounter(String name) { -            return TestStatsProvider.this.getOrCreateCounter(getSubPath(name)); -        } - -        public Gauge<? extends Number> getGauge(String name) { -            return gaugeMap.get(getSubPath(name)); -        } - -        @Override -        public <T extends Number> void registerGauge(String name, Gauge<T> gauge) { -            TestStatsProvider.this.registerGauge(getSubPath(name), gauge); -        } - -        @Override -        public <T extends Number> void unregisterGauge(String name, Gauge<T> gauge) { -            TestStatsProvider.this.unregisterGauge(getSubPath(name), gauge); -        } - -        @Override -        public StatsLogger scope(String name) { -            return new TestStatsLogger(getSubPath(name)); -        } - -        @Override -        public void removeScope(String name, StatsLogger statsLogger) {} - -        @Override -        public OpStatsLogger getThreadScopedOpStatsLogger(String name) { -            return getOpStatsLogger(name); -        } - -        @Override -        public Counter getThreadScopedCounter(String name) { -            return getCounter(name); -        } -    } - -    @Override -    public void start(Configuration conf) { -    } - -    @Override -    public void stop() { -    } - -    private Map<String, TestOpStatsLogger> opStatLoggerMap = new ConcurrentHashMap<>(); -    private Map<String, TestCounter> counterMap = new ConcurrentHashMap<>(); -    private Map<String, Gauge<? extends Number>> gaugeMap = new ConcurrentHashMap<>(); - -    @Override -    public TestStatsLogger getStatsLogger(String scope) { -        return new TestStatsLogger(scope); -    } - -    public TestOpStatsLogger getOpStatsLogger(String path) { -        return opStatLoggerMap.get(path); -    } - -    public TestCounter getCounter(String path) { -        return counterMap.get(path); -    } - -    public Gauge<? extends Number> getGauge(String path) { -        return gaugeMap.get(path); -    } - -    public void forEachOpStatLogger(BiConsumer<String, TestOpStatsLogger> f) { -        for (Map.Entry<String, TestOpStatsLogger> entry : opStatLoggerMap.entrySet()) { -            f.accept(entry.getKey(), entry.getValue()); -        } -    } - -    public void clear() { -        for (TestOpStatsLogger logger : opStatLoggerMap.values()) { -            logger.clear(); -        } -        for (TestCounter counter : counterMap.values()) { -            counter.clear(); -        } -    } - -    private TestOpStatsLogger getOrCreateOpStatsLogger(String path) { -        return opStatLoggerMap.computeIfAbsent( -                path, -                (String s) -> new TestOpStatsLogger()); -    } - -    private TestCounter getOrCreateCounter(String path) { -        return counterMap.computeIfAbsent( -                path, -                (String s) -> new TestCounter()); -    } - -    private <T extends Number> void registerGauge(String name, Gauge<T> gauge) { -        gaugeMap.put(name, gauge); -    } - -    private <T extends Number> void unregisterGauge(String name, Gauge<T> gauge) { -        gaugeMap.remove(name, gauge); -    } - -    @Override -    public String getStatsName(String... statsComponents) { -        if (statsComponents.length == 0) { -            return ""; -        } else if (statsComponents[0].isEmpty()) { -            return StringUtils.join(statsComponents, '.', 1, statsComponents.length); -        } else { -            return StringUtils.join(statsComponents, '.'); -        } -    } - +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; + +import java.util.Map; +import java.util.concurrent.ConcurrentHashMap; +import java.util.concurrent.TimeUnit; +import java.util.concurrent.atomic.AtomicLong; +import java.util.function.BiConsumer; +import org.apache.bookkeeper.stats.Counter; +import org.apache.bookkeeper.stats.Gauge; +import org.apache.bookkeeper.stats.OpStatsData; +import org.apache.bookkeeper.stats.OpStatsLogger; +import org.apache.bookkeeper.stats.StatsLogger; +import org.apache.bookkeeper.stats.StatsProvider; +import org.apache.commons.configuration2.Configuration; +import org.apache.commons.lang3.StringUtils; + +/** + * Simple in-memory stat provider for use in unit tests. + */ +public class TestStatsProvider implements StatsProvider { +    /** +     * In-memory counter. +     */ +    public class TestCounter implements Counter { +        private AtomicLong val = new AtomicLong(0); +        private AtomicLong max = new AtomicLong(0); + +        @Override +        public void clear() { +            val.set(0); +        } + +        @Override +        public void inc() { +            updateMax(val.incrementAndGet()); +        } + +        @Override +        public void dec() { +            val.decrementAndGet(); +        } + +        @Override +        public void addCount(long delta) { +            updateMax(val.addAndGet(delta)); +        } + +        @Override +        public void addLatency(long eventLatency, TimeUnit unit) { +            long valueMillis = unit.toMillis(eventLatency); +            updateMax(val.addAndGet(valueMillis)); +        } + +        @Override +        public Long get() { +            return val.get(); +        } + +        private void updateMax(long newVal) { +            while (true) { +                long curMax = max.get(); +                if (curMax > newVal) { +                    break; +                } +                if (max.compareAndSet(curMax, newVal)) { +                    break; +                } +            } +        } + +        public Long getMax() { +            return max.get(); +        } +    } + +    /** +     * In-memory StatsLogger. +     */ +    public class TestOpStatsLogger implements OpStatsLogger { +        private long successCount; +        private long successValue; + +        private long failureCount; +        private long failureValue; + +        TestOpStatsLogger() { +            clear(); +        } + +        @Override +        public void registerFailedEvent(long eventLatency, TimeUnit unit) { +            registerFailedValue(TimeUnit.NANOSECONDS.convert(eventLatency, unit)); +        } + +        @Override +        public void registerSuccessfulEvent(long eventLatency, TimeUnit unit) { +            registerSuccessfulValue(TimeUnit.NANOSECONDS.convert(eventLatency, unit)); +        } + +        @Override +        public synchronized void registerSuccessfulValue(long value) { +            successCount++; +            successValue += value; +        } + +        @Override +        public synchronized void registerFailedValue(long value) { +            failureCount++; +            failureValue += value; +        } + +        @Override +        public OpStatsData toOpStatsData() { +            // Not supported at this time +            return null; +        } + +        @Override +        public synchronized void clear() { +            successCount = 0; +            successValue = 0; +            failureCount = 0; +            failureValue = 0; +        } + +        public synchronized double getSuccessAverage() { +            if (successCount == 0) { +                return 0; +            } +            return successValue / (double) successCount; +        } + +        public synchronized long getSuccessCount() { +            return successCount; +        } +    } + +    /** +     * In-memory Logger. +     */ +    public class TestStatsLogger implements StatsLogger { +        private String path; + +        TestStatsLogger(String path) { +            this.path = path; +        } + +        private String getSubPath(String name) { +            if (path.isEmpty()) { +                return name; +            } else { +                return path + "." + name; +            } +        } + +        @Override +        public OpStatsLogger getOpStatsLogger(String name) { +            return TestStatsProvider.this.getOrCreateOpStatsLogger(getSubPath(name)); +        } + +        @Override +        public Counter getCounter(String name) { +            return TestStatsProvider.this.getOrCreateCounter(getSubPath(name)); +        } + +        public Gauge<? extends Number> getGauge(String name) { +            return gaugeMap.get(getSubPath(name)); +        } + +        @Override +        public <T extends Number> void registerGauge(String name, Gauge<T> gauge) { +            TestStatsProvider.this.registerGauge(getSubPath(name), gauge); +        } + +        @Override +        public <T extends Number> void unregisterGauge(String name, Gauge<T> gauge) { +            TestStatsProvider.this.unregisterGauge(getSubPath(name), gauge); +        } + +        @Override +        public StatsLogger scope(String name) { +            return new TestStatsLogger(getSubPath(name)); +        } + +        @Override +        public void removeScope(String name, StatsLogger statsLogger) {} + +        @Override +        public OpStatsLogger getThreadScopedOpStatsLogger(String name) { +            return getOpStatsLogger(name); +        } + +        @Override +        public Counter getThreadScopedCounter(String name) { +            return getCounter(name); +        } +    } + +    @Override +    public void start(Configuration conf) { +    } + +    @Override +    public void stop() { +    } + +    private Map<String, TestOpStatsLogger> opStatLoggerMap = new ConcurrentHashMap<>(); +    private Map<String, TestCounter> counterMap = new ConcurrentHashMap<>(); +    private Map<String, Gauge<? extends Number>> gaugeMap = new ConcurrentHashMap<>(); + +    @Override +    public TestStatsLogger getStatsLogger(String scope) { +        return new TestStatsLogger(scope); +    } + +    public TestOpStatsLogger getOpStatsLogger(String path) { +        return opStatLoggerMap.get(path); +    } + +    public TestCounter getCounter(String path) { +        return counterMap.get(path); +    } + +    public Gauge<? extends Number> getGauge(String path) { +        return gaugeMap.get(path); +    } + +    public void forEachOpStatLogger(BiConsumer<String, TestOpStatsLogger> f) { +        for (Map.Entry<String, TestOpStatsLogger> entry : opStatLoggerMap.entrySet()) { +            f.accept(entry.getKey(), entry.getValue()); +        } +    } + +    public void clear() { +        for (TestOpStatsLogger logger : opStatLoggerMap.values()) { +            logger.clear(); +        } +        for (TestCounter counter : counterMap.values()) { +            counter.clear(); +        } +    } + +    private TestOpStatsLogger getOrCreateOpStatsLogger(String path) { +        return opStatLoggerMap.computeIfAbsent( +                path, +                (String s) -> new TestOpStatsLogger()); +    } + +    private TestCounter getOrCreateCounter(String path) { +        return counterMap.computeIfAbsent( +                path, +                (String s) -> new TestCounter()); +    } + +    private <T extends Number> void registerGauge(String name, Gauge<T> gauge) { +        gaugeMap.put(name, gauge); +    } + +    private <T extends Number> void unregisterGauge(String name, Gauge<T> gauge) { +        gaugeMap.remove(name, gauge); +    } + +    @Override +    public String getStatsName(String... statsComponents) { +        if (statsComponents.length == 0) { +            return ""; +        } else if (statsComponents[0].isEmpty()) { +            return StringUtils.join(statsComponents, '.', 1, statsComponents.length); +        } else { +            return StringUtils.join(statsComponents, '.'); +        } +    } +  } \ No newline at end of file diff --git a/testmocks/src/main/java/org/apache/bookkeeper/client/package-info.java b/testmocks/src/main/java/org/apache/bookkeeper/client/package-info.java index 76185fe300..cd59d9cb20 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/client/package-info.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/client/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.bookkeeper.client; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.bookkeeper.client; diff --git a/testmocks/src/main/java/org/apache/bookkeeper/test/ServerTester.java b/testmocks/src/main/java/org/apache/bookkeeper/test/ServerTester.java index f519394d09..1c4e1ed1b5 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/test/ServerTester.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/test/ServerTester.java @@ -1,239 +1,239 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -/** - * This file is derived from BookKeeperClusterTestCase from Apache BookKeeper - * http://bookkeeper.apache.org - */ - -package org.apache.bookkeeper.test; - -import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIE_SCOPE; -import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_INDEX_SCOPE; -import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_LEDGER_SCOPE; -import org.apache.bookkeeper.bookie.Bookie; -import org.apache.bookkeeper.bookie.BookieImpl; -import org.apache.bookkeeper.bookie.BookieResources; -import org.apache.bookkeeper.bookie.LedgerDirsManager; -import org.apache.bookkeeper.bookie.LedgerStorage; -import org.apache.bookkeeper.bookie.LegacyCookieValidation; -import org.apache.bookkeeper.bookie.ReadOnlyBookie; -import org.apache.bookkeeper.bookie.UncleanShutdownDetection; -import org.apache.bookkeeper.bookie.UncleanShutdownDetectionImpl; -import org.apache.bookkeeper.client.TestStatsProvider; -import org.apache.bookkeeper.common.allocator.ByteBufAllocatorWithOomHandler; -import org.apache.bookkeeper.common.allocator.PoolingPolicy; -import org.apache.bookkeeper.conf.ServerConfiguration; -import org.apache.bookkeeper.discover.BookieServiceInfo; -import org.apache.bookkeeper.discover.RegistrationManager; -import org.apache.bookkeeper.meta.LedgerManager; -import org.apache.bookkeeper.meta.LedgerManagerFactory; -import org.apache.bookkeeper.meta.MetadataBookieDriver; -import org.apache.bookkeeper.net.BookieSocketAddress; -import org.apache.bookkeeper.proto.BookieServer; -import org.apache.bookkeeper.replication.Auditor; -import org.apache.bookkeeper.replication.AutoRecoveryMain; -import org.apache.bookkeeper.replication.ReplicationWorker; -import org.apache.bookkeeper.server.Main; -import org.apache.bookkeeper.stats.StatsLogger; -import org.apache.bookkeeper.util.DiskChecker; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * Class to encapsulate all the test objects. - */ -public class ServerTester { -    static final Logger LOG = LoggerFactory.getLogger(ServerTester.class); - -    /** -     * Mock implementation of UncleanShutdownDetection. -     */ -    public static class MockUncleanShutdownDetection implements UncleanShutdownDetection { - -        private boolean startRegistered; -        private boolean shutdownRegistered; - -        @Override -        public void registerStartUp() { -            startRegistered = true; -        } - -        @Override -        public void registerCleanShutdown() { -            shutdownRegistered = true; -        } - -        @Override -        public boolean lastShutdownWasUnclean() { -            return startRegistered && !shutdownRegistered; -        } - -        public boolean getStartRegistered() { -            return startRegistered; -        } - -        public boolean getShutdownRegistered() { -            return shutdownRegistered; -        } -    } - -    private final ServerConfiguration conf; -    private final TestStatsProvider provider; -    private final Bookie bookie; -    private final BookieServer server; -    private final BookieSocketAddress address; -    private final MetadataBookieDriver metadataDriver; -    private final RegistrationManager registrationManager; -    private final LedgerManagerFactory lmFactory; -    private final LedgerManager ledgerManager; -    private final LedgerStorage storage; - -    public AutoRecoveryMain autoRecovery; -    private final ByteBufAllocatorWithOomHandler allocator = BookieResources -            .createAllocator((new ServerConfiguration()).setAllocatorPoolingPolicy(PoolingPolicy.UnpooledHeap)); - -    public ServerTester(ServerConfiguration conf) throws Exception { -        this.conf = conf; -        provider = new TestStatsProvider(); - -        StatsLogger rootStatsLogger = provider.getStatsLogger(""); -        StatsLogger bookieStats = rootStatsLogger.scope(BOOKIE_SCOPE); - -        metadataDriver = BookieResources.createMetadataDriver(conf, bookieStats); -        registrationManager = metadataDriver.createRegistrationManager(); -        lmFactory = metadataDriver.getLedgerManagerFactory(); -        ledgerManager = lmFactory.newLedgerManager(); - -        LegacyCookieValidation cookieValidation = new LegacyCookieValidation( -                conf, registrationManager); -        cookieValidation.checkCookies(Main.storageDirectoriesFromConf(conf)); - -        DiskChecker diskChecker = BookieResources.createDiskChecker(conf); -        LedgerDirsManager ledgerDirsManager = BookieResources.createLedgerDirsManager( -                conf, diskChecker, bookieStats.scope(LD_LEDGER_SCOPE)); -        LedgerDirsManager indexDirsManager = BookieResources.createIndexDirsManager( -                conf, diskChecker, bookieStats.scope(LD_INDEX_SCOPE), ledgerDirsManager); - -        UncleanShutdownDetection uncleanShutdownDetection = new UncleanShutdownDetectionImpl(ledgerDirsManager); - -        storage = BookieResources.createLedgerStorage( -                conf, ledgerManager, ledgerDirsManager, indexDirsManager, -                bookieStats, allocator); - -        if (conf.isForceReadOnlyBookie()) { -            bookie = new ReadOnlyBookie(conf, registrationManager, storage, -                    diskChecker, ledgerDirsManager, indexDirsManager, -                    bookieStats, allocator, BookieServiceInfo.NO_INFO); -        } else { -            bookie = new BookieImpl(conf, registrationManager, storage, -                    diskChecker, ledgerDirsManager, indexDirsManager, -                    bookieStats, allocator, BookieServiceInfo.NO_INFO); -        } -        server = new BookieServer(conf, bookie, rootStatsLogger, allocator, -                uncleanShutdownDetection); -        address = BookieImpl.getBookieAddress(conf); - -        autoRecovery = null; -    } - -    public ServerTester(ServerConfiguration conf, Bookie b) throws Exception { -        this.conf = conf; -        provider = new TestStatsProvider(); - -        metadataDriver = null; -        registrationManager = null; -        ledgerManager = null; -        lmFactory = null; -        storage = null; - -        bookie = b; -        server = new BookieServer(conf, b, provider.getStatsLogger(""), -                allocator, new MockUncleanShutdownDetection()); -        address = BookieImpl.getBookieAddress(conf); - -        autoRecovery = null; -    } - -    public void startAutoRecovery() throws Exception { -        LOG.debug("Starting Auditor Recovery for the bookie: {}", address); -        autoRecovery = new AutoRecoveryMain(conf); -        autoRecovery.start(); -    } - -    public void stopAutoRecovery() { -        if (autoRecovery != null) { -            LOG.debug("Shutdown Auditor Recovery for the bookie: {}", address); -            autoRecovery.shutdown(); -        } -    } - -    public Auditor getAuditor() { -        if (autoRecovery != null) { -            return autoRecovery.getAuditor(); -        } else { -            return null; -        } -    } - -    public ReplicationWorker getReplicationWorker() { -        if (autoRecovery != null) { -            return autoRecovery.getReplicationWorker(); -        } else { -            return null; -        } -    } - -    public ServerConfiguration getConfiguration() { -        return conf; -    } - -    public BookieServer getServer() { -        return server; -    } - -    public TestStatsProvider getStatsProvider() { -        return provider; -    } - -    public BookieSocketAddress getAddress() { -        return address; -    } - -    public void shutdown() throws Exception { -        server.shutdown(); - -        if (ledgerManager != null) { -            ledgerManager.close(); -        } -        if (lmFactory != null) { -            lmFactory.close(); -        } -        if (registrationManager != null) { -            registrationManager.close(); -        } -        if (metadataDriver != null) { -            metadataDriver.close(); -        } - -        if (autoRecovery != null) { -            LOG.debug("Shutdown auto recovery for bookieserver: {}", address); -            autoRecovery.shutdown(); -        } -    } +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +/** + * This file is derived from BookKeeperClusterTestCase from Apache BookKeeper + * http://bookkeeper.apache.org + */ + +package org.apache.bookkeeper.test; + +import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIE_SCOPE; +import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_INDEX_SCOPE; +import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_LEDGER_SCOPE; +import org.apache.bookkeeper.bookie.Bookie; +import org.apache.bookkeeper.bookie.BookieImpl; +import org.apache.bookkeeper.bookie.BookieResources; +import org.apache.bookkeeper.bookie.LedgerDirsManager; +import org.apache.bookkeeper.bookie.LedgerStorage; +import org.apache.bookkeeper.bookie.LegacyCookieValidation; +import org.apache.bookkeeper.bookie.ReadOnlyBookie; +import org.apache.bookkeeper.bookie.UncleanShutdownDetection; +import org.apache.bookkeeper.bookie.UncleanShutdownDetectionImpl; +import org.apache.bookkeeper.client.TestStatsProvider; +import org.apache.bookkeeper.common.allocator.ByteBufAllocatorWithOomHandler; +import org.apache.bookkeeper.common.allocator.PoolingPolicy; +import org.apache.bookkeeper.conf.ServerConfiguration; +import org.apache.bookkeeper.discover.BookieServiceInfo; +import org.apache.bookkeeper.discover.RegistrationManager; +import org.apache.bookkeeper.meta.LedgerManager; +import org.apache.bookkeeper.meta.LedgerManagerFactory; +import org.apache.bookkeeper.meta.MetadataBookieDriver; +import org.apache.bookkeeper.net.BookieSocketAddress; +import org.apache.bookkeeper.proto.BookieServer; +import org.apache.bookkeeper.replication.Auditor; +import org.apache.bookkeeper.replication.AutoRecoveryMain; +import org.apache.bookkeeper.replication.ReplicationWorker; +import org.apache.bookkeeper.server.Main; +import org.apache.bookkeeper.stats.StatsLogger; +import org.apache.bookkeeper.util.DiskChecker; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * Class to encapsulate all the test objects. + */ +public class ServerTester { +    static final Logger LOG = LoggerFactory.getLogger(ServerTester.class); + +    /** +     * Mock implementation of UncleanShutdownDetection. +     */ +    public static class MockUncleanShutdownDetection implements UncleanShutdownDetection { + +        private boolean startRegistered; +        private boolean shutdownRegistered; + +        @Override +        public void registerStartUp() { +            startRegistered = true; +        } + +        @Override +        public void registerCleanShutdown() { +            shutdownRegistered = true; +        } + +        @Override +        public boolean lastShutdownWasUnclean() { +            return startRegistered && !shutdownRegistered; +        } + +        public boolean getStartRegistered() { +            return startRegistered; +        } + +        public boolean getShutdownRegistered() { +            return shutdownRegistered; +        } +    } + +    private final ServerConfiguration conf; +    private final TestStatsProvider provider; +    private final Bookie bookie; +    private final BookieServer server; +    private final BookieSocketAddress address; +    private final MetadataBookieDriver metadataDriver; +    private final RegistrationManager registrationManager; +    private final LedgerManagerFactory lmFactory; +    private final LedgerManager ledgerManager; +    private final LedgerStorage storage; + +    public AutoRecoveryMain autoRecovery; +    private final ByteBufAllocatorWithOomHandler allocator = BookieResources +            .createAllocator((new ServerConfiguration()).setAllocatorPoolingPolicy(PoolingPolicy.UnpooledHeap)); + +    public ServerTester(ServerConfiguration conf) throws Exception { +        this.conf = conf; +        provider = new TestStatsProvider(); + +        StatsLogger rootStatsLogger = provider.getStatsLogger(""); +        StatsLogger bookieStats = rootStatsLogger.scope(BOOKIE_SCOPE); + +        metadataDriver = BookieResources.createMetadataDriver(conf, bookieStats); +        registrationManager = metadataDriver.createRegistrationManager(); +        lmFactory = metadataDriver.getLedgerManagerFactory(); +        ledgerManager = lmFactory.newLedgerManager(); + +        LegacyCookieValidation cookieValidation = new LegacyCookieValidation( +                conf, registrationManager); +        cookieValidation.checkCookies(Main.storageDirectoriesFromConf(conf)); + +        DiskChecker diskChecker = BookieResources.createDiskChecker(conf); +        LedgerDirsManager ledgerDirsManager = BookieResources.createLedgerDirsManager( +                conf, diskChecker, bookieStats.scope(LD_LEDGER_SCOPE)); +        LedgerDirsManager indexDirsManager = BookieResources.createIndexDirsManager( +                conf, diskChecker, bookieStats.scope(LD_INDEX_SCOPE), ledgerDirsManager); + +        UncleanShutdownDetection uncleanShutdownDetection = new UncleanShutdownDetectionImpl(ledgerDirsManager); + +        storage = BookieResources.createLedgerStorage( +                conf, ledgerManager, ledgerDirsManager, indexDirsManager, +                bookieStats, allocator); + +        if (conf.isForceReadOnlyBookie()) { +            bookie = new ReadOnlyBookie(conf, registrationManager, storage, +                    diskChecker, ledgerDirsManager, indexDirsManager, +                    bookieStats, allocator, BookieServiceInfo.NO_INFO); +        } else { +            bookie = new BookieImpl(conf, registrationManager, storage, +                    diskChecker, ledgerDirsManager, indexDirsManager, +                    bookieStats, allocator, BookieServiceInfo.NO_INFO); +        } +        server = new BookieServer(conf, bookie, rootStatsLogger, allocator, +                uncleanShutdownDetection); +        address = BookieImpl.getBookieAddress(conf); + +        autoRecovery = null; +    } + +    public ServerTester(ServerConfiguration conf, Bookie b) throws Exception { +        this.conf = conf; +        provider = new TestStatsProvider(); + +        metadataDriver = null; +        registrationManager = null; +        ledgerManager = null; +        lmFactory = null; +        storage = null; + +        bookie = b; +        server = new BookieServer(conf, b, provider.getStatsLogger(""), +                allocator, new MockUncleanShutdownDetection()); +        address = BookieImpl.getBookieAddress(conf); + +        autoRecovery = null; +    } + +    public void startAutoRecovery() throws Exception { +        LOG.debug("Starting Auditor Recovery for the bookie: {}", address); +        autoRecovery = new AutoRecoveryMain(conf); +        autoRecovery.start(); +    } + +    public void stopAutoRecovery() { +        if (autoRecovery != null) { +            LOG.debug("Shutdown Auditor Recovery for the bookie: {}", address); +            autoRecovery.shutdown(); +        } +    } + +    public Auditor getAuditor() { +        if (autoRecovery != null) { +            return autoRecovery.getAuditor(); +        } else { +            return null; +        } +    } + +    public ReplicationWorker getReplicationWorker() { +        if (autoRecovery != null) { +            return autoRecovery.getReplicationWorker(); +        } else { +            return null; +        } +    } + +    public ServerConfiguration getConfiguration() { +        return conf; +    } + +    public BookieServer getServer() { +        return server; +    } + +    public TestStatsProvider getStatsProvider() { +        return provider; +    } + +    public BookieSocketAddress getAddress() { +        return address; +    } + +    public void shutdown() throws Exception { +        server.shutdown(); + +        if (ledgerManager != null) { +            ledgerManager.close(); +        } +        if (lmFactory != null) { +            lmFactory.close(); +        } +        if (registrationManager != null) { +            registrationManager.close(); +        } +        if (metadataDriver != null) { +            metadataDriver.close(); +        } + +        if (autoRecovery != null) { +            LOG.debug("Shutdown auto recovery for bookieserver: {}", address); +            autoRecovery.shutdown(); +        } +    }  } \ No newline at end of file diff --git a/testmocks/src/main/java/org/apache/bookkeeper/test/package-info.java b/testmocks/src/main/java/org/apache/bookkeeper/test/package-info.java index 920a4979a9..fa95d02aad 100644 --- a/testmocks/src/main/java/org/apache/bookkeeper/test/package-info.java +++ b/testmocks/src/main/java/org/apache/bookkeeper/test/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */  package org.apache.bookkeeper.test; \ No newline at end of file diff --git a/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeper.java b/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeper.java index c8f37e9b3f..e974b3c968 100644 --- a/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeper.java +++ b/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeper.java @@ -1,1222 +1,1222 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.zookeeper; - -import com.google.common.collect.HashMultimap; -import com.google.common.collect.Maps; -import com.google.common.collect.SetMultimap; -import com.google.common.collect.Sets; -import com.google.common.util.concurrent.MoreExecutors; -import io.netty.util.concurrent.DefaultThreadFactory; -import java.util.ArrayList; -import java.util.Collection; -import java.util.Collections; -import java.util.List; -import java.util.Map; -import java.util.Optional; -import java.util.Set; -import java.util.TreeMap; -import java.util.concurrent.Callable; -import java.util.concurrent.CopyOnWriteArrayList; -import java.util.concurrent.ExecutionException; -import java.util.concurrent.ExecutorService; -import java.util.concurrent.Executors; -import java.util.concurrent.Future; -import java.util.concurrent.RejectedExecutionException; -import java.util.concurrent.TimeUnit; -import java.util.concurrent.atomic.AtomicBoolean; -import java.util.concurrent.atomic.AtomicLong; -import java.util.concurrent.atomic.AtomicReference; -import java.util.function.BiPredicate; -import lombok.AllArgsConstructor; -import org.apache.zookeeper.AsyncCallback.Children2Callback; -import org.apache.zookeeper.AsyncCallback.ChildrenCallback; -import org.apache.zookeeper.AsyncCallback.DataCallback; -import org.apache.zookeeper.AsyncCallback.StatCallback; -import org.apache.zookeeper.AsyncCallback.StringCallback; -import org.apache.zookeeper.AsyncCallback.VoidCallback; -import org.apache.zookeeper.Watcher.Event.EventType; -import org.apache.zookeeper.Watcher.Event.KeeperState; -import org.apache.zookeeper.client.ZKClientConfig; -import org.apache.zookeeper.data.ACL; -import org.apache.zookeeper.data.Stat; -import org.apache.zookeeper.proto.DeleteRequest; -import org.apache.zookeeper.proto.SetDataRequest; -import org.objenesis.Objenesis; -import org.objenesis.ObjenesisStd; -import org.objenesis.instantiator.ObjectInstantiator; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -public class MockZooKeeper extends ZooKeeper { -    // ephemeralOwner value for persistent nodes -    private static final long NOT_EPHEMERAL = 0L; -    private static final String ROOT_PATH = "/"; - -    @AllArgsConstructor -    private static class MockZNode { -        byte[] content; -        int version; -        long ephemeralOwner; -        long creationTimestamp; -        long modificationTimestamp; -        List<String> children; - -        static MockZNode of(byte[] content, int version, long ephemeralOwner) { -            return new MockZNode(content, version, ephemeralOwner, System.currentTimeMillis(), -                    System.currentTimeMillis(), new ArrayList<>()); -        } - -        public void updateVersion() { -            version++; -            modificationTimestamp = System.currentTimeMillis(); -        } - -        public void updateData(byte[] data) { -            content = data; -            updateVersion(); -        } - -        public Stat getStat() { -            return applyToStat(new Stat()); -        } - -        public Stat applyToStat(Stat stat) { -            stat.setCtime(creationTimestamp); -            stat.setMtime(modificationTimestamp); -            stat.setVersion(version); -            stat.setEphemeralOwner(ephemeralOwner); -            return stat; -        } - -        public int getVersion() { -            return version; -        } - -        public byte[] getContent() { -            return content; -        } - -        public long getEphemeralOwner() { -            return ephemeralOwner; -        } - -        public List<String> getChildren() { -            return children; -        } -    } - -    private TreeMap<String, MockZNode> tree; -    private SetMultimap<String, NodeWatcher> watchers; -    private AtomicBoolean stopped; -    private AtomicReference<KeeperException.Code> alwaysFail; -    private CopyOnWriteArrayList<Failure> failures; -    private ExecutorService executor; - -    private volatile Watcher sessionWatcher; -    private long sessionId = 1L; -    private int readOpDelayMs; - -    private AtomicLong sequentialIdGenerator; -    private ThreadLocal<Long> overriddenSessionIdThreadLocal; -    private ThreadLocal<Boolean> inExecutorThreadLocal; -    private int referenceCount; -    private List<AutoCloseable> closeables; -    private int sessionTimeout; -    private ZKClientConfig zKClientConfig = new ZKClientConfig(); - -    //see details of Objenesis caching - http://objenesis.org/details.html -    //see supported jvms - https://github.com/easymock/objenesis/blob/master/SupportedJVMs.md -    private static final Objenesis objenesis = new ObjenesisStd(); - -    public enum Op { -        CREATE, GET, SET, GET_CHILDREN, DELETE, EXISTS, SYNC, -    } - -    private static class Failure { -        final KeeperException.Code failReturnCode; -        final BiPredicate<Op, String> predicate; - -        Failure(KeeperException.Code failReturnCode, BiPredicate<Op, String> predicate) { -            this.failReturnCode = failReturnCode; -            this.predicate = predicate; -        } -    } - -    private record PersistentWatcher(String path, Watcher watcher, AddWatchMode mode, long sessionId) { -    } - -    private record NodeWatcher(Watcher watcher, long sessionId) { -    } - -    private List<PersistentWatcher> persistentWatchers; - -    public static MockZooKeeper newInstance() { -        return newInstance(-1); -    } - -    public static MockZooKeeper newInstance(int readOpDelayMs) { -        try { -            return createMockZooKeeperInstance(readOpDelayMs); -        } catch (RuntimeException e) { -            throw e; -        } catch (Exception e) { -            throw new IllegalStateException("Cannot create object", e); -        } -    } - -    private static MockZooKeeper createMockZooKeeperInstance(int readOpDelayMs) { -        ObjectInstantiator<MockZooKeeper> mockZooKeeperInstantiator = -                objenesis.getInstantiatorOf(MockZooKeeper.class); -        MockZooKeeper zk = mockZooKeeperInstantiator.newInstance(); -        zk.overriddenSessionIdThreadLocal = new ThreadLocal<>(); -        zk.inExecutorThreadLocal = ThreadLocal.withInitial(() -> false); -        zk.init(); -        zk.readOpDelayMs = readOpDelayMs; -        zk.sequentialIdGenerator = new AtomicLong(); -        zk.closeables = new ArrayList<>(); -        zk.sessionTimeout = 30_000; -        zk.zKClientConfig = new ZKClientConfig(); -        return zk; -    } - -    private void init() { -        tree = Maps.newTreeMap(); -        tree.put(ROOT_PATH, MockZNode.of(new byte[0], 0, NOT_EPHEMERAL)); -        this.executor = Executors.newSingleThreadExecutor(new DefaultThreadFactory("mock-zookeeper")); -        watchers = HashMultimap.create(); -        stopped = new AtomicBoolean(false); -        alwaysFail = new AtomicReference<>(KeeperException.Code.OK); -        failures = new CopyOnWriteArrayList<>(); -        persistentWatchers = new ArrayList<>(); -    } - -    @Override -    public int getSessionTimeout() { -        return sessionTimeout; -    } - -    public void setSessionTimeout(int sessionTimeout) { -        this.sessionTimeout = sessionTimeout; -    } - -    private MockZooKeeper(String quorum) throws Exception { -        // This constructor is never called -        super(quorum, 1, event -> { -        }); -        assert false; -    } - -    @Override -    public States getState() { -        return States.CONNECTED; -    } - -    @Override -    public void register(Watcher watcher) { -        sessionWatcher = watcher; -    } - -    @Override -    public String create(String path, byte[] data, List<ACL> acl, CreateMode createMode) -            throws KeeperException, InterruptedException { -        return runInExecutorReturningValue(() -> internalCreate(path, data, createMode)); -    } - -    @Override -    public ZKClientConfig getClientConfig() { -        return zKClientConfig; -    } - -    private <T> T runInExecutorReturningValue(Callable<T> task) -            throws InterruptedException, KeeperException { -        if (isStopped()) { -            throw new KeeperException.ConnectionLossException(); -        } -        if (inExecutorThreadLocal.get()) { -            try { -                return task.call(); -            } catch (Exception e) { -                if (e instanceof KeeperException ke) { -                    throw ke; -                } -                if (e instanceof InterruptedException ie) { -                    throw ie; -                } -                log.error("Unexpected exception", e); -                throw new KeeperException.SystemErrorException(); -            } -        } -        try { -            long currentSessionId = getSessionId(); -            return executor.submit(() -> { -                inExecutorThreadLocal.set(true); -                overrideSessionId(currentSessionId); -                try { -                    return task.call(); -                } finally { -                    removeSessionIdOverride(); -                    inExecutorThreadLocal.set(false); -                } -            }).get(); -        } catch (ExecutionException e) { -            Throwable cause = e.getCause(); -            if (cause instanceof KeeperException ke) { -                throw ke; -            } -            if (cause instanceof InterruptedException ie) { -                throw ie; -            } -            log.error("Unexpected exception", e); -            throw new KeeperException.SystemErrorException(); -        } -    } - -    private void runInExecutorAsync(Runnable runnable) { -        if (isStopped()) { -            throw new RejectedExecutionException("MockZooKeeper is stopped"); -        } -        if (inExecutorThreadLocal.get()) { -            try { -                runnable.run(); -            } catch (Throwable t) { -                log.error("Unexpected exception", t); -            } -            return; -        } -        long currentSessionId = getSessionId(); -        executor.submit(() -> { -            try { -                inExecutorThreadLocal.set(true); -                overrideSessionId(currentSessionId); -                try { -                    runnable.run(); -                } finally { -                    removeSessionIdOverride(); -                    inExecutorThreadLocal.set(false); -                } -            } catch (Throwable t) { -                log.error("Unexpected exception", t); -            } -        }); -    } - -    private void runInExecutorSync(Runnable runnable) { -        try { -            runInExecutorReturningValue(() -> { -                runnable.run(); -                return null; -            }); -        } catch (Exception e) { -            log.error("Unexpected error", e); -        } -    } - -    private String internalCreate(String path, byte[] data, CreateMode createMode) throws KeeperException { -        final Set<Watcher> toNotifyCreate = Sets.newHashSet(); -        final Set<Watcher> toNotifyParent = Sets.newHashSet(); -        final String parent = getParentName(path); - -        maybeThrowProgrammedFailure(Op.CREATE, path); - -        if (isStopped()) { -            throw new KeeperException.ConnectionLossException(); -        } - -        if (tree.containsKey(path)) { -            throw new KeeperException.NodeExistsException(path); -        } - -        MockZNode parentNode = tree.get(parent); - -        if (parentNode == null) { -            throw new KeeperException.NoNodeException(parent); -        } - -        if (createMode.isSequential()) { -            int parentVersion = parentNode.getVersion(); -            path = path + parentVersion; -            parentNode.updateVersion(); -        } - -        parentNode.getChildren().add(getNodeName(path)); -        tree.put(path, createMockZNode(data, createMode)); - -        toNotifyCreate.addAll(getWatchers(path)); -        if (!ROOT_PATH.equals(parent)) { -            toNotifyParent.addAll(getWatchers(parent)); -        } -        watchers.removeAll(path); - -        final String finalPath = path; -        executor.execute(() -> { -            if (isStopped()) { -                return; -            } - -            triggerPersistentWatches(finalPath, parent, EventType.NodeCreated); - -            toNotifyCreate.forEach( -                    watcher -> watcher.process( -                            new WatchedEvent(EventType.NodeCreated, -                                    KeeperState.SyncConnected, -                                    finalPath))); -            toNotifyParent.forEach( -                    watcher -> watcher.process( -                            new WatchedEvent(EventType.NodeChildrenChanged, -                                    KeeperState.SyncConnected, -                                    parent))); -        }); - -        return path; -    } - -    private static String getParentName(String path) { -        String parentName = path.substring(0, path.lastIndexOf('/')); -        return parentName.length() > 0 ? parentName : "/"; -    } - -    private static String getNodeName(String path) { -        return path.substring(path.lastIndexOf('/') + 1); -    } - -    private Collection<Watcher> getWatchers(String path) { -        Set<NodeWatcher> nodeWatchers = watchers.get(path); -        if (nodeWatchers != null) { -            return nodeWatchers.stream().map(NodeWatcher::watcher).toList(); -        } else { -            return Collections.emptyList(); -        } -    } - -    @Override -    public long getSessionId() { -        Long overriddenSessionId = overriddenSessionIdThreadLocal.get(); -        if (overriddenSessionId != null) { -            return overriddenSessionId; -        } -        return sessionId; -    } - -    public void overrideSessionId(long sessionId) { -        overriddenSessionIdThreadLocal.set(sessionId); -    } - -    public void removeSessionIdOverride() { -        overriddenSessionIdThreadLocal.remove(); -    } - -    @Override -    public void create(final String path, final byte[] data, final List<ACL> acl, CreateMode createMode, -                       final StringCallback cb, final Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -                    return; -                } - -                final Set<Watcher> toNotifyCreate = Sets.newHashSet(); -                toNotifyCreate.addAll(getWatchers(path)); - -                final Set<Watcher> toNotifyParent = Sets.newHashSet(); -                final String parent = getParentName(path); -                if (!ROOT_PATH.equals(parent)) { -                    toNotifyParent.addAll(getWatchers(parent)); -                } - -                final String name; -                if (createMode != null && createMode.isSequential()) { -                    name = path + sequentialIdGenerator.getAndIncrement(); -                } else { -                    name = path; -                } - -                Optional<KeeperException.Code> failure = programmedFailure(Op.CREATE, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx, null); -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -                } else if (tree.containsKey(path)) { -                    cb.processResult(KeeperException.Code.NODEEXISTS.intValue(), path, ctx, null); -                } else if (!tree.containsKey(parent)) { -                    runNotifications(() -> { -                        toNotifyParent.forEach(watcher -> watcher -                                .process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, -                                        parent))); -                    }); -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); -                } else { -                    tree.get(parent).getChildren().add(getNodeName(name)); -                    tree.put(name, createMockZNode(data, createMode)); -                    watchers.removeAll(name); -                    cb.processResult(0, path, ctx, name); -                    runNotifications(() -> { -                        triggerPersistentWatches(path, parent, EventType.NodeCreated); - -                        toNotifyCreate.forEach( -                                watcher -> watcher.process( -                                        new WatchedEvent(EventType.NodeCreated, -                                                KeeperState.SyncConnected, -                                                name))); -                        toNotifyParent.forEach( -                                watcher -> watcher.process( -                                        new WatchedEvent(EventType.NodeChildrenChanged, -                                                KeeperState.SyncConnected, -                                                parent))); -                    }); -                } -            } catch (Throwable ex) { -                log.error("create path : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); -            } -        }); -    } - -    public void runNotifications(Runnable runnable) { -        executor.execute(() -> { -            if (isStopped()) { -                return; -            } -            runnable.run(); -        }); -    } - -    private boolean isStopped() { -        return stopped.get(); -    } - -    private MockZNode createMockZNode(byte[] data, CreateMode createMode) { -        return MockZNode.of(data, 0, -                createMode != null && createMode.isEphemeral() ? getSessionId() : NOT_EPHEMERAL); -    } - -    @Override -    public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException { -        return runInExecutorReturningValue(() -> internalGetData(path, watcher, stat)); -    } - -    private byte[] internalGetData(String path, Watcher watcher, Stat stat) throws KeeperException { -        maybeThrowProgrammedFailure(Op.GET, path); -        MockZNode value = tree.get(path); -        if (value == null) { -            throw new KeeperException.NoNodeException(path); -        } else { -            if (watcher != null) { -                watchers.put(path, new NodeWatcher(watcher, getSessionId())); -            } -            if (stat != null) { -                value.applyToStat(stat); -            } -            return value.getContent(); -        } -    } - -    @Override -    public void getData(final String path, boolean watch, final DataCallback cb, final Object ctx) { -        getData(path, null, cb, ctx); -    } - -    @Override -    public void getData(final String path, final Watcher watcher, final DataCallback cb, final Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); -            return; -        } -        runInExecutorAsync(() -> { -            checkReadOpDelay(); -            try { -                Optional<KeeperException.Code> failure = programmedFailure(Op.GET, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx, null, null); -                    return; -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); -                    return; -                } - -                MockZNode value = tree.get(path); -                if (value == null) { -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null); -                } else { -                    if (watcher != null) { -                        watchers.put(path, new NodeWatcher(watcher, getSessionId())); -                    } -                    Stat stat = value.getStat(); -                    cb.processResult(0, path, ctx, value.getContent(), stat); -                } -            } catch (Throwable ex) { -                log.error("get data : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null); -            } -        }); -    } - -    @Override -    public void getChildren(final String path, final Watcher watcher, final ChildrenCallback cb, final Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                Optional<KeeperException.Code> failure = programmedFailure(Op.GET_CHILDREN, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx, null); -                    return; -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -                    return; -                } - -                if (!tree.containsKey(path)) { -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); -                    return; -                } - -                List<String> children = findFirstLevelChildren(path); -                if (watcher != null) { -                    watchers.put(path, new NodeWatcher(watcher, getSessionId())); -                } -                cb.processResult(0, path, ctx, children); -            } catch (Throwable ex) { -                log.error("get children : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); -            } -        }); -    } - -    @Override -    public List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException { -        return runInExecutorReturningValue(() -> internalGetChildren(path, watcher)); -    } - -    private List<String> internalGetChildren(String path, Watcher watcher) throws KeeperException { -        maybeThrowProgrammedFailure(Op.GET_CHILDREN, path); - -        if (!tree.containsKey(path)) { -            throw new KeeperException.NoNodeException(path); -        } - -        if (watcher != null) { -            watchers.put(path, new NodeWatcher(watcher, getSessionId())); -        } - -        return findFirstLevelChildren(path); -    } - -    @Override -    public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException { -        return getChildren(path, null); -    } - -    @Override -    public void getChildren(final String path, boolean watcher, final Children2Callback cb, final Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                MockZNode mockZNode = tree.get(path); -                Stat stat = mockZNode != null ? mockZNode.getStat() : null; -                Optional<KeeperException.Code> failure = programmedFailure(Op.GET_CHILDREN, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx, null, null); -                    return; -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); -                    return; -                } else if (mockZNode == null) { -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null); -                    return; -                } - -                List<String> children = findFirstLevelChildren(path); -                cb.processResult(0, path, ctx, children, stat); -            } catch (Throwable ex) { -                log.error("get children : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null); -            } -        }); -    } - -    private List<String> findFirstLevelChildren(String path) { -        return new ArrayList<>(tree.get(path).getChildren()); -    } - -    private boolean hasChildren(String path) { -        return !tree.get(path).getChildren().isEmpty(); -    } - -    @Override -    public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException { -        return runInExecutorReturningValue(() -> internalGetStat(path, null)); -    } - -    private Stat internalGetStat(String path, Watcher watcher) throws KeeperException { -        maybeThrowProgrammedFailure(Op.EXISTS, path); - -        if (isStopped()) { -            throw new KeeperException.ConnectionLossException(); -        } - -        if (watcher != null) { -            watchers.put(path, new NodeWatcher(watcher, getSessionId())); -        } - -        if (tree.containsKey(path)) { -            return tree.get(path).getStat(); -        } else { -            return null; -        } -    } - -    @Override -    public Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException { -        return runInExecutorReturningValue(() -> internalGetStat(path, watcher)); -    } - -    @Override -    public void exists(String path, boolean watch, StatCallback cb, Object ctx) { -        exists(path, null, cb, ctx); -    } - -    @Override -    public void exists(String path, Watcher watcher, StatCallback cb, Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                Optional<KeeperException.Code> failure = programmedFailure(Op.EXISTS, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx, null); -                    return; -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -                    return; -                } - -                if (watcher != null) { -                    watchers.put(path, new NodeWatcher(watcher, getSessionId())); -                } - -                MockZNode mockZNode = tree.get(path); -                if (mockZNode != null) { -                    Stat stat = mockZNode.getStat(); -                    cb.processResult(0, path, ctx, stat); -                } else { -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); -                } -            } catch (Throwable ex) { -                log.error("exist : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); -            } -        }); -    } - -    @Override -    public void sync(String path, VoidCallback cb, Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); -            return; -        } -        runInExecutorAsync(() -> { -            Optional<KeeperException.Code> failure = programmedFailure(Op.SYNC, path); -            if (failure.isPresent()) { -                cb.processResult(failure.get().intValue(), path, ctx); -                return; -            } else if (isStopped()) { -                cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); -                return; -            } -            cb.processResult(0, path, ctx); -        }); -    } - -    @Override -    public Stat setData(final String path, byte[] data, int version) throws KeeperException, InterruptedException { -        return runInExecutorReturningValue(() ->  internalSetData(path, data, version)); -    } - -    private Stat internalSetData(String path, byte[] data, int version) throws KeeperException { -        final Set<Watcher> toNotify = Sets.newHashSet(); -        maybeThrowProgrammedFailure(Op.SET, path); - -        if (isStopped()) { -            throw new KeeperException.ConnectionLossException(); -        } - -        if (!tree.containsKey(path)) { -            throw new KeeperException.NoNodeException(path); -        } - -        MockZNode mockZNode = tree.get(path); -        int currentVersion = mockZNode.getVersion(); - -        // Check version -        if (version != -1 && version != currentVersion) { -            throw new KeeperException.BadVersionException(path); -        } - -        log.debug("[{}] Updating -- current version: {}", path, currentVersion); -        mockZNode.updateData(data); -        Stat stat = mockZNode.getStat(); -        toNotify.addAll(getWatchers(path)); -        watchers.removeAll(path); - -        runNotifications(() -> { -            triggerPersistentWatches(path, null, EventType.NodeDataChanged); - -            toNotify.forEach(watcher -> watcher -                    .process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path))); -        }); - -        return stat; -    } - -    @Override -    public void setData(final String path, final byte[] data, int version, final StatCallback cb, final Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                final Set<Watcher> toNotify = Sets.newHashSet(); -                Stat stat; -                Optional<KeeperException.Code> failure = programmedFailure(Op.SET, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx, null); -                    return; -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); -                    return; -                } - -                if (!tree.containsKey(path)) { -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); -                    return; -                } - -                MockZNode mockZNode = tree.get(path); -                int currentVersion = mockZNode.getVersion(); - -                // Check version -                if (version != -1 && version != currentVersion) { -                    log.debug("[{}] Current version: {} -- Expected: {}", path, currentVersion, version); -                    Stat currentStat = mockZNode.getStat(); -                    cb.processResult(KeeperException.Code.BADVERSION.intValue(), path, ctx, currentStat); -                    return; -                } - -                log.debug("[{}] Updating -- current version: {}", path, currentVersion); -                mockZNode.updateData(data); -                stat = mockZNode.getStat(); -                cb.processResult(0, path, ctx, stat); - -                toNotify.addAll(getWatchers(path)); -                watchers.removeAll(path); - -                runNotifications(() -> { -                    triggerPersistentWatches(path, null, EventType.NodeDataChanged); - -                    for (Watcher watcher : toNotify) { -                        watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path)); -                    } -                }); -            } catch (Throwable ex) { -                log.error("Update data : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); -            } -        }); -    } - -    @Override -    public void delete(final String path, int version) throws InterruptedException, KeeperException { -        runInExecutorReturningValue(() -> { -            internalDelete(path, version); -            return null; -        }); -    } - -    private void internalDelete(String path, int version) throws KeeperException { -        maybeThrowProgrammedFailure(Op.DELETE, path); - -        final Set<Watcher> toNotifyDelete; -        final Set<Watcher> toNotifyParent; -        final String parent; - -        if (isStopped()) { -            throw new KeeperException.ConnectionLossException(); -        } else if (!tree.containsKey(path)) { -            throw new KeeperException.NoNodeException(path); -        } else if (hasChildren(path)) { -            throw new KeeperException.NotEmptyException(path); -        } - -        if (version != -1) { -            int currentVersion = tree.get(path).getVersion(); -            if (version != currentVersion) { -                throw new KeeperException.BadVersionException(path); -            } -        } - -        parent = getParentName(path); -        tree.remove(path); -        tree.get(parent).getChildren().remove(getNodeName(path)); - -        toNotifyDelete = Sets.newHashSet(); -        toNotifyDelete.addAll(getWatchers(path)); - -        toNotifyParent = Sets.newHashSet(); -        if (!ROOT_PATH.equals(parent)) { -            toNotifyParent.addAll(getWatchers(parent)); -        } - -        watchers.removeAll(path); - -        runNotifications(() -> { -            for (Watcher watcher1 : toNotifyDelete) { -                watcher1.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path)); -            } -            for (Watcher watcher2 : toNotifyParent) { -                watcher2.process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, parent)); -            } - -            triggerPersistentWatches(path, parent, EventType.NodeDeleted); -        }); -    } - -    @Override -    public void delete(final String path, int version, final VoidCallback cb, final Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                final Set<Watcher> toNotifyDelete = Sets.newHashSet(); -                toNotifyDelete.addAll(getWatchers(path)); - -                final Set<Watcher> toNotifyParent = Sets.newHashSet(); -                final String parent = getParentName(path); -                if (!ROOT_PATH.equals(parent)) { -                    toNotifyParent.addAll(getWatchers(parent)); -                } -                watchers.removeAll(path); - -                Optional<KeeperException.Code> failure = programmedFailure(Op.DELETE, path); -                if (failure.isPresent()) { -                    cb.processResult(failure.get().intValue(), path, ctx); -                } else if (isStopped()) { -                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); -                } else if (!tree.containsKey(path)) { -                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx); -                } else if (hasChildren(path)) { -                    cb.processResult(KeeperException.Code.NOTEMPTY.intValue(), path, ctx); -                } else { -                    if (version != -1) { -                        int currentVersion = tree.get(path).getVersion(); -                        if (version != currentVersion) { -                            cb.processResult(KeeperException.Code.BADVERSION.intValue(), path, ctx); -                            return; -                        } -                    } - -                    tree.remove(path); -                    tree.get(parent).getChildren().remove(getNodeName(path)); -                    cb.processResult(0, path, ctx); - -                    runNotifications(() -> { -                        triggerPersistentWatches(path, parent, EventType.NodeDeleted); -                        toNotifyDelete.forEach(watcher -> watcher -                                .process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path))); -                        toNotifyParent.forEach(watcher -> watcher -                                .process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, -                                        parent))); -                    }); -                } -            } catch (Throwable ex) { -                log.error("delete path : {} error", path, ex); -                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx); -            } -        }); -    } - -    @Override -    public void multi(Iterable<org.apache.zookeeper.Op> ops, AsyncCallback.MultiCallback cb, Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), null, ctx, null); -            return; -        } -        runInExecutorAsync(() -> { -            try { -                List<OpResult> res = multi(ops); -                cb.processResult(KeeperException.Code.OK.intValue(), null, ctx, res); -            } catch (Exception e) { -                cb.processResult(KeeperException.Code.APIERROR.intValue(), null, ctx, null); -            } -        }); -    } - -    @Override -    public List<OpResult> multi(Iterable<org.apache.zookeeper.Op> ops) throws InterruptedException, KeeperException { -        return runInExecutorReturningValue(() -> internalMulti(ops)); -    } - -    private List<OpResult> internalMulti(Iterable<org.apache.zookeeper.Op> ops) { -        List<OpResult> res = new ArrayList<>(); -        for (org.apache.zookeeper.Op op : ops) { -            switch (op.getType()) { -                case ZooDefs.OpCode.create -> { -                    handleOperation("create", op, () -> { -                        org.apache.zookeeper.Op.Create opc = ((org.apache.zookeeper.Op.Create) op); -                        CreateMode cm = CreateMode.fromFlag(opc.flags); -                        String path = create(op.getPath(), opc.data, null, cm); -                        res.add(new OpResult.CreateResult(path)); -                    }, res); -                } -                case ZooDefs.OpCode.delete -> { -                    handleOperation("delete", op, () -> { -                        DeleteRequest deleteRequest = (DeleteRequest) op.toRequestRecord(); -                        delete(op.getPath(), deleteRequest.getVersion()); -                        res.add(new OpResult.DeleteResult()); -                    }, res); -                } -                case ZooDefs.OpCode.setData -> { -                    handleOperation("setData", op, () -> { -                        SetDataRequest setDataRequest = (SetDataRequest) op.toRequestRecord(); -                        Stat stat = setData(op.getPath(), setDataRequest.getData(), setDataRequest.getVersion()); -                        res.add(new OpResult.SetDataResult(stat)); -                    }, res); -                } -                case ZooDefs.OpCode.getChildren -> { -                    handleOperation("getChildren", op, () -> { -                        List<String> children = getChildren(op.getPath(), null); -                        res.add(new OpResult.GetChildrenResult(children)); -                    }, res); -                } -                case ZooDefs.OpCode.getData -> { -                    Stat stat = new Stat(); -                    handleOperation("getData", op, () -> { -                        byte[] payload = getData(op.getPath(), null, stat); -                        res.add(new OpResult.GetDataResult(payload, stat)); -                    }, res); -                } -                default -> { -                    log.error("Unsupported operation for path {} type {} kind {} request {}", op.getPath(), -                            op.getType(), op.getKind(), op.toRequestRecord()); -                    res.add(new OpResult.ErrorResult(KeeperException.Code.APIERROR.intValue())); -                } -            } -        } -        return res; -    } - -    interface ZkOpHandler { -        void handle() throws KeeperException, InterruptedException; -    } - -    private void handleOperation(String opName, org.apache.zookeeper.Op op, ZkOpHandler handler, List<OpResult> res) { -        try { -            handler.handle(); -        } catch (Exception e) { -            if (e instanceof KeeperException keeperException) { -                res.add(new OpResult.ErrorResult(keeperException.code().intValue())); -            } else { -                log.error("Error handling {} operation for path {} type {} kind {} request {}", opName, op.getPath(), -                        op.getType(), op.getKind(), op.toRequestRecord(), e); -                res.add(new OpResult.ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue())); -            } -        } -    } - -    @Override -    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode) { -        runInExecutorSync(() -> { -            persistentWatchers.add(new PersistentWatcher(basePath, watcher, mode, getSessionId())); -        }); -    } - -    @Override -    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode, VoidCallback cb, Object ctx) { -        if (isStopped()) { -            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), basePath, ctx); -            return; -        } -        runInExecutorAsync(() -> { -            addWatch(basePath, watcher, mode); -            cb.processResult(KeeperException.Code.OK.intValue(), basePath, ctx); -        }); -    } - -    public synchronized void increaseRefCount() { -        referenceCount++; -    } - -    public synchronized MockZooKeeper registerCloseable(AutoCloseable closeable) { -        closeables.add(closeable); -        return this; -    } - -    @Override -    public synchronized void close() throws InterruptedException { -        if (--referenceCount <= 0) { -            shutdown(); -            closeables.forEach(c -> { -                try { -                    c.close(); -                } catch (Exception e) { -                    log.error("Error closing closeable", e); -                } -            }); -            closeables.clear(); -        } -    } - -    public void shutdown() throws InterruptedException { -        if (stopped.compareAndSet(false, true)) { -            Future<?> shutdownTask = executor.submit(() -> { -                tree.clear(); -                watchers.clear(); -                persistentWatchers.clear(); -            }); -            try { -                shutdownTask.get(); -            } catch (ExecutionException e) { -                log.error("Error shutting down", e); -            } -            MoreExecutors.shutdownAndAwaitTermination(executor, 10, TimeUnit.SECONDS); -        } -    } - -    Optional<KeeperException.Code> programmedFailure(Op op, String path) { -        KeeperException.Code error = alwaysFail.get(); -        if (error != KeeperException.Code.OK) { -            return Optional.of(error); -        } -        Optional<Failure> failure = failures.stream().filter(f -> f.predicate.test(op, path)).findFirst(); -        if (failure.isPresent()) { -            failures.remove(failure.get()); -            return Optional.ofNullable(failure.get().failReturnCode); -        } else { -            return Optional.empty(); -        } -    } - -    void maybeThrowProgrammedFailure(Op op, String path) throws KeeperException { -        Optional<KeeperException.Code> failure = programmedFailure(op, path); -        if (failure.isPresent()) { -            throw KeeperException.create(failure.get()); -        } -    } - -    public void failConditional(KeeperException.Code rc, BiPredicate<Op, String> predicate) { -        failures.add(new Failure(rc, predicate)); -    } - -    public void delay(long millis, BiPredicate<Op, String> predicate) { -        failures.add(new Failure(null, (op, s) -> { -            if (predicate.test(op, s)) { -                try { -                    Thread.sleep(millis); -                } catch (InterruptedException e) {} -                return true; -            } -            return false; -        })); -    } - -    public void setAlwaysFail(KeeperException.Code rc) { -        alwaysFail.set(rc); -    } - -    public void unsetAlwaysFail() { -        alwaysFail.set(KeeperException.Code.OK); -    } - -    public void setSessionId(long id) { -        sessionId = id; -    } - -    @Override -    public String toString() { -        return "MockZookeeper"; -    } - -    private void checkReadOpDelay() { -        if (readOpDelayMs > 0) { -            try { -                Thread.sleep(readOpDelayMs); -            } catch (InterruptedException e) { -                // Ok -            } -        } -    } - -    private void triggerPersistentWatches(String path, String parent, EventType eventType) { -        persistentWatchers.forEach(w -> { -            if (w.mode == AddWatchMode.PERSISTENT_RECURSIVE) { -                if (path.startsWith(w.path())) { -                    w.watcher.process(new WatchedEvent(eventType, KeeperState.SyncConnected, path)); -                } -            } else if (w.mode == AddWatchMode.PERSISTENT) { -                if (w.path().equals(path)) { -                    w.watcher.process(new WatchedEvent(eventType, KeeperState.SyncConnected, path)); -                } - -                if (eventType == EventType.NodeCreated || eventType == EventType.NodeDeleted) { -                    // Also notify parent -                    w.watcher.process( -                            new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, parent)); -                } -            } -        }); -    } - -    public void deleteEphemeralNodes(long sessionId) { -        if (sessionId != NOT_EPHEMERAL) { -            runInExecutorSync(() -> { -                tree.values().removeIf(zNode -> zNode.getEphemeralOwner() == sessionId); -            }); -        } -    } - - -    public void deleteWatchers(long sessionId) { -        runInExecutorSync(() -> { -            // remove all persistent watchers for the session -            persistentWatchers.removeIf(w -> w.sessionId == sessionId); -            // remove all watchers for the session -            List<Map.Entry<String, NodeWatcher>> watchersForSession = -                    watchers.entries().stream().filter(e -> e.getValue().sessionId == sessionId).toList(); -            watchersForSession -                    .forEach(e -> watchers.remove(e.getKey(), e.getValue())); -        }); -    } - -    private static final Logger log = LoggerFactory.getLogger(MockZooKeeper.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.zookeeper; + +import com.google.common.collect.HashMultimap; +import com.google.common.collect.Maps; +import com.google.common.collect.SetMultimap; +import com.google.common.collect.Sets; +import com.google.common.util.concurrent.MoreExecutors; +import io.netty.util.concurrent.DefaultThreadFactory; +import java.util.ArrayList; +import java.util.Collection; +import java.util.Collections; +import java.util.List; +import java.util.Map; +import java.util.Optional; +import java.util.Set; +import java.util.TreeMap; +import java.util.concurrent.Callable; +import java.util.concurrent.CopyOnWriteArrayList; +import java.util.concurrent.ExecutionException; +import java.util.concurrent.ExecutorService; +import java.util.concurrent.Executors; +import java.util.concurrent.Future; +import java.util.concurrent.RejectedExecutionException; +import java.util.concurrent.TimeUnit; +import java.util.concurrent.atomic.AtomicBoolean; +import java.util.concurrent.atomic.AtomicLong; +import java.util.concurrent.atomic.AtomicReference; +import java.util.function.BiPredicate; +import lombok.AllArgsConstructor; +import org.apache.zookeeper.AsyncCallback.Children2Callback; +import org.apache.zookeeper.AsyncCallback.ChildrenCallback; +import org.apache.zookeeper.AsyncCallback.DataCallback; +import org.apache.zookeeper.AsyncCallback.StatCallback; +import org.apache.zookeeper.AsyncCallback.StringCallback; +import org.apache.zookeeper.AsyncCallback.VoidCallback; +import org.apache.zookeeper.Watcher.Event.EventType; +import org.apache.zookeeper.Watcher.Event.KeeperState; +import org.apache.zookeeper.client.ZKClientConfig; +import org.apache.zookeeper.data.ACL; +import org.apache.zookeeper.data.Stat; +import org.apache.zookeeper.proto.DeleteRequest; +import org.apache.zookeeper.proto.SetDataRequest; +import org.objenesis.Objenesis; +import org.objenesis.ObjenesisStd; +import org.objenesis.instantiator.ObjectInstantiator; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +public class MockZooKeeper extends ZooKeeper { +    // ephemeralOwner value for persistent nodes +    private static final long NOT_EPHEMERAL = 0L; +    private static final String ROOT_PATH = "/"; + +    @AllArgsConstructor +    private static class MockZNode { +        byte[] content; +        int version; +        long ephemeralOwner; +        long creationTimestamp; +        long modificationTimestamp; +        List<String> children; + +        static MockZNode of(byte[] content, int version, long ephemeralOwner) { +            return new MockZNode(content, version, ephemeralOwner, System.currentTimeMillis(), +                    System.currentTimeMillis(), new ArrayList<>()); +        } + +        public void updateVersion() { +            version++; +            modificationTimestamp = System.currentTimeMillis(); +        } + +        public void updateData(byte[] data) { +            content = data; +            updateVersion(); +        } + +        public Stat getStat() { +            return applyToStat(new Stat()); +        } + +        public Stat applyToStat(Stat stat) { +            stat.setCtime(creationTimestamp); +            stat.setMtime(modificationTimestamp); +            stat.setVersion(version); +            stat.setEphemeralOwner(ephemeralOwner); +            return stat; +        } + +        public int getVersion() { +            return version; +        } + +        public byte[] getContent() { +            return content; +        } + +        public long getEphemeralOwner() { +            return ephemeralOwner; +        } + +        public List<String> getChildren() { +            return children; +        } +    } + +    private TreeMap<String, MockZNode> tree; +    private SetMultimap<String, NodeWatcher> watchers; +    private AtomicBoolean stopped; +    private AtomicReference<KeeperException.Code> alwaysFail; +    private CopyOnWriteArrayList<Failure> failures; +    private ExecutorService executor; + +    private volatile Watcher sessionWatcher; +    private long sessionId = 1L; +    private int readOpDelayMs; + +    private AtomicLong sequentialIdGenerator; +    private ThreadLocal<Long> overriddenSessionIdThreadLocal; +    private ThreadLocal<Boolean> inExecutorThreadLocal; +    private int referenceCount; +    private List<AutoCloseable> closeables; +    private int sessionTimeout; +    private ZKClientConfig zKClientConfig = new ZKClientConfig(); + +    //see details of Objenesis caching - http://objenesis.org/details.html +    //see supported jvms - https://github.com/easymock/objenesis/blob/master/SupportedJVMs.md +    private static final Objenesis objenesis = new ObjenesisStd(); + +    public enum Op { +        CREATE, GET, SET, GET_CHILDREN, DELETE, EXISTS, SYNC, +    } + +    private static class Failure { +        final KeeperException.Code failReturnCode; +        final BiPredicate<Op, String> predicate; + +        Failure(KeeperException.Code failReturnCode, BiPredicate<Op, String> predicate) { +            this.failReturnCode = failReturnCode; +            this.predicate = predicate; +        } +    } + +    private record PersistentWatcher(String path, Watcher watcher, AddWatchMode mode, long sessionId) { +    } + +    private record NodeWatcher(Watcher watcher, long sessionId) { +    } + +    private List<PersistentWatcher> persistentWatchers; + +    public static MockZooKeeper newInstance() { +        return newInstance(-1); +    } + +    public static MockZooKeeper newInstance(int readOpDelayMs) { +        try { +            return createMockZooKeeperInstance(readOpDelayMs); +        } catch (RuntimeException e) { +            throw e; +        } catch (Exception e) { +            throw new IllegalStateException("Cannot create object", e); +        } +    } + +    private static MockZooKeeper createMockZooKeeperInstance(int readOpDelayMs) { +        ObjectInstantiator<MockZooKeeper> mockZooKeeperInstantiator = +                objenesis.getInstantiatorOf(MockZooKeeper.class); +        MockZooKeeper zk = mockZooKeeperInstantiator.newInstance(); +        zk.overriddenSessionIdThreadLocal = new ThreadLocal<>(); +        zk.inExecutorThreadLocal = ThreadLocal.withInitial(() -> false); +        zk.init(); +        zk.readOpDelayMs = readOpDelayMs; +        zk.sequentialIdGenerator = new AtomicLong(); +        zk.closeables = new ArrayList<>(); +        zk.sessionTimeout = 30_000; +        zk.zKClientConfig = new ZKClientConfig(); +        return zk; +    } + +    private void init() { +        tree = Maps.newTreeMap(); +        tree.put(ROOT_PATH, MockZNode.of(new byte[0], 0, NOT_EPHEMERAL)); +        this.executor = Executors.newSingleThreadExecutor(new DefaultThreadFactory("mock-zookeeper")); +        watchers = HashMultimap.create(); +        stopped = new AtomicBoolean(false); +        alwaysFail = new AtomicReference<>(KeeperException.Code.OK); +        failures = new CopyOnWriteArrayList<>(); +        persistentWatchers = new ArrayList<>(); +    } + +    @Override +    public int getSessionTimeout() { +        return sessionTimeout; +    } + +    public void setSessionTimeout(int sessionTimeout) { +        this.sessionTimeout = sessionTimeout; +    } + +    private MockZooKeeper(String quorum) throws Exception { +        // This constructor is never called +        super(quorum, 1, event -> { +        }); +        assert false; +    } + +    @Override +    public States getState() { +        return States.CONNECTED; +    } + +    @Override +    public void register(Watcher watcher) { +        sessionWatcher = watcher; +    } + +    @Override +    public String create(String path, byte[] data, List<ACL> acl, CreateMode createMode) +            throws KeeperException, InterruptedException { +        return runInExecutorReturningValue(() -> internalCreate(path, data, createMode)); +    } + +    @Override +    public ZKClientConfig getClientConfig() { +        return zKClientConfig; +    } + +    private <T> T runInExecutorReturningValue(Callable<T> task) +            throws InterruptedException, KeeperException { +        if (isStopped()) { +            throw new KeeperException.ConnectionLossException(); +        } +        if (inExecutorThreadLocal.get()) { +            try { +                return task.call(); +            } catch (Exception e) { +                if (e instanceof KeeperException ke) { +                    throw ke; +                } +                if (e instanceof InterruptedException ie) { +                    throw ie; +                } +                log.error("Unexpected exception", e); +                throw new KeeperException.SystemErrorException(); +            } +        } +        try { +            long currentSessionId = getSessionId(); +            return executor.submit(() -> { +                inExecutorThreadLocal.set(true); +                overrideSessionId(currentSessionId); +                try { +                    return task.call(); +                } finally { +                    removeSessionIdOverride(); +                    inExecutorThreadLocal.set(false); +                } +            }).get(); +        } catch (ExecutionException e) { +            Throwable cause = e.getCause(); +            if (cause instanceof KeeperException ke) { +                throw ke; +            } +            if (cause instanceof InterruptedException ie) { +                throw ie; +            } +            log.error("Unexpected exception", e); +            throw new KeeperException.SystemErrorException(); +        } +    } + +    private void runInExecutorAsync(Runnable runnable) { +        if (isStopped()) { +            throw new RejectedExecutionException("MockZooKeeper is stopped"); +        } +        if (inExecutorThreadLocal.get()) { +            try { +                runnable.run(); +            } catch (Throwable t) { +                log.error("Unexpected exception", t); +            } +            return; +        } +        long currentSessionId = getSessionId(); +        executor.submit(() -> { +            try { +                inExecutorThreadLocal.set(true); +                overrideSessionId(currentSessionId); +                try { +                    runnable.run(); +                } finally { +                    removeSessionIdOverride(); +                    inExecutorThreadLocal.set(false); +                } +            } catch (Throwable t) { +                log.error("Unexpected exception", t); +            } +        }); +    } + +    private void runInExecutorSync(Runnable runnable) { +        try { +            runInExecutorReturningValue(() -> { +                runnable.run(); +                return null; +            }); +        } catch (Exception e) { +            log.error("Unexpected error", e); +        } +    } + +    private String internalCreate(String path, byte[] data, CreateMode createMode) throws KeeperException { +        final Set<Watcher> toNotifyCreate = Sets.newHashSet(); +        final Set<Watcher> toNotifyParent = Sets.newHashSet(); +        final String parent = getParentName(path); + +        maybeThrowProgrammedFailure(Op.CREATE, path); + +        if (isStopped()) { +            throw new KeeperException.ConnectionLossException(); +        } + +        if (tree.containsKey(path)) { +            throw new KeeperException.NodeExistsException(path); +        } + +        MockZNode parentNode = tree.get(parent); + +        if (parentNode == null) { +            throw new KeeperException.NoNodeException(parent); +        } + +        if (createMode.isSequential()) { +            int parentVersion = parentNode.getVersion(); +            path = path + parentVersion; +            parentNode.updateVersion(); +        } + +        parentNode.getChildren().add(getNodeName(path)); +        tree.put(path, createMockZNode(data, createMode)); + +        toNotifyCreate.addAll(getWatchers(path)); +        if (!ROOT_PATH.equals(parent)) { +            toNotifyParent.addAll(getWatchers(parent)); +        } +        watchers.removeAll(path); + +        final String finalPath = path; +        executor.execute(() -> { +            if (isStopped()) { +                return; +            } + +            triggerPersistentWatches(finalPath, parent, EventType.NodeCreated); + +            toNotifyCreate.forEach( +                    watcher -> watcher.process( +                            new WatchedEvent(EventType.NodeCreated, +                                    KeeperState.SyncConnected, +                                    finalPath))); +            toNotifyParent.forEach( +                    watcher -> watcher.process( +                            new WatchedEvent(EventType.NodeChildrenChanged, +                                    KeeperState.SyncConnected, +                                    parent))); +        }); + +        return path; +    } + +    private static String getParentName(String path) { +        String parentName = path.substring(0, path.lastIndexOf('/')); +        return parentName.length() > 0 ? parentName : "/"; +    } + +    private static String getNodeName(String path) { +        return path.substring(path.lastIndexOf('/') + 1); +    } + +    private Collection<Watcher> getWatchers(String path) { +        Set<NodeWatcher> nodeWatchers = watchers.get(path); +        if (nodeWatchers != null) { +            return nodeWatchers.stream().map(NodeWatcher::watcher).toList(); +        } else { +            return Collections.emptyList(); +        } +    } + +    @Override +    public long getSessionId() { +        Long overriddenSessionId = overriddenSessionIdThreadLocal.get(); +        if (overriddenSessionId != null) { +            return overriddenSessionId; +        } +        return sessionId; +    } + +    public void overrideSessionId(long sessionId) { +        overriddenSessionIdThreadLocal.set(sessionId); +    } + +    public void removeSessionIdOverride() { +        overriddenSessionIdThreadLocal.remove(); +    } + +    @Override +    public void create(final String path, final byte[] data, final List<ACL> acl, CreateMode createMode, +                       final StringCallback cb, final Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +                    return; +                } + +                final Set<Watcher> toNotifyCreate = Sets.newHashSet(); +                toNotifyCreate.addAll(getWatchers(path)); + +                final Set<Watcher> toNotifyParent = Sets.newHashSet(); +                final String parent = getParentName(path); +                if (!ROOT_PATH.equals(parent)) { +                    toNotifyParent.addAll(getWatchers(parent)); +                } + +                final String name; +                if (createMode != null && createMode.isSequential()) { +                    name = path + sequentialIdGenerator.getAndIncrement(); +                } else { +                    name = path; +                } + +                Optional<KeeperException.Code> failure = programmedFailure(Op.CREATE, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx, null); +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +                } else if (tree.containsKey(path)) { +                    cb.processResult(KeeperException.Code.NODEEXISTS.intValue(), path, ctx, null); +                } else if (!tree.containsKey(parent)) { +                    runNotifications(() -> { +                        toNotifyParent.forEach(watcher -> watcher +                                .process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, +                                        parent))); +                    }); +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); +                } else { +                    tree.get(parent).getChildren().add(getNodeName(name)); +                    tree.put(name, createMockZNode(data, createMode)); +                    watchers.removeAll(name); +                    cb.processResult(0, path, ctx, name); +                    runNotifications(() -> { +                        triggerPersistentWatches(path, parent, EventType.NodeCreated); + +                        toNotifyCreate.forEach( +                                watcher -> watcher.process( +                                        new WatchedEvent(EventType.NodeCreated, +                                                KeeperState.SyncConnected, +                                                name))); +                        toNotifyParent.forEach( +                                watcher -> watcher.process( +                                        new WatchedEvent(EventType.NodeChildrenChanged, +                                                KeeperState.SyncConnected, +                                                parent))); +                    }); +                } +            } catch (Throwable ex) { +                log.error("create path : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); +            } +        }); +    } + +    public void runNotifications(Runnable runnable) { +        executor.execute(() -> { +            if (isStopped()) { +                return; +            } +            runnable.run(); +        }); +    } + +    private boolean isStopped() { +        return stopped.get(); +    } + +    private MockZNode createMockZNode(byte[] data, CreateMode createMode) { +        return MockZNode.of(data, 0, +                createMode != null && createMode.isEphemeral() ? getSessionId() : NOT_EPHEMERAL); +    } + +    @Override +    public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException { +        return runInExecutorReturningValue(() -> internalGetData(path, watcher, stat)); +    } + +    private byte[] internalGetData(String path, Watcher watcher, Stat stat) throws KeeperException { +        maybeThrowProgrammedFailure(Op.GET, path); +        MockZNode value = tree.get(path); +        if (value == null) { +            throw new KeeperException.NoNodeException(path); +        } else { +            if (watcher != null) { +                watchers.put(path, new NodeWatcher(watcher, getSessionId())); +            } +            if (stat != null) { +                value.applyToStat(stat); +            } +            return value.getContent(); +        } +    } + +    @Override +    public void getData(final String path, boolean watch, final DataCallback cb, final Object ctx) { +        getData(path, null, cb, ctx); +    } + +    @Override +    public void getData(final String path, final Watcher watcher, final DataCallback cb, final Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); +            return; +        } +        runInExecutorAsync(() -> { +            checkReadOpDelay(); +            try { +                Optional<KeeperException.Code> failure = programmedFailure(Op.GET, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx, null, null); +                    return; +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); +                    return; +                } + +                MockZNode value = tree.get(path); +                if (value == null) { +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null); +                } else { +                    if (watcher != null) { +                        watchers.put(path, new NodeWatcher(watcher, getSessionId())); +                    } +                    Stat stat = value.getStat(); +                    cb.processResult(0, path, ctx, value.getContent(), stat); +                } +            } catch (Throwable ex) { +                log.error("get data : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null); +            } +        }); +    } + +    @Override +    public void getChildren(final String path, final Watcher watcher, final ChildrenCallback cb, final Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                Optional<KeeperException.Code> failure = programmedFailure(Op.GET_CHILDREN, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx, null); +                    return; +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +                    return; +                } + +                if (!tree.containsKey(path)) { +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); +                    return; +                } + +                List<String> children = findFirstLevelChildren(path); +                if (watcher != null) { +                    watchers.put(path, new NodeWatcher(watcher, getSessionId())); +                } +                cb.processResult(0, path, ctx, children); +            } catch (Throwable ex) { +                log.error("get children : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); +            } +        }); +    } + +    @Override +    public List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException { +        return runInExecutorReturningValue(() -> internalGetChildren(path, watcher)); +    } + +    private List<String> internalGetChildren(String path, Watcher watcher) throws KeeperException { +        maybeThrowProgrammedFailure(Op.GET_CHILDREN, path); + +        if (!tree.containsKey(path)) { +            throw new KeeperException.NoNodeException(path); +        } + +        if (watcher != null) { +            watchers.put(path, new NodeWatcher(watcher, getSessionId())); +        } + +        return findFirstLevelChildren(path); +    } + +    @Override +    public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException { +        return getChildren(path, null); +    } + +    @Override +    public void getChildren(final String path, boolean watcher, final Children2Callback cb, final Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                MockZNode mockZNode = tree.get(path); +                Stat stat = mockZNode != null ? mockZNode.getStat() : null; +                Optional<KeeperException.Code> failure = programmedFailure(Op.GET_CHILDREN, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx, null, null); +                    return; +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null); +                    return; +                } else if (mockZNode == null) { +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null); +                    return; +                } + +                List<String> children = findFirstLevelChildren(path); +                cb.processResult(0, path, ctx, children, stat); +            } catch (Throwable ex) { +                log.error("get children : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null); +            } +        }); +    } + +    private List<String> findFirstLevelChildren(String path) { +        return new ArrayList<>(tree.get(path).getChildren()); +    } + +    private boolean hasChildren(String path) { +        return !tree.get(path).getChildren().isEmpty(); +    } + +    @Override +    public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException { +        return runInExecutorReturningValue(() -> internalGetStat(path, null)); +    } + +    private Stat internalGetStat(String path, Watcher watcher) throws KeeperException { +        maybeThrowProgrammedFailure(Op.EXISTS, path); + +        if (isStopped()) { +            throw new KeeperException.ConnectionLossException(); +        } + +        if (watcher != null) { +            watchers.put(path, new NodeWatcher(watcher, getSessionId())); +        } + +        if (tree.containsKey(path)) { +            return tree.get(path).getStat(); +        } else { +            return null; +        } +    } + +    @Override +    public Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException { +        return runInExecutorReturningValue(() -> internalGetStat(path, watcher)); +    } + +    @Override +    public void exists(String path, boolean watch, StatCallback cb, Object ctx) { +        exists(path, null, cb, ctx); +    } + +    @Override +    public void exists(String path, Watcher watcher, StatCallback cb, Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                Optional<KeeperException.Code> failure = programmedFailure(Op.EXISTS, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx, null); +                    return; +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +                    return; +                } + +                if (watcher != null) { +                    watchers.put(path, new NodeWatcher(watcher, getSessionId())); +                } + +                MockZNode mockZNode = tree.get(path); +                if (mockZNode != null) { +                    Stat stat = mockZNode.getStat(); +                    cb.processResult(0, path, ctx, stat); +                } else { +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); +                } +            } catch (Throwable ex) { +                log.error("exist : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); +            } +        }); +    } + +    @Override +    public void sync(String path, VoidCallback cb, Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); +            return; +        } +        runInExecutorAsync(() -> { +            Optional<KeeperException.Code> failure = programmedFailure(Op.SYNC, path); +            if (failure.isPresent()) { +                cb.processResult(failure.get().intValue(), path, ctx); +                return; +            } else if (isStopped()) { +                cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); +                return; +            } +            cb.processResult(0, path, ctx); +        }); +    } + +    @Override +    public Stat setData(final String path, byte[] data, int version) throws KeeperException, InterruptedException { +        return runInExecutorReturningValue(() ->  internalSetData(path, data, version)); +    } + +    private Stat internalSetData(String path, byte[] data, int version) throws KeeperException { +        final Set<Watcher> toNotify = Sets.newHashSet(); +        maybeThrowProgrammedFailure(Op.SET, path); + +        if (isStopped()) { +            throw new KeeperException.ConnectionLossException(); +        } + +        if (!tree.containsKey(path)) { +            throw new KeeperException.NoNodeException(path); +        } + +        MockZNode mockZNode = tree.get(path); +        int currentVersion = mockZNode.getVersion(); + +        // Check version +        if (version != -1 && version != currentVersion) { +            throw new KeeperException.BadVersionException(path); +        } + +        log.debug("[{}] Updating -- current version: {}", path, currentVersion); +        mockZNode.updateData(data); +        Stat stat = mockZNode.getStat(); +        toNotify.addAll(getWatchers(path)); +        watchers.removeAll(path); + +        runNotifications(() -> { +            triggerPersistentWatches(path, null, EventType.NodeDataChanged); + +            toNotify.forEach(watcher -> watcher +                    .process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path))); +        }); + +        return stat; +    } + +    @Override +    public void setData(final String path, final byte[] data, int version, final StatCallback cb, final Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                final Set<Watcher> toNotify = Sets.newHashSet(); +                Stat stat; +                Optional<KeeperException.Code> failure = programmedFailure(Op.SET, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx, null); +                    return; +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null); +                    return; +                } + +                if (!tree.containsKey(path)) { +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null); +                    return; +                } + +                MockZNode mockZNode = tree.get(path); +                int currentVersion = mockZNode.getVersion(); + +                // Check version +                if (version != -1 && version != currentVersion) { +                    log.debug("[{}] Current version: {} -- Expected: {}", path, currentVersion, version); +                    Stat currentStat = mockZNode.getStat(); +                    cb.processResult(KeeperException.Code.BADVERSION.intValue(), path, ctx, currentStat); +                    return; +                } + +                log.debug("[{}] Updating -- current version: {}", path, currentVersion); +                mockZNode.updateData(data); +                stat = mockZNode.getStat(); +                cb.processResult(0, path, ctx, stat); + +                toNotify.addAll(getWatchers(path)); +                watchers.removeAll(path); + +                runNotifications(() -> { +                    triggerPersistentWatches(path, null, EventType.NodeDataChanged); + +                    for (Watcher watcher : toNotify) { +                        watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path)); +                    } +                }); +            } catch (Throwable ex) { +                log.error("Update data : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null); +            } +        }); +    } + +    @Override +    public void delete(final String path, int version) throws InterruptedException, KeeperException { +        runInExecutorReturningValue(() -> { +            internalDelete(path, version); +            return null; +        }); +    } + +    private void internalDelete(String path, int version) throws KeeperException { +        maybeThrowProgrammedFailure(Op.DELETE, path); + +        final Set<Watcher> toNotifyDelete; +        final Set<Watcher> toNotifyParent; +        final String parent; + +        if (isStopped()) { +            throw new KeeperException.ConnectionLossException(); +        } else if (!tree.containsKey(path)) { +            throw new KeeperException.NoNodeException(path); +        } else if (hasChildren(path)) { +            throw new KeeperException.NotEmptyException(path); +        } + +        if (version != -1) { +            int currentVersion = tree.get(path).getVersion(); +            if (version != currentVersion) { +                throw new KeeperException.BadVersionException(path); +            } +        } + +        parent = getParentName(path); +        tree.remove(path); +        tree.get(parent).getChildren().remove(getNodeName(path)); + +        toNotifyDelete = Sets.newHashSet(); +        toNotifyDelete.addAll(getWatchers(path)); + +        toNotifyParent = Sets.newHashSet(); +        if (!ROOT_PATH.equals(parent)) { +            toNotifyParent.addAll(getWatchers(parent)); +        } + +        watchers.removeAll(path); + +        runNotifications(() -> { +            for (Watcher watcher1 : toNotifyDelete) { +                watcher1.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path)); +            } +            for (Watcher watcher2 : toNotifyParent) { +                watcher2.process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, parent)); +            } + +            triggerPersistentWatches(path, parent, EventType.NodeDeleted); +        }); +    } + +    @Override +    public void delete(final String path, int version, final VoidCallback cb, final Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                final Set<Watcher> toNotifyDelete = Sets.newHashSet(); +                toNotifyDelete.addAll(getWatchers(path)); + +                final Set<Watcher> toNotifyParent = Sets.newHashSet(); +                final String parent = getParentName(path); +                if (!ROOT_PATH.equals(parent)) { +                    toNotifyParent.addAll(getWatchers(parent)); +                } +                watchers.removeAll(path); + +                Optional<KeeperException.Code> failure = programmedFailure(Op.DELETE, path); +                if (failure.isPresent()) { +                    cb.processResult(failure.get().intValue(), path, ctx); +                } else if (isStopped()) { +                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx); +                } else if (!tree.containsKey(path)) { +                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx); +                } else if (hasChildren(path)) { +                    cb.processResult(KeeperException.Code.NOTEMPTY.intValue(), path, ctx); +                } else { +                    if (version != -1) { +                        int currentVersion = tree.get(path).getVersion(); +                        if (version != currentVersion) { +                            cb.processResult(KeeperException.Code.BADVERSION.intValue(), path, ctx); +                            return; +                        } +                    } + +                    tree.remove(path); +                    tree.get(parent).getChildren().remove(getNodeName(path)); +                    cb.processResult(0, path, ctx); + +                    runNotifications(() -> { +                        triggerPersistentWatches(path, parent, EventType.NodeDeleted); +                        toNotifyDelete.forEach(watcher -> watcher +                                .process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path))); +                        toNotifyParent.forEach(watcher -> watcher +                                .process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, +                                        parent))); +                    }); +                } +            } catch (Throwable ex) { +                log.error("delete path : {} error", path, ex); +                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx); +            } +        }); +    } + +    @Override +    public void multi(Iterable<org.apache.zookeeper.Op> ops, AsyncCallback.MultiCallback cb, Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), null, ctx, null); +            return; +        } +        runInExecutorAsync(() -> { +            try { +                List<OpResult> res = multi(ops); +                cb.processResult(KeeperException.Code.OK.intValue(), null, ctx, res); +            } catch (Exception e) { +                cb.processResult(KeeperException.Code.APIERROR.intValue(), null, ctx, null); +            } +        }); +    } + +    @Override +    public List<OpResult> multi(Iterable<org.apache.zookeeper.Op> ops) throws InterruptedException, KeeperException { +        return runInExecutorReturningValue(() -> internalMulti(ops)); +    } + +    private List<OpResult> internalMulti(Iterable<org.apache.zookeeper.Op> ops) { +        List<OpResult> res = new ArrayList<>(); +        for (org.apache.zookeeper.Op op : ops) { +            switch (op.getType()) { +                case ZooDefs.OpCode.create -> { +                    handleOperation("create", op, () -> { +                        org.apache.zookeeper.Op.Create opc = ((org.apache.zookeeper.Op.Create) op); +                        CreateMode cm = CreateMode.fromFlag(opc.flags); +                        String path = create(op.getPath(), opc.data, null, cm); +                        res.add(new OpResult.CreateResult(path)); +                    }, res); +                } +                case ZooDefs.OpCode.delete -> { +                    handleOperation("delete", op, () -> { +                        DeleteRequest deleteRequest = (DeleteRequest) op.toRequestRecord(); +                        delete(op.getPath(), deleteRequest.getVersion()); +                        res.add(new OpResult.DeleteResult()); +                    }, res); +                } +                case ZooDefs.OpCode.setData -> { +                    handleOperation("setData", op, () -> { +                        SetDataRequest setDataRequest = (SetDataRequest) op.toRequestRecord(); +                        Stat stat = setData(op.getPath(), setDataRequest.getData(), setDataRequest.getVersion()); +                        res.add(new OpResult.SetDataResult(stat)); +                    }, res); +                } +                case ZooDefs.OpCode.getChildren -> { +                    handleOperation("getChildren", op, () -> { +                        List<String> children = getChildren(op.getPath(), null); +                        res.add(new OpResult.GetChildrenResult(children)); +                    }, res); +                } +                case ZooDefs.OpCode.getData -> { +                    Stat stat = new Stat(); +                    handleOperation("getData", op, () -> { +                        byte[] payload = getData(op.getPath(), null, stat); +                        res.add(new OpResult.GetDataResult(payload, stat)); +                    }, res); +                } +                default -> { +                    log.error("Unsupported operation for path {} type {} kind {} request {}", op.getPath(), +                            op.getType(), op.getKind(), op.toRequestRecord()); +                    res.add(new OpResult.ErrorResult(KeeperException.Code.APIERROR.intValue())); +                } +            } +        } +        return res; +    } + +    interface ZkOpHandler { +        void handle() throws KeeperException, InterruptedException; +    } + +    private void handleOperation(String opName, org.apache.zookeeper.Op op, ZkOpHandler handler, List<OpResult> res) { +        try { +            handler.handle(); +        } catch (Exception e) { +            if (e instanceof KeeperException keeperException) { +                res.add(new OpResult.ErrorResult(keeperException.code().intValue())); +            } else { +                log.error("Error handling {} operation for path {} type {} kind {} request {}", opName, op.getPath(), +                        op.getType(), op.getKind(), op.toRequestRecord(), e); +                res.add(new OpResult.ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue())); +            } +        } +    } + +    @Override +    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode) { +        runInExecutorSync(() -> { +            persistentWatchers.add(new PersistentWatcher(basePath, watcher, mode, getSessionId())); +        }); +    } + +    @Override +    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode, VoidCallback cb, Object ctx) { +        if (isStopped()) { +            cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), basePath, ctx); +            return; +        } +        runInExecutorAsync(() -> { +            addWatch(basePath, watcher, mode); +            cb.processResult(KeeperException.Code.OK.intValue(), basePath, ctx); +        }); +    } + +    public synchronized void increaseRefCount() { +        referenceCount++; +    } + +    public synchronized MockZooKeeper registerCloseable(AutoCloseable closeable) { +        closeables.add(closeable); +        return this; +    } + +    @Override +    public synchronized void close() throws InterruptedException { +        if (--referenceCount <= 0) { +            shutdown(); +            closeables.forEach(c -> { +                try { +                    c.close(); +                } catch (Exception e) { +                    log.error("Error closing closeable", e); +                } +            }); +            closeables.clear(); +        } +    } + +    public void shutdown() throws InterruptedException { +        if (stopped.compareAndSet(false, true)) { +            Future<?> shutdownTask = executor.submit(() -> { +                tree.clear(); +                watchers.clear(); +                persistentWatchers.clear(); +            }); +            try { +                shutdownTask.get(); +            } catch (ExecutionException e) { +                log.error("Error shutting down", e); +            } +            MoreExecutors.shutdownAndAwaitTermination(executor, 10, TimeUnit.SECONDS); +        } +    } + +    Optional<KeeperException.Code> programmedFailure(Op op, String path) { +        KeeperException.Code error = alwaysFail.get(); +        if (error != KeeperException.Code.OK) { +            return Optional.of(error); +        } +        Optional<Failure> failure = failures.stream().filter(f -> f.predicate.test(op, path)).findFirst(); +        if (failure.isPresent()) { +            failures.remove(failure.get()); +            return Optional.ofNullable(failure.get().failReturnCode); +        } else { +            return Optional.empty(); +        } +    } + +    void maybeThrowProgrammedFailure(Op op, String path) throws KeeperException { +        Optional<KeeperException.Code> failure = programmedFailure(op, path); +        if (failure.isPresent()) { +            throw KeeperException.create(failure.get()); +        } +    } + +    public void failConditional(KeeperException.Code rc, BiPredicate<Op, String> predicate) { +        failures.add(new Failure(rc, predicate)); +    } + +    public void delay(long millis, BiPredicate<Op, String> predicate) { +        failures.add(new Failure(null, (op, s) -> { +            if (predicate.test(op, s)) { +                try { +                    Thread.sleep(millis); +                } catch (InterruptedException e) {} +                return true; +            } +            return false; +        })); +    } + +    public void setAlwaysFail(KeeperException.Code rc) { +        alwaysFail.set(rc); +    } + +    public void unsetAlwaysFail() { +        alwaysFail.set(KeeperException.Code.OK); +    } + +    public void setSessionId(long id) { +        sessionId = id; +    } + +    @Override +    public String toString() { +        return "MockZookeeper"; +    } + +    private void checkReadOpDelay() { +        if (readOpDelayMs > 0) { +            try { +                Thread.sleep(readOpDelayMs); +            } catch (InterruptedException e) { +                // Ok +            } +        } +    } + +    private void triggerPersistentWatches(String path, String parent, EventType eventType) { +        persistentWatchers.forEach(w -> { +            if (w.mode == AddWatchMode.PERSISTENT_RECURSIVE) { +                if (path.startsWith(w.path())) { +                    w.watcher.process(new WatchedEvent(eventType, KeeperState.SyncConnected, path)); +                } +            } else if (w.mode == AddWatchMode.PERSISTENT) { +                if (w.path().equals(path)) { +                    w.watcher.process(new WatchedEvent(eventType, KeeperState.SyncConnected, path)); +                } + +                if (eventType == EventType.NodeCreated || eventType == EventType.NodeDeleted) { +                    // Also notify parent +                    w.watcher.process( +                            new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, parent)); +                } +            } +        }); +    } + +    public void deleteEphemeralNodes(long sessionId) { +        if (sessionId != NOT_EPHEMERAL) { +            runInExecutorSync(() -> { +                tree.values().removeIf(zNode -> zNode.getEphemeralOwner() == sessionId); +            }); +        } +    } + + +    public void deleteWatchers(long sessionId) { +        runInExecutorSync(() -> { +            // remove all persistent watchers for the session +            persistentWatchers.removeIf(w -> w.sessionId == sessionId); +            // remove all watchers for the session +            List<Map.Entry<String, NodeWatcher>> watchersForSession = +                    watchers.entries().stream().filter(e -> e.getValue().sessionId == sessionId).toList(); +            watchersForSession +                    .forEach(e -> watchers.remove(e.getKey(), e.getValue())); +        }); +    } + +    private static final Logger log = LoggerFactory.getLogger(MockZooKeeper.class); +} diff --git a/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeperSession.java b/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeperSession.java index 0da88c03c2..bd75371797 100644 --- a/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeperSession.java +++ b/testmocks/src/main/java/org/apache/zookeeper/MockZooKeeperSession.java @@ -1,416 +1,416 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.zookeeper; - -import java.util.List; -import java.util.Optional; -import java.util.concurrent.atomic.AtomicInteger; -import java.util.function.BiPredicate; -import org.apache.zookeeper.AsyncCallback.Children2Callback; -import org.apache.zookeeper.AsyncCallback.ChildrenCallback; -import org.apache.zookeeper.AsyncCallback.DataCallback; -import org.apache.zookeeper.AsyncCallback.StatCallback; -import org.apache.zookeeper.AsyncCallback.VoidCallback; -import org.apache.zookeeper.client.ZKClientConfig; -import org.apache.zookeeper.data.ACL; -import org.apache.zookeeper.data.Stat; -import org.objenesis.Objenesis; -import org.objenesis.ObjenesisStd; -import org.objenesis.instantiator.ObjectInstantiator; - -/** - * mock zookeeper with different session based on {@link MockZooKeeper}. - */ -public class MockZooKeeperSession extends ZooKeeper { - -    private MockZooKeeper mockZooKeeper; - -    private long sessionId = 1L; - -    private static final Objenesis objenesis = new ObjenesisStd(); - -    private static final AtomicInteger sessionIdGenerator = new AtomicInteger(1000); - -    private boolean closeMockZooKeeperOnClose; - -    private int sessionTimeout = -1; - -    private ZKClientConfig zkClientConfig = new ZKClientConfig(); - -    public static MockZooKeeperSession newInstance(MockZooKeeper mockZooKeeper) { -        return newInstance(mockZooKeeper, true); -    } - -    public static MockZooKeeperSession newInstance(MockZooKeeper mockZooKeeper, boolean closeMockZooKeeperOnClose) { -        ObjectInstantiator<MockZooKeeperSession> instantiator = objenesis.getInstantiatorOf(MockZooKeeperSession.class); -        MockZooKeeperSession mockZooKeeperSession = instantiator.newInstance(); - -        mockZooKeeperSession.mockZooKeeper = mockZooKeeper; -        mockZooKeeperSession.sessionId = sessionIdGenerator.getAndIncrement(); -        mockZooKeeperSession.closeMockZooKeeperOnClose = closeMockZooKeeperOnClose; -        mockZooKeeperSession.zkClientConfig = new ZKClientConfig(); -        if (closeMockZooKeeperOnClose) { -            mockZooKeeper.increaseRefCount(); -        } -        return mockZooKeeperSession; -    } - -    private MockZooKeeperSession(String quorum) throws Exception { -        // This constructor is never called -        super(quorum, 1, event -> { -        }); -        assert false; -    } - -    @Override -    public ZKClientConfig getClientConfig() { -        return zkClientConfig; -    } - -    @Override -    public int getSessionTimeout() { -        if (sessionTimeout > 0) { -            return sessionTimeout; -        } else { -            return mockZooKeeper.getSessionTimeout(); -        } -    } - -    public void setSessionTimeout(int sessionTimeout) { -        this.sessionTimeout = sessionTimeout; -    } - -    @Override -    public States getState() { -        return mockZooKeeper.getState(); -    } - -    @Override -    public void register(Watcher watcher) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.register(watcher); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public String create(String path, byte[] data, List<ACL> acl, CreateMode createMode) -            throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.create(path, data, acl, createMode); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void create(final String path, final byte[] data, final List<ACL> acl, CreateMode createMode, -                       final AsyncCallback.StringCallback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.create(path, data, acl, createMode, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.getData(path, watcher, stat); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void getData(final String path, boolean watch, final DataCallback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.getData(path, watch, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void getData(final String path, final Watcher watcher, final DataCallback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.getData(path, watcher, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void getChildren(final String path, final Watcher watcher, final ChildrenCallback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.getChildren(path, watcher, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.getChildren(path, watcher); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.getChildren(path, watch); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void getChildren(final String path, boolean watcher, final Children2Callback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.getChildren(path, watcher, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.exists(path, watch); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.exists(path, watcher); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void exists(String path, boolean watch, StatCallback cb, Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.exists(path, watch, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void exists(String path, Watcher watcher, StatCallback cb, Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.exists(path, watcher, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void sync(String path, VoidCallback cb, Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.sync(path, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public Stat setData(final String path, byte[] data, int version) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.setData(path, data, version); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void setData(final String path, final byte[] data, int version, final StatCallback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.setData(path, data, version, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void delete(final String path, int version) throws InterruptedException, KeeperException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.delete(path, version); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void delete(final String path, int version, final VoidCallback cb, final Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.delete(path, version, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void multi(Iterable<org.apache.zookeeper.Op> ops, AsyncCallback.MultiCallback cb, Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.multi(ops, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public List<OpResult> multi(Iterable<org.apache.zookeeper.Op> ops) throws InterruptedException, KeeperException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            return mockZooKeeper.multi(ops); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode, VoidCallback cb, Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.addWatch(basePath, watcher, mode, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode) -            throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.addWatch(basePath, watcher, mode); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void addWatch(String basePath, AddWatchMode mode) throws KeeperException, InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.addWatch(basePath, mode); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void addWatch(String basePath, AddWatchMode mode, VoidCallback cb, Object ctx) { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.addWatch(basePath, mode, cb, ctx); -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    @Override -    public void close() throws InterruptedException { -        internalClose(false); -    } - -    public void shutdown() throws InterruptedException { -        internalClose(true); -    } - -    private void internalClose(boolean shutdown) throws InterruptedException { -        try { -            mockZooKeeper.overrideSessionId(getSessionId()); -            mockZooKeeper.deleteEphemeralNodes(getSessionId()); -            mockZooKeeper.deleteWatchers(getSessionId()); -            if (closeMockZooKeeperOnClose) { -                if (shutdown) { -                    mockZooKeeper.shutdown(); -                } else { -                    mockZooKeeper.close(); -                } -            } -        } finally { -            mockZooKeeper.removeSessionIdOverride(); -        } -    } - -    Optional<KeeperException.Code> programmedFailure(MockZooKeeper.Op op, String path) { -        return mockZooKeeper.programmedFailure(op, path); -    } - -    void maybeThrowProgrammedFailure(MockZooKeeper.Op op, String path) throws KeeperException { -        mockZooKeeper.maybeThrowProgrammedFailure(op, path); -    } - -    public void failConditional(KeeperException.Code rc, BiPredicate<MockZooKeeper.Op, String> predicate) { -        mockZooKeeper.failConditional(rc, predicate); -    } - -    public void setAlwaysFail(KeeperException.Code rc) { -        mockZooKeeper.setAlwaysFail(rc); -    } - -    public void unsetAlwaysFail() { -        mockZooKeeper.unsetAlwaysFail(); -    } - -    public void setSessionId(long id) { -        sessionId = id; -    } - -    @Override -    public long getSessionId() { -        return sessionId; -    } - -    @Override -    public String toString() { -        return "MockZooKeeperSession{" + "sessionId=" + sessionId + '}'; -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.zookeeper; + +import java.util.List; +import java.util.Optional; +import java.util.concurrent.atomic.AtomicInteger; +import java.util.function.BiPredicate; +import org.apache.zookeeper.AsyncCallback.Children2Callback; +import org.apache.zookeeper.AsyncCallback.ChildrenCallback; +import org.apache.zookeeper.AsyncCallback.DataCallback; +import org.apache.zookeeper.AsyncCallback.StatCallback; +import org.apache.zookeeper.AsyncCallback.VoidCallback; +import org.apache.zookeeper.client.ZKClientConfig; +import org.apache.zookeeper.data.ACL; +import org.apache.zookeeper.data.Stat; +import org.objenesis.Objenesis; +import org.objenesis.ObjenesisStd; +import org.objenesis.instantiator.ObjectInstantiator; + +/** + * mock zookeeper with different session based on {@link MockZooKeeper}. + */ +public class MockZooKeeperSession extends ZooKeeper { + +    private MockZooKeeper mockZooKeeper; + +    private long sessionId = 1L; + +    private static final Objenesis objenesis = new ObjenesisStd(); + +    private static final AtomicInteger sessionIdGenerator = new AtomicInteger(1000); + +    private boolean closeMockZooKeeperOnClose; + +    private int sessionTimeout = -1; + +    private ZKClientConfig zkClientConfig = new ZKClientConfig(); + +    public static MockZooKeeperSession newInstance(MockZooKeeper mockZooKeeper) { +        return newInstance(mockZooKeeper, true); +    } + +    public static MockZooKeeperSession newInstance(MockZooKeeper mockZooKeeper, boolean closeMockZooKeeperOnClose) { +        ObjectInstantiator<MockZooKeeperSession> instantiator = objenesis.getInstantiatorOf(MockZooKeeperSession.class); +        MockZooKeeperSession mockZooKeeperSession = instantiator.newInstance(); + +        mockZooKeeperSession.mockZooKeeper = mockZooKeeper; +        mockZooKeeperSession.sessionId = sessionIdGenerator.getAndIncrement(); +        mockZooKeeperSession.closeMockZooKeeperOnClose = closeMockZooKeeperOnClose; +        mockZooKeeperSession.zkClientConfig = new ZKClientConfig(); +        if (closeMockZooKeeperOnClose) { +            mockZooKeeper.increaseRefCount(); +        } +        return mockZooKeeperSession; +    } + +    private MockZooKeeperSession(String quorum) throws Exception { +        // This constructor is never called +        super(quorum, 1, event -> { +        }); +        assert false; +    } + +    @Override +    public ZKClientConfig getClientConfig() { +        return zkClientConfig; +    } + +    @Override +    public int getSessionTimeout() { +        if (sessionTimeout > 0) { +            return sessionTimeout; +        } else { +            return mockZooKeeper.getSessionTimeout(); +        } +    } + +    public void setSessionTimeout(int sessionTimeout) { +        this.sessionTimeout = sessionTimeout; +    } + +    @Override +    public States getState() { +        return mockZooKeeper.getState(); +    } + +    @Override +    public void register(Watcher watcher) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.register(watcher); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public String create(String path, byte[] data, List<ACL> acl, CreateMode createMode) +            throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.create(path, data, acl, createMode); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void create(final String path, final byte[] data, final List<ACL> acl, CreateMode createMode, +                       final AsyncCallback.StringCallback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.create(path, data, acl, createMode, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.getData(path, watcher, stat); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void getData(final String path, boolean watch, final DataCallback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.getData(path, watch, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void getData(final String path, final Watcher watcher, final DataCallback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.getData(path, watcher, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void getChildren(final String path, final Watcher watcher, final ChildrenCallback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.getChildren(path, watcher, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public List<String> getChildren(String path, Watcher watcher) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.getChildren(path, watcher); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public List<String> getChildren(String path, boolean watch) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.getChildren(path, watch); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void getChildren(final String path, boolean watcher, final Children2Callback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.getChildren(path, watcher, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public Stat exists(String path, boolean watch) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.exists(path, watch); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public Stat exists(String path, Watcher watcher) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.exists(path, watcher); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void exists(String path, boolean watch, StatCallback cb, Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.exists(path, watch, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void exists(String path, Watcher watcher, StatCallback cb, Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.exists(path, watcher, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void sync(String path, VoidCallback cb, Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.sync(path, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public Stat setData(final String path, byte[] data, int version) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.setData(path, data, version); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void setData(final String path, final byte[] data, int version, final StatCallback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.setData(path, data, version, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void delete(final String path, int version) throws InterruptedException, KeeperException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.delete(path, version); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void delete(final String path, int version, final VoidCallback cb, final Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.delete(path, version, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void multi(Iterable<org.apache.zookeeper.Op> ops, AsyncCallback.MultiCallback cb, Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.multi(ops, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public List<OpResult> multi(Iterable<org.apache.zookeeper.Op> ops) throws InterruptedException, KeeperException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            return mockZooKeeper.multi(ops); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode, VoidCallback cb, Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.addWatch(basePath, watcher, mode, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void addWatch(String basePath, Watcher watcher, AddWatchMode mode) +            throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.addWatch(basePath, watcher, mode); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void addWatch(String basePath, AddWatchMode mode) throws KeeperException, InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.addWatch(basePath, mode); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void addWatch(String basePath, AddWatchMode mode, VoidCallback cb, Object ctx) { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.addWatch(basePath, mode, cb, ctx); +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    @Override +    public void close() throws InterruptedException { +        internalClose(false); +    } + +    public void shutdown() throws InterruptedException { +        internalClose(true); +    } + +    private void internalClose(boolean shutdown) throws InterruptedException { +        try { +            mockZooKeeper.overrideSessionId(getSessionId()); +            mockZooKeeper.deleteEphemeralNodes(getSessionId()); +            mockZooKeeper.deleteWatchers(getSessionId()); +            if (closeMockZooKeeperOnClose) { +                if (shutdown) { +                    mockZooKeeper.shutdown(); +                } else { +                    mockZooKeeper.close(); +                } +            } +        } finally { +            mockZooKeeper.removeSessionIdOverride(); +        } +    } + +    Optional<KeeperException.Code> programmedFailure(MockZooKeeper.Op op, String path) { +        return mockZooKeeper.programmedFailure(op, path); +    } + +    void maybeThrowProgrammedFailure(MockZooKeeper.Op op, String path) throws KeeperException { +        mockZooKeeper.maybeThrowProgrammedFailure(op, path); +    } + +    public void failConditional(KeeperException.Code rc, BiPredicate<MockZooKeeper.Op, String> predicate) { +        mockZooKeeper.failConditional(rc, predicate); +    } + +    public void setAlwaysFail(KeeperException.Code rc) { +        mockZooKeeper.setAlwaysFail(rc); +    } + +    public void unsetAlwaysFail() { +        mockZooKeeper.unsetAlwaysFail(); +    } + +    public void setSessionId(long id) { +        sessionId = id; +    } + +    @Override +    public long getSessionId() { +        return sessionId; +    } + +    @Override +    public String toString() { +        return "MockZooKeeperSession{" + "sessionId=" + sessionId + '}'; +    } +} diff --git a/testmocks/src/main/java/org/apache/zookeeper/package-info.java b/testmocks/src/main/java/org/apache/zookeeper/package-info.java index ee611465ef..038cb79c6a 100644 --- a/testmocks/src/main/java/org/apache/zookeeper/package-info.java +++ b/testmocks/src/main/java/org/apache/zookeeper/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.zookeeper; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.zookeeper;