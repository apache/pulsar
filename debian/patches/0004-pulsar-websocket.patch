From: HelgiSaga <bglegb@gmail.com>
Date: Tue, 21 Jan 2026 12:30:00 +0300
Subject: [PATCH] debian: Update Pulsar WebSocket implementation and tests

Description: Update Pulsar WebSocket implementation and tests
Author: HelgiSaga <bglegb@gmail.com>
Forwarded: no
Last-Update: 2026-01-21

diff --git a/pulsar-websocket/pom.xml b/pulsar-websocket/pom.xml index e2229b2329..e17cdc481a 100644 --- a/pulsar-websocket/pom.xml +++ b/pulsar-websocket/pom.xml @@ -1,192 +1,192 @@ -<!-- - -    Licensed to the Apache Software Foundation (ASF) under one -    or more contributor license agreements.  See the NOTICE file -    distributed with this work for additional information -    regarding copyright ownership.  The ASF licenses this file -    to you under the Apache License, Version 2.0 (the -    "License"); you may not use this file except in compliance -    with the License.  You may obtain a copy of the License at - -      http://www.apache.org/licenses/LICENSE-2.0 - -    Unless required by applicable law or agreed to in writing, -    software distributed under the License is distributed on an -    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -    KIND, either express or implied.  See the License for the -    specific language governing permissions and limitations -    under the License. - ---> -<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" -  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> -  <modelVersion>4.0.0</modelVersion> - -  <parent> -    <groupId>org.apache.pulsar</groupId> -    <artifactId>pulsar</artifactId> -    <version>4.1.2</version> -  </parent> - -  <artifactId>pulsar-websocket</artifactId> -  <name>Pulsar WebSocket</name> - -  <dependencies> -    <dependency> -      <groupId>${project.groupId}</groupId> -      <artifactId>pulsar-broker-common</artifactId> -      <version>${project.version}</version> -    </dependency> - -    <dependency> -      <groupId>${project.groupId}</groupId> -      <artifactId>pulsar-common</artifactId> -      <version>${project.version}</version> -    </dependency> - -    <dependency> -      <groupId>${project.groupId}</groupId> -      <artifactId>pulsar-client-original</artifactId> -      <version>${project.version}</version> -    </dependency> - -    <dependency> -      <groupId>${project.groupId}</groupId> -      <artifactId>managed-ledger</artifactId> -      <version>${project.parent.version}</version> -      <scope>test</scope> -    </dependency> - -    <dependency> -      <groupId>${project.groupId}</groupId> -      <artifactId>pulsar-docs-tools</artifactId> -      <version>${project.version}</version> -      <exclusions> -        <exclusion> -          <groupId>io.swagger</groupId> -          <artifactId>*</artifactId> -        </exclusion> -      </exclusions> -    </dependency> - -    <dependency> -      <groupId>org.apache.commons</groupId> -      <artifactId>commons-lang3</artifactId> -    </dependency> - -    <dependency> -      <groupId>org.glassfish.jersey.containers</groupId> -      <artifactId>jersey-container-servlet-core</artifactId> -    </dependency> - -    <dependency> -      <groupId>org.glassfish.jersey.containers</groupId> -      <artifactId>jersey-container-servlet</artifactId> -    </dependency> - -    <dependency> -      <groupId>org.glassfish.jersey.inject</groupId> -      <artifactId>jersey-hk2</artifactId> -    </dependency> - -    <dependency> -      <groupId>com.google.code.gson</groupId> -      <artifactId>gson</artifactId> -    </dependency> - -    <dependency> -      <groupId>io.swagger</groupId> -      <artifactId>swagger-core</artifactId> -      <scope>provided</scope> -    </dependency> - -    <dependency> -      <groupId>com.fasterxml.jackson.jaxrs</groupId> -      <artifactId>jackson-jaxrs-json-provider</artifactId> -    </dependency> - -		<!-- To write basic websockets against --> -    <dependency> -      <groupId>org.eclipse.jetty.websocket</groupId> -      <artifactId>websocket-api</artifactId> -      <version>${jetty.version}</version> -    </dependency> - -		<!-- To run websockets in embedded server --> -    <dependency> -      <groupId>org.eclipse.jetty.websocket</groupId> -      <artifactId>websocket-server</artifactId> -      <version>${jetty.version}</version> -    </dependency> -		<!-- To run javax.websocket client --> -    <dependency> -      <groupId>org.eclipse.jetty.websocket</groupId> -      <artifactId>javax-websocket-client-impl</artifactId> -      <version>${jetty.version}</version> -    </dependency> -    <dependency> -      <groupId>org.eclipse.jetty</groupId> -      <artifactId>jetty-servlets</artifactId> -      <version>${jetty.version}</version> -    </dependency> -    <dependency> -      <groupId>org.hdrhistogram</groupId> -      <artifactId>HdrHistogram</artifactId> -    </dependency> - -  </dependencies> - -  <build> -    <plugins> -      <plugin> -        <groupId>org.gaul</groupId> -        <artifactId>modernizer-maven-plugin</artifactId> -        <configuration> -          <failOnViolations>true</failOnViolations> -          <javaVersion>8</javaVersion> -        </configuration> -        <executions> -          <execution> -            <id>modernizer</id> -            <phase>verify</phase> -            <goals> -              <goal>modernizer</goal> -            </goals> -          </execution> -        </executions> -      </plugin> - -      <plugin> -        <groupId>com.github.spotbugs</groupId> -        <artifactId>spotbugs-maven-plugin</artifactId> -        <version>${spotbugs-maven-plugin.version}</version> -        <configuration> -          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile> -        </configuration> -        <executions> -          <execution> -            <id>check</id> -            <phase>verify</phase> -            <goals> -              <goal>check</goal> -            </goals> -          </execution> -        </executions> -      </plugin> - -      <plugin> -        <groupId>org.apache.maven.plugins</groupId> -        <artifactId>maven-checkstyle-plugin</artifactId> -        <executions> -          <execution> -            <id>checkstyle</id> -            <phase>verify</phase> -            <goals> -              <goal>check</goal> -            </goals> -          </execution> -        </executions> -      </plugin> -    </plugins> -  </build> -</project> +<!-- + +    Licensed to the Apache Software Foundation (ASF) under one +    or more contributor license agreements.  See the NOTICE file +    distributed with this work for additional information +    regarding copyright ownership.  The ASF licenses this file +    to you under the Apache License, Version 2.0 (the +    "License"); you may not use this file except in compliance +    with the License.  You may obtain a copy of the License at + +      http://www.apache.org/licenses/LICENSE-2.0 + +    Unless required by applicable law or agreed to in writing, +    software distributed under the License is distributed on an +    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY +    KIND, either express or implied.  See the License for the +    specific language governing permissions and limitations +    under the License. + +--> +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" +  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> +  <modelVersion>4.0.0</modelVersion> + +  <parent> +    <groupId>org.apache.pulsar</groupId> +    <artifactId>pulsar</artifactId> +    <version>4.1.2</version> +  </parent> + +  <artifactId>pulsar-websocket</artifactId> +  <name>Pulsar WebSocket</name> + +  <dependencies> +    <dependency> +      <groupId>${project.groupId}</groupId> +      <artifactId>pulsar-broker-common</artifactId> +      <version>${project.version}</version> +    </dependency> + +    <dependency> +      <groupId>${project.groupId}</groupId> +      <artifactId>pulsar-common</artifactId> +      <version>${project.version}</version> +    </dependency> + +    <dependency> +      <groupId>${project.groupId}</groupId> +      <artifactId>pulsar-client-original</artifactId> +      <version>${project.version}</version> +    </dependency> + +    <dependency> +      <groupId>${project.groupId}</groupId> +      <artifactId>managed-ledger</artifactId> +      <version>${project.parent.version}</version> +      <scope>test</scope> +    </dependency> + +    <dependency> +      <groupId>${project.groupId}</groupId> +      <artifactId>pulsar-docs-tools</artifactId> +      <version>${project.version}</version> +      <exclusions> +        <exclusion> +          <groupId>io.swagger</groupId> +          <artifactId>*</artifactId> +        </exclusion> +      </exclusions> +    </dependency> + +    <dependency> +      <groupId>org.apache.commons</groupId> +      <artifactId>commons-lang3</artifactId> +    </dependency> + +    <dependency> +      <groupId>org.glassfish.jersey.containers</groupId> +      <artifactId>jersey-container-servlet-core</artifactId> +    </dependency> + +    <dependency> +      <groupId>org.glassfish.jersey.containers</groupId> +      <artifactId>jersey-container-servlet</artifactId> +    </dependency> + +    <dependency> +      <groupId>org.glassfish.jersey.inject</groupId> +      <artifactId>jersey-hk2</artifactId> +    </dependency> + +    <dependency> +      <groupId>com.google.code.gson</groupId> +      <artifactId>gson</artifactId> +    </dependency> + +    <dependency> +      <groupId>io.swagger</groupId> +      <artifactId>swagger-core</artifactId> +      <scope>provided</scope> +    </dependency> + +    <dependency> +      <groupId>com.fasterxml.jackson.jaxrs</groupId> +      <artifactId>jackson-jaxrs-json-provider</artifactId> +    </dependency> + +		<!-- To write basic websockets against --> +    <dependency> +      <groupId>org.eclipse.jetty.websocket</groupId> +      <artifactId>websocket-api</artifactId> +      <version>${jetty.version}</version> +    </dependency> + +		<!-- To run websockets in embedded server --> +    <dependency> +      <groupId>org.eclipse.jetty.websocket</groupId> +      <artifactId>websocket-server</artifactId> +      <version>${jetty.version}</version> +    </dependency> +		<!-- To run javax.websocket client --> +    <dependency> +      <groupId>org.eclipse.jetty.websocket</groupId> +      <artifactId>javax-websocket-client-impl</artifactId> +      <version>${jetty.version}</version> +    </dependency> +    <dependency> +      <groupId>org.eclipse.jetty</groupId> +      <artifactId>jetty-servlets</artifactId> +      <version>${jetty.version}</version> +    </dependency> +    <dependency> +      <groupId>org.hdrhistogram</groupId> +      <artifactId>HdrHistogram</artifactId> +    </dependency> + +  </dependencies> + +  <build> +    <plugins> +      <plugin> +        <groupId>org.gaul</groupId> +        <artifactId>modernizer-maven-plugin</artifactId> +        <configuration> +          <failOnViolations>true</failOnViolations> +          <javaVersion>8</javaVersion> +        </configuration> +        <executions> +          <execution> +            <id>modernizer</id> +            <phase>verify</phase> +            <goals> +              <goal>modernizer</goal> +            </goals> +          </execution> +        </executions> +      </plugin> + +      <plugin> +        <groupId>com.github.spotbugs</groupId> +        <artifactId>spotbugs-maven-plugin</artifactId> +        <version>${spotbugs-maven-plugin.version}</version> +        <configuration> +          <excludeFilterFile>${basedir}/src/main/resources/findbugsExclude.xml</excludeFilterFile> +        </configuration> +        <executions> +          <execution> +            <id>check</id> +            <phase>verify</phase> +            <goals> +              <goal>check</goal> +            </goals> +          </execution> +        </executions> +      </plugin> + +      <plugin> +        <groupId>org.apache.maven.plugins</groupId> +        <artifactId>maven-checkstyle-plugin</artifactId> +        <executions> +          <execution> +            <id>checkstyle</id> +            <phase>verify</phase> +            <goals> +              <goal>check</goal> +            </goals> +          </execution> +        </executions> +      </plugin> +    </plugins> +  </build> +</project> diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/AbstractWebSocketHandler.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/AbstractWebSocketHandler.java index b6ed27c87b..bb48c54b4e 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/AbstractWebSocketHandler.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/AbstractWebSocketHandler.java @@ -1,307 +1,307 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static com.google.common.base.Preconditions.checkArgument; -import com.fasterxml.jackson.databind.ObjectReader; -import com.fasterxml.jackson.databind.ObjectWriter; -import com.google.common.annotations.VisibleForTesting; -import com.google.common.base.Splitter; -import java.io.Closeable; -import java.io.IOException; -import java.nio.ByteBuffer; -import java.nio.charset.StandardCharsets; -import java.util.List; -import java.util.Map; -import java.util.TreeMap; -import java.util.concurrent.ScheduledFuture; -import java.util.concurrent.TimeUnit; -import javax.servlet.http.HttpServletRequest; -import javax.servlet.http.HttpServletResponse; -import org.apache.commons.lang3.StringUtils; -import org.apache.pulsar.broker.authentication.AuthenticationDataHttps; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.authentication.AuthenticationState; -import org.apache.pulsar.client.api.PulsarClientException.AuthenticationException; -import org.apache.pulsar.client.api.PulsarClientException.AuthorizationException; -import org.apache.pulsar.client.api.PulsarClientException.ConsumerBusyException; -import org.apache.pulsar.client.api.PulsarClientException.IncompatibleSchemaException; -import org.apache.pulsar.client.api.PulsarClientException.NotFoundException; -import org.apache.pulsar.client.api.PulsarClientException.ProducerBlockedQuotaExceededError; -import org.apache.pulsar.client.api.PulsarClientException.ProducerBlockedQuotaExceededException; -import org.apache.pulsar.client.api.PulsarClientException.ProducerBusyException; -import org.apache.pulsar.client.api.PulsarClientException.ProducerFencedException; -import org.apache.pulsar.client.api.PulsarClientException.TimeoutException; -import org.apache.pulsar.client.api.PulsarClientException.TooManyRequestsException; -import org.apache.pulsar.client.api.PulsarClientException.TopicDoesNotExistException; -import org.apache.pulsar.client.api.PulsarClientException.TopicTerminatedException; -import org.apache.pulsar.common.naming.NamespaceName; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.util.Codec; -import org.apache.pulsar.common.util.ObjectMapperFactory; -import org.apache.pulsar.websocket.data.ConsumerCommand; -import org.eclipse.jetty.websocket.api.Session; -import org.eclipse.jetty.websocket.api.WebSocketAdapter; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -public abstract class AbstractWebSocketHandler extends WebSocketAdapter implements Closeable { - -    protected final WebSocketService service; -    protected final HttpServletRequest request; - -    protected TopicName topic; -    protected final Map<String, String> queryParams; -    private static final String PULSAR_AUTH_METHOD_NAME = "X-Pulsar-Auth-Method-Name"; -    protected final ObjectReader consumerCommandReader = -            ObjectMapperFactory.getMapper().reader().forType(ConsumerCommand.class); - -    private ScheduledFuture<?> pingFuture; - -    public AbstractWebSocketHandler(WebSocketService service, -                                    HttpServletRequest request, -                                    ServletUpgradeResponse response) { -        this.service = service; -        this.request = new WebSocketHttpServletRequestWrapper(request); - -        this.queryParams = new TreeMap<>(); -        request.getParameterMap().forEach((key, values) -> { -            queryParams.put(key, values[0]); -        }); -        extractTopicName(request); -    } - -    protected boolean checkAuth(ServletUpgradeResponse response) { -        String authRole = "<none>"; -        String authMethodName = request.getHeader(PULSAR_AUTH_METHOD_NAME); -        AuthenticationState authenticationState = null; -        if (service.isAuthenticationEnabled()) { -            try { -                if (authMethodName != null -                        && service.getAuthenticationService().getAuthenticationProvider(authMethodName) != null) { -                    authenticationState = service.getAuthenticationService() -                            .getAuthenticationProvider(authMethodName).newHttpAuthState(request); -                } -                if (authenticationState != null) { -                    authRole = service.getAuthenticationService() -                            .authenticateHttpRequest(request, authenticationState.getAuthDataSource()); -                } else { -                    authRole = service.getAuthenticationService().authenticateHttpRequest(request); -                } -                log.info("[{}:{}] Authenticated WebSocket client {} on topic {}", request.getRemoteAddr(), -                        request.getRemotePort(), authRole, topic); - -            } catch (javax.naming.AuthenticationException e) { -                log.warn("[{}:{}] Failed to authenticated WebSocket client {} on topic {}: {}", request.getRemoteAddr(), -                        request.getRemotePort(), authRole, topic, e.getMessage()); -                try { -                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Failed to authenticate"); -                } catch (IOException e1) { -                    log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), -                            e1.getMessage(), e1); -                } -                return false; -            } -        } - -        if (service.isAuthorizationEnabled()) { -            AuthenticationDataSource authenticationData; -            if (authenticationState != null) { -                authenticationData = authenticationState.getAuthDataSource(); -            } else { -                authenticationData = new AuthenticationDataHttps(request); -            } -            try { -                if (!isAuthorized(authRole, authenticationData)) { -                    log.warn("[{}:{}] WebSocket Client [{}] is not authorized on topic {}", request.getRemoteAddr(), -                            request.getRemotePort(), authRole, topic); -                    response.sendError(HttpServletResponse.SC_FORBIDDEN, "Not authorized"); -                    return false; -                } -            } catch (Exception e) { -                log.warn("[{}:{}] Got an exception when authorizing WebSocket client {} on topic {} on: {}", -                        request.getRemoteAddr(), request.getRemotePort(), authRole, topic, e.getMessage()); -                try { -                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Server error"); -                } catch (IOException e1) { -                    log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), -                            e1.getMessage(), e1); -                } -                return false; -            } -        } -        return true; -    } - -    protected static int getErrorCode(Exception e) { -        if (e instanceof IllegalArgumentException) { -            return HttpServletResponse.SC_BAD_REQUEST; -        } else if (e instanceof AuthenticationException) { -            return HttpServletResponse.SC_UNAUTHORIZED; -        } else if (e instanceof AuthorizationException) { -            return HttpServletResponse.SC_FORBIDDEN; -        } else if (e instanceof NotFoundException || e instanceof TopicDoesNotExistException) { -            return HttpServletResponse.SC_NOT_FOUND; -        } else if (e instanceof ProducerBusyException || e instanceof ConsumerBusyException -                || e instanceof ProducerFencedException || e instanceof IncompatibleSchemaException) { -            return HttpServletResponse.SC_CONFLICT; -        } else if (e instanceof TooManyRequestsException) { -            return 429; // Too Many Requests -        } else if (e instanceof ProducerBlockedQuotaExceededError || e instanceof ProducerBlockedQuotaExceededException -                || e instanceof TopicTerminatedException) { -            return HttpServletResponse.SC_SERVICE_UNAVAILABLE; -        } else if (e instanceof TimeoutException) { -            return HttpServletResponse.SC_GATEWAY_TIMEOUT; -        } else { -            return HttpServletResponse.SC_INTERNAL_SERVER_ERROR; -        } -    } - -    protected static String getErrorMessage(Exception e) { -        if (e instanceof IllegalArgumentException) { -            return "Invalid query params: " + e.getMessage(); -        } else { -            return "Failed to create producer/consumer: " + e.getMessage(); -        } -    } - -    private void closePingFuture() { -        if (pingFuture != null && !pingFuture.isDone()) { -            pingFuture.cancel(true); -        } -    } - -    @Override -    public void onWebSocketConnect(Session session) { -        super.onWebSocketConnect(session); -        int webSocketPingDurationSeconds = service.getConfig().getWebSocketPingDurationSeconds(); -        if (webSocketPingDurationSeconds > 0) { -            pingFuture = service.getExecutor().scheduleAtFixedRate(() -> { -                try { -                    session.getRemote().sendPing(ByteBuffer.wrap("PING".getBytes(StandardCharsets.UTF_8))); -                } catch (IOException e) { -                    log.warn("[{}] WebSocket send ping", getSession().getRemoteAddress(), e); -                } -            }, webSocketPingDurationSeconds, webSocketPingDurationSeconds, TimeUnit.SECONDS); -        } -        log.info("[{}] New WebSocket session on topic {}", session.getRemoteAddress(), topic); -    } - -    @Override -    public void onWebSocketError(Throwable cause) { -        super.onWebSocketError(cause); -        log.info("[{}] WebSocket error on topic {} : {}", getSession().getRemoteAddress(), topic, cause.getMessage()); -        try { -            closePingFuture(); -            close(); -        } catch (IOException e) { -            log.error("Failed in closing WebSocket session for topic {} with error: {}", topic, e.getMessage()); -        } -    } - -    @Override -    public void onWebSocketClose(int statusCode, String reason) { -        log.info("[{}] Closed WebSocket session on topic {}. status: {} - reason: {}", getSession().getRemoteAddress(), -                topic, statusCode, reason); -        try { -            closePingFuture(); -            close(); -        } catch (IOException e) { -            log.warn("[{}] Failed to close handler for topic {}. ", getSession().getRemoteAddress(), topic, e); -        } -    } - -    public void close(WebSocketError error) { -        log.warn("[{}] Closing WebSocket session for topic {} - code: [{}], reason: [{}]", -                getSession().getRemoteAddress(), topic, error.getCode(), error.getDescription()); -        getSession().close(error.getCode(), error.getDescription()); -    } - -    public void close(WebSocketError error, String message) { -        log.warn("[{}] Closing WebSocket session for topic {} - code: [{}], reason: [{}]", -                getSession().getRemoteAddress(), topic, error.getCode(), error.getDescription() + ": " + message); -        getSession().close(error.getCode(), error.getDescription() + ": " + message); -    } - -    protected String checkAuthentication() { -        return null; -    } - -    protected void extractTopicName(HttpServletRequest request) { -        String uri = request.getRequestURI(); -        List<String> parts = Splitter.on("/").splitToList(uri); - -        // V1 Format must be like : -        // /ws/producer/persistent/my-property/my-cluster/my-ns/my-topic -        // or -        // /ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription -        // or -        // /ws/reader/persistent/my-property/my-cluster/my-ns/my-topic - -        // V2 Format must be like : -        // /ws/v2/producer/persistent/my-property/my-ns/my-topic -        // or -        // /ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription -        // or -        // /ws/v2/reader/persistent/my-property/my-ns/my-topic - -        checkArgument(parts.size() >= 8, "Invalid topic name format"); -        checkArgument(parts.get(1).equals("ws")); - -        final boolean isV2Format = parts.get(2).equals("v2"); -        final int domainIndex = isV2Format ? 4 : 3; -        checkArgument(parts.get(domainIndex).equals("persistent") -                || parts.get(domainIndex).equals("non-persistent")); - -        final String domain = parts.get(domainIndex); -        final NamespaceName namespace = isV2Format ? NamespaceName.get(parts.get(5), parts.get(6)) : -                NamespaceName.get(parts.get(4), parts.get(5), parts.get(6)); - -        // The topic name which contains slashes is also split, so it needs to be jointed -        int startPosition = 7; -        boolean isConsumer = "consumer".equals(parts.get(2)) || "consumer".equals(parts.get(3)); -        int endPosition = isConsumer ? parts.size() - 1 : parts.size(); -        StringBuilder topicName = new StringBuilder(parts.get(startPosition)); -        while (++startPosition < endPosition) { -            if (StringUtils.isEmpty(parts.get(startPosition))) { -               continue; -            } -            topicName.append("/").append(parts.get(startPosition)); -        } -        final String name = Codec.decode(topicName.toString()); - -        topic = TopicName.get(domain, namespace, name); -    } - -    @VisibleForTesting -    public ScheduledFuture<?> getPingFuture() { -        return pingFuture; -    } - - -    protected abstract Boolean isAuthorized(String authRole, -                                            AuthenticationDataSource authenticationData) throws Exception; - -    private static final Logger log = LoggerFactory.getLogger(AbstractWebSocketHandler.class); - -    protected ObjectWriter objectWriter() { -        return ObjectMapperFactory.getMapper().writer(); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static com.google.common.base.Preconditions.checkArgument; +import com.fasterxml.jackson.databind.ObjectReader; +import com.fasterxml.jackson.databind.ObjectWriter; +import com.google.common.annotations.VisibleForTesting; +import com.google.common.base.Splitter; +import java.io.Closeable; +import java.io.IOException; +import java.nio.ByteBuffer; +import java.nio.charset.StandardCharsets; +import java.util.List; +import java.util.Map; +import java.util.TreeMap; +import java.util.concurrent.ScheduledFuture; +import java.util.concurrent.TimeUnit; +import javax.servlet.http.HttpServletRequest; +import javax.servlet.http.HttpServletResponse; +import org.apache.commons.lang3.StringUtils; +import org.apache.pulsar.broker.authentication.AuthenticationDataHttps; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.authentication.AuthenticationState; +import org.apache.pulsar.client.api.PulsarClientException.AuthenticationException; +import org.apache.pulsar.client.api.PulsarClientException.AuthorizationException; +import org.apache.pulsar.client.api.PulsarClientException.ConsumerBusyException; +import org.apache.pulsar.client.api.PulsarClientException.IncompatibleSchemaException; +import org.apache.pulsar.client.api.PulsarClientException.NotFoundException; +import org.apache.pulsar.client.api.PulsarClientException.ProducerBlockedQuotaExceededError; +import org.apache.pulsar.client.api.PulsarClientException.ProducerBlockedQuotaExceededException; +import org.apache.pulsar.client.api.PulsarClientException.ProducerBusyException; +import org.apache.pulsar.client.api.PulsarClientException.ProducerFencedException; +import org.apache.pulsar.client.api.PulsarClientException.TimeoutException; +import org.apache.pulsar.client.api.PulsarClientException.TooManyRequestsException; +import org.apache.pulsar.client.api.PulsarClientException.TopicDoesNotExistException; +import org.apache.pulsar.client.api.PulsarClientException.TopicTerminatedException; +import org.apache.pulsar.common.naming.NamespaceName; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.util.Codec; +import org.apache.pulsar.common.util.ObjectMapperFactory; +import org.apache.pulsar.websocket.data.ConsumerCommand; +import org.eclipse.jetty.websocket.api.Session; +import org.eclipse.jetty.websocket.api.WebSocketAdapter; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +public abstract class AbstractWebSocketHandler extends WebSocketAdapter implements Closeable { + +    protected final WebSocketService service; +    protected final HttpServletRequest request; + +    protected TopicName topic; +    protected final Map<String, String> queryParams; +    private static final String PULSAR_AUTH_METHOD_NAME = "X-Pulsar-Auth-Method-Name"; +    protected final ObjectReader consumerCommandReader = +            ObjectMapperFactory.getMapper().reader().forType(ConsumerCommand.class); + +    private ScheduledFuture<?> pingFuture; + +    public AbstractWebSocketHandler(WebSocketService service, +                                    HttpServletRequest request, +                                    ServletUpgradeResponse response) { +        this.service = service; +        this.request = new WebSocketHttpServletRequestWrapper(request); + +        this.queryParams = new TreeMap<>(); +        request.getParameterMap().forEach((key, values) -> { +            queryParams.put(key, values[0]); +        }); +        extractTopicName(request); +    } + +    protected boolean checkAuth(ServletUpgradeResponse response) { +        String authRole = "<none>"; +        String authMethodName = request.getHeader(PULSAR_AUTH_METHOD_NAME); +        AuthenticationState authenticationState = null; +        if (service.isAuthenticationEnabled()) { +            try { +                if (authMethodName != null +                        && service.getAuthenticationService().getAuthenticationProvider(authMethodName) != null) { +                    authenticationState = service.getAuthenticationService() +                            .getAuthenticationProvider(authMethodName).newHttpAuthState(request); +                } +                if (authenticationState != null) { +                    authRole = service.getAuthenticationService() +                            .authenticateHttpRequest(request, authenticationState.getAuthDataSource()); +                } else { +                    authRole = service.getAuthenticationService().authenticateHttpRequest(request); +                } +                log.info("[{}:{}] Authenticated WebSocket client {} on topic {}", request.getRemoteAddr(), +                        request.getRemotePort(), authRole, topic); + +            } catch (javax.naming.AuthenticationException e) { +                log.warn("[{}:{}] Failed to authenticated WebSocket client {} on topic {}: {}", request.getRemoteAddr(), +                        request.getRemotePort(), authRole, topic, e.getMessage()); +                try { +                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Failed to authenticate"); +                } catch (IOException e1) { +                    log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), +                            e1.getMessage(), e1); +                } +                return false; +            } +        } + +        if (service.isAuthorizationEnabled()) { +            AuthenticationDataSource authenticationData; +            if (authenticationState != null) { +                authenticationData = authenticationState.getAuthDataSource(); +            } else { +                authenticationData = new AuthenticationDataHttps(request); +            } +            try { +                if (!isAuthorized(authRole, authenticationData)) { +                    log.warn("[{}:{}] WebSocket Client [{}] is not authorized on topic {}", request.getRemoteAddr(), +                            request.getRemotePort(), authRole, topic); +                    response.sendError(HttpServletResponse.SC_FORBIDDEN, "Not authorized"); +                    return false; +                } +            } catch (Exception e) { +                log.warn("[{}:{}] Got an exception when authorizing WebSocket client {} on topic {} on: {}", +                        request.getRemoteAddr(), request.getRemotePort(), authRole, topic, e.getMessage()); +                try { +                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Server error"); +                } catch (IOException e1) { +                    log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), +                            e1.getMessage(), e1); +                } +                return false; +            } +        } +        return true; +    } + +    protected static int getErrorCode(Exception e) { +        if (e instanceof IllegalArgumentException) { +            return HttpServletResponse.SC_BAD_REQUEST; +        } else if (e instanceof AuthenticationException) { +            return HttpServletResponse.SC_UNAUTHORIZED; +        } else if (e instanceof AuthorizationException) { +            return HttpServletResponse.SC_FORBIDDEN; +        } else if (e instanceof NotFoundException || e instanceof TopicDoesNotExistException) { +            return HttpServletResponse.SC_NOT_FOUND; +        } else if (e instanceof ProducerBusyException || e instanceof ConsumerBusyException +                || e instanceof ProducerFencedException || e instanceof IncompatibleSchemaException) { +            return HttpServletResponse.SC_CONFLICT; +        } else if (e instanceof TooManyRequestsException) { +            return 429; // Too Many Requests +        } else if (e instanceof ProducerBlockedQuotaExceededError || e instanceof ProducerBlockedQuotaExceededException +                || e instanceof TopicTerminatedException) { +            return HttpServletResponse.SC_SERVICE_UNAVAILABLE; +        } else if (e instanceof TimeoutException) { +            return HttpServletResponse.SC_GATEWAY_TIMEOUT; +        } else { +            return HttpServletResponse.SC_INTERNAL_SERVER_ERROR; +        } +    } + +    protected static String getErrorMessage(Exception e) { +        if (e instanceof IllegalArgumentException) { +            return "Invalid query params: " + e.getMessage(); +        } else { +            return "Failed to create producer/consumer: " + e.getMessage(); +        } +    } + +    private void closePingFuture() { +        if (pingFuture != null && !pingFuture.isDone()) { +            pingFuture.cancel(true); +        } +    } + +    @Override +    public void onWebSocketConnect(Session session) { +        super.onWebSocketConnect(session); +        int webSocketPingDurationSeconds = service.getConfig().getWebSocketPingDurationSeconds(); +        if (webSocketPingDurationSeconds > 0) { +            pingFuture = service.getExecutor().scheduleAtFixedRate(() -> { +                try { +                    session.getRemote().sendPing(ByteBuffer.wrap("PING".getBytes(StandardCharsets.UTF_8))); +                } catch (IOException e) { +                    log.warn("[{}] WebSocket send ping", getSession().getRemoteAddress(), e); +                } +            }, webSocketPingDurationSeconds, webSocketPingDurationSeconds, TimeUnit.SECONDS); +        } +        log.info("[{}] New WebSocket session on topic {}", session.getRemoteAddress(), topic); +    } + +    @Override +    public void onWebSocketError(Throwable cause) { +        super.onWebSocketError(cause); +        log.info("[{}] WebSocket error on topic {} : {}", getSession().getRemoteAddress(), topic, cause.getMessage()); +        try { +            closePingFuture(); +            close(); +        } catch (IOException e) { +            log.error("Failed in closing WebSocket session for topic {} with error: {}", topic, e.getMessage()); +        } +    } + +    @Override +    public void onWebSocketClose(int statusCode, String reason) { +        log.info("[{}] Closed WebSocket session on topic {}. status: {} - reason: {}", getSession().getRemoteAddress(), +                topic, statusCode, reason); +        try { +            closePingFuture(); +            close(); +        } catch (IOException e) { +            log.warn("[{}] Failed to close handler for topic {}. ", getSession().getRemoteAddress(), topic, e); +        } +    } + +    public void close(WebSocketError error) { +        log.warn("[{}] Closing WebSocket session for topic {} - code: [{}], reason: [{}]", +                getSession().getRemoteAddress(), topic, error.getCode(), error.getDescription()); +        getSession().close(error.getCode(), error.getDescription()); +    } + +    public void close(WebSocketError error, String message) { +        log.warn("[{}] Closing WebSocket session for topic {} - code: [{}], reason: [{}]", +                getSession().getRemoteAddress(), topic, error.getCode(), error.getDescription() + ": " + message); +        getSession().close(error.getCode(), error.getDescription() + ": " + message); +    } + +    protected String checkAuthentication() { +        return null; +    } + +    protected void extractTopicName(HttpServletRequest request) { +        String uri = request.getRequestURI(); +        List<String> parts = Splitter.on("/").splitToList(uri); + +        // V1 Format must be like : +        // /ws/producer/persistent/my-property/my-cluster/my-ns/my-topic +        // or +        // /ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription +        // or +        // /ws/reader/persistent/my-property/my-cluster/my-ns/my-topic + +        // V2 Format must be like : +        // /ws/v2/producer/persistent/my-property/my-ns/my-topic +        // or +        // /ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription +        // or +        // /ws/v2/reader/persistent/my-property/my-ns/my-topic + +        checkArgument(parts.size() >= 8, "Invalid topic name format"); +        checkArgument(parts.get(1).equals("ws")); + +        final boolean isV2Format = parts.get(2).equals("v2"); +        final int domainIndex = isV2Format ? 4 : 3; +        checkArgument(parts.get(domainIndex).equals("persistent") +                || parts.get(domainIndex).equals("non-persistent")); + +        final String domain = parts.get(domainIndex); +        final NamespaceName namespace = isV2Format ? NamespaceName.get(parts.get(5), parts.get(6)) : +                NamespaceName.get(parts.get(4), parts.get(5), parts.get(6)); + +        // The topic name which contains slashes is also split, so it needs to be jointed +        int startPosition = 7; +        boolean isConsumer = "consumer".equals(parts.get(2)) || "consumer".equals(parts.get(3)); +        int endPosition = isConsumer ? parts.size() - 1 : parts.size(); +        StringBuilder topicName = new StringBuilder(parts.get(startPosition)); +        while (++startPosition < endPosition) { +            if (StringUtils.isEmpty(parts.get(startPosition))) { +               continue; +            } +            topicName.append("/").append(parts.get(startPosition)); +        } +        final String name = Codec.decode(topicName.toString()); + +        topic = TopicName.get(domain, namespace, name); +    } + +    @VisibleForTesting +    public ScheduledFuture<?> getPingFuture() { +        return pingFuture; +    } + + +    protected abstract Boolean isAuthorized(String authRole, +                                            AuthenticationDataSource authenticationData) throws Exception; + +    private static final Logger log = LoggerFactory.getLogger(AbstractWebSocketHandler.class); + +    protected ObjectWriter objectWriter() { +        return ObjectMapperFactory.getMapper().writer(); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ConsumerHandler.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ConsumerHandler.java index b93c4b2151..767cbd5b37 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ConsumerHandler.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ConsumerHandler.java @@ -1,531 +1,531 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static com.google.common.base.Preconditions.checkArgument; -import static java.util.concurrent.TimeUnit.SECONDS; -import com.fasterxml.jackson.core.JsonProcessingException; -import com.google.common.base.Enums; -import com.google.common.base.Splitter; -import com.google.common.cache.Cache; -import com.google.common.cache.CacheBuilder; -import java.io.IOException; -import java.util.Base64; -import java.util.List; -import java.util.concurrent.TimeUnit; -import java.util.concurrent.TimeoutException; -import java.util.concurrent.atomic.AtomicInteger; -import java.util.concurrent.atomic.AtomicLongFieldUpdater; -import java.util.concurrent.atomic.LongAdder; -import javax.servlet.http.HttpServletRequest; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.authentication.AuthenticationDataSubscription; -import org.apache.pulsar.client.api.Consumer; -import org.apache.pulsar.client.api.ConsumerBuilder; -import org.apache.pulsar.client.api.ConsumerCryptoFailureAction; -import org.apache.pulsar.client.api.DeadLetterPolicy; -import org.apache.pulsar.client.api.MessageId; -import org.apache.pulsar.client.api.PulsarClient; -import org.apache.pulsar.client.api.PulsarClientException; -import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException; -import org.apache.pulsar.client.api.SubscriptionInitialPosition; -import org.apache.pulsar.client.api.SubscriptionMode; -import org.apache.pulsar.client.api.SubscriptionType; -import org.apache.pulsar.client.impl.ConsumerBuilderImpl; -import org.apache.pulsar.common.policies.data.TopicOperation; -import org.apache.pulsar.common.util.Codec; -import org.apache.pulsar.common.util.DateFormatter; -import org.apache.pulsar.websocket.data.ConsumerCommand; -import org.apache.pulsar.websocket.data.ConsumerMessage; -import org.apache.pulsar.websocket.data.EndOfTopicResponse; -import org.eclipse.jetty.websocket.api.Session; -import org.eclipse.jetty.websocket.api.WriteCallback; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * - * WebSocket end-point url handler to handle incoming receive and acknowledge requests. - * <p> - * <b>receive:</b> socket-proxy keeps pushing messages to client by writing into session. However, it dispatches N - * messages at any point and after that on acknowledgement from client it dispatches further messages. <br/> - * <b>acknowledge:</b> it accepts acknowledgement for a given message from client and send it to broker. and for next - * action it notifies receive to dispatch further messages to client. - * </P> - * - */ -public class ConsumerHandler extends AbstractWebSocketHandler { - -    protected String subscription = null; -    private SubscriptionType subscriptionType; -    private SubscriptionMode subscriptionMode; -    private Consumer<byte[]> consumer; - -    private int maxPendingMessages = 0; -    private final AtomicInteger pendingMessages = new AtomicInteger(); -    private final boolean pullMode; - -    private final LongAdder numMsgsDelivered; -    private final LongAdder numBytesDelivered; -    private final LongAdder numMsgsAcked; -    private volatile long msgDeliveredCounter = 0; - -    protected String topicsPattern; - -    protected String topics; -    private static final AtomicLongFieldUpdater<ConsumerHandler> MSG_DELIVERED_COUNTER_UPDATER = -            AtomicLongFieldUpdater.newUpdater(ConsumerHandler.class, "msgDeliveredCounter"); - -    // Make sure use the same BatchMessageIdImpl to acknowledge the batch message, otherwise the BatchMessageAcker -    // of the BatchMessageIdImpl will not complete. -    private Cache<String, MessageId> messageIdCache = CacheBuilder.newBuilder() -            .expireAfterWrite(1, TimeUnit.HOURS) -            .build(); - -    public ConsumerHandler(WebSocketService service, HttpServletRequest request, ServletUpgradeResponse response) { -        super(service, request, response); - -        ConsumerBuilderImpl<byte[]> builder; - -        this.numMsgsDelivered = new LongAdder(); -        this.numBytesDelivered = new LongAdder(); -        this.numMsgsAcked = new LongAdder(); -        this.pullMode = Boolean.parseBoolean(queryParams.get("pullMode")); - -        try { -            // checkAuth() and getConsumerConfiguration() should be called after assigning a value to this.subscription -            this.subscription = extractSubscription(request); -            builder = (ConsumerBuilderImpl<byte[]>) getConsumerConfiguration(service.getPulsarClient()); - -            if (!this.pullMode) { -                this.maxPendingMessages = (builder.getConf().getReceiverQueueSize() == 0) ? 1 -                        : builder.getConf().getReceiverQueueSize(); -            } -            this.subscriptionType = builder.getConf().getSubscriptionType(); -            this.subscriptionMode = builder.getConf().getSubscriptionMode(); - -            if (!checkAuth(response)) { -                return; -            } - -            if (topicsPattern != null) { -                this.consumer = builder.topicsPattern(topicsPattern).subscriptionName(subscription).subscribe(); -            } else if (topics != null) { -                this.consumer = builder.topics(Splitter.on(",").splitToList(topics)) -                        .subscriptionName(subscription).subscribe(); -            } else { -                this.consumer = builder.topic(topic.toString()).subscriptionName(subscription).subscribe(); -            } -            if (!this.service.addConsumer(this)) { -                log.warn("[{}:{}] Failed to add consumer handler for topic {}", request.getRemoteAddr(), -                        request.getRemotePort(), topic); -            } -        } catch (Exception e) { -            log.warn("[{}:{}] Failed in creating subscription {} on topic {}", request.getRemoteAddr(), -                    request.getRemotePort(), subscription, topic, e); - -            try { -                response.sendError(getErrorCode(e), getErrorMessage(e)); -            } catch (IOException e1) { -                log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), -                        e1.getMessage(), e1); -            } -        } -    } - -    private void receiveMessage() { -        if (log.isDebugEnabled()) { -            log.debug("[{}:{}] [{}] [{}] Receive next message", -                    request.getRemoteAddr(), request.getRemotePort(), topic, subscription); -        } - -        consumer.receiveAsync().thenAccept(msg -> { -            if (log.isDebugEnabled()) { -                log.debug("[{}] [{}] [{}] Got message {}", getSession().getRemoteAddress(), topic, subscription, -                        msg.getMessageId()); -            } - -            ConsumerMessage dm = new ConsumerMessage(); -            dm.messageId = Base64.getEncoder().encodeToString(msg.getMessageId().toByteArray()); -            dm.payload = Base64.getEncoder().encodeToString(msg.getData()); -            dm.properties = msg.getProperties(); -            dm.publishTime = DateFormatter.format(msg.getPublishTime()); -            dm.redeliveryCount = msg.getRedeliveryCount(); -            dm.encryptionContext = msg.getEncryptionCtx().orElse(null); -            if (msg.getEventTime() != 0) { -                dm.eventTime = DateFormatter.format(msg.getEventTime()); -            } -            if (msg.hasKey()) { -                dm.key = msg.getKey(); -            } -            final long msgSize = msg.getData().length; - -            messageIdCache.put(dm.messageId, msg.getMessageId()); - -            try { -                getSession().getRemote() -                        .sendString(objectWriter().writeValueAsString(dm), -                                new WriteCallback() { -                                    @Override -                                    public void writeFailed(Throwable th) { -                                        log.warn("[{}/{}] Failed to deliver msg to {} {}", consumer.getTopic(), -                                                subscription, -                                                getRemote().getInetSocketAddress().toString(), th.getMessage()); -                                        pendingMessages.decrementAndGet(); -                                        // schedule receive as one of the delivery failed -                                        service.getExecutor().execute(() -> receiveMessage()); -                                    } - -                                    @Override -                                    public void writeSuccess() { -                                        if (log.isDebugEnabled()) { -                                            log.debug("[{}/{}] message is delivered successfully to {} ", -                                                    consumer.getTopic(), -                                                    subscription, getRemote().getInetSocketAddress().toString()); -                                        } -                                        updateDeliverMsgStat(msgSize); -                                    } -                                }); -            } catch (JsonProcessingException e) { -                close(WebSocketError.FailedToSerializeToJSON); -            } - -            int pending = pendingMessages.incrementAndGet(); -            if (pending < maxPendingMessages) { -                // Start next read in a separate thread to avoid recursion -                service.getExecutor().execute(this::receiveMessage); -            } -        }).exceptionally(exception -> { -            if (exception.getCause() instanceof AlreadyClosedException) { -                log.info("[{}/{}] Consumer was closed while receiving msg from broker", consumer.getTopic(), -                        subscription); -            } else { -                log.warn("[{}/{}] Error occurred while consumer handler was delivering msg to {}: {}", -                        consumer.getTopic(), subscription, getRemote().getInetSocketAddress().toString(), -                        exception.getMessage()); -            } -            return null; -        }); -    } - -    @Override -    public void onWebSocketConnect(Session session) { -        super.onWebSocketConnect(session); -        if (!pullMode) { -            receiveMessage(); -        } -    } - -    @Override -    public void onWebSocketText(String message) { -        super.onWebSocketText(message); - -        try { -            ConsumerCommand command = consumerCommandReader.readValue(message); -            if ("permit".equals(command.type)) { -                handlePermit(command); -            } else if ("unsubscribe".equals(command.type)) { -                handleUnsubscribe(command); -            } else if ("negativeAcknowledge".equals(command.type)) { -                handleNack(command); -            } else if ("isEndOfTopic".equals(command.type)) { -                handleEndOfTopic(); -            } else { -                handleAck(command); -            } -        } catch (IOException e) { -            log.warn("Failed to deserialize message id: {}", message, e); -            close(WebSocketError.FailedToDeserializeFromJSON); -        } -    } - -    // Check and notify consumer if reached end of topic. -    private void handleEndOfTopic() { -        if (log.isDebugEnabled()) { -            log.debug("[{}/{}] Received check reach the end of topic request from {} ", consumer.getTopic(), -                    subscription, getRemote().getInetSocketAddress().toString()); -        } -        try { -            String msg = objectWriter().writeValueAsString( -                    new EndOfTopicResponse(consumer.hasReachedEndOfTopic())); -            getSession().getRemote() -            .sendString(msg, new WriteCallback() { -                @Override -                public void writeFailed(Throwable th) { -                    log.warn("[{}/{}] Failed to send end of topic msg to {} due to {}", consumer.getTopic(), -                            subscription, getRemote().getInetSocketAddress().toString(), th.getMessage()); -                } - -                @Override -                public void writeSuccess() { -                    if (log.isDebugEnabled()) { -                        log.debug("[{}/{}] End of topic message is delivered successfully to {} ", -                                consumer.getTopic(), subscription, getRemote().getInetSocketAddress().toString()); -                    } -                } -            }); -        } catch (JsonProcessingException e) { -            log.warn("[{}] Failed to generate end of topic response: {}", consumer.getTopic(), e.getMessage()); -        } catch (Exception e) { -            log.warn("[{}] Failed to send end of topic response: {}", consumer.getTopic(), e.getMessage()); -        } -    } - -    private void handleUnsubscribe(ConsumerCommand command) throws PulsarClientException { -        if (log.isDebugEnabled()) { -            log.debug("[{}/{}] Received unsubscribe request from {} ", consumer.getTopic(), -                    subscription, getRemote().getInetSocketAddress().toString()); -        } -        consumer.unsubscribe(); -    } - -    private void checkResumeReceive() { -        if (!this.pullMode) { -            int pending = pendingMessages.getAndDecrement(); -            if (pending >= maxPendingMessages) { -                // Resume delivery -                receiveMessage(); -            } -        } -    } - -    private void handleAck(ConsumerCommand command) throws IOException { -        // We should have received an ack -        MessageId msgId = MessageId.fromByteArray(Base64.getDecoder().decode(command.messageId)); -        if (log.isDebugEnabled()) { -            log.debug("[{}/{}] Received ack request of message {} from {} ", consumer.getTopic(), -                    subscription, msgId, getRemote().getInetSocketAddress().toString()); -        } - -        MessageId originalMsgId = messageIdCache.asMap().remove(command.messageId); -        if (originalMsgId != null) { -            consumer.acknowledgeAsync(originalMsgId).thenAccept(consumer -> numMsgsAcked.increment()); -        } else { -            consumer.acknowledgeAsync(msgId).thenAccept(consumer -> numMsgsAcked.increment()); -        } - -        checkResumeReceive(); -    } - -    private void handleNack(ConsumerCommand command) throws IOException { -        MessageId msgId = MessageId.fromByteArrayWithTopic(Base64.getDecoder().decode(command.messageId), -            topic.toString()); -        if (log.isDebugEnabled()) { -            log.debug("[{}/{}] Received negative ack request of message {} from {} ", consumer.getTopic(), -                    subscription, msgId, getRemote().getInetSocketAddress().toString()); -        } - -        MessageId originalMsgId = messageIdCache.asMap().remove(command.messageId); -        if (originalMsgId != null) { -            consumer.negativeAcknowledge(originalMsgId); -        } else { -            consumer.negativeAcknowledge(msgId); -        } -        checkResumeReceive(); -    } - -    private void handlePermit(ConsumerCommand command) throws IOException { -        if (log.isDebugEnabled()) { -            log.debug("[{}/{}] Received {} permits request from {} ", consumer.getTopic(), -                    subscription, command.permitMessages, getRemote().getInetSocketAddress().toString()); -        } -        if (command.permitMessages == null) { -            throw new IOException("Missing required permitMessages field for 'permit' command"); -        } -        if (this.pullMode) { -            int pending = pendingMessages.getAndAdd(-command.permitMessages); -            if (pending >= 0) { -                // Resume delivery -                receiveMessage(); -            } -        } -    } - -    @Override -    public void close() throws IOException { -        if (consumer != null) { -            if (!this.service.removeConsumer(this)) { -                log.warn("[{}] Failed to remove consumer handler", consumer.getTopic()); -            } -            consumer.closeAsync().thenAccept(x -> { -                if (log.isDebugEnabled()) { -                    log.debug("[{}] Closed consumer asynchronously", consumer.getTopic()); -                } -            }).exceptionally(exception -> { -                log.warn("[{}] Failed to close consumer", consumer.getTopic(), exception); -                return null; -            }); -        } -    } - -    public Consumer<byte[]> getConsumer() { -        return this.consumer; -    } - -    public String getSubscription() { -        return subscription; -    } - -    public SubscriptionType getSubscriptionType() { -        return subscriptionType; -    } - -    public SubscriptionMode getSubscriptionMode() { -        return subscriptionMode; -    } - -    public long getAndResetNumMsgsDelivered() { -        return numMsgsDelivered.sumThenReset(); -    } - -    public long getAndResetNumBytesDelivered() { -        return numBytesDelivered.sumThenReset(); -    } - -    public long getAndResetNumMsgsAcked() { -        return numMsgsAcked.sumThenReset(); -    } - -    public long getMsgDeliveredCounter() { -        return msgDeliveredCounter; -    } - -    protected void updateDeliverMsgStat(long msgSize) { -        numMsgsDelivered.increment(); -        MSG_DELIVERED_COUNTER_UPDATER.incrementAndGet(this); -        numBytesDelivered.add(msgSize); -    } - -    protected ConsumerBuilder<byte[]> getConsumerConfiguration(PulsarClient client) { -        ConsumerBuilder<byte[]> builder = client.newConsumer(); - -        if (queryParams.containsKey("ackTimeoutMillis")) { -            builder.ackTimeout(Integer.parseInt(queryParams.get("ackTimeoutMillis")), TimeUnit.MILLISECONDS); -        } - -        if (queryParams.containsKey("subscriptionType")) { -            checkArgument(Enums.getIfPresent(SubscriptionType.class, queryParams.get("subscriptionType")).isPresent(), -                    "Invalid subscriptionType %s", queryParams.get("subscriptionType")); -            builder.subscriptionType(SubscriptionType.valueOf(queryParams.get("subscriptionType"))); -        } - -        if (queryParams.containsKey("subscriptionMode")) { -            checkArgument(Enums.getIfPresent(SubscriptionMode.class, queryParams.get("subscriptionMode")).isPresent(), -                    "Invalid subscriptionMode %s", queryParams.get("subscriptionMode")); -            builder.subscriptionMode(SubscriptionMode.valueOf(queryParams.get("subscriptionMode"))); -        } - -        if (queryParams.containsKey("subscriptionInitialPosition")) { -            final String subscriptionInitialPosition = queryParams.get("subscriptionInitialPosition"); -            checkArgument( -                    Enums.getIfPresent(SubscriptionInitialPosition.class, subscriptionInitialPosition).isPresent(), -                    "Invalid subscriptionInitialPosition %s", subscriptionInitialPosition); -            builder.subscriptionInitialPosition(SubscriptionInitialPosition.valueOf(subscriptionInitialPosition)); -        } - -        if (queryParams.containsKey("receiverQueueSize")) { -            builder.receiverQueueSize(Math.min(Integer.parseInt(queryParams.get("receiverQueueSize")), 1000)); -        } - -        if (queryParams.containsKey("consumerName")) { -            builder.consumerName(queryParams.get("consumerName")); -        } - -        if (queryParams.containsKey("priorityLevel")) { -            builder.priorityLevel(Integer.parseInt(queryParams.get("priorityLevel"))); -        } - -        if (queryParams.containsKey("negativeAckRedeliveryDelay")) { -            builder.negativeAckRedeliveryDelay(Integer.parseInt(queryParams.get("negativeAckRedeliveryDelay")), -                    TimeUnit.MILLISECONDS); -        } - -        if (queryParams.containsKey("maxRedeliverCount") || queryParams.containsKey("deadLetterTopic")) { -            DeadLetterPolicy.DeadLetterPolicyBuilder dlpBuilder = DeadLetterPolicy.builder(); -            if (queryParams.containsKey("maxRedeliverCount")) { -                dlpBuilder.maxRedeliverCount(Integer.parseInt(queryParams.get("maxRedeliverCount"))) -                        .deadLetterTopic(String.format("%s-%s-DLQ", topic, subscription)); -            } - -            if (queryParams.containsKey("deadLetterTopic")) { -                dlpBuilder.deadLetterTopic(queryParams.get("deadLetterTopic")); -            } -            builder.deadLetterPolicy(dlpBuilder.build()); -        } - -        if (queryParams.containsKey("cryptoFailureAction")) { -            String action = queryParams.get("cryptoFailureAction"); -            try { -                builder.cryptoFailureAction(ConsumerCryptoFailureAction.valueOf(action)); -            } catch (Exception e) { -                log.warn("Failed to configure cryptoFailureAction {}, {}", action, e.getMessage()); -            } -        } - -        if (service.getCryptoKeyReader().isPresent()) { -            builder.cryptoKeyReader(service.getCryptoKeyReader().get()); -        } else { -            // If users want to decrypt messages themselves, they should set "cryptoFailureAction" to "CONSUME". -        } -        return builder; -    } - -    @Override -    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { -        try { -            AuthenticationDataSubscription subscription = new AuthenticationDataSubscription(authenticationData, -                    this.subscription); -            return service.getAuthorizationService() -                    .allowTopicOperationAsync(topic, TopicOperation.CONSUME, authRole, subscription) -                    .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); -        } catch (TimeoutException e) { -            log.warn("Time-out {} sec while checking authorization on {} ", -                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); -            throw e; -        } catch (Exception e) { -            log.warn("Consumer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, -                    e.getMessage()); -            throw e; -        } -    } - -    public String extractSubscription(HttpServletRequest request) { -        String uri = request.getRequestURI(); -        List<String> parts = Splitter.on("/").splitToList(uri); - -        // v1 Format must be like : -        // /ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription - -        // v2 Format must be like : -        // /ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription -        checkArgument(parts.size() == 9, "Invalid topic name format"); -        checkArgument(parts.get(1).equals("ws")); - -        final boolean isV2Format = parts.get(2).equals("v2"); -        final int domainIndex = isV2Format ? 4 : 3; -        checkArgument(parts.get(domainIndex).equals("persistent") -                || parts.get(domainIndex).equals("non-persistent")); -        checkArgument(parts.get(8).length() > 0, "Empty subscription name"); - -        return Codec.decode(parts.get(8)); -    } - -    private static final Logger log = LoggerFactory.getLogger(ConsumerHandler.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static com.google.common.base.Preconditions.checkArgument; +import static java.util.concurrent.TimeUnit.SECONDS; +import com.fasterxml.jackson.core.JsonProcessingException; +import com.google.common.base.Enums; +import com.google.common.base.Splitter; +import com.google.common.cache.Cache; +import com.google.common.cache.CacheBuilder; +import java.io.IOException; +import java.util.Base64; +import java.util.List; +import java.util.concurrent.TimeUnit; +import java.util.concurrent.TimeoutException; +import java.util.concurrent.atomic.AtomicInteger; +import java.util.concurrent.atomic.AtomicLongFieldUpdater; +import java.util.concurrent.atomic.LongAdder; +import javax.servlet.http.HttpServletRequest; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.authentication.AuthenticationDataSubscription; +import org.apache.pulsar.client.api.Consumer; +import org.apache.pulsar.client.api.ConsumerBuilder; +import org.apache.pulsar.client.api.ConsumerCryptoFailureAction; +import org.apache.pulsar.client.api.DeadLetterPolicy; +import org.apache.pulsar.client.api.MessageId; +import org.apache.pulsar.client.api.PulsarClient; +import org.apache.pulsar.client.api.PulsarClientException; +import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException; +import org.apache.pulsar.client.api.SubscriptionInitialPosition; +import org.apache.pulsar.client.api.SubscriptionMode; +import org.apache.pulsar.client.api.SubscriptionType; +import org.apache.pulsar.client.impl.ConsumerBuilderImpl; +import org.apache.pulsar.common.policies.data.TopicOperation; +import org.apache.pulsar.common.util.Codec; +import org.apache.pulsar.common.util.DateFormatter; +import org.apache.pulsar.websocket.data.ConsumerCommand; +import org.apache.pulsar.websocket.data.ConsumerMessage; +import org.apache.pulsar.websocket.data.EndOfTopicResponse; +import org.eclipse.jetty.websocket.api.Session; +import org.eclipse.jetty.websocket.api.WriteCallback; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * + * WebSocket end-point url handler to handle incoming receive and acknowledge requests. + * <p> + * <b>receive:</b> socket-proxy keeps pushing messages to client by writing into session. However, it dispatches N + * messages at any point and after that on acknowledgement from client it dispatches further messages. <br/> + * <b>acknowledge:</b> it accepts acknowledgement for a given message from client and send it to broker. and for next + * action it notifies receive to dispatch further messages to client. + * </P> + * + */ +public class ConsumerHandler extends AbstractWebSocketHandler { + +    protected String subscription = null; +    private SubscriptionType subscriptionType; +    private SubscriptionMode subscriptionMode; +    private Consumer<byte[]> consumer; + +    private int maxPendingMessages = 0; +    private final AtomicInteger pendingMessages = new AtomicInteger(); +    private final boolean pullMode; + +    private final LongAdder numMsgsDelivered; +    private final LongAdder numBytesDelivered; +    private final LongAdder numMsgsAcked; +    private volatile long msgDeliveredCounter = 0; + +    protected String topicsPattern; + +    protected String topics; +    private static final AtomicLongFieldUpdater<ConsumerHandler> MSG_DELIVERED_COUNTER_UPDATER = +            AtomicLongFieldUpdater.newUpdater(ConsumerHandler.class, "msgDeliveredCounter"); + +    // Make sure use the same BatchMessageIdImpl to acknowledge the batch message, otherwise the BatchMessageAcker +    // of the BatchMessageIdImpl will not complete. +    private Cache<String, MessageId> messageIdCache = CacheBuilder.newBuilder() +            .expireAfterWrite(1, TimeUnit.HOURS) +            .build(); + +    public ConsumerHandler(WebSocketService service, HttpServletRequest request, ServletUpgradeResponse response) { +        super(service, request, response); + +        ConsumerBuilderImpl<byte[]> builder; + +        this.numMsgsDelivered = new LongAdder(); +        this.numBytesDelivered = new LongAdder(); +        this.numMsgsAcked = new LongAdder(); +        this.pullMode = Boolean.parseBoolean(queryParams.get("pullMode")); + +        try { +            // checkAuth() and getConsumerConfiguration() should be called after assigning a value to this.subscription +            this.subscription = extractSubscription(request); +            builder = (ConsumerBuilderImpl<byte[]>) getConsumerConfiguration(service.getPulsarClient()); + +            if (!this.pullMode) { +                this.maxPendingMessages = (builder.getConf().getReceiverQueueSize() == 0) ? 1 +                        : builder.getConf().getReceiverQueueSize(); +            } +            this.subscriptionType = builder.getConf().getSubscriptionType(); +            this.subscriptionMode = builder.getConf().getSubscriptionMode(); + +            if (!checkAuth(response)) { +                return; +            } + +            if (topicsPattern != null) { +                this.consumer = builder.topicsPattern(topicsPattern).subscriptionName(subscription).subscribe(); +            } else if (topics != null) { +                this.consumer = builder.topics(Splitter.on(",").splitToList(topics)) +                        .subscriptionName(subscription).subscribe(); +            } else { +                this.consumer = builder.topic(topic.toString()).subscriptionName(subscription).subscribe(); +            } +            if (!this.service.addConsumer(this)) { +                log.warn("[{}:{}] Failed to add consumer handler for topic {}", request.getRemoteAddr(), +                        request.getRemotePort(), topic); +            } +        } catch (Exception e) { +            log.warn("[{}:{}] Failed in creating subscription {} on topic {}", request.getRemoteAddr(), +                    request.getRemotePort(), subscription, topic, e); + +            try { +                response.sendError(getErrorCode(e), getErrorMessage(e)); +            } catch (IOException e1) { +                log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), +                        e1.getMessage(), e1); +            } +        } +    } + +    private void receiveMessage() { +        if (log.isDebugEnabled()) { +            log.debug("[{}:{}] [{}] [{}] Receive next message", +                    request.getRemoteAddr(), request.getRemotePort(), topic, subscription); +        } + +        consumer.receiveAsync().thenAccept(msg -> { +            if (log.isDebugEnabled()) { +                log.debug("[{}] [{}] [{}] Got message {}", getSession().getRemoteAddress(), topic, subscription, +                        msg.getMessageId()); +            } + +            ConsumerMessage dm = new ConsumerMessage(); +            dm.messageId = Base64.getEncoder().encodeToString(msg.getMessageId().toByteArray()); +            dm.payload = Base64.getEncoder().encodeToString(msg.getData()); +            dm.properties = msg.getProperties(); +            dm.publishTime = DateFormatter.format(msg.getPublishTime()); +            dm.redeliveryCount = msg.getRedeliveryCount(); +            dm.encryptionContext = msg.getEncryptionCtx().orElse(null); +            if (msg.getEventTime() != 0) { +                dm.eventTime = DateFormatter.format(msg.getEventTime()); +            } +            if (msg.hasKey()) { +                dm.key = msg.getKey(); +            } +            final long msgSize = msg.getData().length; + +            messageIdCache.put(dm.messageId, msg.getMessageId()); + +            try { +                getSession().getRemote() +                        .sendString(objectWriter().writeValueAsString(dm), +                                new WriteCallback() { +                                    @Override +                                    public void writeFailed(Throwable th) { +                                        log.warn("[{}/{}] Failed to deliver msg to {} {}", consumer.getTopic(), +                                                subscription, +                                                getRemote().getInetSocketAddress().toString(), th.getMessage()); +                                        pendingMessages.decrementAndGet(); +                                        // schedule receive as one of the delivery failed +                                        service.getExecutor().execute(() -> receiveMessage()); +                                    } + +                                    @Override +                                    public void writeSuccess() { +                                        if (log.isDebugEnabled()) { +                                            log.debug("[{}/{}] message is delivered successfully to {} ", +                                                    consumer.getTopic(), +                                                    subscription, getRemote().getInetSocketAddress().toString()); +                                        } +                                        updateDeliverMsgStat(msgSize); +                                    } +                                }); +            } catch (JsonProcessingException e) { +                close(WebSocketError.FailedToSerializeToJSON); +            } + +            int pending = pendingMessages.incrementAndGet(); +            if (pending < maxPendingMessages) { +                // Start next read in a separate thread to avoid recursion +                service.getExecutor().execute(this::receiveMessage); +            } +        }).exceptionally(exception -> { +            if (exception.getCause() instanceof AlreadyClosedException) { +                log.info("[{}/{}] Consumer was closed while receiving msg from broker", consumer.getTopic(), +                        subscription); +            } else { +                log.warn("[{}/{}] Error occurred while consumer handler was delivering msg to {}: {}", +                        consumer.getTopic(), subscription, getRemote().getInetSocketAddress().toString(), +                        exception.getMessage()); +            } +            return null; +        }); +    } + +    @Override +    public void onWebSocketConnect(Session session) { +        super.onWebSocketConnect(session); +        if (!pullMode) { +            receiveMessage(); +        } +    } + +    @Override +    public void onWebSocketText(String message) { +        super.onWebSocketText(message); + +        try { +            ConsumerCommand command = consumerCommandReader.readValue(message); +            if ("permit".equals(command.type)) { +                handlePermit(command); +            } else if ("unsubscribe".equals(command.type)) { +                handleUnsubscribe(command); +            } else if ("negativeAcknowledge".equals(command.type)) { +                handleNack(command); +            } else if ("isEndOfTopic".equals(command.type)) { +                handleEndOfTopic(); +            } else { +                handleAck(command); +            } +        } catch (IOException e) { +            log.warn("Failed to deserialize message id: {}", message, e); +            close(WebSocketError.FailedToDeserializeFromJSON); +        } +    } + +    // Check and notify consumer if reached end of topic. +    private void handleEndOfTopic() { +        if (log.isDebugEnabled()) { +            log.debug("[{}/{}] Received check reach the end of topic request from {} ", consumer.getTopic(), +                    subscription, getRemote().getInetSocketAddress().toString()); +        } +        try { +            String msg = objectWriter().writeValueAsString( +                    new EndOfTopicResponse(consumer.hasReachedEndOfTopic())); +            getSession().getRemote() +            .sendString(msg, new WriteCallback() { +                @Override +                public void writeFailed(Throwable th) { +                    log.warn("[{}/{}] Failed to send end of topic msg to {} due to {}", consumer.getTopic(), +                            subscription, getRemote().getInetSocketAddress().toString(), th.getMessage()); +                } + +                @Override +                public void writeSuccess() { +                    if (log.isDebugEnabled()) { +                        log.debug("[{}/{}] End of topic message is delivered successfully to {} ", +                                consumer.getTopic(), subscription, getRemote().getInetSocketAddress().toString()); +                    } +                } +            }); +        } catch (JsonProcessingException e) { +            log.warn("[{}] Failed to generate end of topic response: {}", consumer.getTopic(), e.getMessage()); +        } catch (Exception e) { +            log.warn("[{}] Failed to send end of topic response: {}", consumer.getTopic(), e.getMessage()); +        } +    } + +    private void handleUnsubscribe(ConsumerCommand command) throws PulsarClientException { +        if (log.isDebugEnabled()) { +            log.debug("[{}/{}] Received unsubscribe request from {} ", consumer.getTopic(), +                    subscription, getRemote().getInetSocketAddress().toString()); +        } +        consumer.unsubscribe(); +    } + +    private void checkResumeReceive() { +        if (!this.pullMode) { +            int pending = pendingMessages.getAndDecrement(); +            if (pending >= maxPendingMessages) { +                // Resume delivery +                receiveMessage(); +            } +        } +    } + +    private void handleAck(ConsumerCommand command) throws IOException { +        // We should have received an ack +        MessageId msgId = MessageId.fromByteArray(Base64.getDecoder().decode(command.messageId)); +        if (log.isDebugEnabled()) { +            log.debug("[{}/{}] Received ack request of message {} from {} ", consumer.getTopic(), +                    subscription, msgId, getRemote().getInetSocketAddress().toString()); +        } + +        MessageId originalMsgId = messageIdCache.asMap().remove(command.messageId); +        if (originalMsgId != null) { +            consumer.acknowledgeAsync(originalMsgId).thenAccept(consumer -> numMsgsAcked.increment()); +        } else { +            consumer.acknowledgeAsync(msgId).thenAccept(consumer -> numMsgsAcked.increment()); +        } + +        checkResumeReceive(); +    } + +    private void handleNack(ConsumerCommand command) throws IOException { +        MessageId msgId = MessageId.fromByteArrayWithTopic(Base64.getDecoder().decode(command.messageId), +            topic.toString()); +        if (log.isDebugEnabled()) { +            log.debug("[{}/{}] Received negative ack request of message {} from {} ", consumer.getTopic(), +                    subscription, msgId, getRemote().getInetSocketAddress().toString()); +        } + +        MessageId originalMsgId = messageIdCache.asMap().remove(command.messageId); +        if (originalMsgId != null) { +            consumer.negativeAcknowledge(originalMsgId); +        } else { +            consumer.negativeAcknowledge(msgId); +        } +        checkResumeReceive(); +    } + +    private void handlePermit(ConsumerCommand command) throws IOException { +        if (log.isDebugEnabled()) { +            log.debug("[{}/{}] Received {} permits request from {} ", consumer.getTopic(), +                    subscription, command.permitMessages, getRemote().getInetSocketAddress().toString()); +        } +        if (command.permitMessages == null) { +            throw new IOException("Missing required permitMessages field for 'permit' command"); +        } +        if (this.pullMode) { +            int pending = pendingMessages.getAndAdd(-command.permitMessages); +            if (pending >= 0) { +                // Resume delivery +                receiveMessage(); +            } +        } +    } + +    @Override +    public void close() throws IOException { +        if (consumer != null) { +            if (!this.service.removeConsumer(this)) { +                log.warn("[{}] Failed to remove consumer handler", consumer.getTopic()); +            } +            consumer.closeAsync().thenAccept(x -> { +                if (log.isDebugEnabled()) { +                    log.debug("[{}] Closed consumer asynchronously", consumer.getTopic()); +                } +            }).exceptionally(exception -> { +                log.warn("[{}] Failed to close consumer", consumer.getTopic(), exception); +                return null; +            }); +        } +    } + +    public Consumer<byte[]> getConsumer() { +        return this.consumer; +    } + +    public String getSubscription() { +        return subscription; +    } + +    public SubscriptionType getSubscriptionType() { +        return subscriptionType; +    } + +    public SubscriptionMode getSubscriptionMode() { +        return subscriptionMode; +    } + +    public long getAndResetNumMsgsDelivered() { +        return numMsgsDelivered.sumThenReset(); +    } + +    public long getAndResetNumBytesDelivered() { +        return numBytesDelivered.sumThenReset(); +    } + +    public long getAndResetNumMsgsAcked() { +        return numMsgsAcked.sumThenReset(); +    } + +    public long getMsgDeliveredCounter() { +        return msgDeliveredCounter; +    } + +    protected void updateDeliverMsgStat(long msgSize) { +        numMsgsDelivered.increment(); +        MSG_DELIVERED_COUNTER_UPDATER.incrementAndGet(this); +        numBytesDelivered.add(msgSize); +    } + +    protected ConsumerBuilder<byte[]> getConsumerConfiguration(PulsarClient client) { +        ConsumerBuilder<byte[]> builder = client.newConsumer(); + +        if (queryParams.containsKey("ackTimeoutMillis")) { +            builder.ackTimeout(Integer.parseInt(queryParams.get("ackTimeoutMillis")), TimeUnit.MILLISECONDS); +        } + +        if (queryParams.containsKey("subscriptionType")) { +            checkArgument(Enums.getIfPresent(SubscriptionType.class, queryParams.get("subscriptionType")).isPresent(), +                    "Invalid subscriptionType %s", queryParams.get("subscriptionType")); +            builder.subscriptionType(SubscriptionType.valueOf(queryParams.get("subscriptionType"))); +        } + +        if (queryParams.containsKey("subscriptionMode")) { +            checkArgument(Enums.getIfPresent(SubscriptionMode.class, queryParams.get("subscriptionMode")).isPresent(), +                    "Invalid subscriptionMode %s", queryParams.get("subscriptionMode")); +            builder.subscriptionMode(SubscriptionMode.valueOf(queryParams.get("subscriptionMode"))); +        } + +        if (queryParams.containsKey("subscriptionInitialPosition")) { +            final String subscriptionInitialPosition = queryParams.get("subscriptionInitialPosition"); +            checkArgument( +                    Enums.getIfPresent(SubscriptionInitialPosition.class, subscriptionInitialPosition).isPresent(), +                    "Invalid subscriptionInitialPosition %s", subscriptionInitialPosition); +            builder.subscriptionInitialPosition(SubscriptionInitialPosition.valueOf(subscriptionInitialPosition)); +        } + +        if (queryParams.containsKey("receiverQueueSize")) { +            builder.receiverQueueSize(Math.min(Integer.parseInt(queryParams.get("receiverQueueSize")), 1000)); +        } + +        if (queryParams.containsKey("consumerName")) { +            builder.consumerName(queryParams.get("consumerName")); +        } + +        if (queryParams.containsKey("priorityLevel")) { +            builder.priorityLevel(Integer.parseInt(queryParams.get("priorityLevel"))); +        } + +        if (queryParams.containsKey("negativeAckRedeliveryDelay")) { +            builder.negativeAckRedeliveryDelay(Integer.parseInt(queryParams.get("negativeAckRedeliveryDelay")), +                    TimeUnit.MILLISECONDS); +        } + +        if (queryParams.containsKey("maxRedeliverCount") || queryParams.containsKey("deadLetterTopic")) { +            DeadLetterPolicy.DeadLetterPolicyBuilder dlpBuilder = DeadLetterPolicy.builder(); +            if (queryParams.containsKey("maxRedeliverCount")) { +                dlpBuilder.maxRedeliverCount(Integer.parseInt(queryParams.get("maxRedeliverCount"))) +                        .deadLetterTopic(String.format("%s-%s-DLQ", topic, subscription)); +            } + +            if (queryParams.containsKey("deadLetterTopic")) { +                dlpBuilder.deadLetterTopic(queryParams.get("deadLetterTopic")); +            } +            builder.deadLetterPolicy(dlpBuilder.build()); +        } + +        if (queryParams.containsKey("cryptoFailureAction")) { +            String action = queryParams.get("cryptoFailureAction"); +            try { +                builder.cryptoFailureAction(ConsumerCryptoFailureAction.valueOf(action)); +            } catch (Exception e) { +                log.warn("Failed to configure cryptoFailureAction {}, {}", action, e.getMessage()); +            } +        } + +        if (service.getCryptoKeyReader().isPresent()) { +            builder.cryptoKeyReader(service.getCryptoKeyReader().get()); +        } else { +            // If users want to decrypt messages themselves, they should set "cryptoFailureAction" to "CONSUME". +        } +        return builder; +    } + +    @Override +    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { +        try { +            AuthenticationDataSubscription subscription = new AuthenticationDataSubscription(authenticationData, +                    this.subscription); +            return service.getAuthorizationService() +                    .allowTopicOperationAsync(topic, TopicOperation.CONSUME, authRole, subscription) +                    .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); +        } catch (TimeoutException e) { +            log.warn("Time-out {} sec while checking authorization on {} ", +                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); +            throw e; +        } catch (Exception e) { +            log.warn("Consumer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, +                    e.getMessage()); +            throw e; +        } +    } + +    public String extractSubscription(HttpServletRequest request) { +        String uri = request.getRequestURI(); +        List<String> parts = Splitter.on("/").splitToList(uri); + +        // v1 Format must be like : +        // /ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription + +        // v2 Format must be like : +        // /ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription +        checkArgument(parts.size() == 9, "Invalid topic name format"); +        checkArgument(parts.get(1).equals("ws")); + +        final boolean isV2Format = parts.get(2).equals("v2"); +        final int domainIndex = isV2Format ? 4 : 3; +        checkArgument(parts.get(domainIndex).equals("persistent") +                || parts.get(domainIndex).equals("non-persistent")); +        checkArgument(parts.get(8).length() > 0, "Empty subscription name"); + +        return Codec.decode(parts.get(8)); +    } + +    private static final Logger log = LoggerFactory.getLogger(ConsumerHandler.class); +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/CryptoKeyReaderFactory.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/CryptoKeyReaderFactory.java index 106f34fbca..e891d01621 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/CryptoKeyReaderFactory.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/CryptoKeyReaderFactory.java @@ -1,29 +1,29 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import org.apache.pulsar.client.api.CryptoKeyReader; - -/** - * Factory class to create {@link CryptoKeyReader}. - * - */ -public interface CryptoKeyReaderFactory { -    CryptoKeyReader create(); +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import org.apache.pulsar.client.api.CryptoKeyReader; + +/** + * Factory class to create {@link CryptoKeyReader}. + * + */ +public interface CryptoKeyReaderFactory { +    CryptoKeyReader create();  } \ No newline at end of file diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/MultiTopicConsumerHandler.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/MultiTopicConsumerHandler.java index 7fbe257d2e..a7073e7f68 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/MultiTopicConsumerHandler.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/MultiTopicConsumerHandler.java @@ -1,119 +1,119 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static com.google.common.base.Preconditions.checkArgument; -import static java.util.concurrent.TimeUnit.SECONDS; -import com.google.common.base.Splitter; -import java.util.ArrayList; -import java.util.List; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.TimeoutException; -import javax.servlet.http.HttpServletRequest; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.authentication.AuthenticationDataSubscription; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.policies.data.TopicOperation; -import org.apache.pulsar.common.util.Codec; -import org.apache.pulsar.common.util.FutureUtil; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * Subscribing for multi-topic. - */ -public class MultiTopicConsumerHandler extends ConsumerHandler { - -    public MultiTopicConsumerHandler(WebSocketService service, HttpServletRequest request, -                                     ServletUpgradeResponse response) { -        super(service, request, response); -    } - -    @Override -    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { -        try { -            AuthenticationDataSubscription subscription = new AuthenticationDataSubscription(authenticationData, -                    this.subscription); -            if (topics != null) { -                List<String> topicNames = Splitter.on(",").splitToList(topics); -                List<CompletableFuture<Boolean>> futures = new ArrayList<>(); -                for (String topicName : topicNames) { -                    futures.add(service.getAuthorizationService() -                                .allowTopicOperationAsync(TopicName.get(topicName), -                                        TopicOperation.CONSUME, authRole, subscription)); -                } -                FutureUtil.waitForAll(futures) -                        .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); -                return futures.stream().allMatch(f -> f.join()); -            } else { -                return service.getAuthorizationService() -                        .allowTopicOperationAsync(topic, TopicOperation.CONSUME, authRole, subscription) -                        .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); -            } -        } catch (TimeoutException e) { -            log.warn("Time-out {} sec while checking authorization on {} ", -                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); -            throw e; -        } catch (Exception e) { -            log.warn("Consumer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, -                    e.getMessage()); -            throw e; -        } -    } - -    @Override -    protected void extractTopicName(HttpServletRequest request) { -        String uri = request.getRequestURI(); -        List<String> parts = Splitter.on("/").splitToList(uri); - -        // V3 Format must be like : -        // /ws/v3/consumer/my-subscription?topicsPattern="a.*"  //ws/v3/consumer/my-subscription?topics="a,b,c" -        checkArgument(parts.size() >= 4, "Invalid topic name format"); -        checkArgument(parts.get(2).equals("v3")); -        checkArgument(queryParams.containsKey("topicsPattern") || queryParams.containsKey("topics"), -                "Should set topics or topicsPattern"); -        checkArgument(!(queryParams.containsKey("topicsPattern") && queryParams.containsKey("topics")), -                "Topics must be null when use topicsPattern"); -        topicsPattern = queryParams.get("topicsPattern"); -        topics = queryParams.get("topics"); -        if (topicsPattern != null) { -            topic = TopicName.get(topicsPattern); -        } else { -            // Multi topics only use the first topic name- -            topic = TopicName.get(Splitter.on(",").splitToList(topics).get(0)); -        } -    } - -    @Override -    public String extractSubscription(HttpServletRequest request) { -        String uri = request.getRequestURI(); -        List<String> parts = Splitter.on("/").splitToList(uri); -        // v3 Format must be like : -        // /ws/v3/consumer/my-subscription?topicsPattern="a.*"  //ws/v3/consumer/my-subscription?topics="a,b,c" -        checkArgument(parts.size() >= 5 , "Invalid topic name format"); -        checkArgument(parts.get(1).equals("ws")); -        checkArgument(parts.get(2).equals("v3")); -        checkArgument(parts.get(4).length() > 0, "Empty subscription name"); - -        return Codec.decode(parts.get(4)); -    } - -    private static final Logger log = LoggerFactory.getLogger(MultiTopicConsumerHandler.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static com.google.common.base.Preconditions.checkArgument; +import static java.util.concurrent.TimeUnit.SECONDS; +import com.google.common.base.Splitter; +import java.util.ArrayList; +import java.util.List; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.TimeoutException; +import javax.servlet.http.HttpServletRequest; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.authentication.AuthenticationDataSubscription; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.policies.data.TopicOperation; +import org.apache.pulsar.common.util.Codec; +import org.apache.pulsar.common.util.FutureUtil; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * Subscribing for multi-topic. + */ +public class MultiTopicConsumerHandler extends ConsumerHandler { + +    public MultiTopicConsumerHandler(WebSocketService service, HttpServletRequest request, +                                     ServletUpgradeResponse response) { +        super(service, request, response); +    } + +    @Override +    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { +        try { +            AuthenticationDataSubscription subscription = new AuthenticationDataSubscription(authenticationData, +                    this.subscription); +            if (topics != null) { +                List<String> topicNames = Splitter.on(",").splitToList(topics); +                List<CompletableFuture<Boolean>> futures = new ArrayList<>(); +                for (String topicName : topicNames) { +                    futures.add(service.getAuthorizationService() +                                .allowTopicOperationAsync(TopicName.get(topicName), +                                        TopicOperation.CONSUME, authRole, subscription)); +                } +                FutureUtil.waitForAll(futures) +                        .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); +                return futures.stream().allMatch(f -> f.join()); +            } else { +                return service.getAuthorizationService() +                        .allowTopicOperationAsync(topic, TopicOperation.CONSUME, authRole, subscription) +                        .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); +            } +        } catch (TimeoutException e) { +            log.warn("Time-out {} sec while checking authorization on {} ", +                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); +            throw e; +        } catch (Exception e) { +            log.warn("Consumer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, +                    e.getMessage()); +            throw e; +        } +    } + +    @Override +    protected void extractTopicName(HttpServletRequest request) { +        String uri = request.getRequestURI(); +        List<String> parts = Splitter.on("/").splitToList(uri); + +        // V3 Format must be like : +        // /ws/v3/consumer/my-subscription?topicsPattern="a.*"  //ws/v3/consumer/my-subscription?topics="a,b,c" +        checkArgument(parts.size() >= 4, "Invalid topic name format"); +        checkArgument(parts.get(2).equals("v3")); +        checkArgument(queryParams.containsKey("topicsPattern") || queryParams.containsKey("topics"), +                "Should set topics or topicsPattern"); +        checkArgument(!(queryParams.containsKey("topicsPattern") && queryParams.containsKey("topics")), +                "Topics must be null when use topicsPattern"); +        topicsPattern = queryParams.get("topicsPattern"); +        topics = queryParams.get("topics"); +        if (topicsPattern != null) { +            topic = TopicName.get(topicsPattern); +        } else { +            // Multi topics only use the first topic name- +            topic = TopicName.get(Splitter.on(",").splitToList(topics).get(0)); +        } +    } + +    @Override +    public String extractSubscription(HttpServletRequest request) { +        String uri = request.getRequestURI(); +        List<String> parts = Splitter.on("/").splitToList(uri); +        // v3 Format must be like : +        // /ws/v3/consumer/my-subscription?topicsPattern="a.*"  //ws/v3/consumer/my-subscription?topics="a,b,c" +        checkArgument(parts.size() >= 5 , "Invalid topic name format"); +        checkArgument(parts.get(1).equals("ws")); +        checkArgument(parts.get(2).equals("v3")); +        checkArgument(parts.get(4).length() > 0, "Empty subscription name"); + +        return Codec.decode(parts.get(4)); +    } + +    private static final Logger log = LoggerFactory.getLogger(MultiTopicConsumerHandler.class); +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ProducerHandler.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ProducerHandler.java index 3c0f42935e..d5e9bf5a16 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ProducerHandler.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ProducerHandler.java @@ -1,535 +1,535 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static com.google.common.base.Preconditions.checkArgument; -import static java.lang.String.format; -import static java.util.concurrent.TimeUnit.SECONDS; -import static org.apache.pulsar.common.api.EncryptionContext.EncryptionKey; -import static org.apache.pulsar.websocket.WebSocketError.FailedToDeserializeFromJSON; -import static org.apache.pulsar.websocket.WebSocketError.PayloadEncodingError; -import static org.apache.pulsar.websocket.WebSocketError.UnknownError; -import com.fasterxml.jackson.core.JsonProcessingException; -import com.fasterxml.jackson.core.type.TypeReference; -import com.fasterxml.jackson.databind.ObjectReader; -import com.google.common.base.Enums; -import java.io.IOException; -import java.time.format.DateTimeParseException; -import java.util.Arrays; -import java.util.Base64; -import java.util.Collections; -import java.util.List; -import java.util.Map; -import java.util.concurrent.TimeUnit; -import java.util.concurrent.TimeoutException; -import java.util.concurrent.atomic.AtomicLongFieldUpdater; -import java.util.concurrent.atomic.LongAdder; -import java.util.stream.Collectors; -import javax.servlet.http.HttpServletRequest; -import javax.servlet.http.HttpServletResponse; -import org.apache.commons.lang3.StringUtils; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.client.api.CompressionType; -import org.apache.pulsar.client.api.DummyCryptoKeyReaderImpl; -import org.apache.pulsar.client.api.HashingScheme; -import org.apache.pulsar.client.api.MessageRoutingMode; -import org.apache.pulsar.client.api.Producer; -import org.apache.pulsar.client.api.ProducerBuilder; -import org.apache.pulsar.client.api.PulsarClient; -import org.apache.pulsar.client.api.SchemaSerializationException; -import org.apache.pulsar.client.impl.TypedMessageBuilderImpl; -import org.apache.pulsar.common.api.proto.KeyValue; -import org.apache.pulsar.common.policies.data.TopicOperation; -import org.apache.pulsar.common.util.DateFormatter; -import org.apache.pulsar.common.util.ObjectMapperFactory; -import org.apache.pulsar.websocket.data.ProducerAck; -import org.apache.pulsar.websocket.data.ProducerMessage; -import org.apache.pulsar.websocket.service.WSSDummyMessageCryptoImpl; -import org.apache.pulsar.websocket.stats.StatsBuckets; -import org.eclipse.jetty.websocket.api.WriteCallback; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * Websocket end-point url handler to handle incoming message coming from client. Websocket end-point url handler to - * handle incoming message coming from client. - * <p> - * On every produced message from client it calls broker to persists it. - * </p> - * - */ - -public class ProducerHandler extends AbstractWebSocketHandler { - -    private WebSocketService service; -    private Producer<byte[]> producer; -    private final LongAdder numMsgsSent; -    private final LongAdder numMsgsFailed; -    private final LongAdder numBytesSent; -    private final StatsBuckets publishLatencyStatsUSec; -    private volatile long msgPublishedCounter = 0; -    private boolean clientSideEncrypt; -    private static final AtomicLongFieldUpdater<ProducerHandler> MSG_PUBLISHED_COUNTER_UPDATER = -            AtomicLongFieldUpdater.newUpdater(ProducerHandler.class, "msgPublishedCounter"); - -    public static final List<Long> ENTRY_LATENCY_BUCKETS_USEC = Collections.unmodifiableList(Arrays.asList( -            500L, 1_000L, 5_000L, 10_000L, 20_000L, 50_000L, 100_000L, 200_000L, 1000_000L)); -    private final ObjectReader producerMessageReader = -            ObjectMapperFactory.getMapper().reader().forType(ProducerMessage.class); - -    public ProducerHandler(WebSocketService service, HttpServletRequest request, ServletUpgradeResponse response) { -        super(service, request, response); -        this.numMsgsSent = new LongAdder(); -        this.numBytesSent = new LongAdder(); -        this.numMsgsFailed = new LongAdder(); -        this.publishLatencyStatsUSec = new StatsBuckets(ENTRY_LATENCY_BUCKETS_USEC); -        this.service = service; - -        if (!checkAuth(response)) { -            return; -        } - -        try { -            this.producer = getProducerBuilder(service.getPulsarClient()).topic(topic.toString()).create(); -            if (clientSideEncrypt) { -                log.info("[{}] [{}] The producer session is created with param encryptionKeyValues, which means that" -                                + " message encryption will be done on the client side, then the server will skip " -                                + "batch message processing, message compression processing, and message encryption" -                                + " processing", producer.getTopic(), producer.getProducerName()); -            } -            if (!this.service.addProducer(this)) { -                log.warn("[{}:{}] Failed to add producer handler for topic {}", request.getRemoteAddr(), -                        request.getRemotePort(), topic); -            } -        } catch (Exception e) { -            int errorCode = getErrorCode(e); -            boolean isKnownError = errorCode != HttpServletResponse.SC_INTERNAL_SERVER_ERROR; -            if (isKnownError) { -                log.warn("[{}:{}] Failed in creating producer on topic {}: {}", request.getRemoteAddr(), -                        request.getRemotePort(), topic, e.getMessage()); -            } else { -                log.error("[{}:{}] Failed in creating producer on topic {}: {}", request.getRemoteAddr(), -                        request.getRemotePort(), topic, e.getMessage(), e); -            } - -            try { -                response.sendError(errorCode, getErrorMessage(e)); -            } catch (IOException e1) { -                log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), -                        e1.getMessage(), e1); -            } -        } -    } - -    @Override -    public void close() throws IOException { -        if (producer != null) { -            if (!this.service.removeProducer(this)) { -                log.warn("[{}] Failed to remove producer handler", producer.getTopic()); -            } -            producer.closeAsync().thenAccept(x -> { -                if (log.isDebugEnabled()) { -                    log.debug("[{}] Closed producer asynchronously", producer.getTopic()); -                } -            }).exceptionally(exception -> { -                log.warn("[{}] Failed to close producer", producer.getTopic(), exception); -                return null; -            }); -        } -    } - -    @Override -    public void onWebSocketText(String message) { -        if (log.isDebugEnabled()) { -            log.debug("[{}] Received new message from producer {} ", producer.getTopic(), -                    getRemote().getInetSocketAddress().toString()); -        } -        ProducerMessage sendRequest; -        byte[] rawPayload = null; -        String requestContext = null; -        try { -            sendRequest = producerMessageReader.readValue(message); -            requestContext = sendRequest.context; -            rawPayload = Base64.getDecoder().decode(sendRequest.payload); -        } catch (IOException e) { -            sendAckResponse(new ProducerAck(FailedToDeserializeFromJSON, e.getMessage(), null, null)); -            return; -        } catch (IllegalArgumentException e) { -            String msg = format("Invalid Base64 message-payload error=%s", e.getMessage()); -            sendAckResponse(new ProducerAck(PayloadEncodingError, msg, null, requestContext)); -            return; -        } catch (NullPointerException e) { -            // Null payload -            sendAckResponse(new ProducerAck(PayloadEncodingError, e.getMessage(), null, requestContext)); -            return; -        } - -        final long msgSize = rawPayload.length; -        TypedMessageBuilderImpl<byte[]> builder = (TypedMessageBuilderImpl<byte[]>) producer.newMessage(); - -        try { -            builder.value(rawPayload); -        } catch (SchemaSerializationException e) { -            sendAckResponse(new ProducerAck(PayloadEncodingError, e.getMessage(), null, requestContext)); -            return; -        } - -        if (sendRequest.properties != null) { -            builder.properties(sendRequest.properties); -        } -        if (sendRequest.key != null) { -            builder.key(sendRequest.key); -        } -        if (sendRequest.replicationClusters != null) { -            builder.replicationClusters(sendRequest.replicationClusters); -        } -        if (sendRequest.eventTime != null) { -            try { -                builder.eventTime(DateFormatter.parse(sendRequest.eventTime)); -            } catch (DateTimeParseException e) { -                sendAckResponse(new ProducerAck(PayloadEncodingError, e.getMessage(), null, requestContext)); -                return; -            } -        } -        if (sendRequest.deliverAt > 0) { -            builder.deliverAt(sendRequest.deliverAt); -        } -        if (sendRequest.deliverAfterMs > 0) { -            builder.deliverAfter(sendRequest.deliverAfterMs, TimeUnit.MILLISECONDS); -        } - -        // If client-side encryption is enabled, the attributes "encryptParam", "uncompressedMessageSize", -        // "uncompressedMessageSize" and "batchSize" of message metadata must be set according to the parameters -        // when the client sends messages. -        if (clientSideEncrypt) { -            try { -                if (!StringUtils.isBlank(sendRequest.encryptionParam)) { -                    builder.getMetadataBuilder().setEncryptionParam(Base64.getDecoder() -                            .decode(sendRequest.encryptionParam)); -                } -            } catch (Exception e){ -                String msg = format("Invalid Base64 encryptionParam error=%s", e.getMessage()); -                sendAckResponse(new ProducerAck(PayloadEncodingError, msg, null, requestContext)); -                return; -            } -            if (sendRequest.compressionType != null && sendRequest.uncompressedMessageSize != null) { -                // Set compression information. -                builder.getMetadataBuilder().setCompression(sendRequest.compressionType); -                builder.getMetadataBuilder().setUncompressedSize(sendRequest.uncompressedMessageSize); -            } else if ((org.apache.pulsar.common.api.proto.CompressionType.NONE.equals(sendRequest.compressionType) -                    || sendRequest.compressionType == null) -                    && sendRequest.uncompressedMessageSize == null) { -                // Nothing to do, the method send async will set these two attributes. -            } else { -                // Only one param is set. -                sendAckResponse(new ProducerAck(PayloadEncodingError, "the params compressionType and" -                        + " uncompressedMessageSize should both empty or both non-empty", -                        null, requestContext)); -                return; -            } -        } - -        final long now = System.nanoTime(); - -        builder.sendAsync().thenAccept(msgId -> { -            if (log.isDebugEnabled()) { -                log.debug("[{}] Success fully write the message to broker with returned message ID {} from producer {}", -                        producer.getTopic(), msgId, getRemote().getInetSocketAddress().toString()); -            } -            updateSentMsgStats(msgSize, TimeUnit.NANOSECONDS.toMicros(System.nanoTime() - now)); -            if (isConnected()) { -                String messageId = Base64.getEncoder().encodeToString(msgId.toByteArray()); -                sendAckResponse(new ProducerAck(messageId, sendRequest.context)); -            } -        }).exceptionally(exception -> { -            log.warn("[{}] Error occurred while producer handler was sending msg from {}", producer.getTopic(), -                    getRemote().getInetSocketAddress().toString(), exception); -            numMsgsFailed.increment(); -            sendAckResponse( -                    new ProducerAck(UnknownError, exception.getMessage(), null, sendRequest.context)); -            return null; -        }); -    } - -    public Producer<byte[]> getProducer() { -        return this.producer; -    } - -    public long getAndResetNumMsgsSent() { -        return numMsgsSent.sumThenReset(); -    } - -    public long getAndResetNumBytesSent() { -        return numBytesSent.sumThenReset(); -    } - -    public long getAndResetNumMsgsFailed() { -        return numMsgsFailed.sumThenReset(); -    } - -    public long[] getAndResetPublishLatencyStatsUSec() { -        publishLatencyStatsUSec.refresh(); -        return publishLatencyStatsUSec.getBuckets(); -    } - -    public StatsBuckets getPublishLatencyStatsUSec() { -        return this.publishLatencyStatsUSec; -    } - -    public long getMsgPublishedCounter() { -        return msgPublishedCounter; -    } - -    @Override -    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { -        try { -            return service.getAuthorizationService() -                    .allowTopicOperationAsync(topic, TopicOperation.PRODUCE, authRole, authenticationData) -                    .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); -        } catch (TimeoutException e) { -            log.warn("Time-out {} sec while checking authorization on {} ", -                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); -            throw e; -        } catch (Exception e) { -            log.warn("Producer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, -                    e.getMessage()); -            throw e; -        } -    } - -    private void sendAckResponse(ProducerAck response) { -        try { -            String msg = objectWriter().writeValueAsString(response); -            getSession().getRemote().sendString(msg, new WriteCallback() { -                @Override -                public void writeFailed(Throwable th) { -                    log.warn("[{}] Failed to send ack: {}", producer.getTopic(), th.getMessage()); -                } - -                @Override -                public void writeSuccess() { -                    if (log.isDebugEnabled()) { -                        log.debug("[{}] Ack was sent successfully to {}", producer.getTopic(), -                                getRemote().getInetSocketAddress().toString()); -                    } -                } -            }); -        } catch (JsonProcessingException e) { -            log.warn("[{}] Failed to generate ack json-response: {}", producer.getTopic(), e.getMessage()); -        } catch (Exception e) { -            log.warn("[{}] Failed to send ack: {}", producer.getTopic(), e.getMessage()); -        } -    } - -    private void updateSentMsgStats(long msgSize, long latencyUsec) { -        this.publishLatencyStatsUSec.addValue(latencyUsec); -        this.numBytesSent.add(msgSize); -        this.numMsgsSent.increment(); -        MSG_PUBLISHED_COUNTER_UPDATER.getAndIncrement(this); -    } - -    protected ProducerBuilder<byte[]> getProducerBuilder(PulsarClient client) { -        ProducerBuilder<byte[]> builder = client.newProducer() -            .enableBatching(false) -            .messageRoutingMode(MessageRoutingMode.SinglePartition); - -        // Set to false to prevent the server thread from being blocked if a lot of messages are pending. -        builder.blockIfQueueFull(false); - -        if (queryParams.containsKey("producerName")) { -            builder.producerName(queryParams.get("producerName")); -        } - -        if (queryParams.containsKey("initialSequenceId")) { -            builder.initialSequenceId(Long.parseLong(queryParams.get("initialSequenceId"))); -        } - -        if (queryParams.containsKey("hashingScheme")) { -            builder.hashingScheme(HashingScheme.valueOf(queryParams.get("hashingScheme"))); -        } - -        if (queryParams.containsKey("sendTimeoutMillis")) { -            builder.sendTimeout(Integer.parseInt(queryParams.get("sendTimeoutMillis")), TimeUnit.MILLISECONDS); -        } - -        if (queryParams.containsKey("messageRoutingMode")) { -            checkArgument( -                    Enums.getIfPresent(MessageRoutingMode.class, queryParams.get("messageRoutingMode")).isPresent(), -                    "Invalid messageRoutingMode %s", queryParams.get("messageRoutingMode")); -            MessageRoutingMode routingMode = MessageRoutingMode.valueOf(queryParams.get("messageRoutingMode")); -            if (!MessageRoutingMode.CustomPartition.equals(routingMode)) { -                builder.messageRoutingMode(routingMode); -            } -        } - -        Map<String, EncryptionKey> encryptionKeyMap = tryToExtractJsonEncryptionKeys(); -        if (encryptionKeyMap != null) { -            popularProducerBuilderForClientSideEncrypt(builder, encryptionKeyMap); -        } else { -            popularProducerBuilderForServerSideEncrypt(builder); -        } -        return builder; -    } - -    private Map<String, EncryptionKey> tryToExtractJsonEncryptionKeys() { -        if (!queryParams.containsKey("encryptionKeys")) { -            return null; -        } -        // Base64 decode. -        byte[] param = null; -        try { -            param = Base64.getDecoder().decode(StringUtils.trim(queryParams.get("encryptionKeys"))); -        } catch (Exception base64DecodeEx) { -            return null; -        } -        try { -            Map<String, EncryptionKey> keys = ObjectMapperFactory.getMapper().getObjectMapper() -                    .readValue(param, new TypeReference<Map<String, EncryptionKey>>() {}); -            if (keys.isEmpty()) { -                return null; -            } -            if (keys.values().iterator().next().getKeyValue() == null) { -                return null; -            } -            return keys; -        } catch (IOException ex) { -            return null; -        } -    } - -    private void popularProducerBuilderForClientSideEncrypt(ProducerBuilder<byte[]> builder, -                                                            Map<String, EncryptionKey> encryptionKeyMap) { -        this.clientSideEncrypt = true; -        int keysLen = encryptionKeyMap.size(); -        final String[] keyNameArray = new String[keysLen]; -        final byte[][] keyValueArray = new byte[keysLen][]; -        final List<KeyValue>[] keyMetadataArray = new List[keysLen]; -        // Format keys. -        int index = 0; -        for (Map.Entry<String, EncryptionKey> entry : encryptionKeyMap.entrySet()) { -            checkArgument(StringUtils.isNotBlank(entry.getKey()), "Empty param encryptionKeys.key"); -            checkArgument(entry.getValue() != null, "Empty param encryptionKeys.value"); -            checkArgument(entry.getValue().getKeyValue() != null, "Empty param encryptionKeys.value.keyValue"); -            keyNameArray[index] = StringUtils.trim(entry.getKey()); -            keyValueArray[index] = entry.getValue().getKeyValue(); -            if (entry.getValue().getMetadata() == null) { -                keyMetadataArray[index] = Collections.emptyList(); -            } else { -                keyMetadataArray[index] = entry.getValue().getMetadata().entrySet().stream() -                        .map(e -> new KeyValue().setKey(e.getKey()).setValue(e.getValue())) -                        .collect(Collectors.toList()); -            } -            builder.addEncryptionKey(keyNameArray[index]); -        } -        // Background: The order of message payload process during message sending: -        //  1. The Producer will composite several message payloads into a batched message payload if the producer is -        //    enabled batch; -        //  2. The Producer will compress the batched message payload to a compressed payload if enabled compression; -        //  3. After the previous two steps, the Producer encrypts the compressed payload to an encrypted payload. -        // -        // Since the order of producer operation for message payloads is "compression --> encryption", users need to -        // handle Compression themselves if needed. We just disable server-side batch process, server-side compression, -        // and server-side encryption, and only set the message metadata that. -        builder.enableBatching(false); -        // Disable server-side compression, and just set compression attributes into the message metadata when sending -        // messages(see the method "onWebSocketText"). -        builder.compressionType(CompressionType.NONE); -        // Disable server-side encryption, and just set encryption attributes into the message metadata when sending -        // messages(see the method "onWebSocketText"). -        builder.cryptoKeyReader(DummyCryptoKeyReaderImpl.INSTANCE); -        // Set the param `enableChunking` to `false`(the default value is `false`) to prevent unexpected problems if -        // the default setting is changed in the future. -        builder.enableChunking(false); -        // Inject encryption metadata decorator. -        builder.messageCrypto(new WSSDummyMessageCryptoImpl(msgMetadata -> { -            for (int i = 0; i < keyNameArray.length; i++) { -                msgMetadata.addEncryptionKey().setKey(keyNameArray[i]).setValue(keyValueArray[i]) -                        .addAllMetadatas(keyMetadataArray[i]); -            } -        })); -        // Do warning param check and print warning log. -        printLogIfSettingDiscardedBatchedParams(); -        printLogIfSettingDiscardedCompressionParams(); -    } - -    private void popularProducerBuilderForServerSideEncrypt(ProducerBuilder<byte[]> builder) { -        this.clientSideEncrypt = false; -        if (queryParams.containsKey("batchingEnabled")) { -            boolean batchingEnabled = Boolean.parseBoolean(queryParams.get("batchingEnabled")); -            if (batchingEnabled) { -                builder.enableBatching(true); -                if (queryParams.containsKey("batchingMaxMessages")) { -                    builder.batchingMaxMessages(Integer.parseInt(queryParams.get("batchingMaxMessages"))); -                } - -                if (queryParams.containsKey("maxPendingMessages")) { -                    builder.maxPendingMessages(Integer.parseInt(queryParams.get("maxPendingMessages"))); -                } - -                if (queryParams.containsKey("batchingMaxPublishDelay")) { -                    builder.batchingMaxPublishDelay(Integer.parseInt(queryParams.get("batchingMaxPublishDelay")), -                            TimeUnit.MILLISECONDS); -                } -            } else { -                builder.enableBatching(false); -                printLogIfSettingDiscardedBatchedParams(); -            } -        } - -        if (queryParams.containsKey("compressionType")) { -            checkArgument(Enums.getIfPresent(CompressionType.class, queryParams.get("compressionType")).isPresent(), -                    "Invalid compressionType %s", queryParams.get("compressionType")); -            builder.compressionType(CompressionType.valueOf(queryParams.get("compressionType"))); -        } - -        if (queryParams.containsKey("encryptionKeys")) { -            builder.cryptoKeyReader(service.getCryptoKeyReader().orElseThrow(() -> new IllegalStateException( -                    "Can't add encryption key without configuring cryptoKeyReaderFactoryClassName"))); -            String[] keys = queryParams.get("encryptionKeys").split(","); -            for (String key : keys) { -                builder.addEncryptionKey(key); -            } -        } -    } - -    private void printLogIfSettingDiscardedBatchedParams() { -        if (clientSideEncrypt && queryParams.containsKey("batchingEnabled")) { -            log.info("Since clientSideEncrypt is true, the param batchingEnabled of producer will be ignored"); -        } -        if (queryParams.containsKey("batchingMaxMessages")) { -            log.info("Since batchingEnabled is false, the param batchingMaxMessages of producer will be ignored"); -        } -        if (queryParams.containsKey("maxPendingMessages")) { -            log.info("Since batchingEnabled is false, the param maxPendingMessages of producer will be ignored"); -        } -        if (queryParams.containsKey("batchingMaxPublishDelay")) { -            log.info("Since batchingEnabled is false, the param batchingMaxPublishDelay of producer will be ignored"); -        } -    } - -    private void printLogIfSettingDiscardedCompressionParams() { -        if (clientSideEncrypt && queryParams.containsKey("compressionType")) { -            log.info("Since clientSideEncrypt is true, the param compressionType of producer will be ignored"); -        } -    } - -    private static final Logger log = LoggerFactory.getLogger(ProducerHandler.class); - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static com.google.common.base.Preconditions.checkArgument; +import static java.lang.String.format; +import static java.util.concurrent.TimeUnit.SECONDS; +import static org.apache.pulsar.common.api.EncryptionContext.EncryptionKey; +import static org.apache.pulsar.websocket.WebSocketError.FailedToDeserializeFromJSON; +import static org.apache.pulsar.websocket.WebSocketError.PayloadEncodingError; +import static org.apache.pulsar.websocket.WebSocketError.UnknownError; +import com.fasterxml.jackson.core.JsonProcessingException; +import com.fasterxml.jackson.core.type.TypeReference; +import com.fasterxml.jackson.databind.ObjectReader; +import com.google.common.base.Enums; +import java.io.IOException; +import java.time.format.DateTimeParseException; +import java.util.Arrays; +import java.util.Base64; +import java.util.Collections; +import java.util.List; +import java.util.Map; +import java.util.concurrent.TimeUnit; +import java.util.concurrent.TimeoutException; +import java.util.concurrent.atomic.AtomicLongFieldUpdater; +import java.util.concurrent.atomic.LongAdder; +import java.util.stream.Collectors; +import javax.servlet.http.HttpServletRequest; +import javax.servlet.http.HttpServletResponse; +import org.apache.commons.lang3.StringUtils; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.client.api.CompressionType; +import org.apache.pulsar.client.api.DummyCryptoKeyReaderImpl; +import org.apache.pulsar.client.api.HashingScheme; +import org.apache.pulsar.client.api.MessageRoutingMode; +import org.apache.pulsar.client.api.Producer; +import org.apache.pulsar.client.api.ProducerBuilder; +import org.apache.pulsar.client.api.PulsarClient; +import org.apache.pulsar.client.api.SchemaSerializationException; +import org.apache.pulsar.client.impl.TypedMessageBuilderImpl; +import org.apache.pulsar.common.api.proto.KeyValue; +import org.apache.pulsar.common.policies.data.TopicOperation; +import org.apache.pulsar.common.util.DateFormatter; +import org.apache.pulsar.common.util.ObjectMapperFactory; +import org.apache.pulsar.websocket.data.ProducerAck; +import org.apache.pulsar.websocket.data.ProducerMessage; +import org.apache.pulsar.websocket.service.WSSDummyMessageCryptoImpl; +import org.apache.pulsar.websocket.stats.StatsBuckets; +import org.eclipse.jetty.websocket.api.WriteCallback; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * Websocket end-point url handler to handle incoming message coming from client. Websocket end-point url handler to + * handle incoming message coming from client. + * <p> + * On every produced message from client it calls broker to persists it. + * </p> + * + */ + +public class ProducerHandler extends AbstractWebSocketHandler { + +    private WebSocketService service; +    private Producer<byte[]> producer; +    private final LongAdder numMsgsSent; +    private final LongAdder numMsgsFailed; +    private final LongAdder numBytesSent; +    private final StatsBuckets publishLatencyStatsUSec; +    private volatile long msgPublishedCounter = 0; +    private boolean clientSideEncrypt; +    private static final AtomicLongFieldUpdater<ProducerHandler> MSG_PUBLISHED_COUNTER_UPDATER = +            AtomicLongFieldUpdater.newUpdater(ProducerHandler.class, "msgPublishedCounter"); + +    public static final List<Long> ENTRY_LATENCY_BUCKETS_USEC = Collections.unmodifiableList(Arrays.asList( +            500L, 1_000L, 5_000L, 10_000L, 20_000L, 50_000L, 100_000L, 200_000L, 1000_000L)); +    private final ObjectReader producerMessageReader = +            ObjectMapperFactory.getMapper().reader().forType(ProducerMessage.class); + +    public ProducerHandler(WebSocketService service, HttpServletRequest request, ServletUpgradeResponse response) { +        super(service, request, response); +        this.numMsgsSent = new LongAdder(); +        this.numBytesSent = new LongAdder(); +        this.numMsgsFailed = new LongAdder(); +        this.publishLatencyStatsUSec = new StatsBuckets(ENTRY_LATENCY_BUCKETS_USEC); +        this.service = service; + +        if (!checkAuth(response)) { +            return; +        } + +        try { +            this.producer = getProducerBuilder(service.getPulsarClient()).topic(topic.toString()).create(); +            if (clientSideEncrypt) { +                log.info("[{}] [{}] The producer session is created with param encryptionKeyValues, which means that" +                                + " message encryption will be done on the client side, then the server will skip " +                                + "batch message processing, message compression processing, and message encryption" +                                + " processing", producer.getTopic(), producer.getProducerName()); +            } +            if (!this.service.addProducer(this)) { +                log.warn("[{}:{}] Failed to add producer handler for topic {}", request.getRemoteAddr(), +                        request.getRemotePort(), topic); +            } +        } catch (Exception e) { +            int errorCode = getErrorCode(e); +            boolean isKnownError = errorCode != HttpServletResponse.SC_INTERNAL_SERVER_ERROR; +            if (isKnownError) { +                log.warn("[{}:{}] Failed in creating producer on topic {}: {}", request.getRemoteAddr(), +                        request.getRemotePort(), topic, e.getMessage()); +            } else { +                log.error("[{}:{}] Failed in creating producer on topic {}: {}", request.getRemoteAddr(), +                        request.getRemotePort(), topic, e.getMessage(), e); +            } + +            try { +                response.sendError(errorCode, getErrorMessage(e)); +            } catch (IOException e1) { +                log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), +                        e1.getMessage(), e1); +            } +        } +    } + +    @Override +    public void close() throws IOException { +        if (producer != null) { +            if (!this.service.removeProducer(this)) { +                log.warn("[{}] Failed to remove producer handler", producer.getTopic()); +            } +            producer.closeAsync().thenAccept(x -> { +                if (log.isDebugEnabled()) { +                    log.debug("[{}] Closed producer asynchronously", producer.getTopic()); +                } +            }).exceptionally(exception -> { +                log.warn("[{}] Failed to close producer", producer.getTopic(), exception); +                return null; +            }); +        } +    } + +    @Override +    public void onWebSocketText(String message) { +        if (log.isDebugEnabled()) { +            log.debug("[{}] Received new message from producer {} ", producer.getTopic(), +                    getRemote().getInetSocketAddress().toString()); +        } +        ProducerMessage sendRequest; +        byte[] rawPayload = null; +        String requestContext = null; +        try { +            sendRequest = producerMessageReader.readValue(message); +            requestContext = sendRequest.context; +            rawPayload = Base64.getDecoder().decode(sendRequest.payload); +        } catch (IOException e) { +            sendAckResponse(new ProducerAck(FailedToDeserializeFromJSON, e.getMessage(), null, null)); +            return; +        } catch (IllegalArgumentException e) { +            String msg = format("Invalid Base64 message-payload error=%s", e.getMessage()); +            sendAckResponse(new ProducerAck(PayloadEncodingError, msg, null, requestContext)); +            return; +        } catch (NullPointerException e) { +            // Null payload +            sendAckResponse(new ProducerAck(PayloadEncodingError, e.getMessage(), null, requestContext)); +            return; +        } + +        final long msgSize = rawPayload.length; +        TypedMessageBuilderImpl<byte[]> builder = (TypedMessageBuilderImpl<byte[]>) producer.newMessage(); + +        try { +            builder.value(rawPayload); +        } catch (SchemaSerializationException e) { +            sendAckResponse(new ProducerAck(PayloadEncodingError, e.getMessage(), null, requestContext)); +            return; +        } + +        if (sendRequest.properties != null) { +            builder.properties(sendRequest.properties); +        } +        if (sendRequest.key != null) { +            builder.key(sendRequest.key); +        } +        if (sendRequest.replicationClusters != null) { +            builder.replicationClusters(sendRequest.replicationClusters); +        } +        if (sendRequest.eventTime != null) { +            try { +                builder.eventTime(DateFormatter.parse(sendRequest.eventTime)); +            } catch (DateTimeParseException e) { +                sendAckResponse(new ProducerAck(PayloadEncodingError, e.getMessage(), null, requestContext)); +                return; +            } +        } +        if (sendRequest.deliverAt > 0) { +            builder.deliverAt(sendRequest.deliverAt); +        } +        if (sendRequest.deliverAfterMs > 0) { +            builder.deliverAfter(sendRequest.deliverAfterMs, TimeUnit.MILLISECONDS); +        } + +        // If client-side encryption is enabled, the attributes "encryptParam", "uncompressedMessageSize", +        // "uncompressedMessageSize" and "batchSize" of message metadata must be set according to the parameters +        // when the client sends messages. +        if (clientSideEncrypt) { +            try { +                if (!StringUtils.isBlank(sendRequest.encryptionParam)) { +                    builder.getMetadataBuilder().setEncryptionParam(Base64.getDecoder() +                            .decode(sendRequest.encryptionParam)); +                } +            } catch (Exception e){ +                String msg = format("Invalid Base64 encryptionParam error=%s", e.getMessage()); +                sendAckResponse(new ProducerAck(PayloadEncodingError, msg, null, requestContext)); +                return; +            } +            if (sendRequest.compressionType != null && sendRequest.uncompressedMessageSize != null) { +                // Set compression information. +                builder.getMetadataBuilder().setCompression(sendRequest.compressionType); +                builder.getMetadataBuilder().setUncompressedSize(sendRequest.uncompressedMessageSize); +            } else if ((org.apache.pulsar.common.api.proto.CompressionType.NONE.equals(sendRequest.compressionType) +                    || sendRequest.compressionType == null) +                    && sendRequest.uncompressedMessageSize == null) { +                // Nothing to do, the method send async will set these two attributes. +            } else { +                // Only one param is set. +                sendAckResponse(new ProducerAck(PayloadEncodingError, "the params compressionType and" +                        + " uncompressedMessageSize should both empty or both non-empty", +                        null, requestContext)); +                return; +            } +        } + +        final long now = System.nanoTime(); + +        builder.sendAsync().thenAccept(msgId -> { +            if (log.isDebugEnabled()) { +                log.debug("[{}] Success fully write the message to broker with returned message ID {} from producer {}", +                        producer.getTopic(), msgId, getRemote().getInetSocketAddress().toString()); +            } +            updateSentMsgStats(msgSize, TimeUnit.NANOSECONDS.toMicros(System.nanoTime() - now)); +            if (isConnected()) { +                String messageId = Base64.getEncoder().encodeToString(msgId.toByteArray()); +                sendAckResponse(new ProducerAck(messageId, sendRequest.context)); +            } +        }).exceptionally(exception -> { +            log.warn("[{}] Error occurred while producer handler was sending msg from {}", producer.getTopic(), +                    getRemote().getInetSocketAddress().toString(), exception); +            numMsgsFailed.increment(); +            sendAckResponse( +                    new ProducerAck(UnknownError, exception.getMessage(), null, sendRequest.context)); +            return null; +        }); +    } + +    public Producer<byte[]> getProducer() { +        return this.producer; +    } + +    public long getAndResetNumMsgsSent() { +        return numMsgsSent.sumThenReset(); +    } + +    public long getAndResetNumBytesSent() { +        return numBytesSent.sumThenReset(); +    } + +    public long getAndResetNumMsgsFailed() { +        return numMsgsFailed.sumThenReset(); +    } + +    public long[] getAndResetPublishLatencyStatsUSec() { +        publishLatencyStatsUSec.refresh(); +        return publishLatencyStatsUSec.getBuckets(); +    } + +    public StatsBuckets getPublishLatencyStatsUSec() { +        return this.publishLatencyStatsUSec; +    } + +    public long getMsgPublishedCounter() { +        return msgPublishedCounter; +    } + +    @Override +    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { +        try { +            return service.getAuthorizationService() +                    .allowTopicOperationAsync(topic, TopicOperation.PRODUCE, authRole, authenticationData) +                    .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); +        } catch (TimeoutException e) { +            log.warn("Time-out {} sec while checking authorization on {} ", +                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); +            throw e; +        } catch (Exception e) { +            log.warn("Producer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, +                    e.getMessage()); +            throw e; +        } +    } + +    private void sendAckResponse(ProducerAck response) { +        try { +            String msg = objectWriter().writeValueAsString(response); +            getSession().getRemote().sendString(msg, new WriteCallback() { +                @Override +                public void writeFailed(Throwable th) { +                    log.warn("[{}] Failed to send ack: {}", producer.getTopic(), th.getMessage()); +                } + +                @Override +                public void writeSuccess() { +                    if (log.isDebugEnabled()) { +                        log.debug("[{}] Ack was sent successfully to {}", producer.getTopic(), +                                getRemote().getInetSocketAddress().toString()); +                    } +                } +            }); +        } catch (JsonProcessingException e) { +            log.warn("[{}] Failed to generate ack json-response: {}", producer.getTopic(), e.getMessage()); +        } catch (Exception e) { +            log.warn("[{}] Failed to send ack: {}", producer.getTopic(), e.getMessage()); +        } +    } + +    private void updateSentMsgStats(long msgSize, long latencyUsec) { +        this.publishLatencyStatsUSec.addValue(latencyUsec); +        this.numBytesSent.add(msgSize); +        this.numMsgsSent.increment(); +        MSG_PUBLISHED_COUNTER_UPDATER.getAndIncrement(this); +    } + +    protected ProducerBuilder<byte[]> getProducerBuilder(PulsarClient client) { +        ProducerBuilder<byte[]> builder = client.newProducer() +            .enableBatching(false) +            .messageRoutingMode(MessageRoutingMode.SinglePartition); + +        // Set to false to prevent the server thread from being blocked if a lot of messages are pending. +        builder.blockIfQueueFull(false); + +        if (queryParams.containsKey("producerName")) { +            builder.producerName(queryParams.get("producerName")); +        } + +        if (queryParams.containsKey("initialSequenceId")) { +            builder.initialSequenceId(Long.parseLong(queryParams.get("initialSequenceId"))); +        } + +        if (queryParams.containsKey("hashingScheme")) { +            builder.hashingScheme(HashingScheme.valueOf(queryParams.get("hashingScheme"))); +        } + +        if (queryParams.containsKey("sendTimeoutMillis")) { +            builder.sendTimeout(Integer.parseInt(queryParams.get("sendTimeoutMillis")), TimeUnit.MILLISECONDS); +        } + +        if (queryParams.containsKey("messageRoutingMode")) { +            checkArgument( +                    Enums.getIfPresent(MessageRoutingMode.class, queryParams.get("messageRoutingMode")).isPresent(), +                    "Invalid messageRoutingMode %s", queryParams.get("messageRoutingMode")); +            MessageRoutingMode routingMode = MessageRoutingMode.valueOf(queryParams.get("messageRoutingMode")); +            if (!MessageRoutingMode.CustomPartition.equals(routingMode)) { +                builder.messageRoutingMode(routingMode); +            } +        } + +        Map<String, EncryptionKey> encryptionKeyMap = tryToExtractJsonEncryptionKeys(); +        if (encryptionKeyMap != null) { +            popularProducerBuilderForClientSideEncrypt(builder, encryptionKeyMap); +        } else { +            popularProducerBuilderForServerSideEncrypt(builder); +        } +        return builder; +    } + +    private Map<String, EncryptionKey> tryToExtractJsonEncryptionKeys() { +        if (!queryParams.containsKey("encryptionKeys")) { +            return null; +        } +        // Base64 decode. +        byte[] param = null; +        try { +            param = Base64.getDecoder().decode(StringUtils.trim(queryParams.get("encryptionKeys"))); +        } catch (Exception base64DecodeEx) { +            return null; +        } +        try { +            Map<String, EncryptionKey> keys = ObjectMapperFactory.getMapper().getObjectMapper() +                    .readValue(param, new TypeReference<Map<String, EncryptionKey>>() {}); +            if (keys.isEmpty()) { +                return null; +            } +            if (keys.values().iterator().next().getKeyValue() == null) { +                return null; +            } +            return keys; +        } catch (IOException ex) { +            return null; +        } +    } + +    private void popularProducerBuilderForClientSideEncrypt(ProducerBuilder<byte[]> builder, +                                                            Map<String, EncryptionKey> encryptionKeyMap) { +        this.clientSideEncrypt = true; +        int keysLen = encryptionKeyMap.size(); +        final String[] keyNameArray = new String[keysLen]; +        final byte[][] keyValueArray = new byte[keysLen][]; +        final List<KeyValue>[] keyMetadataArray = new List[keysLen]; +        // Format keys. +        int index = 0; +        for (Map.Entry<String, EncryptionKey> entry : encryptionKeyMap.entrySet()) { +            checkArgument(StringUtils.isNotBlank(entry.getKey()), "Empty param encryptionKeys.key"); +            checkArgument(entry.getValue() != null, "Empty param encryptionKeys.value"); +            checkArgument(entry.getValue().getKeyValue() != null, "Empty param encryptionKeys.value.keyValue"); +            keyNameArray[index] = StringUtils.trim(entry.getKey()); +            keyValueArray[index] = entry.getValue().getKeyValue(); +            if (entry.getValue().getMetadata() == null) { +                keyMetadataArray[index] = Collections.emptyList(); +            } else { +                keyMetadataArray[index] = entry.getValue().getMetadata().entrySet().stream() +                        .map(e -> new KeyValue().setKey(e.getKey()).setValue(e.getValue())) +                        .collect(Collectors.toList()); +            } +            builder.addEncryptionKey(keyNameArray[index]); +        } +        // Background: The order of message payload process during message sending: +        //  1. The Producer will composite several message payloads into a batched message payload if the producer is +        //    enabled batch; +        //  2. The Producer will compress the batched message payload to a compressed payload if enabled compression; +        //  3. After the previous two steps, the Producer encrypts the compressed payload to an encrypted payload. +        // +        // Since the order of producer operation for message payloads is "compression --> encryption", users need to +        // handle Compression themselves if needed. We just disable server-side batch process, server-side compression, +        // and server-side encryption, and only set the message metadata that. +        builder.enableBatching(false); +        // Disable server-side compression, and just set compression attributes into the message metadata when sending +        // messages(see the method "onWebSocketText"). +        builder.compressionType(CompressionType.NONE); +        // Disable server-side encryption, and just set encryption attributes into the message metadata when sending +        // messages(see the method "onWebSocketText"). +        builder.cryptoKeyReader(DummyCryptoKeyReaderImpl.INSTANCE); +        // Set the param `enableChunking` to `false`(the default value is `false`) to prevent unexpected problems if +        // the default setting is changed in the future. +        builder.enableChunking(false); +        // Inject encryption metadata decorator. +        builder.messageCrypto(new WSSDummyMessageCryptoImpl(msgMetadata -> { +            for (int i = 0; i < keyNameArray.length; i++) { +                msgMetadata.addEncryptionKey().setKey(keyNameArray[i]).setValue(keyValueArray[i]) +                        .addAllMetadatas(keyMetadataArray[i]); +            } +        })); +        // Do warning param check and print warning log. +        printLogIfSettingDiscardedBatchedParams(); +        printLogIfSettingDiscardedCompressionParams(); +    } + +    private void popularProducerBuilderForServerSideEncrypt(ProducerBuilder<byte[]> builder) { +        this.clientSideEncrypt = false; +        if (queryParams.containsKey("batchingEnabled")) { +            boolean batchingEnabled = Boolean.parseBoolean(queryParams.get("batchingEnabled")); +            if (batchingEnabled) { +                builder.enableBatching(true); +                if (queryParams.containsKey("batchingMaxMessages")) { +                    builder.batchingMaxMessages(Integer.parseInt(queryParams.get("batchingMaxMessages"))); +                } + +                if (queryParams.containsKey("maxPendingMessages")) { +                    builder.maxPendingMessages(Integer.parseInt(queryParams.get("maxPendingMessages"))); +                } + +                if (queryParams.containsKey("batchingMaxPublishDelay")) { +                    builder.batchingMaxPublishDelay(Integer.parseInt(queryParams.get("batchingMaxPublishDelay")), +                            TimeUnit.MILLISECONDS); +                } +            } else { +                builder.enableBatching(false); +                printLogIfSettingDiscardedBatchedParams(); +            } +        } + +        if (queryParams.containsKey("compressionType")) { +            checkArgument(Enums.getIfPresent(CompressionType.class, queryParams.get("compressionType")).isPresent(), +                    "Invalid compressionType %s", queryParams.get("compressionType")); +            builder.compressionType(CompressionType.valueOf(queryParams.get("compressionType"))); +        } + +        if (queryParams.containsKey("encryptionKeys")) { +            builder.cryptoKeyReader(service.getCryptoKeyReader().orElseThrow(() -> new IllegalStateException( +                    "Can't add encryption key without configuring cryptoKeyReaderFactoryClassName"))); +            String[] keys = queryParams.get("encryptionKeys").split(","); +            for (String key : keys) { +                builder.addEncryptionKey(key); +            } +        } +    } + +    private void printLogIfSettingDiscardedBatchedParams() { +        if (clientSideEncrypt && queryParams.containsKey("batchingEnabled")) { +            log.info("Since clientSideEncrypt is true, the param batchingEnabled of producer will be ignored"); +        } +        if (queryParams.containsKey("batchingMaxMessages")) { +            log.info("Since batchingEnabled is false, the param batchingMaxMessages of producer will be ignored"); +        } +        if (queryParams.containsKey("maxPendingMessages")) { +            log.info("Since batchingEnabled is false, the param maxPendingMessages of producer will be ignored"); +        } +        if (queryParams.containsKey("batchingMaxPublishDelay")) { +            log.info("Since batchingEnabled is false, the param batchingMaxPublishDelay of producer will be ignored"); +        } +    } + +    private void printLogIfSettingDiscardedCompressionParams() { +        if (clientSideEncrypt && queryParams.containsKey("compressionType")) { +            log.info("Since clientSideEncrypt is true, the param compressionType of producer will be ignored"); +        } +    } + +    private static final Logger log = LoggerFactory.getLogger(ProducerHandler.class); + +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ReaderHandler.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ReaderHandler.java index 2f985b2076..08361b96cd 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ReaderHandler.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/ReaderHandler.java @@ -1,356 +1,356 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static java.util.concurrent.TimeUnit.SECONDS; -import static org.apache.commons.lang3.StringUtils.isNotBlank; -import com.fasterxml.jackson.core.JsonProcessingException; -import java.io.IOException; -import java.util.Base64; -import java.util.concurrent.TimeoutException; -import java.util.concurrent.atomic.AtomicInteger; -import java.util.concurrent.atomic.AtomicLongFieldUpdater; -import java.util.concurrent.atomic.LongAdder; -import javax.servlet.http.HttpServletRequest; -import javax.servlet.http.HttpServletResponse; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.authentication.AuthenticationDataSubscription; -import org.apache.pulsar.client.api.Consumer; -import org.apache.pulsar.client.api.ConsumerCryptoFailureAction; -import org.apache.pulsar.client.api.MessageId; -import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException; -import org.apache.pulsar.client.api.Reader; -import org.apache.pulsar.client.api.ReaderBuilder; -import org.apache.pulsar.client.api.SubscriptionType; -import org.apache.pulsar.client.impl.MessageIdImpl; -import org.apache.pulsar.client.impl.MultiTopicsReaderImpl; -import org.apache.pulsar.client.impl.ReaderImpl; -import org.apache.pulsar.common.policies.data.TopicOperation; -import org.apache.pulsar.common.util.DateFormatter; -import org.apache.pulsar.websocket.data.ConsumerCommand; -import org.apache.pulsar.websocket.data.ConsumerMessage; -import org.apache.pulsar.websocket.data.EndOfTopicResponse; -import org.eclipse.jetty.websocket.api.Session; -import org.eclipse.jetty.websocket.api.WriteCallback; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * - * WebSocket end-point url handler to handle incoming receive. - * <p> - * <b>receive:</b> socket-proxy keeps pushing messages to client by writing into session.<br/> - * </P> - * - */ -public class ReaderHandler extends AbstractWebSocketHandler { - -    private static final int DEFAULT_RECEIVER_QUEUE_SIZE = 1000; - -    private String subscription = ""; -    private Reader<byte[]> reader; - -    private final int maxPendingMessages; -    private final AtomicInteger pendingMessages = new AtomicInteger(); - -    private final LongAdder numMsgsDelivered; -    private final LongAdder numBytesDelivered; -    private volatile long msgDeliveredCounter = 0; -    private static final AtomicLongFieldUpdater<ReaderHandler> MSG_DELIVERED_COUNTER_UPDATER = -            AtomicLongFieldUpdater.newUpdater(ReaderHandler.class, "msgDeliveredCounter"); - -    public ReaderHandler(WebSocketService service, HttpServletRequest request, ServletUpgradeResponse response) { -        super(service, request, response); - -        final int receiverQueueSize = getReceiverQueueSize(); - -        this.maxPendingMessages = (receiverQueueSize == 0) ? 1 : receiverQueueSize; -        this.numMsgsDelivered = new LongAdder(); -        this.numBytesDelivered = new LongAdder(); - -        if (!checkAuth(response)) { -            return; -        } - -        try { -            ReaderBuilder<byte[]> builder = service.getPulsarClient().newReader() -                    .topic(topic.toString()) -                    .startMessageId(getMessageId()) -                    .receiverQueueSize(receiverQueueSize); -            if (queryParams.containsKey("readerName")) { -                builder.readerName(queryParams.get("readerName")); -            } -            if (queryParams.containsKey("cryptoFailureAction")) { -                String action = queryParams.get("cryptoFailureAction"); -                try { -                    builder.cryptoFailureAction(ConsumerCryptoFailureAction.valueOf(action)); -                } catch (Exception e) { -                    log.warn("Failed to configure cryptoFailureAction {}, {}", action, e.getMessage()); -                } -            } -            if (service.getCryptoKeyReader().isPresent()) { -                builder.cryptoKeyReader(service.getCryptoKeyReader().get()); -            } - -            this.reader = builder.create(); -            Consumer<?> consumer = getConsumer(); -            if (consumer == null) { -                throw new IllegalArgumentException(String.format("Illegal Reader Type %s", reader.getClass())); -            } -            this.subscription = consumer.getSubscription(); -            if (!this.service.addReader(this)) { -                log.warn("[{}:{}] Failed to add reader handler for topic {}", request.getRemoteAddr(), -                        request.getRemotePort(), topic); -            } -        } catch (Exception e) { -            log.warn("[{}:{}] Failed in creating reader {} on topic {}", request.getRemoteAddr(), -                    request.getRemotePort(), subscription, topic, e); -            try { -                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, -                        "Failed to create reader: " + e.getMessage()); -            } catch (IOException e1) { -                log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), -                        e1.getMessage(), e1); -            } -        } -    } - -    private void receiveMessage() { -        if (log.isDebugEnabled()) { -            log.debug("[{}:{}] [{}] [{}] Receive next message", -                    request.getRemoteAddr(), request.getRemotePort(), topic, subscription); -        } - -        reader.readNextAsync().thenAccept(msg -> { -            if (log.isDebugEnabled()) { -                log.debug("[{}] [{}] [{}] Got message {}", getSession().getRemoteAddress(), topic, subscription, -                        msg.getMessageId()); -            } - -            ConsumerMessage dm = new ConsumerMessage(); -            dm.messageId = Base64.getEncoder().encodeToString(msg.getMessageId().toByteArray()); -            dm.payload = Base64.getEncoder().encodeToString(msg.getData()); -            dm.properties = msg.getProperties(); -            dm.publishTime = DateFormatter.format(msg.getPublishTime()); -            dm.redeliveryCount = msg.getRedeliveryCount(); -            if (msg.getEventTime() != 0) { -                dm.eventTime = DateFormatter.format(msg.getEventTime()); -            } -            if (msg.hasKey()) { -                dm.key = msg.getKey(); -            } -            final long msgSize = msg.getData().length; - -            try { -                getSession().getRemote() -                        .sendString(objectWriter().writeValueAsString(dm), -                                new WriteCallback() { -                            @Override -                            public void writeFailed(Throwable th) { -                                log.warn("[{}/{}] Failed to deliver msg to {} {}", reader.getTopic(), subscription, -                                        getRemote().getInetSocketAddress().toString(), th.getMessage()); -                                pendingMessages.decrementAndGet(); -                                // schedule receive as one of the delivery failed -                                service.getExecutor().execute(() -> receiveMessage()); -                            } - -                            @Override -                            public void writeSuccess() { -                                if (log.isDebugEnabled()) { -                                    log.debug("[{}/{}] message is delivered successfully to {} ", reader.getTopic(), -                                            subscription, getRemote().getInetSocketAddress().toString()); -                                } -                                updateDeliverMsgStat(msgSize); -                            } -                        }); -            } catch (JsonProcessingException e) { -                close(WebSocketError.FailedToSerializeToJSON); -            } - -            int pending = pendingMessages.incrementAndGet(); -            if (pending < maxPendingMessages) { -                // Start next read in a separate thread to avoid recursion -                service.getExecutor().execute(() -> receiveMessage()); -            } -        }).exceptionally(exception -> { -            if (exception.getCause() instanceof AlreadyClosedException) { -                log.info("[{}/{}] Reader was closed while receiving msg from broker", reader.getTopic(), subscription); -            } else { -                log.warn("[{}/{}] Error occurred while reader handler was delivering msg to {}: {}", reader.getTopic(), -                        subscription, getRemote().getInetSocketAddress().toString(), exception.getMessage()); -            } -            return null; -        }); -    } - -    @Override -    public void onWebSocketConnect(Session session) { -        super.onWebSocketConnect(session); -        receiveMessage(); -    } - -    @Override -    public void onWebSocketText(String message) { -        super.onWebSocketText(message); - -        try { -            ConsumerCommand command = consumerCommandReader.readValue(message); -            if ("isEndOfTopic".equals(command.type)) { -                handleEndOfTopic(); -                return; -            } -        } catch (IOException e) { -            log.warn("Failed to deserialize message id: {}", message, e); -            close(WebSocketError.FailedToDeserializeFromJSON); -        } - -        // We should have received an ack -        // but reader doesn't send an ack to broker here because already reader did - -        int pending = pendingMessages.getAndDecrement(); -        if (pending >= maxPendingMessages) { -            // Resume delivery -            receiveMessage(); -        } -    } - -    // Check and notify reader if reached end of topic. -    private void handleEndOfTopic() { -        try { -            String msg = objectWriter().writeValueAsString( -                    new EndOfTopicResponse(reader.hasReachedEndOfTopic())); -            getSession().getRemote() -                    .sendString(msg, new WriteCallback() { -                        @Override -                        public void writeFailed(Throwable th) { -                            log.warn("[{}/{}] Failed to send end of topic msg to {} due to {}", reader.getTopic(), -                                    subscription, getRemote().getInetSocketAddress().toString(), th.getMessage()); -                        } - -                        @Override -                        public void writeSuccess() { -                            if (log.isDebugEnabled()) { -                                log.debug("[{}/{}] End of topic message is delivered successfully to {} ", -                                        reader.getTopic(), subscription, getRemote().getInetSocketAddress().toString()); -                            } -                        } -                    }); -        } catch (JsonProcessingException e) { -            log.warn("[{}] Failed to generate end of topic response: {}", reader.getTopic(), e.getMessage()); -        } catch (Exception e) { -            log.warn("[{}] Failed to send end of topic response: {}", reader.getTopic(), e.getMessage()); -        } -    } - -    @Override -    public void close() throws IOException { -        if (reader != null) { -            if (!this.service.removeReader(this)) { -                log.warn("[{}] Failed to remove reader handler", reader.getTopic()); -            } -            reader.closeAsync().thenAccept(x -> { -                if (log.isDebugEnabled()) { -                    log.debug("[{}] Closed reader asynchronously", reader.getTopic()); -                } -            }).exceptionally(exception -> { -                log.warn("[{}] Failed to close reader", reader.getTopic(), exception); -                return null; -            }); -        } -    } - -    public Consumer<?> getConsumer() { -        if (reader instanceof MultiTopicsReaderImpl) { -            return ((MultiTopicsReaderImpl<?>) reader).getMultiTopicsConsumer(); -        } else if (reader instanceof ReaderImpl) { -            return ((ReaderImpl<?>) reader).getConsumer(); -        } else { -            return null; -        } -    } - -    public String getSubscription() { -        return subscription; -    } - -    public SubscriptionType getSubscriptionType() { -        return SubscriptionType.Exclusive; -    } - -    public long getAndResetNumMsgsDelivered() { -        return numMsgsDelivered.sumThenReset(); -    } - -    public long getAndResetNumBytesDelivered() { -        return numBytesDelivered.sumThenReset(); -    } - -    public long getMsgDeliveredCounter() { -        return msgDeliveredCounter; -    } - -    protected void updateDeliverMsgStat(long msgSize) { -        numMsgsDelivered.increment(); -        MSG_DELIVERED_COUNTER_UPDATER.incrementAndGet(this); -        numBytesDelivered.add(msgSize); -    } - -    @Override -    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { -        try { -            AuthenticationDataSubscription subscription = new AuthenticationDataSubscription(authenticationData, -                    this.subscription); -            return service.getAuthorizationService() -                    .allowTopicOperationAsync(topic, TopicOperation.CONSUME, authRole, subscription) -                    .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); -        } catch (TimeoutException e) { -            log.warn("Time-out {} sec while checking authorization on {} ", -                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); -            throw e; -        } catch (Exception e) { -            log.warn("Consumer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, -                    e.getMessage()); -            throw e; -        } -    } - -    private int getReceiverQueueSize() { -        int size = DEFAULT_RECEIVER_QUEUE_SIZE; -        if (queryParams.containsKey("receiverQueueSize")) { -            size =  Math.min(Integer.parseInt(queryParams.get("receiverQueueSize")), DEFAULT_RECEIVER_QUEUE_SIZE); -        } -        return size; -    } - -    private MessageId getMessageId() throws IOException { -        MessageId messageId = MessageId.latest; -        if (isNotBlank(queryParams.get("messageId"))) { -            if (queryParams.get("messageId").equals("earliest")) { -                messageId = MessageId.earliest; -            } else if (!queryParams.get("messageId").equals("latest")) { -                messageId = MessageIdImpl.fromByteArray(Base64.getDecoder().decode(queryParams.get("messageId"))); -            } -        } -        return messageId; -    } - -    private static final Logger log = LoggerFactory.getLogger(ReaderHandler.class); - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static java.util.concurrent.TimeUnit.SECONDS; +import static org.apache.commons.lang3.StringUtils.isNotBlank; +import com.fasterxml.jackson.core.JsonProcessingException; +import java.io.IOException; +import java.util.Base64; +import java.util.concurrent.TimeoutException; +import java.util.concurrent.atomic.AtomicInteger; +import java.util.concurrent.atomic.AtomicLongFieldUpdater; +import java.util.concurrent.atomic.LongAdder; +import javax.servlet.http.HttpServletRequest; +import javax.servlet.http.HttpServletResponse; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.authentication.AuthenticationDataSubscription; +import org.apache.pulsar.client.api.Consumer; +import org.apache.pulsar.client.api.ConsumerCryptoFailureAction; +import org.apache.pulsar.client.api.MessageId; +import org.apache.pulsar.client.api.PulsarClientException.AlreadyClosedException; +import org.apache.pulsar.client.api.Reader; +import org.apache.pulsar.client.api.ReaderBuilder; +import org.apache.pulsar.client.api.SubscriptionType; +import org.apache.pulsar.client.impl.MessageIdImpl; +import org.apache.pulsar.client.impl.MultiTopicsReaderImpl; +import org.apache.pulsar.client.impl.ReaderImpl; +import org.apache.pulsar.common.policies.data.TopicOperation; +import org.apache.pulsar.common.util.DateFormatter; +import org.apache.pulsar.websocket.data.ConsumerCommand; +import org.apache.pulsar.websocket.data.ConsumerMessage; +import org.apache.pulsar.websocket.data.EndOfTopicResponse; +import org.eclipse.jetty.websocket.api.Session; +import org.eclipse.jetty.websocket.api.WriteCallback; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * + * WebSocket end-point url handler to handle incoming receive. + * <p> + * <b>receive:</b> socket-proxy keeps pushing messages to client by writing into session.<br/> + * </P> + * + */ +public class ReaderHandler extends AbstractWebSocketHandler { + +    private static final int DEFAULT_RECEIVER_QUEUE_SIZE = 1000; + +    private String subscription = ""; +    private Reader<byte[]> reader; + +    private final int maxPendingMessages; +    private final AtomicInteger pendingMessages = new AtomicInteger(); + +    private final LongAdder numMsgsDelivered; +    private final LongAdder numBytesDelivered; +    private volatile long msgDeliveredCounter = 0; +    private static final AtomicLongFieldUpdater<ReaderHandler> MSG_DELIVERED_COUNTER_UPDATER = +            AtomicLongFieldUpdater.newUpdater(ReaderHandler.class, "msgDeliveredCounter"); + +    public ReaderHandler(WebSocketService service, HttpServletRequest request, ServletUpgradeResponse response) { +        super(service, request, response); + +        final int receiverQueueSize = getReceiverQueueSize(); + +        this.maxPendingMessages = (receiverQueueSize == 0) ? 1 : receiverQueueSize; +        this.numMsgsDelivered = new LongAdder(); +        this.numBytesDelivered = new LongAdder(); + +        if (!checkAuth(response)) { +            return; +        } + +        try { +            ReaderBuilder<byte[]> builder = service.getPulsarClient().newReader() +                    .topic(topic.toString()) +                    .startMessageId(getMessageId()) +                    .receiverQueueSize(receiverQueueSize); +            if (queryParams.containsKey("readerName")) { +                builder.readerName(queryParams.get("readerName")); +            } +            if (queryParams.containsKey("cryptoFailureAction")) { +                String action = queryParams.get("cryptoFailureAction"); +                try { +                    builder.cryptoFailureAction(ConsumerCryptoFailureAction.valueOf(action)); +                } catch (Exception e) { +                    log.warn("Failed to configure cryptoFailureAction {}, {}", action, e.getMessage()); +                } +            } +            if (service.getCryptoKeyReader().isPresent()) { +                builder.cryptoKeyReader(service.getCryptoKeyReader().get()); +            } + +            this.reader = builder.create(); +            Consumer<?> consumer = getConsumer(); +            if (consumer == null) { +                throw new IllegalArgumentException(String.format("Illegal Reader Type %s", reader.getClass())); +            } +            this.subscription = consumer.getSubscription(); +            if (!this.service.addReader(this)) { +                log.warn("[{}:{}] Failed to add reader handler for topic {}", request.getRemoteAddr(), +                        request.getRemotePort(), topic); +            } +        } catch (Exception e) { +            log.warn("[{}:{}] Failed in creating reader {} on topic {}", request.getRemoteAddr(), +                    request.getRemotePort(), subscription, topic, e); +            try { +                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, +                        "Failed to create reader: " + e.getMessage()); +            } catch (IOException e1) { +                log.warn("[{}:{}] Failed to send error: {}", request.getRemoteAddr(), request.getRemotePort(), +                        e1.getMessage(), e1); +            } +        } +    } + +    private void receiveMessage() { +        if (log.isDebugEnabled()) { +            log.debug("[{}:{}] [{}] [{}] Receive next message", +                    request.getRemoteAddr(), request.getRemotePort(), topic, subscription); +        } + +        reader.readNextAsync().thenAccept(msg -> { +            if (log.isDebugEnabled()) { +                log.debug("[{}] [{}] [{}] Got message {}", getSession().getRemoteAddress(), topic, subscription, +                        msg.getMessageId()); +            } + +            ConsumerMessage dm = new ConsumerMessage(); +            dm.messageId = Base64.getEncoder().encodeToString(msg.getMessageId().toByteArray()); +            dm.payload = Base64.getEncoder().encodeToString(msg.getData()); +            dm.properties = msg.getProperties(); +            dm.publishTime = DateFormatter.format(msg.getPublishTime()); +            dm.redeliveryCount = msg.getRedeliveryCount(); +            if (msg.getEventTime() != 0) { +                dm.eventTime = DateFormatter.format(msg.getEventTime()); +            } +            if (msg.hasKey()) { +                dm.key = msg.getKey(); +            } +            final long msgSize = msg.getData().length; + +            try { +                getSession().getRemote() +                        .sendString(objectWriter().writeValueAsString(dm), +                                new WriteCallback() { +                            @Override +                            public void writeFailed(Throwable th) { +                                log.warn("[{}/{}] Failed to deliver msg to {} {}", reader.getTopic(), subscription, +                                        getRemote().getInetSocketAddress().toString(), th.getMessage()); +                                pendingMessages.decrementAndGet(); +                                // schedule receive as one of the delivery failed +                                service.getExecutor().execute(() -> receiveMessage()); +                            } + +                            @Override +                            public void writeSuccess() { +                                if (log.isDebugEnabled()) { +                                    log.debug("[{}/{}] message is delivered successfully to {} ", reader.getTopic(), +                                            subscription, getRemote().getInetSocketAddress().toString()); +                                } +                                updateDeliverMsgStat(msgSize); +                            } +                        }); +            } catch (JsonProcessingException e) { +                close(WebSocketError.FailedToSerializeToJSON); +            } + +            int pending = pendingMessages.incrementAndGet(); +            if (pending < maxPendingMessages) { +                // Start next read in a separate thread to avoid recursion +                service.getExecutor().execute(() -> receiveMessage()); +            } +        }).exceptionally(exception -> { +            if (exception.getCause() instanceof AlreadyClosedException) { +                log.info("[{}/{}] Reader was closed while receiving msg from broker", reader.getTopic(), subscription); +            } else { +                log.warn("[{}/{}] Error occurred while reader handler was delivering msg to {}: {}", reader.getTopic(), +                        subscription, getRemote().getInetSocketAddress().toString(), exception.getMessage()); +            } +            return null; +        }); +    } + +    @Override +    public void onWebSocketConnect(Session session) { +        super.onWebSocketConnect(session); +        receiveMessage(); +    } + +    @Override +    public void onWebSocketText(String message) { +        super.onWebSocketText(message); + +        try { +            ConsumerCommand command = consumerCommandReader.readValue(message); +            if ("isEndOfTopic".equals(command.type)) { +                handleEndOfTopic(); +                return; +            } +        } catch (IOException e) { +            log.warn("Failed to deserialize message id: {}", message, e); +            close(WebSocketError.FailedToDeserializeFromJSON); +        } + +        // We should have received an ack +        // but reader doesn't send an ack to broker here because already reader did + +        int pending = pendingMessages.getAndDecrement(); +        if (pending >= maxPendingMessages) { +            // Resume delivery +            receiveMessage(); +        } +    } + +    // Check and notify reader if reached end of topic. +    private void handleEndOfTopic() { +        try { +            String msg = objectWriter().writeValueAsString( +                    new EndOfTopicResponse(reader.hasReachedEndOfTopic())); +            getSession().getRemote() +                    .sendString(msg, new WriteCallback() { +                        @Override +                        public void writeFailed(Throwable th) { +                            log.warn("[{}/{}] Failed to send end of topic msg to {} due to {}", reader.getTopic(), +                                    subscription, getRemote().getInetSocketAddress().toString(), th.getMessage()); +                        } + +                        @Override +                        public void writeSuccess() { +                            if (log.isDebugEnabled()) { +                                log.debug("[{}/{}] End of topic message is delivered successfully to {} ", +                                        reader.getTopic(), subscription, getRemote().getInetSocketAddress().toString()); +                            } +                        } +                    }); +        } catch (JsonProcessingException e) { +            log.warn("[{}] Failed to generate end of topic response: {}", reader.getTopic(), e.getMessage()); +        } catch (Exception e) { +            log.warn("[{}] Failed to send end of topic response: {}", reader.getTopic(), e.getMessage()); +        } +    } + +    @Override +    public void close() throws IOException { +        if (reader != null) { +            if (!this.service.removeReader(this)) { +                log.warn("[{}] Failed to remove reader handler", reader.getTopic()); +            } +            reader.closeAsync().thenAccept(x -> { +                if (log.isDebugEnabled()) { +                    log.debug("[{}] Closed reader asynchronously", reader.getTopic()); +                } +            }).exceptionally(exception -> { +                log.warn("[{}] Failed to close reader", reader.getTopic(), exception); +                return null; +            }); +        } +    } + +    public Consumer<?> getConsumer() { +        if (reader instanceof MultiTopicsReaderImpl) { +            return ((MultiTopicsReaderImpl<?>) reader).getMultiTopicsConsumer(); +        } else if (reader instanceof ReaderImpl) { +            return ((ReaderImpl<?>) reader).getConsumer(); +        } else { +            return null; +        } +    } + +    public String getSubscription() { +        return subscription; +    } + +    public SubscriptionType getSubscriptionType() { +        return SubscriptionType.Exclusive; +    } + +    public long getAndResetNumMsgsDelivered() { +        return numMsgsDelivered.sumThenReset(); +    } + +    public long getAndResetNumBytesDelivered() { +        return numBytesDelivered.sumThenReset(); +    } + +    public long getMsgDeliveredCounter() { +        return msgDeliveredCounter; +    } + +    protected void updateDeliverMsgStat(long msgSize) { +        numMsgsDelivered.increment(); +        MSG_DELIVERED_COUNTER_UPDATER.incrementAndGet(this); +        numBytesDelivered.add(msgSize); +    } + +    @Override +    protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { +        try { +            AuthenticationDataSubscription subscription = new AuthenticationDataSubscription(authenticationData, +                    this.subscription); +            return service.getAuthorizationService() +                    .allowTopicOperationAsync(topic, TopicOperation.CONSUME, authRole, subscription) +                    .get(service.getConfig().getMetadataStoreOperationTimeoutSeconds(), SECONDS); +        } catch (TimeoutException e) { +            log.warn("Time-out {} sec while checking authorization on {} ", +                    service.getConfig().getMetadataStoreOperationTimeoutSeconds(), topic); +            throw e; +        } catch (Exception e) { +            log.warn("Consumer-client  with Role - {} failed to get permissions for topic - {}. {}", authRole, topic, +                    e.getMessage()); +            throw e; +        } +    } + +    private int getReceiverQueueSize() { +        int size = DEFAULT_RECEIVER_QUEUE_SIZE; +        if (queryParams.containsKey("receiverQueueSize")) { +            size =  Math.min(Integer.parseInt(queryParams.get("receiverQueueSize")), DEFAULT_RECEIVER_QUEUE_SIZE); +        } +        return size; +    } + +    private MessageId getMessageId() throws IOException { +        MessageId messageId = MessageId.latest; +        if (isNotBlank(queryParams.get("messageId"))) { +            if (queryParams.get("messageId").equals("earliest")) { +                messageId = MessageId.earliest; +            } else if (!queryParams.get("messageId").equals("latest")) { +                messageId = MessageIdImpl.fromByteArray(Base64.getDecoder().decode(queryParams.get("messageId"))); +            } +        } +        return messageId; +    } + +    private static final Logger log = LoggerFactory.getLogger(ReaderHandler.class); + +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketConsumerServlet.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketConsumerServlet.java index 8f718bc744..6abe360a4a 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketConsumerServlet.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketConsumerServlet.java @@ -1,46 +1,46 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import org.eclipse.jetty.websocket.servlet.WebSocketServlet; -import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; - -public class WebSocketConsumerServlet extends WebSocketServlet { -    private static final long serialVersionUID = 1L; - -    public static final String SERVLET_PATH = "/ws/consumer"; -    public static final String SERVLET_PATH_V2 = "/ws/v2/consumer"; - -    private final transient WebSocketService service; - -    public WebSocketConsumerServlet(WebSocketService service) { -        super(); -        this.service = service; -    } - -    @Override -    public void configure(WebSocketServletFactory factory) { -        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); -        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { -            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); -        } -        factory.setCreator( -                (request, response) -> new ConsumerHandler(service, request.getHttpServletRequest(), response)); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import org.eclipse.jetty.websocket.servlet.WebSocketServlet; +import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; + +public class WebSocketConsumerServlet extends WebSocketServlet { +    private static final long serialVersionUID = 1L; + +    public static final String SERVLET_PATH = "/ws/consumer"; +    public static final String SERVLET_PATH_V2 = "/ws/v2/consumer"; + +    private final transient WebSocketService service; + +    public WebSocketConsumerServlet(WebSocketService service) { +        super(); +        this.service = service; +    } + +    @Override +    public void configure(WebSocketServletFactory factory) { +        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); +        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { +            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); +        } +        factory.setCreator( +                (request, response) -> new ConsumerHandler(service, request.getHttpServletRequest(), response)); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketError.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketError.java index 07d6959a3f..330feacff6 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketError.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketError.java @@ -1,58 +1,58 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -/** - * Enum for possible errors in the proxy - * <p> - * Enum has error code and description of the error. - * </p> - */ -public enum WebSocketError { - -    FailedToCreateProducer(1, "Failed to create producer"), // -    FailedToSubscribe(2, "Failed to subscribe"), // -    FailedToDeserializeFromJSON(3, "Failed to de-serialize from JSON"), // -    FailedToSerializeToJSON(4, "Failed to serialize to JSON"), // -    AuthenticationError(5, "Failed to authenticate client"), // -    NotAuthorizedError(6, "Client is not authorized"), // -    PayloadEncodingError(7, "Invalid payload encoding"), // -    UnknownError(8, "Unknown error"); // - -    private final int code; -    private final String description; - -    public String getDescription() { -        return description; -    } - -    private WebSocketError(int code, String description) { -        this.code = code; -        this.description = description; -    } - -    public int getCode() { -        return code; -    } - -    @Override -    public String toString() { -        return description; -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +/** + * Enum for possible errors in the proxy + * <p> + * Enum has error code and description of the error. + * </p> + */ +public enum WebSocketError { + +    FailedToCreateProducer(1, "Failed to create producer"), // +    FailedToSubscribe(2, "Failed to subscribe"), // +    FailedToDeserializeFromJSON(3, "Failed to de-serialize from JSON"), // +    FailedToSerializeToJSON(4, "Failed to serialize to JSON"), // +    AuthenticationError(5, "Failed to authenticate client"), // +    NotAuthorizedError(6, "Client is not authorized"), // +    PayloadEncodingError(7, "Invalid payload encoding"), // +    UnknownError(8, "Unknown error"); // + +    private final int code; +    private final String description; + +    public String getDescription() { +        return description; +    } + +    private WebSocketError(int code, String description) { +        this.code = code; +        this.description = description; +    } + +    public int getCode() { +        return code; +    } + +    @Override +    public String toString() { +        return description; +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapper.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapper.java index 19ce9a3236..c17e206fc8 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapper.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapper.java @@ -1,52 +1,52 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import javax.servlet.http.HttpServletRequest; -import javax.servlet.http.HttpServletRequestWrapper; -import org.eclipse.jetty.websocket.servlet.UpgradeHttpServletRequest; - -/** - * WebSocket HttpServletRequest wrapper. - */ -public class WebSocketHttpServletRequestWrapper extends HttpServletRequestWrapper { - -    static final String HTTP_HEADER_NAME = "Authorization"; -    static final String HTTP_HEADER_VALUE_PREFIX = "Bearer "; -    static final String TOKEN = "token"; - -    public WebSocketHttpServletRequestWrapper(HttpServletRequest request) { -        super(request); -    } - -    @Override -    public String getHeader(String name) { -        // The browser javascript WebSocket client couldn't add the auth param to the request header, use the -        // query param `token` to transport the auth token for the browser javascript WebSocket client. -        if (name.equals(HTTP_HEADER_NAME) -                && !((UpgradeHttpServletRequest) this.getRequest()).getHeaders().containsKey(HTTP_HEADER_NAME)) { -            String token = getRequest().getParameter(TOKEN); -            if (token != null && !token.startsWith(HTTP_HEADER_VALUE_PREFIX)) { -                return HTTP_HEADER_VALUE_PREFIX + token; -            } -            return token; -        } -        return super.getHeader(name); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import javax.servlet.http.HttpServletRequest; +import javax.servlet.http.HttpServletRequestWrapper; +import org.eclipse.jetty.websocket.servlet.UpgradeHttpServletRequest; + +/** + * WebSocket HttpServletRequest wrapper. + */ +public class WebSocketHttpServletRequestWrapper extends HttpServletRequestWrapper { + +    static final String HTTP_HEADER_NAME = "Authorization"; +    static final String HTTP_HEADER_VALUE_PREFIX = "Bearer "; +    static final String TOKEN = "token"; + +    public WebSocketHttpServletRequestWrapper(HttpServletRequest request) { +        super(request); +    } + +    @Override +    public String getHeader(String name) { +        // The browser javascript WebSocket client couldn't add the auth param to the request header, use the +        // query param `token` to transport the auth token for the browser javascript WebSocket client. +        if (name.equals(HTTP_HEADER_NAME) +                && !((UpgradeHttpServletRequest) this.getRequest()).getHeaders().containsKey(HTTP_HEADER_NAME)) { +            String token = getRequest().getParameter(TOKEN); +            if (token != null && !token.startsWith(HTTP_HEADER_VALUE_PREFIX)) { +                return HTTP_HEADER_VALUE_PREFIX + token; +            } +            return token; +        } +        return super.getHeader(name); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketMultiTopicConsumerServlet.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketMultiTopicConsumerServlet.java index 4653cea98c..07c41413b9 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketMultiTopicConsumerServlet.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketMultiTopicConsumerServlet.java @@ -1,45 +1,45 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import org.eclipse.jetty.websocket.servlet.WebSocketServlet; -import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; - -public class WebSocketMultiTopicConsumerServlet extends WebSocketServlet { -    private static final long serialVersionUID = 1L; - -    public static final String SERVLET_PATH = "/ws/v3/consumer"; - -    private final transient WebSocketService service; - -    public WebSocketMultiTopicConsumerServlet(WebSocketService service) { -        super(); -        this.service = service; -    } - -    @Override -    public void configure(WebSocketServletFactory factory) { -        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); -        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { -            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); -        } -        factory.setCreator((request, response) -> -                new MultiTopicConsumerHandler(service, request.getHttpServletRequest(), response)); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import org.eclipse.jetty.websocket.servlet.WebSocketServlet; +import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; + +public class WebSocketMultiTopicConsumerServlet extends WebSocketServlet { +    private static final long serialVersionUID = 1L; + +    public static final String SERVLET_PATH = "/ws/v3/consumer"; + +    private final transient WebSocketService service; + +    public WebSocketMultiTopicConsumerServlet(WebSocketService service) { +        super(); +        this.service = service; +    } + +    @Override +    public void configure(WebSocketServletFactory factory) { +        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); +        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { +            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); +        } +        factory.setCreator((request, response) -> +                new MultiTopicConsumerHandler(service, request.getHttpServletRequest(), response)); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketProducerServlet.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketProducerServlet.java index c9d8861b76..b7f6534abd 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketProducerServlet.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketProducerServlet.java @@ -1,45 +1,45 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import org.eclipse.jetty.websocket.servlet.WebSocketServlet; -import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; - -public class WebSocketProducerServlet extends WebSocketServlet { -    private static final long serialVersionUID = 1L; - -    public static final String SERVLET_PATH = "/ws/producer"; -    public static final String SERVLET_PATH_V2 = "/ws/v2/producer"; - -    private final transient WebSocketService service; - -    public WebSocketProducerServlet(WebSocketService service) { -        this.service = service; -    } - -    @Override -    public void configure(WebSocketServletFactory factory) { -        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); -        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { -            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); -        } -        factory.setCreator((request, response) -> -                new ProducerHandler(service, request.getHttpServletRequest(), response)); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import org.eclipse.jetty.websocket.servlet.WebSocketServlet; +import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; + +public class WebSocketProducerServlet extends WebSocketServlet { +    private static final long serialVersionUID = 1L; + +    public static final String SERVLET_PATH = "/ws/producer"; +    public static final String SERVLET_PATH_V2 = "/ws/v2/producer"; + +    private final transient WebSocketService service; + +    public WebSocketProducerServlet(WebSocketService service) { +        this.service = service; +    } + +    @Override +    public void configure(WebSocketServletFactory factory) { +        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); +        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { +            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); +        } +        factory.setCreator((request, response) -> +                new ProducerHandler(service, request.getHttpServletRequest(), response)); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketReaderServlet.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketReaderServlet.java index 9d23d10c39..ba5b9b94ec 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketReaderServlet.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketReaderServlet.java @@ -1,46 +1,46 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import org.eclipse.jetty.websocket.servlet.WebSocketServlet; -import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; - -public class WebSocketReaderServlet extends WebSocketServlet { -    private static final transient long serialVersionUID = 1L; - -    public static final String SERVLET_PATH = "/ws/reader"; -    public static final String SERVLET_PATH_V2 = "/ws/v2/reader"; - -    private final transient WebSocketService service; - -    public WebSocketReaderServlet(WebSocketService service) { -        super(); -        this.service = service; -    } - -    @Override -    public void configure(WebSocketServletFactory factory) { -        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); -        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { -            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); -        } -        factory.setCreator( -                (request, response) -> new ReaderHandler(service, request.getHttpServletRequest(), response)); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import org.eclipse.jetty.websocket.servlet.WebSocketServlet; +import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; + +public class WebSocketReaderServlet extends WebSocketServlet { +    private static final transient long serialVersionUID = 1L; + +    public static final String SERVLET_PATH = "/ws/reader"; +    public static final String SERVLET_PATH_V2 = "/ws/v2/reader"; + +    private final transient WebSocketService service; + +    public WebSocketReaderServlet(WebSocketService service) { +        super(); +        this.service = service; +    } + +    @Override +    public void configure(WebSocketServletFactory factory) { +        factory.getPolicy().setMaxTextMessageSize(service.getConfig().getWebSocketMaxTextFrameSize()); +        if (service.getConfig().getWebSocketSessionIdleTimeoutMillis() > 0) { +            factory.getPolicy().setIdleTimeout(service.getConfig().getWebSocketSessionIdleTimeoutMillis()); +        } +        factory.setCreator( +                (request, response) -> new ReaderHandler(service, request.getHttpServletRequest(), response)); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketService.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketService.java index d379d01d1b..0c8e14d1ff 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketService.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/WebSocketService.java @@ -1,342 +1,342 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static org.apache.commons.lang3.StringUtils.isNotBlank; -import static org.apache.pulsar.common.naming.Constants.WEBSOCKET_DUMMY_ORIGINAL_PRINCIPLE; -import io.netty.util.concurrent.DefaultThreadFactory; -import java.io.Closeable; -import java.io.IOException; -import java.net.MalformedURLException; -import java.util.Map; -import java.util.Optional; -import java.util.Set; -import java.util.concurrent.ConcurrentHashMap; -import java.util.concurrent.Executors; -import java.util.concurrent.ScheduledExecutorService; -import java.util.concurrent.TimeUnit; -import javax.servlet.ServletException; -import javax.websocket.DeploymentException; -import lombok.Getter; -import org.apache.commons.lang3.StringUtils; -import org.apache.pulsar.broker.PulsarServerException; -import org.apache.pulsar.broker.ServiceConfiguration; -import org.apache.pulsar.broker.authentication.AuthenticationService; -import org.apache.pulsar.broker.authorization.AuthorizationService; -import org.apache.pulsar.broker.resources.PulsarResources; -import org.apache.pulsar.client.api.ClientBuilder; -import org.apache.pulsar.client.api.CryptoKeyReader; -import org.apache.pulsar.client.api.PulsarClient; -import org.apache.pulsar.client.api.PulsarClientException; -import org.apache.pulsar.client.api.SizeUnit; -import org.apache.pulsar.client.impl.ClientBuilderImpl; -import org.apache.pulsar.client.internal.PropertiesUtils; -import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; -import org.apache.pulsar.common.policies.data.ClusterData; -import org.apache.pulsar.metadata.api.MetadataStoreException; -import org.apache.pulsar.metadata.api.MetadataStoreException.NotFoundException; -import org.apache.pulsar.metadata.api.extended.MetadataStoreExtended; -import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; -import org.apache.pulsar.websocket.stats.ProxyStats; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * Socket proxy server which initializes other dependent services and starts server by opening web-socket end-point url. - * - */ -public class WebSocketService implements Closeable { - -    AuthenticationService authenticationService; -    AuthorizationService authorizationService; -    PulsarClient pulsarClient; - -    private final ScheduledExecutorService executor; -    private PulsarResources pulsarResources; -    private MetadataStoreExtended configMetadataStore; -    private ServiceConfiguration config; - -    @Getter -    private Optional<CryptoKeyReader> cryptoKeyReader = Optional.empty(); - -    private ClusterData localCluster; -    private final Map<String, Set<ProducerHandler>> topicProducerMap = new ConcurrentHashMap<>(); -    private final Map<String, Set<ConsumerHandler>> topicConsumerMap = new ConcurrentHashMap<>(); -    private final Map<String, Set<ReaderHandler>> topicReaderMap = new ConcurrentHashMap<>(); -    private final ProxyStats proxyStats; - -    public WebSocketService(WebSocketProxyConfiguration config) { -        this(createClusterData(config), PulsarConfigurationLoader.convertFrom(config)); -    } - -    public WebSocketService(ClusterData localCluster, ServiceConfiguration config) { -        this.config = config; -        this.executor = Executors -                .newScheduledThreadPool(config.getWebSocketNumServiceThreads(), -                        new DefaultThreadFactory("pulsar-websocket")); -        this.localCluster = localCluster; -        this.proxyStats = new ProxyStats(this); -    } - -    public void start() throws PulsarServerException, PulsarClientException, MalformedURLException, ServletException, -            DeploymentException { - -        if (isNotBlank(config.getConfigurationMetadataStoreUrl())) { -            try { -                configMetadataStore = createConfigMetadataStore(config.getConfigurationMetadataStoreUrl(), -                        (int) config.getMetadataStoreSessionTimeoutMillis(), -                        config.isMetadataStoreAllowReadOnlyOperations()); -            } catch (MetadataStoreException e) { -                throw new PulsarServerException(e); -            } -            pulsarResources = new PulsarResources(null, configMetadataStore); -        } - -        // start authorizationService -        if (config.isAuthorizationEnabled()) { -            if (pulsarResources == null) { -                throw new PulsarServerException( -                        "Failed to initialize authorization manager due to empty ConfigurationStoreServers"); -            } -            authorizationService = new AuthorizationService(this.config, pulsarResources); -        } -        // start authentication service -        authenticationService = new AuthenticationService(this.config); -        // initialize crypto key reader -        String cryptoFactoryClassName = (String) config.getProperties().get("cryptoKeyReaderFactoryClassName"); -        if (StringUtils.isNotBlank(cryptoFactoryClassName)) { -            try { -                CryptoKeyReaderFactory factoryInstance = (CryptoKeyReaderFactory) Class.forName(cryptoFactoryClassName) -                        .getDeclaredConstructor().newInstance(); -                cryptoKeyReader = Optional.ofNullable(factoryInstance.create()); -            } catch (Exception e) { -                log.info("Failed to initialize crypto-key reader", e); -                throw new PulsarServerException(e); -            } -        } - -        log.info("Pulsar WebSocket Service started"); -    } - -    public MetadataStoreExtended createConfigMetadataStore(String serverUrls, int sessionTimeoutMs, boolean -            isAllowReadOnlyOperations) -            throws MetadataStoreException { -        return PulsarResources.createConfigMetadataStore(serverUrls, sessionTimeoutMs, isAllowReadOnlyOperations); -    } - -    @Override -    public void close() throws IOException { -        if (pulsarClient != null) { -            pulsarClient.close(); -        } - -        if (authenticationService != null) { -            authenticationService.close(); -        } - -        if (configMetadataStore != null) { -            try { -                configMetadataStore.close(); -            } catch (Exception e) { -                throw new IOException(e); -            } -        } - -        executor.shutdown(); -    } - -    public AuthenticationService getAuthenticationService() { -        return authenticationService; -    } - -    public AuthorizationService getAuthorizationService() { -        return authorizationService; -    } - -    public synchronized PulsarClient getPulsarClient() throws IOException { -        // Do lazy initialization of client -        if (pulsarClient == null) { -            if (localCluster == null) { -                // If not explicitly set, read clusters data from ZK -                localCluster = retrieveClusterData(); -            } -            pulsarClient = createClientInstance(localCluster); -        } -        return pulsarClient; -    } - -    public synchronized void setLocalCluster(ClusterData clusterData) { -        this.localCluster = clusterData; -    } - -    private PulsarClient createClientInstance(ClusterData clusterData) throws IOException { -        ClientBuilder clientBuilder = PulsarClient.builder() // -                .memoryLimit(SizeUnit.MEGA_BYTES.toBytes(config.getWebSocketPulsarClientMemoryLimitInMB()), -                        SizeUnit.BYTES) -                .statsInterval(0, TimeUnit.SECONDS) // -                .enableTls(config.isTlsEnabled()) // -                .allowTlsInsecureConnection(config.isTlsAllowInsecureConnection()) // -                .enableTlsHostnameVerification(config.isTlsHostnameVerificationEnabled()) -                .tlsTrustCertsFilePath(config.getBrokerClientTrustCertsFilePath()) // -                .ioThreads(config.getWebSocketNumIoThreads()) // -                .connectionsPerBroker(config.getWebSocketConnectionsPerBroker()); -        if (clientBuilder instanceof  ClientBuilderImpl) { -            ((ClientBuilderImpl) clientBuilder).originalPrincipal(WEBSOCKET_DUMMY_ORIGINAL_PRINCIPLE); -        } - -        // Apply all arbitrary configuration. This must be called before setting any fields annotated as -        // @Secret on the ClientConfigurationData object because of the way they are serialized. -        // See https://github.com/apache/pulsar/issues/8509 for more information. -        clientBuilder.loadConf(PropertiesUtils.filterAndMapProperties(config.getProperties(), "brokerClient_")); -        // Disabled auto release useless connection. -        clientBuilder.connectionMaxIdleSeconds(-1); - -        if (isNotBlank(config.getBrokerClientAuthenticationPlugin()) -                && isNotBlank(config.getBrokerClientAuthenticationParameters())) { -            clientBuilder.authentication(config.getBrokerClientAuthenticationPlugin(), -                    config.getBrokerClientAuthenticationParameters()); -        } - -        if (config.isBrokerClientTlsEnabled()) { -            if (isNotBlank(clusterData.getBrokerServiceUrlTls())) { -                clientBuilder.serviceUrl(clusterData.getBrokerServiceUrlTls()); -            } else if (isNotBlank(clusterData.getServiceUrlTls())) { -                clientBuilder.serviceUrl(clusterData.getServiceUrlTls()); -            } -        } else if (isNotBlank(clusterData.getBrokerServiceUrl())) { -            clientBuilder.serviceUrl(clusterData.getBrokerServiceUrl()); -        } else { -            clientBuilder.serviceUrl(clusterData.getServiceUrl()); -        } -        return clientBuilder.build(); -    } - -    private static ClusterData createClusterData(WebSocketProxyConfiguration config) { -        if (isNotBlank(config.getBrokerServiceUrl()) || isNotBlank(config.getBrokerServiceUrlTls())) { -            return ClusterData.builder() -                    .serviceUrl(config.getServiceUrl()) -                    .serviceUrlTls(config.getServiceUrlTls()) -                    .brokerServiceUrl(config.getBrokerServiceUrl()) -                    .brokerServiceUrlTls(config.getBrokerServiceUrlTls()) -                    .build(); -        } else if (isNotBlank(config.getServiceUrl()) || isNotBlank(config.getServiceUrlTls())) { -            return ClusterData.builder() -                    .serviceUrl(config.getServiceUrl()) -                    .serviceUrlTls(config.getServiceUrlTls()) -                    .build(); -        } else { -            return null; -        } -    } - -    private ClusterData retrieveClusterData() throws PulsarServerException { -        if (pulsarResources == null) { -            throw new PulsarServerException( -                "Failed to retrieve Cluster data due to empty ConfigurationStoreServers"); -        } -        try { -            return localCluster = pulsarResources.getClusterResources().getCluster(config.getClusterName()) -                    .orElseThrow(() -> new NotFoundException("Cluster " + config.getClusterName())); -        } catch (Exception e) { -            throw new PulsarServerException(e); -        } -    } - -    public ProxyStats getProxyStats() { -        return proxyStats; -    } - -    public ScheduledExecutorService getExecutor() { -        return executor; -    } - -    public boolean isAuthenticationEnabled() { -        if (this.config == null) { -            return false; -        } -        return this.config.isAuthenticationEnabled(); -    } - -    public boolean isAuthorizationEnabled() { -        if (this.config == null) { -            return false; -        } -        return this.config.isAuthorizationEnabled(); -    } - -    public boolean addProducer(ProducerHandler producer) { -        return topicProducerMap -                .computeIfAbsent(producer.getProducer().getTopic(), -                        topic -> ConcurrentHashMap.newKeySet()) -                .add(producer); -    } - -    public Map<String, Set<ProducerHandler>> getProducers() { -        return topicProducerMap; -    } - -    public boolean removeProducer(ProducerHandler producer) { -        final String topicName = producer.getProducer().getTopic(); -        if (topicProducerMap.containsKey(topicName)) { -            return topicProducerMap.get(topicName).remove(producer); -        } -        return false; -    } - -    public boolean addConsumer(ConsumerHandler consumer) { -        return topicConsumerMap -                .computeIfAbsent(consumer.getConsumer().getTopic(), topic -> ConcurrentHashMap.newKeySet()) -                .add(consumer); -    } - -    public Map<String, Set<ConsumerHandler>> getConsumers() { -        return topicConsumerMap; -    } - -    public boolean removeConsumer(ConsumerHandler consumer) { -        final String topicName = consumer.getConsumer().getTopic(); -        if (topicConsumerMap.containsKey(topicName)) { -            return topicConsumerMap.get(topicName).remove(consumer); -        } -        return false; -    } - -    public boolean addReader(ReaderHandler reader) { -        return topicReaderMap.computeIfAbsent(reader.getConsumer().getTopic(), topic -> ConcurrentHashMap.newKeySet()) -                .add(reader); -    } - -    public Map<String, Set<ReaderHandler>> getReaders() { -        return topicReaderMap; -    } - -    public boolean removeReader(ReaderHandler reader) { -        final String topicName = reader.getConsumer().getTopic(); -        if (topicReaderMap.containsKey(topicName)) { -            return topicReaderMap.get(topicName).remove(reader); -        } -        return false; -    } - -    public ServiceConfiguration getConfig() { -        return config; -    } - -    private static final Logger log = LoggerFactory.getLogger(WebSocketService.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static org.apache.commons.lang3.StringUtils.isNotBlank; +import static org.apache.pulsar.common.naming.Constants.WEBSOCKET_DUMMY_ORIGINAL_PRINCIPLE; +import io.netty.util.concurrent.DefaultThreadFactory; +import java.io.Closeable; +import java.io.IOException; +import java.net.MalformedURLException; +import java.util.Map; +import java.util.Optional; +import java.util.Set; +import java.util.concurrent.ConcurrentHashMap; +import java.util.concurrent.Executors; +import java.util.concurrent.ScheduledExecutorService; +import java.util.concurrent.TimeUnit; +import javax.servlet.ServletException; +import javax.websocket.DeploymentException; +import lombok.Getter; +import org.apache.commons.lang3.StringUtils; +import org.apache.pulsar.broker.PulsarServerException; +import org.apache.pulsar.broker.ServiceConfiguration; +import org.apache.pulsar.broker.authentication.AuthenticationService; +import org.apache.pulsar.broker.authorization.AuthorizationService; +import org.apache.pulsar.broker.resources.PulsarResources; +import org.apache.pulsar.client.api.ClientBuilder; +import org.apache.pulsar.client.api.CryptoKeyReader; +import org.apache.pulsar.client.api.PulsarClient; +import org.apache.pulsar.client.api.PulsarClientException; +import org.apache.pulsar.client.api.SizeUnit; +import org.apache.pulsar.client.impl.ClientBuilderImpl; +import org.apache.pulsar.client.internal.PropertiesUtils; +import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; +import org.apache.pulsar.common.policies.data.ClusterData; +import org.apache.pulsar.metadata.api.MetadataStoreException; +import org.apache.pulsar.metadata.api.MetadataStoreException.NotFoundException; +import org.apache.pulsar.metadata.api.extended.MetadataStoreExtended; +import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; +import org.apache.pulsar.websocket.stats.ProxyStats; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * Socket proxy server which initializes other dependent services and starts server by opening web-socket end-point url. + * + */ +public class WebSocketService implements Closeable { + +    AuthenticationService authenticationService; +    AuthorizationService authorizationService; +    PulsarClient pulsarClient; + +    private final ScheduledExecutorService executor; +    private PulsarResources pulsarResources; +    private MetadataStoreExtended configMetadataStore; +    private ServiceConfiguration config; + +    @Getter +    private Optional<CryptoKeyReader> cryptoKeyReader = Optional.empty(); + +    private ClusterData localCluster; +    private final Map<String, Set<ProducerHandler>> topicProducerMap = new ConcurrentHashMap<>(); +    private final Map<String, Set<ConsumerHandler>> topicConsumerMap = new ConcurrentHashMap<>(); +    private final Map<String, Set<ReaderHandler>> topicReaderMap = new ConcurrentHashMap<>(); +    private final ProxyStats proxyStats; + +    public WebSocketService(WebSocketProxyConfiguration config) { +        this(createClusterData(config), PulsarConfigurationLoader.convertFrom(config)); +    } + +    public WebSocketService(ClusterData localCluster, ServiceConfiguration config) { +        this.config = config; +        this.executor = Executors +                .newScheduledThreadPool(config.getWebSocketNumServiceThreads(), +                        new DefaultThreadFactory("pulsar-websocket")); +        this.localCluster = localCluster; +        this.proxyStats = new ProxyStats(this); +    } + +    public void start() throws PulsarServerException, PulsarClientException, MalformedURLException, ServletException, +            DeploymentException { + +        if (isNotBlank(config.getConfigurationMetadataStoreUrl())) { +            try { +                configMetadataStore = createConfigMetadataStore(config.getConfigurationMetadataStoreUrl(), +                        (int) config.getMetadataStoreSessionTimeoutMillis(), +                        config.isMetadataStoreAllowReadOnlyOperations()); +            } catch (MetadataStoreException e) { +                throw new PulsarServerException(e); +            } +            pulsarResources = new PulsarResources(null, configMetadataStore); +        } + +        // start authorizationService +        if (config.isAuthorizationEnabled()) { +            if (pulsarResources == null) { +                throw new PulsarServerException( +                        "Failed to initialize authorization manager due to empty ConfigurationStoreServers"); +            } +            authorizationService = new AuthorizationService(this.config, pulsarResources); +        } +        // start authentication service +        authenticationService = new AuthenticationService(this.config); +        // initialize crypto key reader +        String cryptoFactoryClassName = (String) config.getProperties().get("cryptoKeyReaderFactoryClassName"); +        if (StringUtils.isNotBlank(cryptoFactoryClassName)) { +            try { +                CryptoKeyReaderFactory factoryInstance = (CryptoKeyReaderFactory) Class.forName(cryptoFactoryClassName) +                        .getDeclaredConstructor().newInstance(); +                cryptoKeyReader = Optional.ofNullable(factoryInstance.create()); +            } catch (Exception e) { +                log.info("Failed to initialize crypto-key reader", e); +                throw new PulsarServerException(e); +            } +        } + +        log.info("Pulsar WebSocket Service started"); +    } + +    public MetadataStoreExtended createConfigMetadataStore(String serverUrls, int sessionTimeoutMs, boolean +            isAllowReadOnlyOperations) +            throws MetadataStoreException { +        return PulsarResources.createConfigMetadataStore(serverUrls, sessionTimeoutMs, isAllowReadOnlyOperations); +    } + +    @Override +    public void close() throws IOException { +        if (pulsarClient != null) { +            pulsarClient.close(); +        } + +        if (authenticationService != null) { +            authenticationService.close(); +        } + +        if (configMetadataStore != null) { +            try { +                configMetadataStore.close(); +            } catch (Exception e) { +                throw new IOException(e); +            } +        } + +        executor.shutdown(); +    } + +    public AuthenticationService getAuthenticationService() { +        return authenticationService; +    } + +    public AuthorizationService getAuthorizationService() { +        return authorizationService; +    } + +    public synchronized PulsarClient getPulsarClient() throws IOException { +        // Do lazy initialization of client +        if (pulsarClient == null) { +            if (localCluster == null) { +                // If not explicitly set, read clusters data from ZK +                localCluster = retrieveClusterData(); +            } +            pulsarClient = createClientInstance(localCluster); +        } +        return pulsarClient; +    } + +    public synchronized void setLocalCluster(ClusterData clusterData) { +        this.localCluster = clusterData; +    } + +    private PulsarClient createClientInstance(ClusterData clusterData) throws IOException { +        ClientBuilder clientBuilder = PulsarClient.builder() // +                .memoryLimit(SizeUnit.MEGA_BYTES.toBytes(config.getWebSocketPulsarClientMemoryLimitInMB()), +                        SizeUnit.BYTES) +                .statsInterval(0, TimeUnit.SECONDS) // +                .enableTls(config.isTlsEnabled()) // +                .allowTlsInsecureConnection(config.isTlsAllowInsecureConnection()) // +                .enableTlsHostnameVerification(config.isTlsHostnameVerificationEnabled()) +                .tlsTrustCertsFilePath(config.getBrokerClientTrustCertsFilePath()) // +                .ioThreads(config.getWebSocketNumIoThreads()) // +                .connectionsPerBroker(config.getWebSocketConnectionsPerBroker()); +        if (clientBuilder instanceof  ClientBuilderImpl) { +            ((ClientBuilderImpl) clientBuilder).originalPrincipal(WEBSOCKET_DUMMY_ORIGINAL_PRINCIPLE); +        } + +        // Apply all arbitrary configuration. This must be called before setting any fields annotated as +        // @Secret on the ClientConfigurationData object because of the way they are serialized. +        // See https://github.com/apache/pulsar/issues/8509 for more information. +        clientBuilder.loadConf(PropertiesUtils.filterAndMapProperties(config.getProperties(), "brokerClient_")); +        // Disabled auto release useless connection. +        clientBuilder.connectionMaxIdleSeconds(-1); + +        if (isNotBlank(config.getBrokerClientAuthenticationPlugin()) +                && isNotBlank(config.getBrokerClientAuthenticationParameters())) { +            clientBuilder.authentication(config.getBrokerClientAuthenticationPlugin(), +                    config.getBrokerClientAuthenticationParameters()); +        } + +        if (config.isBrokerClientTlsEnabled()) { +            if (isNotBlank(clusterData.getBrokerServiceUrlTls())) { +                clientBuilder.serviceUrl(clusterData.getBrokerServiceUrlTls()); +            } else if (isNotBlank(clusterData.getServiceUrlTls())) { +                clientBuilder.serviceUrl(clusterData.getServiceUrlTls()); +            } +        } else if (isNotBlank(clusterData.getBrokerServiceUrl())) { +            clientBuilder.serviceUrl(clusterData.getBrokerServiceUrl()); +        } else { +            clientBuilder.serviceUrl(clusterData.getServiceUrl()); +        } +        return clientBuilder.build(); +    } + +    private static ClusterData createClusterData(WebSocketProxyConfiguration config) { +        if (isNotBlank(config.getBrokerServiceUrl()) || isNotBlank(config.getBrokerServiceUrlTls())) { +            return ClusterData.builder() +                    .serviceUrl(config.getServiceUrl()) +                    .serviceUrlTls(config.getServiceUrlTls()) +                    .brokerServiceUrl(config.getBrokerServiceUrl()) +                    .brokerServiceUrlTls(config.getBrokerServiceUrlTls()) +                    .build(); +        } else if (isNotBlank(config.getServiceUrl()) || isNotBlank(config.getServiceUrlTls())) { +            return ClusterData.builder() +                    .serviceUrl(config.getServiceUrl()) +                    .serviceUrlTls(config.getServiceUrlTls()) +                    .build(); +        } else { +            return null; +        } +    } + +    private ClusterData retrieveClusterData() throws PulsarServerException { +        if (pulsarResources == null) { +            throw new PulsarServerException( +                "Failed to retrieve Cluster data due to empty ConfigurationStoreServers"); +        } +        try { +            return localCluster = pulsarResources.getClusterResources().getCluster(config.getClusterName()) +                    .orElseThrow(() -> new NotFoundException("Cluster " + config.getClusterName())); +        } catch (Exception e) { +            throw new PulsarServerException(e); +        } +    } + +    public ProxyStats getProxyStats() { +        return proxyStats; +    } + +    public ScheduledExecutorService getExecutor() { +        return executor; +    } + +    public boolean isAuthenticationEnabled() { +        if (this.config == null) { +            return false; +        } +        return this.config.isAuthenticationEnabled(); +    } + +    public boolean isAuthorizationEnabled() { +        if (this.config == null) { +            return false; +        } +        return this.config.isAuthorizationEnabled(); +    } + +    public boolean addProducer(ProducerHandler producer) { +        return topicProducerMap +                .computeIfAbsent(producer.getProducer().getTopic(), +                        topic -> ConcurrentHashMap.newKeySet()) +                .add(producer); +    } + +    public Map<String, Set<ProducerHandler>> getProducers() { +        return topicProducerMap; +    } + +    public boolean removeProducer(ProducerHandler producer) { +        final String topicName = producer.getProducer().getTopic(); +        if (topicProducerMap.containsKey(topicName)) { +            return topicProducerMap.get(topicName).remove(producer); +        } +        return false; +    } + +    public boolean addConsumer(ConsumerHandler consumer) { +        return topicConsumerMap +                .computeIfAbsent(consumer.getConsumer().getTopic(), topic -> ConcurrentHashMap.newKeySet()) +                .add(consumer); +    } + +    public Map<String, Set<ConsumerHandler>> getConsumers() { +        return topicConsumerMap; +    } + +    public boolean removeConsumer(ConsumerHandler consumer) { +        final String topicName = consumer.getConsumer().getTopic(); +        if (topicConsumerMap.containsKey(topicName)) { +            return topicConsumerMap.get(topicName).remove(consumer); +        } +        return false; +    } + +    public boolean addReader(ReaderHandler reader) { +        return topicReaderMap.computeIfAbsent(reader.getConsumer().getTopic(), topic -> ConcurrentHashMap.newKeySet()) +                .add(reader); +    } + +    public Map<String, Set<ReaderHandler>> getReaders() { +        return topicReaderMap; +    } + +    public boolean removeReader(ReaderHandler reader) { +        final String topicName = reader.getConsumer().getTopic(); +        if (topicReaderMap.containsKey(topicName)) { +            return topicReaderMap.get(topicName).remove(reader); +        } +        return false; +    } + +    public ServiceConfiguration getConfig() { +        return config; +    } + +    private static final Logger log = LoggerFactory.getLogger(WebSocketService.class); +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketProxyStatsBase.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketProxyStatsBase.java index 682b64d51b..506901138b 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketProxyStatsBase.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketProxyStatsBase.java @@ -1,114 +1,114 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin; - -import java.util.Collection; -import java.util.HashMap; -import java.util.Map; -import javax.ws.rs.core.Response.Status; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.stats.Metrics; -import org.apache.pulsar.common.util.RestException; -import org.apache.pulsar.websocket.stats.ProxyTopicStat; -import org.apache.pulsar.websocket.stats.ProxyTopicStat.ConsumerStats; -import org.apache.pulsar.websocket.stats.ProxyTopicStat.ProducerStats; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -public class WebSocketProxyStatsBase extends WebSocketWebResource { -    private static final Logger LOG = LoggerFactory.getLogger(WebSocketProxyStatsBase.class); - -    protected Collection<Metrics> internalGetMetrics() throws Exception { -        // Ensure super user access only -        validateSuperUserAccess(); -        try { -            return service().getProxyStats().getMetrics(); -        } catch (Exception e) { -            LOG.error("[{}] Failed to generate metrics", clientAppId(), e); -            throw new RestException(e); -        } -    } - -    protected ProxyTopicStat internalGetStats(TopicName topicName) { -        validateUserAccess(topicName); -        ProxyTopicStat stats = getStat(topicName); -        if (stats == null) { -            throw new RestException(Status.NOT_FOUND, "Topic does not exist"); -        } -        return stats; -    } - -    protected Map<String, ProxyTopicStat> internalGetProxyStats() { -        validateSuperUserAccess(); -        return getStat(); -    } - -    private ProxyTopicStat getStat(TopicName topicName) { -        String topicNameStr = topicName.toString(); -        if (!service().getProducers().containsKey(topicNameStr) && !service().getConsumers().containsKey(topicNameStr) -                && !service().getReaders().containsKey(topicNameStr)) { -            LOG.warn("topic doesn't exist {}", topicNameStr); -            throw new RestException(Status.NOT_FOUND, "Topic does not exist"); -        } -        ProxyTopicStat topicStat = new ProxyTopicStat(); -        if (service().getProducers().containsKey(topicNameStr)) { -            service().getProducers().get(topicNameStr).forEach(handler -> { -                ProducerStats stat = new ProducerStats(handler); -                topicStat.producerStats.add(stat); - -            }); -        } - -        if (service().getConsumers().containsKey(topicNameStr)) { -            service().getConsumers().get(topicNameStr).forEach(handler -> { -                topicStat.consumerStats.add(new ConsumerStats(handler)); -            }); -        } - -        if (service().getReaders().containsKey(topicNameStr)) { -            service().getReaders().get(topicNameStr).forEach(handler -> { -                topicStat.consumerStats.add(new ConsumerStats(handler)); -            }); -        } -        return topicStat; -    } - -    public Map<String, ProxyTopicStat> getStat() { - -        Map<String, ProxyTopicStat> statMap = new HashMap<>(); - -        service().getProducers().forEach((topicName, handlers) -> { -            ProxyTopicStat topicStat = statMap.computeIfAbsent(topicName, t -> new ProxyTopicStat()); -            handlers.forEach(handler -> topicStat.producerStats.add(new ProducerStats(handler))); -            statMap.put(topicName, topicStat); -        }); -        service().getConsumers().forEach((topicName, handlers) -> { -            ProxyTopicStat topicStat = statMap.computeIfAbsent(topicName, t -> new ProxyTopicStat()); -            handlers.forEach(handler -> topicStat.consumerStats.add(new ConsumerStats(handler))); -            statMap.put(topicName, topicStat); -        }); -        service().getReaders().forEach((topicName, handlers) -> { -            ProxyTopicStat topicStat = statMap.computeIfAbsent(topicName, t -> new ProxyTopicStat()); -            handlers.forEach(handler -> topicStat.consumerStats.add(new ConsumerStats(handler))); -            statMap.put(topicName, topicStat); -        }); - -        return statMap; -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin; + +import java.util.Collection; +import java.util.HashMap; +import java.util.Map; +import javax.ws.rs.core.Response.Status; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.stats.Metrics; +import org.apache.pulsar.common.util.RestException; +import org.apache.pulsar.websocket.stats.ProxyTopicStat; +import org.apache.pulsar.websocket.stats.ProxyTopicStat.ConsumerStats; +import org.apache.pulsar.websocket.stats.ProxyTopicStat.ProducerStats; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +public class WebSocketProxyStatsBase extends WebSocketWebResource { +    private static final Logger LOG = LoggerFactory.getLogger(WebSocketProxyStatsBase.class); + +    protected Collection<Metrics> internalGetMetrics() throws Exception { +        // Ensure super user access only +        validateSuperUserAccess(); +        try { +            return service().getProxyStats().getMetrics(); +        } catch (Exception e) { +            LOG.error("[{}] Failed to generate metrics", clientAppId(), e); +            throw new RestException(e); +        } +    } + +    protected ProxyTopicStat internalGetStats(TopicName topicName) { +        validateUserAccess(topicName); +        ProxyTopicStat stats = getStat(topicName); +        if (stats == null) { +            throw new RestException(Status.NOT_FOUND, "Topic does not exist"); +        } +        return stats; +    } + +    protected Map<String, ProxyTopicStat> internalGetProxyStats() { +        validateSuperUserAccess(); +        return getStat(); +    } + +    private ProxyTopicStat getStat(TopicName topicName) { +        String topicNameStr = topicName.toString(); +        if (!service().getProducers().containsKey(topicNameStr) && !service().getConsumers().containsKey(topicNameStr) +                && !service().getReaders().containsKey(topicNameStr)) { +            LOG.warn("topic doesn't exist {}", topicNameStr); +            throw new RestException(Status.NOT_FOUND, "Topic does not exist"); +        } +        ProxyTopicStat topicStat = new ProxyTopicStat(); +        if (service().getProducers().containsKey(topicNameStr)) { +            service().getProducers().get(topicNameStr).forEach(handler -> { +                ProducerStats stat = new ProducerStats(handler); +                topicStat.producerStats.add(stat); + +            }); +        } + +        if (service().getConsumers().containsKey(topicNameStr)) { +            service().getConsumers().get(topicNameStr).forEach(handler -> { +                topicStat.consumerStats.add(new ConsumerStats(handler)); +            }); +        } + +        if (service().getReaders().containsKey(topicNameStr)) { +            service().getReaders().get(topicNameStr).forEach(handler -> { +                topicStat.consumerStats.add(new ConsumerStats(handler)); +            }); +        } +        return topicStat; +    } + +    public Map<String, ProxyTopicStat> getStat() { + +        Map<String, ProxyTopicStat> statMap = new HashMap<>(); + +        service().getProducers().forEach((topicName, handlers) -> { +            ProxyTopicStat topicStat = statMap.computeIfAbsent(topicName, t -> new ProxyTopicStat()); +            handlers.forEach(handler -> topicStat.producerStats.add(new ProducerStats(handler))); +            statMap.put(topicName, topicStat); +        }); +        service().getConsumers().forEach((topicName, handlers) -> { +            ProxyTopicStat topicStat = statMap.computeIfAbsent(topicName, t -> new ProxyTopicStat()); +            handlers.forEach(handler -> topicStat.consumerStats.add(new ConsumerStats(handler))); +            statMap.put(topicName, topicStat); +        }); +        service().getReaders().forEach((topicName, handlers) -> { +            ProxyTopicStat topicStat = statMap.computeIfAbsent(topicName, t -> new ProxyTopicStat()); +            handlers.forEach(handler -> topicStat.consumerStats.add(new ConsumerStats(handler))); +            statMap.put(topicName, topicStat); +        }); + +        return statMap; +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketWebResource.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketWebResource.java index 6515a01c47..6150b5c67e 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketWebResource.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/WebSocketWebResource.java @@ -1,160 +1,160 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin; - -import static org.apache.commons.lang3.StringUtils.isBlank; -import javax.naming.AuthenticationException; -import javax.servlet.ServletContext; -import javax.servlet.http.HttpServletRequest; -import javax.ws.rs.core.Context; -import javax.ws.rs.core.Response.Status; -import javax.ws.rs.core.UriInfo; -import org.apache.pulsar.broker.authentication.AuthenticationDataHttps; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.web.AuthenticationFilter; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.util.RestException; -import org.apache.pulsar.websocket.WebSocketService; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -public class WebSocketWebResource { - -    public static final String ATTRIBUTE_PROXY_SERVICE_NAME = "webProxyService"; -    public static final String ADMIN_PATH_V1 = "/admin"; -    public static final String ADMIN_PATH_V2 = "/admin/v2"; - -    @Context -    protected ServletContext servletContext; - -    @Context -    protected HttpServletRequest httpRequest; - -    @Context -    protected UriInfo uri; - -    private WebSocketService socketService; - -    private String clientId; -    private AuthenticationDataSource authenticationDataSource; - -    protected WebSocketService service() { -        if (socketService == null) { -            socketService = (WebSocketService) servletContext.getAttribute(ATTRIBUTE_PROXY_SERVICE_NAME); -        } -        return socketService; -    } - -    /** -     * Gets a caller id (IP + role). -     * -     * @return the web service caller identification -     */ -    public String clientAppId() { -        if (isBlank(clientId)) { -            try { -                String authMethodName = httpRequest.getHeader(AuthenticationFilter.PULSAR_AUTH_METHOD_NAME); -                if (authMethodName != null -                    && service().getAuthenticationService().getAuthenticationProvider(authMethodName) != null) { -                    authenticationDataSource = service().getAuthenticationService() -                            .getAuthenticationProvider(authMethodName) -                            .newHttpAuthState(httpRequest).getAuthDataSource(); -                    clientId = service().getAuthenticationService().authenticateHttpRequest( -                            httpRequest, authenticationDataSource); -                } else { -                    clientId = service().getAuthenticationService().authenticateHttpRequest(httpRequest); -                    authenticationDataSource = new AuthenticationDataHttps(httpRequest); -                } -            } catch (AuthenticationException e) { -                if (service().getConfig().isAuthenticationEnabled()) { -                    throw new RestException(Status.UNAUTHORIZED, "Failed to get clientId from request"); -                } -            } - -            if (isBlank(clientId) && service().getConfig().isAuthenticationEnabled()) { -                throw new RestException(Status.UNAUTHORIZED, "Failed to get auth data from the request"); -            } -        } -        return clientId; -    } - -    public AuthenticationDataSource authData() throws AuthenticationException { -        return authenticationDataSource; -    } - -    /** -     * Checks whether the user has Pulsar Super-User access to the system. -     * -     * @throws RestException -     *             if not authorized -     */ -    protected void validateSuperUserAccess() { -        if (service().getConfig().isAuthenticationEnabled()) { -            String appId = clientAppId(); -            if (log.isDebugEnabled()) { -                log.debug("[{}] Check super user access: Authenticated: {} -- Role: {}", uri.getRequestUri(), -                        clientAppId(), appId); -            } -            if (!service().getConfig().getSuperUserRoles().contains(appId)) { -                throw new RestException(Status.UNAUTHORIZED, "This operation requires super-user access"); -            } -        } -    } - -    /** -     * Checks if user has super-user access or user is authorized to produce/consume on a given topic. -     * -     * @param topic -     * @throws RestException -     */ -    protected void validateUserAccess(TopicName topic) { -        boolean isAuthorized = false; - -        try { -            validateSuperUserAccess(); -            isAuthorized = true; -        } catch (Exception e) { -            try { -                isAuthorized = isAuthorized(topic); -            } catch (Exception ne) { -                throw new RestException(ne); -            } -        } - -        if (!isAuthorized) { -            throw new RestException(Status.UNAUTHORIZED, "Don't have permission to access this topic"); -        } -    } - -    /** -     * Checks if user is authorized to produce/consume on a given topic. -     * -     * @param topic -     * @return -     * @throws Exception -     */ -    protected boolean isAuthorized(TopicName topic) throws Exception { -        if (service().isAuthorizationEnabled()) { -            return service().getAuthorizationService().canLookup(topic, clientAppId(), authData()); -        } -        return true; -    } - -    private static final Logger log = LoggerFactory.getLogger(WebSocketWebResource.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin; + +import static org.apache.commons.lang3.StringUtils.isBlank; +import javax.naming.AuthenticationException; +import javax.servlet.ServletContext; +import javax.servlet.http.HttpServletRequest; +import javax.ws.rs.core.Context; +import javax.ws.rs.core.Response.Status; +import javax.ws.rs.core.UriInfo; +import org.apache.pulsar.broker.authentication.AuthenticationDataHttps; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.web.AuthenticationFilter; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.util.RestException; +import org.apache.pulsar.websocket.WebSocketService; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +public class WebSocketWebResource { + +    public static final String ATTRIBUTE_PROXY_SERVICE_NAME = "webProxyService"; +    public static final String ADMIN_PATH_V1 = "/admin"; +    public static final String ADMIN_PATH_V2 = "/admin/v2"; + +    @Context +    protected ServletContext servletContext; + +    @Context +    protected HttpServletRequest httpRequest; + +    @Context +    protected UriInfo uri; + +    private WebSocketService socketService; + +    private String clientId; +    private AuthenticationDataSource authenticationDataSource; + +    protected WebSocketService service() { +        if (socketService == null) { +            socketService = (WebSocketService) servletContext.getAttribute(ATTRIBUTE_PROXY_SERVICE_NAME); +        } +        return socketService; +    } + +    /** +     * Gets a caller id (IP + role). +     * +     * @return the web service caller identification +     */ +    public String clientAppId() { +        if (isBlank(clientId)) { +            try { +                String authMethodName = httpRequest.getHeader(AuthenticationFilter.PULSAR_AUTH_METHOD_NAME); +                if (authMethodName != null +                    && service().getAuthenticationService().getAuthenticationProvider(authMethodName) != null) { +                    authenticationDataSource = service().getAuthenticationService() +                            .getAuthenticationProvider(authMethodName) +                            .newHttpAuthState(httpRequest).getAuthDataSource(); +                    clientId = service().getAuthenticationService().authenticateHttpRequest( +                            httpRequest, authenticationDataSource); +                } else { +                    clientId = service().getAuthenticationService().authenticateHttpRequest(httpRequest); +                    authenticationDataSource = new AuthenticationDataHttps(httpRequest); +                } +            } catch (AuthenticationException e) { +                if (service().getConfig().isAuthenticationEnabled()) { +                    throw new RestException(Status.UNAUTHORIZED, "Failed to get clientId from request"); +                } +            } + +            if (isBlank(clientId) && service().getConfig().isAuthenticationEnabled()) { +                throw new RestException(Status.UNAUTHORIZED, "Failed to get auth data from the request"); +            } +        } +        return clientId; +    } + +    public AuthenticationDataSource authData() throws AuthenticationException { +        return authenticationDataSource; +    } + +    /** +     * Checks whether the user has Pulsar Super-User access to the system. +     * +     * @throws RestException +     *             if not authorized +     */ +    protected void validateSuperUserAccess() { +        if (service().getConfig().isAuthenticationEnabled()) { +            String appId = clientAppId(); +            if (log.isDebugEnabled()) { +                log.debug("[{}] Check super user access: Authenticated: {} -- Role: {}", uri.getRequestUri(), +                        clientAppId(), appId); +            } +            if (!service().getConfig().getSuperUserRoles().contains(appId)) { +                throw new RestException(Status.UNAUTHORIZED, "This operation requires super-user access"); +            } +        } +    } + +    /** +     * Checks if user has super-user access or user is authorized to produce/consume on a given topic. +     * +     * @param topic +     * @throws RestException +     */ +    protected void validateUserAccess(TopicName topic) { +        boolean isAuthorized = false; + +        try { +            validateSuperUserAccess(); +            isAuthorized = true; +        } catch (Exception e) { +            try { +                isAuthorized = isAuthorized(topic); +            } catch (Exception ne) { +                throw new RestException(ne); +            } +        } + +        if (!isAuthorized) { +            throw new RestException(Status.UNAUTHORIZED, "Don't have permission to access this topic"); +        } +    } + +    /** +     * Checks if user is authorized to produce/consume on a given topic. +     * +     * @param topic +     * @return +     * @throws Exception +     */ +    protected boolean isAuthorized(TopicName topic) throws Exception { +        if (service().isAuthorizationEnabled()) { +            return service().getAuthorizationService().canLookup(topic, clientAppId(), authData()); +        } +        return true; +    } + +    private static final Logger log = LoggerFactory.getLogger(WebSocketWebResource.class); +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/package-info.java index 14245c4d1e..f4598f7845 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin; diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/WebSocketProxyStatsV1.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/WebSocketProxyStatsV1.java index 66dc1d4942..9d479a54da 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/WebSocketProxyStatsV1.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/WebSocketProxyStatsV1.java @@ -1,72 +1,72 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin.v1; - -import static org.apache.pulsar.common.util.Codec.decode; -import io.swagger.annotations.Api; -import io.swagger.annotations.ApiOperation; -import io.swagger.annotations.ApiResponse; -import io.swagger.annotations.ApiResponses; -import java.util.Collection; -import java.util.Map; -import javax.ws.rs.Encoded; -import javax.ws.rs.GET; -import javax.ws.rs.Path; -import javax.ws.rs.PathParam; -import javax.ws.rs.Produces; -import javax.ws.rs.core.MediaType; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.stats.Metrics; -import org.apache.pulsar.websocket.admin.WebSocketProxyStatsBase; -import org.apache.pulsar.websocket.stats.ProxyTopicStat; - -@Path("/proxy-stats") -@Api(value = "/proxy", description = "Stats for web-socket proxy", tags = "proxy-stats") -@Produces(MediaType.APPLICATION_JSON) -public class WebSocketProxyStatsV1 extends WebSocketProxyStatsBase { - -    @GET -    @Path("/metrics") -    @ApiOperation(value = "Gets the metrics for Monitoring", -                  notes = "Requested should be executed by Monitoring agent on each proxy to fetch the metrics", -                  response = Metrics.class, responseContainer = "List") -    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) -    public Collection<Metrics> internalGetMetrics() throws Exception { -        return super.internalGetMetrics(); -    } - -    @GET -    @Path("/{tenant}/{cluster}/{namespace}/{topic}/stats") -    @ApiOperation(value = "Get the stats for the topic.") -    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission"), -            @ApiResponse(code = 404, message = "Topic does not exist") }) -    public ProxyTopicStat getStats(@PathParam("tenant") String tenant, @PathParam("cluster") String cluster, -            @PathParam("namespace") String namespace, @PathParam("topic") @Encoded String encodedTopic) { -        return super.internalGetStats( -                TopicName.get("persistent", tenant, cluster, namespace, decode(encodedTopic))); -    } - -    @GET -    @Path("/stats") -    @ApiOperation(value = "Get the stats for the topic.") -    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) -    public Map<String, ProxyTopicStat> internalGetProxyStats() { -        return super.internalGetProxyStats(); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin.v1; + +import static org.apache.pulsar.common.util.Codec.decode; +import io.swagger.annotations.Api; +import io.swagger.annotations.ApiOperation; +import io.swagger.annotations.ApiResponse; +import io.swagger.annotations.ApiResponses; +import java.util.Collection; +import java.util.Map; +import javax.ws.rs.Encoded; +import javax.ws.rs.GET; +import javax.ws.rs.Path; +import javax.ws.rs.PathParam; +import javax.ws.rs.Produces; +import javax.ws.rs.core.MediaType; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.stats.Metrics; +import org.apache.pulsar.websocket.admin.WebSocketProxyStatsBase; +import org.apache.pulsar.websocket.stats.ProxyTopicStat; + +@Path("/proxy-stats") +@Api(value = "/proxy", description = "Stats for web-socket proxy", tags = "proxy-stats") +@Produces(MediaType.APPLICATION_JSON) +public class WebSocketProxyStatsV1 extends WebSocketProxyStatsBase { + +    @GET +    @Path("/metrics") +    @ApiOperation(value = "Gets the metrics for Monitoring", +                  notes = "Requested should be executed by Monitoring agent on each proxy to fetch the metrics", +                  response = Metrics.class, responseContainer = "List") +    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) +    public Collection<Metrics> internalGetMetrics() throws Exception { +        return super.internalGetMetrics(); +    } + +    @GET +    @Path("/{tenant}/{cluster}/{namespace}/{topic}/stats") +    @ApiOperation(value = "Get the stats for the topic.") +    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission"), +            @ApiResponse(code = 404, message = "Topic does not exist") }) +    public ProxyTopicStat getStats(@PathParam("tenant") String tenant, @PathParam("cluster") String cluster, +            @PathParam("namespace") String namespace, @PathParam("topic") @Encoded String encodedTopic) { +        return super.internalGetStats( +                TopicName.get("persistent", tenant, cluster, namespace, decode(encodedTopic))); +    } + +    @GET +    @Path("/stats") +    @ApiOperation(value = "Get the stats for the topic.") +    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) +    public Map<String, ProxyTopicStat> internalGetProxyStats() { +        return super.internalGetProxyStats(); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/package-info.java index 25b6612ce3..cd5f29ec97 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v1/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin.v1; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin.v1; diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/WebSocketProxyStatsV2.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/WebSocketProxyStatsV2.java index 779b0ec4b1..8a68267aa0 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/WebSocketProxyStatsV2.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/WebSocketProxyStatsV2.java @@ -1,70 +1,70 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin.v2; - -import static org.apache.pulsar.common.util.Codec.decode; -import io.swagger.annotations.Api; -import io.swagger.annotations.ApiOperation; -import io.swagger.annotations.ApiResponse; -import io.swagger.annotations.ApiResponses; -import java.util.Collection; -import java.util.Map; -import javax.ws.rs.Encoded; -import javax.ws.rs.GET; -import javax.ws.rs.Path; -import javax.ws.rs.PathParam; -import javax.ws.rs.Produces; -import javax.ws.rs.core.MediaType; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.stats.Metrics; -import org.apache.pulsar.websocket.admin.WebSocketProxyStatsBase; -import org.apache.pulsar.websocket.stats.ProxyTopicStat; - -@Path("/proxy-stats") -@Api(value = "/proxy", description = "Stats for web-socket proxy", tags = "proxy-stats") -@Produces(MediaType.APPLICATION_JSON) -public class WebSocketProxyStatsV2 extends WebSocketProxyStatsBase { -    @GET -    @Path("/metrics") -    @ApiOperation(value = "Gets the metrics for Monitoring", -                  notes = "Requested should be executed by Monitoring agent on each proxy to fetch the metrics", -                  response = Metrics.class, responseContainer = "List") -    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) -    public Collection<Metrics> internalGetMetrics() throws Exception { -        return super.internalGetMetrics(); -    } - -    @GET -    @Path("/{domain}/{tenant}/{namespace}/{topic}/stats") -    @ApiOperation(value = "Get the stats for the topic.") -    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission"), -            @ApiResponse(code = 404, message = "Topic does not exist") }) -    public ProxyTopicStat getStats(@PathParam("domain") String domain, @PathParam("tenant") String tenant, -            @PathParam("namespace") String namespace, @PathParam("topic") @Encoded String encodedTopic) { -        return super.internalGetStats(TopicName.get(domain, tenant, namespace, decode(encodedTopic))); -    } - -    @GET -    @Path("/stats") -    @ApiOperation(value = "Get the stats for the topic.") -    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) -    public Map<String, ProxyTopicStat> internalGetProxyStats() { -        return super.internalGetProxyStats(); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin.v2; + +import static org.apache.pulsar.common.util.Codec.decode; +import io.swagger.annotations.Api; +import io.swagger.annotations.ApiOperation; +import io.swagger.annotations.ApiResponse; +import io.swagger.annotations.ApiResponses; +import java.util.Collection; +import java.util.Map; +import javax.ws.rs.Encoded; +import javax.ws.rs.GET; +import javax.ws.rs.Path; +import javax.ws.rs.PathParam; +import javax.ws.rs.Produces; +import javax.ws.rs.core.MediaType; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.stats.Metrics; +import org.apache.pulsar.websocket.admin.WebSocketProxyStatsBase; +import org.apache.pulsar.websocket.stats.ProxyTopicStat; + +@Path("/proxy-stats") +@Api(value = "/proxy", description = "Stats for web-socket proxy", tags = "proxy-stats") +@Produces(MediaType.APPLICATION_JSON) +public class WebSocketProxyStatsV2 extends WebSocketProxyStatsBase { +    @GET +    @Path("/metrics") +    @ApiOperation(value = "Gets the metrics for Monitoring", +                  notes = "Requested should be executed by Monitoring agent on each proxy to fetch the metrics", +                  response = Metrics.class, responseContainer = "List") +    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) +    public Collection<Metrics> internalGetMetrics() throws Exception { +        return super.internalGetMetrics(); +    } + +    @GET +    @Path("/{domain}/{tenant}/{namespace}/{topic}/stats") +    @ApiOperation(value = "Get the stats for the topic.") +    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission"), +            @ApiResponse(code = 404, message = "Topic does not exist") }) +    public ProxyTopicStat getStats(@PathParam("domain") String domain, @PathParam("tenant") String tenant, +            @PathParam("namespace") String namespace, @PathParam("topic") @Encoded String encodedTopic) { +        return super.internalGetStats(TopicName.get(domain, tenant, namespace, decode(encodedTopic))); +    } + +    @GET +    @Path("/stats") +    @ApiOperation(value = "Get the stats for the topic.") +    @ApiResponses(value = { @ApiResponse(code = 403, message = "Don't have admin permission") }) +    public Map<String, ProxyTopicStat> internalGetProxyStats() { +        return super.internalGetProxyStats(); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/package-info.java index 83c4643023..cf68f21dc7 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/admin/v2/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin.v2; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin.v2; diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerCommand.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerCommand.java index 9d4b653c54..2e600b6022 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerCommand.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerCommand.java @@ -1,25 +1,25 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -public class ConsumerCommand { -    public String type; -    public String messageId; -    public Integer permitMessages; -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +public class ConsumerCommand { +    public String type; +    public String messageId; +    public Integer permitMessages; +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerMessage.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerMessage.java index 99ce86dbf1..ab920f1bb1 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerMessage.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ConsumerMessage.java @@ -1,38 +1,38 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -import com.fasterxml.jackson.annotation.JsonInclude; -import com.fasterxml.jackson.annotation.JsonInclude.Include; -import java.util.Map; -import org.apache.pulsar.common.api.EncryptionContext; - -@JsonInclude(Include.NON_NULL) -public class ConsumerMessage { -    public String messageId; -    public String payload; -    public Map<String, String> properties; -    public String publishTime; -    public int redeliveryCount; -    public String eventTime; - -    public EncryptionContext encryptionContext; - -    public String key; -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +import com.fasterxml.jackson.annotation.JsonInclude; +import com.fasterxml.jackson.annotation.JsonInclude.Include; +import java.util.Map; +import org.apache.pulsar.common.api.EncryptionContext; + +@JsonInclude(Include.NON_NULL) +public class ConsumerMessage { +    public String messageId; +    public String payload; +    public Map<String, String> properties; +    public String publishTime; +    public int redeliveryCount; +    public String eventTime; + +    public EncryptionContext encryptionContext; + +    public String key; +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/EndOfTopicResponse.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/EndOfTopicResponse.java index de829e0ad9..45c8f1101c 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/EndOfTopicResponse.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/EndOfTopicResponse.java @@ -1,34 +1,34 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -import com.fasterxml.jackson.annotation.JsonInclude; -import lombok.AllArgsConstructor; -import lombok.Data; - -/** - * Represent result of request to check if we've reached end of topic. - */ -@Data -@AllArgsConstructor -@JsonInclude(JsonInclude.Include.NON_NULL) -public class EndOfTopicResponse { -    // If reach end of topic. -    public boolean endOfTopic; -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +import com.fasterxml.jackson.annotation.JsonInclude; +import lombok.AllArgsConstructor; +import lombok.Data; + +/** + * Represent result of request to check if we've reached end of topic. + */ +@Data +@AllArgsConstructor +@JsonInclude(JsonInclude.Include.NON_NULL) +public class EndOfTopicResponse { +    // If reach end of topic. +    public boolean endOfTopic; +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAck.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAck.java index 1e62098ac2..4c6b06cb13 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAck.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAck.java @@ -1,67 +1,67 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -import static com.google.common.base.Joiner.on; -import com.fasterxml.jackson.annotation.JsonInclude; -import com.fasterxml.jackson.annotation.JsonInclude.Include; -import lombok.AllArgsConstructor; -import lombok.Data; -import lombok.NoArgsConstructor; -import org.apache.pulsar.websocket.WebSocketError; - -/** - * Represent result of publishing a single message. - */ -@Data -@NoArgsConstructor -@AllArgsConstructor -@JsonInclude(Include.NON_NULL) -public class ProducerAck { - -    // Message publishing result -    public String result; - -    // Error message if fail to publish a message. -    public String errorMsg; - -    public String messageId; - -    public String context; - -    // Indicating if error is retriable error. -    public int errorCode; - -    // Version of schema used to encode the message. -    public long schemaVersion; - -    public ProducerAck(String messageId, String context) { -        this.result = "ok"; -        this.messageId = messageId; -        this.context = context; -    } - -    public ProducerAck(WebSocketError error, String errorMsg, String messageId, String context) { -        this.result = on(':').join("send-error", error.getCode()); -        this.errorMsg = errorMsg; -        this.messageId = messageId; -        this.context = context; -    } - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +import static com.google.common.base.Joiner.on; +import com.fasterxml.jackson.annotation.JsonInclude; +import com.fasterxml.jackson.annotation.JsonInclude.Include; +import lombok.AllArgsConstructor; +import lombok.Data; +import lombok.NoArgsConstructor; +import org.apache.pulsar.websocket.WebSocketError; + +/** + * Represent result of publishing a single message. + */ +@Data +@NoArgsConstructor +@AllArgsConstructor +@JsonInclude(Include.NON_NULL) +public class ProducerAck { + +    // Message publishing result +    public String result; + +    // Error message if fail to publish a message. +    public String errorMsg; + +    public String messageId; + +    public String context; + +    // Indicating if error is retriable error. +    public int errorCode; + +    // Version of schema used to encode the message. +    public long schemaVersion; + +    public ProducerAck(String messageId, String context) { +        this.result = "ok"; +        this.messageId = messageId; +        this.context = context; +    } + +    public ProducerAck(WebSocketError error, String errorMsg, String messageId, String context) { +        this.result = on(':').join("send-error", error.getCode()); +        this.errorMsg = errorMsg; +        this.messageId = messageId; +        this.context = context; +    } + +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAcks.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAcks.java index 4b6236be77..ef3fcb9c4e 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAcks.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerAcks.java @@ -1,37 +1,37 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -import java.util.List; -import lombok.AllArgsConstructor; -import lombok.Data; -import lombok.NoArgsConstructor; - -/** - * Represent results of publishing multiple messages. - */ -@Data -@NoArgsConstructor -@AllArgsConstructor -public class ProducerAcks { -    List<ProducerAck> messagePublishResults; - -    // Version of schema used to encode messages. -    long schemaVersion; -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +import java.util.List; +import lombok.AllArgsConstructor; +import lombok.Data; +import lombok.NoArgsConstructor; + +/** + * Represent results of publishing multiple messages. + */ +@Data +@NoArgsConstructor +@AllArgsConstructor +public class ProducerAcks { +    List<ProducerAck> messagePublishResults; + +    // Version of schema used to encode messages. +    long schemaVersion; +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessage.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessage.java index 12cb3b20c1..7cb846f8a1 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessage.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessage.java @@ -1,82 +1,82 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -import java.util.List; -import java.util.Map; -import lombok.AllArgsConstructor; -import lombok.Data; -import lombok.NoArgsConstructor; -import org.apache.pulsar.common.api.proto.CompressionType; - -/** - * Class represent single message to be published. - */ -@Data -@NoArgsConstructor -@AllArgsConstructor -public class ProducerMessage { -    // Actual message payload. -    public String payload; - -    // Optional properties. -    public Map<String, String> properties; - -    // Request context -    public String context; - -    // Partition key. -    public String key; - -    // Clusters to replicate message to. -    public List<String> replicationClusters; - -    // Message event time. -    public String eventTime; - -    // Message sequenceId. -    public long sequenceId; - -    // Whether to disable replication of the message. -    public boolean disableReplication; - -    // Deliver the message only at or after the specified absolute timestamp. -    public long deliverAt; - -    // Deliver the message only after the specified relative delay in milliseconds. -    public long deliverAfterMs; - -    // Version of schema to use for the message. -    public long schemaVersion; - -    // Base64 encoded serialized schema for key -    public String keySchema; - -    // Base64 encoded serialized schema for payload -    public String valueSchema; - -    // Base64 encoded serialized initialization vector used when the client encrypts. -    public String encryptionParam; - -    // Compression type. Do not set it if compression is not performed. -    public CompressionType compressionType; - -    // The size of the payload before compression. Do not set it if compression is not performed. -    public Integer uncompressedMessageSize; -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +import java.util.List; +import java.util.Map; +import lombok.AllArgsConstructor; +import lombok.Data; +import lombok.NoArgsConstructor; +import org.apache.pulsar.common.api.proto.CompressionType; + +/** + * Class represent single message to be published. + */ +@Data +@NoArgsConstructor +@AllArgsConstructor +public class ProducerMessage { +    // Actual message payload. +    public String payload; + +    // Optional properties. +    public Map<String, String> properties; + +    // Request context +    public String context; + +    // Partition key. +    public String key; + +    // Clusters to replicate message to. +    public List<String> replicationClusters; + +    // Message event time. +    public String eventTime; + +    // Message sequenceId. +    public long sequenceId; + +    // Whether to disable replication of the message. +    public boolean disableReplication; + +    // Deliver the message only at or after the specified absolute timestamp. +    public long deliverAt; + +    // Deliver the message only after the specified relative delay in milliseconds. +    public long deliverAfterMs; + +    // Version of schema to use for the message. +    public long schemaVersion; + +    // Base64 encoded serialized schema for key +    public String keySchema; + +    // Base64 encoded serialized schema for payload +    public String valueSchema; + +    // Base64 encoded serialized initialization vector used when the client encrypts. +    public String encryptionParam; + +    // Compression type. Do not set it if compression is not performed. +    public CompressionType compressionType; + +    // The size of the payload before compression. Do not set it if compression is not performed. +    public Integer uncompressedMessageSize; +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessages.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessages.java index a1247dc69f..219c456c98 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessages.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/ProducerMessages.java @@ -1,45 +1,45 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; - -import java.util.List; -import lombok.AllArgsConstructor; -import lombok.Data; -import lombok.NoArgsConstructor; - -/** - * Class represent messages to be published. - */ -@Data -@NoArgsConstructor -@AllArgsConstructor -public class ProducerMessages { -    // Version of schema used for messages. -    private long schemaVersion = -1; - -    // Base64 encoded serialized schema for key -    private String keySchema; - -    // Base64 encoded serialized schema for value -    private String valueSchema; - -    private String producerName; - -    private List<ProducerMessage> messages; -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; + +import java.util.List; +import lombok.AllArgsConstructor; +import lombok.Data; +import lombok.NoArgsConstructor; + +/** + * Class represent messages to be published. + */ +@Data +@NoArgsConstructor +@AllArgsConstructor +public class ProducerMessages { +    // Version of schema used for messages. +    private long schemaVersion = -1; + +    // Base64 encoded serialized schema for key +    private String keySchema; + +    // Base64 encoded serialized schema for value +    private String valueSchema; + +    private String producerName; + +    private List<ProducerMessage> messages; +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/package-info.java index c8ddcdbef2..7b8580fd0c 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/data/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.data; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.data; diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/package-info.java index 294c9a8a39..03e2afcb79 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/ProxyServer.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/ProxyServer.java index e7523252bd..abc0c0207e 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/ProxyServer.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/ProxyServer.java @@ -1,275 +1,275 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; - -import java.net.MalformedURLException; -import java.util.ArrayList; -import java.util.Arrays; -import java.util.EnumSet; -import java.util.List; -import java.util.Optional; -import java.util.concurrent.Executors; -import java.util.concurrent.ScheduledExecutorService; -import java.util.concurrent.TimeUnit; -import java.util.stream.Collectors; -import javax.servlet.DispatcherType; -import javax.servlet.Servlet; -import javax.servlet.ServletException; -import javax.websocket.DeploymentException; -import org.apache.pulsar.broker.PulsarServerException; -import org.apache.pulsar.broker.web.JettyRequestLogFactory; -import org.apache.pulsar.broker.web.JsonMapperProvider; -import org.apache.pulsar.broker.web.WebExecutorThreadPool; -import org.apache.pulsar.client.api.PulsarClientException; -import org.apache.pulsar.client.util.ExecutorProvider; -import org.apache.pulsar.common.util.DefaultPulsarSslFactory; -import org.apache.pulsar.common.util.PulsarSslConfiguration; -import org.apache.pulsar.common.util.PulsarSslFactory; -import org.apache.pulsar.jetty.tls.JettySslContextFactory; -import org.eclipse.jetty.server.ConnectionFactory; -import org.eclipse.jetty.server.ConnectionLimit; -import org.eclipse.jetty.server.ForwardedRequestCustomizer; -import org.eclipse.jetty.server.Handler; -import org.eclipse.jetty.server.HttpConfiguration; -import org.eclipse.jetty.server.HttpConnectionFactory; -import org.eclipse.jetty.server.ProxyConnectionFactory; -import org.eclipse.jetty.server.SecureRequestCustomizer; -import org.eclipse.jetty.server.Server; -import org.eclipse.jetty.server.ServerConnector; -import org.eclipse.jetty.server.SslConnectionFactory; -import org.eclipse.jetty.server.handler.ContextHandlerCollection; -import org.eclipse.jetty.server.handler.DefaultHandler; -import org.eclipse.jetty.server.handler.HandlerCollection; -import org.eclipse.jetty.server.handler.RequestLogHandler; -import org.eclipse.jetty.servlet.FilterHolder; -import org.eclipse.jetty.servlet.ServletContextHandler; -import org.eclipse.jetty.servlet.ServletHolder; -import org.eclipse.jetty.servlets.QoSFilter; -import org.eclipse.jetty.util.ssl.SslContextFactory; -import org.glassfish.jersey.server.ResourceConfig; -import org.glassfish.jersey.servlet.ServletContainer; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -public class ProxyServer { -    private static final String MATCH_ALL = "/*"; -    private final Server server; -    private final List<Handler> handlers = new ArrayList<>(); -    private final WebSocketProxyConfiguration conf; -    private final WebExecutorThreadPool executorService; -    private final FilterHolder qualityOfServiceFilterHolder; - -    private ServerConnector connector; -    private ServerConnector connectorTls; -    private PulsarSslFactory sslFactory; -    private ScheduledExecutorService scheduledExecutorService; - -    public ProxyServer(WebSocketProxyConfiguration config) -            throws PulsarClientException, MalformedURLException, PulsarServerException { -        this.conf = config; -        executorService = new WebExecutorThreadPool(config.getNumHttpServerThreads(), "pulsar-websocket-web", -                config.getHttpServerThreadPoolQueueSize()); -        this.server = new Server(executorService); -        if (config.getMaxHttpServerConnections() > 0) { -            server.addBean(new ConnectionLimit(config.getMaxHttpServerConnections(), server)); -        } - -        HttpConfiguration httpConfig = new HttpConfiguration(); -        if (config.isWebServiceTrustXForwardedFor()) { -            httpConfig.addCustomizer(new ForwardedRequestCustomizer()); -        } -        HttpConnectionFactory httpConnectionFactory = new HttpConnectionFactory(httpConfig); - -        List<ServerConnector> connectors = new ArrayList<>(); - -        if (config.getWebServicePort().isPresent()) { -            List<ConnectionFactory> connectionFactories = new ArrayList<>(); -            if (config.isWebServiceHaProxyProtocolEnabled()) { -                connectionFactories.add(new ProxyConnectionFactory()); -            } -            connectionFactories.add(httpConnectionFactory); -            connector = new ServerConnector(server, connectionFactories.toArray(new ConnectionFactory[0])); -            connector.setPort(config.getWebServicePort().get()); -            connectors.add(connector); -        } -        // TLS enabled connector -        if (config.getWebServicePortTls().isPresent()) { -            try { -                PulsarSslConfiguration sslConfiguration = buildSslConfiguration(config); -                this.sslFactory = new DefaultPulsarSslFactory(); -                this.sslFactory.initialize(sslConfiguration); -                this.sslFactory.createInternalSslContext(); -                this.scheduledExecutorService = Executors -                        .newSingleThreadScheduledExecutor(new ExecutorProvider -                                .ExtendedThreadFactory("proxy-websocket-ssl-refresh")); -                if (config.getTlsCertRefreshCheckDurationSec() > 0) { -                    this.scheduledExecutorService.scheduleWithFixedDelay(this::refreshSslContext, -                            config.getTlsCertRefreshCheckDurationSec(), -                            config.getTlsCertRefreshCheckDurationSec(), -                            TimeUnit.SECONDS); -                } -                SslContextFactory sslCtxFactory = -                        JettySslContextFactory.createSslContextFactory(config.getTlsProvider(), -                                sslFactory, config.isTlsRequireTrustedClientCertOnConnect(), -                                config.getWebServiceTlsCiphers(), config.getWebServiceTlsProtocols()); -                List<ConnectionFactory> connectionFactories = new ArrayList<>(); -                if (config.isWebServiceHaProxyProtocolEnabled()) { -                    connectionFactories.add(new ProxyConnectionFactory()); -                } -                connectionFactories.add(new SslConnectionFactory(sslCtxFactory, httpConnectionFactory.getProtocol())); -                connectionFactories.add(httpConnectionFactory); -                // org.eclipse.jetty.server.AbstractConnectionFactory.getFactories contains similar logic -                // this is needed for TLS authentication -                if (httpConfig.getCustomizer(SecureRequestCustomizer.class) == null) { -                    httpConfig.addCustomizer(new SecureRequestCustomizer()); -                } -                connectorTls = new ServerConnector(server, connectionFactories.toArray(new ConnectionFactory[0])); -                connectorTls.setPort(config.getWebServicePortTls().get()); -                connectors.add(connectorTls); -            } catch (Exception e) { -                throw new PulsarServerException(e); -            } -        } - -        // Limit number of concurrent HTTP connections to avoid getting out of -        // file descriptors -        connectors.stream().forEach(c -> c.setAcceptQueueSize(config.getHttpServerAcceptQueueSize())); -        server.setConnectors(connectors.toArray(new ServerConnector[connectors.size()])); - -        if (config.getMaxConcurrentHttpRequests() > 0) { -            qualityOfServiceFilterHolder = new FilterHolder(QoSFilter.class); -            qualityOfServiceFilterHolder.setInitParameter("maxRequests", -                    String.valueOf(config.getMaxConcurrentHttpRequests())); -        } else { -            qualityOfServiceFilterHolder = null; -        } -    } - -    public void addWebSocketServlet(String basePath, Servlet socketServlet) -            throws ServletException, DeploymentException { -        ServletHolder servletHolder = new ServletHolder("ws-events", socketServlet); -        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); -        context.setContextPath(basePath); -        context.addServlet(servletHolder, MATCH_ALL); -        addQosFilterIfNeeded(context); -        handlers.add(context); -    } - -    public void addRestResource(String basePath, String attribute, Object attributeValue, Class<?> resourceClass) { -        ResourceConfig config = new ResourceConfig(); -        config.register(resourceClass); -        config.register(JsonMapperProvider.class); -        ServletHolder servletHolder = new ServletHolder(new ServletContainer(config)); -        servletHolder.setAsyncSupported(true); -        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); -        context.setContextPath(basePath); -        context.addServlet(servletHolder, MATCH_ALL); -        context.setAttribute(attribute, attributeValue); -        addQosFilterIfNeeded(context); -        handlers.add(context); -    } - -    private void addQosFilterIfNeeded(ServletContextHandler context) { -        if (qualityOfServiceFilterHolder != null) { -            context.addFilter(qualityOfServiceFilterHolder, -                    MATCH_ALL, EnumSet.allOf(DispatcherType.class)); -        } -    } - -    public void start() throws PulsarServerException { -        log.info("Starting web socket proxy at port {}", Arrays.stream(server.getConnectors()) -                .map(ServerConnector.class::cast).map(ServerConnector::getPort).map(Object::toString) -                .collect(Collectors.joining(","))); -        RequestLogHandler requestLogHandler = new RequestLogHandler(); -        boolean showDetailedAddresses = conf.getWebServiceLogDetailedAddresses() != null -                ? conf.getWebServiceLogDetailedAddresses() : -                (conf.isWebServiceHaProxyProtocolEnabled() || conf.isWebServiceTrustXForwardedFor()); -        requestLogHandler.setRequestLog(JettyRequestLogFactory.createRequestLogger(showDetailedAddresses, server)); -        handlers.add(0, new ContextHandlerCollection()); -        handlers.add(requestLogHandler); - -        ContextHandlerCollection contexts = new ContextHandlerCollection(); -        contexts.setHandlers(handlers.toArray(new Handler[handlers.size()])); - -        HandlerCollection handlerCollection = new HandlerCollection(); -        handlerCollection.setHandlers(new Handler[] { contexts, new DefaultHandler(), requestLogHandler }); -        server.setHandler(handlerCollection); - -        try { -            server.start(); -        } catch (Exception e) { -            throw new PulsarServerException(e); -        } -    } - -    public void stop() throws Exception { -        server.stop(); -        executorService.stop(); -        if (scheduledExecutorService != null) { -            scheduledExecutorService.shutdownNow(); -        } -    } - -    public Optional<Integer> getListenPortHTTP() { -        if (connector != null) { -            return Optional.of(connector.getLocalPort()); -        } else { -            return Optional.empty(); -        } -    } - -    public Optional<Integer> getListenPortHTTPS() { -        if (connectorTls != null) { -            return Optional.of(connectorTls.getLocalPort()); -        } else { -            return Optional.empty(); -        } -    } - -    protected PulsarSslConfiguration buildSslConfiguration(WebSocketProxyConfiguration config) { -        return PulsarSslConfiguration.builder() -                .tlsKeyStoreType(config.getTlsKeyStoreType()) -                .tlsKeyStorePath(config.getTlsKeyStore()) -                .tlsKeyStorePassword(config.getTlsKeyStorePassword()) -                .tlsTrustStoreType(config.getTlsTrustStoreType()) -                .tlsTrustStorePath(config.getTlsTrustStore()) -                .tlsTrustStorePassword(config.getTlsTrustStorePassword()) -                .tlsCiphers(config.getWebServiceTlsCiphers()) -                .tlsProtocols(config.getWebServiceTlsProtocols()) -                .tlsTrustCertsFilePath(config.getTlsTrustCertsFilePath()) -                .tlsCertificateFilePath(config.getTlsCertificateFilePath()) -                .tlsKeyFilePath(config.getTlsKeyFilePath()) -                .allowInsecureConnection(config.isTlsAllowInsecureConnection()) -                .requireTrustedClientCertOnConnect(config.isTlsRequireTrustedClientCertOnConnect()) -                .tlsEnabledWithKeystore(config.isTlsEnabledWithKeyStore()) -                .serverMode(true) -                .isHttps(true) -                .build(); -    } - -    protected void refreshSslContext() { -        try { -            this.sslFactory.update(); -        } catch (Exception e) { -            log.error("Failed to refresh SSL context", e); -        } -    } - -    private static final Logger log = LoggerFactory.getLogger(ProxyServer.class); -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; + +import java.net.MalformedURLException; +import java.util.ArrayList; +import java.util.Arrays; +import java.util.EnumSet; +import java.util.List; +import java.util.Optional; +import java.util.concurrent.Executors; +import java.util.concurrent.ScheduledExecutorService; +import java.util.concurrent.TimeUnit; +import java.util.stream.Collectors; +import javax.servlet.DispatcherType; +import javax.servlet.Servlet; +import javax.servlet.ServletException; +import javax.websocket.DeploymentException; +import org.apache.pulsar.broker.PulsarServerException; +import org.apache.pulsar.broker.web.JettyRequestLogFactory; +import org.apache.pulsar.broker.web.JsonMapperProvider; +import org.apache.pulsar.broker.web.WebExecutorThreadPool; +import org.apache.pulsar.client.api.PulsarClientException; +import org.apache.pulsar.client.util.ExecutorProvider; +import org.apache.pulsar.common.util.DefaultPulsarSslFactory; +import org.apache.pulsar.common.util.PulsarSslConfiguration; +import org.apache.pulsar.common.util.PulsarSslFactory; +import org.apache.pulsar.jetty.tls.JettySslContextFactory; +import org.eclipse.jetty.server.ConnectionFactory; +import org.eclipse.jetty.server.ConnectionLimit; +import org.eclipse.jetty.server.ForwardedRequestCustomizer; +import org.eclipse.jetty.server.Handler; +import org.eclipse.jetty.server.HttpConfiguration; +import org.eclipse.jetty.server.HttpConnectionFactory; +import org.eclipse.jetty.server.ProxyConnectionFactory; +import org.eclipse.jetty.server.SecureRequestCustomizer; +import org.eclipse.jetty.server.Server; +import org.eclipse.jetty.server.ServerConnector; +import org.eclipse.jetty.server.SslConnectionFactory; +import org.eclipse.jetty.server.handler.ContextHandlerCollection; +import org.eclipse.jetty.server.handler.DefaultHandler; +import org.eclipse.jetty.server.handler.HandlerCollection; +import org.eclipse.jetty.server.handler.RequestLogHandler; +import org.eclipse.jetty.servlet.FilterHolder; +import org.eclipse.jetty.servlet.ServletContextHandler; +import org.eclipse.jetty.servlet.ServletHolder; +import org.eclipse.jetty.servlets.QoSFilter; +import org.eclipse.jetty.util.ssl.SslContextFactory; +import org.glassfish.jersey.server.ResourceConfig; +import org.glassfish.jersey.servlet.ServletContainer; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +public class ProxyServer { +    private static final String MATCH_ALL = "/*"; +    private final Server server; +    private final List<Handler> handlers = new ArrayList<>(); +    private final WebSocketProxyConfiguration conf; +    private final WebExecutorThreadPool executorService; +    private final FilterHolder qualityOfServiceFilterHolder; + +    private ServerConnector connector; +    private ServerConnector connectorTls; +    private PulsarSslFactory sslFactory; +    private ScheduledExecutorService scheduledExecutorService; + +    public ProxyServer(WebSocketProxyConfiguration config) +            throws PulsarClientException, MalformedURLException, PulsarServerException { +        this.conf = config; +        executorService = new WebExecutorThreadPool(config.getNumHttpServerThreads(), "pulsar-websocket-web", +                config.getHttpServerThreadPoolQueueSize()); +        this.server = new Server(executorService); +        if (config.getMaxHttpServerConnections() > 0) { +            server.addBean(new ConnectionLimit(config.getMaxHttpServerConnections(), server)); +        } + +        HttpConfiguration httpConfig = new HttpConfiguration(); +        if (config.isWebServiceTrustXForwardedFor()) { +            httpConfig.addCustomizer(new ForwardedRequestCustomizer()); +        } +        HttpConnectionFactory httpConnectionFactory = new HttpConnectionFactory(httpConfig); + +        List<ServerConnector> connectors = new ArrayList<>(); + +        if (config.getWebServicePort().isPresent()) { +            List<ConnectionFactory> connectionFactories = new ArrayList<>(); +            if (config.isWebServiceHaProxyProtocolEnabled()) { +                connectionFactories.add(new ProxyConnectionFactory()); +            } +            connectionFactories.add(httpConnectionFactory); +            connector = new ServerConnector(server, connectionFactories.toArray(new ConnectionFactory[0])); +            connector.setPort(config.getWebServicePort().get()); +            connectors.add(connector); +        } +        // TLS enabled connector +        if (config.getWebServicePortTls().isPresent()) { +            try { +                PulsarSslConfiguration sslConfiguration = buildSslConfiguration(config); +                this.sslFactory = new DefaultPulsarSslFactory(); +                this.sslFactory.initialize(sslConfiguration); +                this.sslFactory.createInternalSslContext(); +                this.scheduledExecutorService = Executors +                        .newSingleThreadScheduledExecutor(new ExecutorProvider +                                .ExtendedThreadFactory("proxy-websocket-ssl-refresh")); +                if (config.getTlsCertRefreshCheckDurationSec() > 0) { +                    this.scheduledExecutorService.scheduleWithFixedDelay(this::refreshSslContext, +                            config.getTlsCertRefreshCheckDurationSec(), +                            config.getTlsCertRefreshCheckDurationSec(), +                            TimeUnit.SECONDS); +                } +                SslContextFactory sslCtxFactory = +                        JettySslContextFactory.createSslContextFactory(config.getTlsProvider(), +                                sslFactory, config.isTlsRequireTrustedClientCertOnConnect(), +                                config.getWebServiceTlsCiphers(), config.getWebServiceTlsProtocols()); +                List<ConnectionFactory> connectionFactories = new ArrayList<>(); +                if (config.isWebServiceHaProxyProtocolEnabled()) { +                    connectionFactories.add(new ProxyConnectionFactory()); +                } +                connectionFactories.add(new SslConnectionFactory(sslCtxFactory, httpConnectionFactory.getProtocol())); +                connectionFactories.add(httpConnectionFactory); +                // org.eclipse.jetty.server.AbstractConnectionFactory.getFactories contains similar logic +                // this is needed for TLS authentication +                if (httpConfig.getCustomizer(SecureRequestCustomizer.class) == null) { +                    httpConfig.addCustomizer(new SecureRequestCustomizer()); +                } +                connectorTls = new ServerConnector(server, connectionFactories.toArray(new ConnectionFactory[0])); +                connectorTls.setPort(config.getWebServicePortTls().get()); +                connectors.add(connectorTls); +            } catch (Exception e) { +                throw new PulsarServerException(e); +            } +        } + +        // Limit number of concurrent HTTP connections to avoid getting out of +        // file descriptors +        connectors.stream().forEach(c -> c.setAcceptQueueSize(config.getHttpServerAcceptQueueSize())); +        server.setConnectors(connectors.toArray(new ServerConnector[connectors.size()])); + +        if (config.getMaxConcurrentHttpRequests() > 0) { +            qualityOfServiceFilterHolder = new FilterHolder(QoSFilter.class); +            qualityOfServiceFilterHolder.setInitParameter("maxRequests", +                    String.valueOf(config.getMaxConcurrentHttpRequests())); +        } else { +            qualityOfServiceFilterHolder = null; +        } +    } + +    public void addWebSocketServlet(String basePath, Servlet socketServlet) +            throws ServletException, DeploymentException { +        ServletHolder servletHolder = new ServletHolder("ws-events", socketServlet); +        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); +        context.setContextPath(basePath); +        context.addServlet(servletHolder, MATCH_ALL); +        addQosFilterIfNeeded(context); +        handlers.add(context); +    } + +    public void addRestResource(String basePath, String attribute, Object attributeValue, Class<?> resourceClass) { +        ResourceConfig config = new ResourceConfig(); +        config.register(resourceClass); +        config.register(JsonMapperProvider.class); +        ServletHolder servletHolder = new ServletHolder(new ServletContainer(config)); +        servletHolder.setAsyncSupported(true); +        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); +        context.setContextPath(basePath); +        context.addServlet(servletHolder, MATCH_ALL); +        context.setAttribute(attribute, attributeValue); +        addQosFilterIfNeeded(context); +        handlers.add(context); +    } + +    private void addQosFilterIfNeeded(ServletContextHandler context) { +        if (qualityOfServiceFilterHolder != null) { +            context.addFilter(qualityOfServiceFilterHolder, +                    MATCH_ALL, EnumSet.allOf(DispatcherType.class)); +        } +    } + +    public void start() throws PulsarServerException { +        log.info("Starting web socket proxy at port {}", Arrays.stream(server.getConnectors()) +                .map(ServerConnector.class::cast).map(ServerConnector::getPort).map(Object::toString) +                .collect(Collectors.joining(","))); +        RequestLogHandler requestLogHandler = new RequestLogHandler(); +        boolean showDetailedAddresses = conf.getWebServiceLogDetailedAddresses() != null +                ? conf.getWebServiceLogDetailedAddresses() : +                (conf.isWebServiceHaProxyProtocolEnabled() || conf.isWebServiceTrustXForwardedFor()); +        requestLogHandler.setRequestLog(JettyRequestLogFactory.createRequestLogger(showDetailedAddresses, server)); +        handlers.add(0, new ContextHandlerCollection()); +        handlers.add(requestLogHandler); + +        ContextHandlerCollection contexts = new ContextHandlerCollection(); +        contexts.setHandlers(handlers.toArray(new Handler[handlers.size()])); + +        HandlerCollection handlerCollection = new HandlerCollection(); +        handlerCollection.setHandlers(new Handler[] { contexts, new DefaultHandler(), requestLogHandler }); +        server.setHandler(handlerCollection); + +        try { +            server.start(); +        } catch (Exception e) { +            throw new PulsarServerException(e); +        } +    } + +    public void stop() throws Exception { +        server.stop(); +        executorService.stop(); +        if (scheduledExecutorService != null) { +            scheduledExecutorService.shutdownNow(); +        } +    } + +    public Optional<Integer> getListenPortHTTP() { +        if (connector != null) { +            return Optional.of(connector.getLocalPort()); +        } else { +            return Optional.empty(); +        } +    } + +    public Optional<Integer> getListenPortHTTPS() { +        if (connectorTls != null) { +            return Optional.of(connectorTls.getLocalPort()); +        } else { +            return Optional.empty(); +        } +    } + +    protected PulsarSslConfiguration buildSslConfiguration(WebSocketProxyConfiguration config) { +        return PulsarSslConfiguration.builder() +                .tlsKeyStoreType(config.getTlsKeyStoreType()) +                .tlsKeyStorePath(config.getTlsKeyStore()) +                .tlsKeyStorePassword(config.getTlsKeyStorePassword()) +                .tlsTrustStoreType(config.getTlsTrustStoreType()) +                .tlsTrustStorePath(config.getTlsTrustStore()) +                .tlsTrustStorePassword(config.getTlsTrustStorePassword()) +                .tlsCiphers(config.getWebServiceTlsCiphers()) +                .tlsProtocols(config.getWebServiceTlsProtocols()) +                .tlsTrustCertsFilePath(config.getTlsTrustCertsFilePath()) +                .tlsCertificateFilePath(config.getTlsCertificateFilePath()) +                .tlsKeyFilePath(config.getTlsKeyFilePath()) +                .allowInsecureConnection(config.isTlsAllowInsecureConnection()) +                .requireTrustedClientCertOnConnect(config.isTlsRequireTrustedClientCertOnConnect()) +                .tlsEnabledWithKeystore(config.isTlsEnabledWithKeyStore()) +                .serverMode(true) +                .isHttps(true) +                .build(); +    } + +    protected void refreshSslContext() { +        try { +            this.sslFactory.update(); +        } catch (Exception e) { +            log.error("Failed to refresh SSL context", e); +        } +    } + +    private static final Logger log = LoggerFactory.getLogger(ProxyServer.class); +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WSSDummyMessageCryptoImpl.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WSSDummyMessageCryptoImpl.java index 43f7a368bb..4576813195 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WSSDummyMessageCryptoImpl.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WSSDummyMessageCryptoImpl.java @@ -1,77 +1,77 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; - -import java.nio.ByteBuffer; -import java.util.Set; -import java.util.function.Consumer; -import java.util.function.Supplier; -import org.apache.pulsar.client.api.CryptoKeyReader; -import org.apache.pulsar.client.api.MessageCrypto; -import org.apache.pulsar.client.api.PulsarClientException; -import org.apache.pulsar.common.api.proto.MessageMetadata; - -/*** - * This class is used in scenarios where the payload of the message has been encrypted and the producer does not need - * to encrypt it again. - * It discards payload encryption and only relies {@link #metadataModifierForSend} to set the encryption info into the - * message metadata. - */ -public class WSSDummyMessageCryptoImpl implements MessageCrypto<MessageMetadata, MessageMetadata> { - -    public static final WSSDummyMessageCryptoImpl INSTANCE_FOR_CONSUMER = -            new WSSDummyMessageCryptoImpl(msgMetadata -> {}); - -    private final Consumer<MessageMetadata> metadataModifierForSend; - -    public WSSDummyMessageCryptoImpl(Consumer<MessageMetadata> metadataModifierForSend) { -        this.metadataModifierForSend = metadataModifierForSend; -    } - -    @Override -    public void addPublicKeyCipher(Set keyNames, CryptoKeyReader keyReader) -            throws PulsarClientException.CryptoException {} - -    @Override -    public boolean removeKeyCipher(String keyName) { -        return true; -    } - -    @Override -    public int getMaxOutputSize(int inputLen) { -        return inputLen; -    } - -    @Override -    public boolean decrypt(Supplier<MessageMetadata> messageMetadataSupplier, ByteBuffer payload, ByteBuffer outBuffer, -                           CryptoKeyReader keyReader) { -        outBuffer.put(payload); -        outBuffer.flip(); -        return true; -    } - -    @Override -    public synchronized void encrypt(Set<String> encKeys, CryptoKeyReader keyReader, -                                    Supplier<MessageMetadata> messageMetadataSupplier, -                                    ByteBuffer payload, ByteBuffer outBuffer) throws PulsarClientException { -        outBuffer.put(payload); -        outBuffer.flip(); -        metadataModifierForSend.accept(messageMetadataSupplier.get()); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; + +import java.nio.ByteBuffer; +import java.util.Set; +import java.util.function.Consumer; +import java.util.function.Supplier; +import org.apache.pulsar.client.api.CryptoKeyReader; +import org.apache.pulsar.client.api.MessageCrypto; +import org.apache.pulsar.client.api.PulsarClientException; +import org.apache.pulsar.common.api.proto.MessageMetadata; + +/*** + * This class is used in scenarios where the payload of the message has been encrypted and the producer does not need + * to encrypt it again. + * It discards payload encryption and only relies {@link #metadataModifierForSend} to set the encryption info into the + * message metadata. + */ +public class WSSDummyMessageCryptoImpl implements MessageCrypto<MessageMetadata, MessageMetadata> { + +    public static final WSSDummyMessageCryptoImpl INSTANCE_FOR_CONSUMER = +            new WSSDummyMessageCryptoImpl(msgMetadata -> {}); + +    private final Consumer<MessageMetadata> metadataModifierForSend; + +    public WSSDummyMessageCryptoImpl(Consumer<MessageMetadata> metadataModifierForSend) { +        this.metadataModifierForSend = metadataModifierForSend; +    } + +    @Override +    public void addPublicKeyCipher(Set keyNames, CryptoKeyReader keyReader) +            throws PulsarClientException.CryptoException {} + +    @Override +    public boolean removeKeyCipher(String keyName) { +        return true; +    } + +    @Override +    public int getMaxOutputSize(int inputLen) { +        return inputLen; +    } + +    @Override +    public boolean decrypt(Supplier<MessageMetadata> messageMetadataSupplier, ByteBuffer payload, ByteBuffer outBuffer, +                           CryptoKeyReader keyReader) { +        outBuffer.put(payload); +        outBuffer.flip(); +        return true; +    } + +    @Override +    public synchronized void encrypt(Set<String> encKeys, CryptoKeyReader keyReader, +                                    Supplier<MessageMetadata> messageMetadataSupplier, +                                    ByteBuffer payload, ByteBuffer outBuffer) throws PulsarClientException { +        outBuffer.put(payload); +        outBuffer.flip(); +        metadataModifierForSend.accept(messageMetadataSupplier.get()); +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketProxyConfiguration.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketProxyConfiguration.java index 31a1adc291..5a8232b5f7 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketProxyConfiguration.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketProxyConfiguration.java @@ -1,287 +1,287 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; - -import java.util.Optional; -import java.util.Properties; -import java.util.Set; -import java.util.TreeSet; -import lombok.Getter; -import lombok.Setter; -import lombok.ToString; -import org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider; -import org.apache.pulsar.common.configuration.FieldContext; -import org.apache.pulsar.common.configuration.PulsarConfiguration; - -@Getter -@Setter -public class WebSocketProxyConfiguration implements PulsarConfiguration { -    @FieldContext(required = true, doc = "Name of the cluster to which this broker belongs to") -    private String clusterName; - -    @FieldContext(doc = "The HTTPS REST service URL to connect to broker") -    private String serviceUrl; - -    @FieldContext(doc = "The HTTPS REST service TLS URL") -    private String serviceUrlTls; - -    @FieldContext(doc = "The broker binary service URL (for produce and consume operations)") -    private String brokerServiceUrl; - -    @FieldContext(doc = "The secured broker binary service URL (for produce and consume operations)") -    private String brokerServiceUrlTls; - -    @FieldContext(doc = "Path for the file used to determine the rotation status for the broker " -            + "when responding to service discovery health checks") -    private String statusFilePath; - -    @Deprecated -    @FieldContext( -            doc = "Configuration Store connection string", -            deprecated = true -    ) -    private String globalZookeeperServers; - -    @Deprecated -    @FieldContext( -            deprecated = true, -            doc = "Configuration store connection string (as a comma-separated list). Deprecated in favor of " -                    + "`configurationMetadataStoreUrl`" -    ) -    private String configurationStoreServers; - -    @FieldContext(doc = "Connection string of configuration metadata store servers") -    private String configurationMetadataStoreUrl; - -    @FieldContext(doc = "Metadata store session timeout in milliseconds.") -    private long metadataStoreSessionTimeoutMillis = 30_000; - -    @FieldContext(doc = "Metadata store cache expiry time in seconds.") -    private int metadataStoreCacheExpirySeconds = 300; - -    @FieldContext( -            deprecated = true, -            doc = "ZooKeeper session timeout in milliseconds. " -                        + "@deprecated - Use metadataStoreSessionTimeoutMillis instead.") -    private long zooKeeperSessionTimeoutMillis = -1; - -    @FieldContext( -            deprecated = true, -            doc = "ZooKeeper cache expiry time in seconds. " -                        + "@deprecated - Use metadataStoreCacheExpirySeconds instead.") -    private int zooKeeperCacheExpirySeconds = -1; - -    @FieldContext(doc = "Port to use to server HTTP request") -    private Optional<Integer> webServicePort = Optional.of(8080); - -    @FieldContext(doc = "Port to use to server HTTPS request") -    private Optional<Integer> webServicePortTls = Optional.empty(); - -    @FieldContext(doc = "Hostname or IP address the service binds on, default is 0.0.0.0.") -    private String bindAddress = "0.0.0.0"; - -    @FieldContext(doc = "Enable or disable the use of HA proxy protocol for resolving the client IP for http/https " -                    + "requests. Default is false.") -    private boolean webServiceHaProxyProtocolEnabled = false; - -    @FieldContext(doc = "Trust X-Forwarded-For header for resolving the client IP for http/https requests.\n" -                    + "Default is false.") -    private boolean webServiceTrustXForwardedFor = false; - -    @FieldContext(doc = -            "Add detailed client/remote and server/local addresses and ports to http/https request logging.\n" -                    + "Defaults to true when either webServiceHaProxyProtocolEnabled or webServiceTrustXForwardedFor " -                    + "is enabled.") -    private Boolean webServiceLogDetailedAddresses; - -    @FieldContext(doc = "Maximum size of a text message during parsing in WebSocket proxy") -    private int webSocketMaxTextFrameSize = 1024 * 1024; -    // --- Authentication --- -    @FieldContext(doc = "Enable authentication") -    private boolean authenticationEnabled; - -    @FieldContext(doc = "Authentication provider name list, which is a list of class names") -    private Set<String> authenticationProviders = new TreeSet<>(); - -    @FieldContext(doc = "Enforce authorization") -    private boolean authorizationEnabled; - -    @FieldContext(doc = "Authorization provider fully qualified class name") -    private String authorizationProvider = PulsarAuthorizationProvider.class.getName(); - -    @FieldContext(doc = "Role names that are treated as \"super-user\", " -            + "which means they can do all admin operations and publish to or consume from all topics") -    private Set<String> superUserRoles = new TreeSet<>(); - -    @FieldContext(doc = "Allow wildcard matching in authorization " -            + "(wildcard matching only applicable if wildcard-char: " -            + "presents at first or last position. For example: *.pulsar.service,pulsar.service.*)") -    private boolean authorizationAllowWildcardsMatching = false; - -    @FieldContext(doc = "Proxy authentication settings used to connect to brokers") -    private String brokerClientAuthenticationPlugin; - -    @FieldContext(doc = "Proxy authentication parameters used to connect to brokers") -    private String brokerClientAuthenticationParameters; - -    @FieldContext(doc = "Path for the trusted TLS certificate file for outgoing connection to a server (broker)") -    private String brokerClientTrustCertsFilePath = ""; - -    // Note: name matches the ServiceConfiguration name to ensure correct mapping -    @FieldContext(doc = "Enable TLS hostname verification when connecting to broker") -    private boolean tlsHostnameVerificationEnabled = false; - -    @FieldContext(doc = "Number of IO threads in Pulsar client used in WebSocket proxy") -    private int webSocketNumIoThreads = Runtime.getRuntime().availableProcessors(); - -    @FieldContext(doc = "Number of threads to used in HTTP server") -    private int numHttpServerThreads = Math.max(6, Runtime.getRuntime().availableProcessors()); - -    @FieldContext(doc = "Number of threads used by Websocket service") -    private int webSocketNumServiceThreads = 20; - -    @FieldContext(doc = "Max concurrent web requests") -    private int maxConcurrentHttpRequests = 1024; - -    @FieldContext(doc = "Capacity for thread pool queue in the HTTP server" -                    + " Default is set to 8192." -    ) -    private int httpServerThreadPoolQueueSize = 8192; - -    @FieldContext(doc = "Capacity for accept queue in the HTTP server" -                    + " Default is set to 8192." -    ) -    private int httpServerAcceptQueueSize = 8192; - -    @FieldContext(doc = "Maximum number of inbound http connections. " -            + "(0 to disable limiting)") -    private int maxHttpServerConnections = 2048; - -    @FieldContext(doc = "Number of connections per broker in Pulsar client used in WebSocket proxy") -    private int webSocketConnectionsPerBroker = Runtime.getRuntime().availableProcessors(); - -    @FieldContext(doc = "Memory limit in MBs for direct memory in Pulsar Client used in WebSocket proxy") -    private int webSocketPulsarClientMemoryLimitInMB = 0; - -    @FieldContext(doc = "Timeout of idling WebSocket session (in milliseconds)") -    private int webSocketSessionIdleTimeoutMillis = 300000; - -    @FieldContext(doc = "Interval of time to sending the ping to keep alive. This value greater than 0 means enabled") -    private int webSocketPingDurationSeconds = -1; - -    @FieldContext(doc = "When this parameter is not empty, unauthenticated users perform as anonymousUserRole") -    private String anonymousUserRole = null; - -    /* --- TLS --- */ -    @Deprecated -    private boolean tlsEnabled = false; - -    @FieldContext(doc = "Enable TLS of broker client") -    private boolean brokerClientTlsEnabled = false; - -    @FieldContext(doc = "Path for the TLS certificate file") -    private String tlsCertificateFilePath; - -    @FieldContext(doc = "Path for the TLS private key file") -    private String tlsKeyFilePath; - -    @FieldContext(doc = "Path for the trusted TLS certificate file") -    private String tlsTrustCertsFilePath = ""; - -    @FieldContext(doc = "Accept untrusted TLS certificate from client and broker") -    private boolean tlsAllowInsecureConnection = false; - -    @FieldContext(doc = "Specify whether client certificates are required for " -            + "TLS rejecting the connection if the client certificate is not trusted") -    private boolean tlsRequireTrustedClientCertOnConnect = false; - -    @FieldContext(doc = "TLS cert refresh duration (in seconds). 0 means checking every new connection.") -    private long tlsCertRefreshCheckDurationSec = 300; - -    /**** --- KeyStore TLS config variables. --- ****/ -    @FieldContext( -            doc = "Enable TLS with KeyStore type configuration for WebSocket" -    ) -    private boolean tlsEnabledWithKeyStore = false; - -    @FieldContext( -            doc = "Specify the TLS provider for the WebSocket service: SunJSSE, Conscrypt and etc." -    ) -    private String tlsProvider = "Conscrypt"; - -    @FieldContext( -            doc = "TLS KeyStore type configuration in WebSocket: JKS, PKCS12" -    ) -    private String tlsKeyStoreType = "JKS"; - -    @FieldContext( -            doc = "TLS KeyStore path in WebSocket" -    ) -    private String tlsKeyStore = null; - -    @FieldContext( -            doc = "TLS KeyStore password for WebSocket" -    ) -    @ToString.Exclude -    private String tlsKeyStorePassword = null; - -    @FieldContext( -            doc = "TLS TrustStore type configuration in WebSocket: JKS, PKCS12" -    ) -    private String tlsTrustStoreType = "JKS"; - -    @FieldContext( -            doc = "TLS TrustStore path in WebSocket" -    ) -    private String tlsTrustStore = null; - -    @FieldContext( -            doc = "TLS TrustStore password for WebSocket, null means empty password." -    ) -    @ToString.Exclude -    private String tlsTrustStorePassword = null; - -    @FieldContext( -            doc = "Specify the tls protocols the proxy's web service will use to negotiate during TLS Handshake.\n\n" -                    + "Example:- [TLSv1.3, TLSv1.2]" -    ) -    private Set<String> webServiceTlsProtocols = new TreeSet<>(); - -    @FieldContext( -            doc = "Specify the tls cipher the proxy's web service will use to negotiate during TLS Handshake.\n\n" -                    + "Example:- [TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256]" -    ) -    private Set<String> webServiceTlsCiphers = new TreeSet<>(); - -    @FieldContext( -            doc = "CryptoKeyReader factory classname to support encryption at websocket." -    ) -    private String cryptoKeyReaderFactoryClassName; - -    @FieldContext(doc = "Key-value properties. Types are all String") -    private Properties properties = new Properties(); - -    public long getMetadataStoreSessionTimeoutMillis() { -        return zooKeeperSessionTimeoutMillis > 0 ? zooKeeperSessionTimeoutMillis : metadataStoreSessionTimeoutMillis; -    } - -    public int getMetadataStoreCacheExpirySeconds() { -        return zooKeeperCacheExpirySeconds > 0 ? zooKeeperCacheExpirySeconds : metadataStoreCacheExpirySeconds; -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; + +import java.util.Optional; +import java.util.Properties; +import java.util.Set; +import java.util.TreeSet; +import lombok.Getter; +import lombok.Setter; +import lombok.ToString; +import org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider; +import org.apache.pulsar.common.configuration.FieldContext; +import org.apache.pulsar.common.configuration.PulsarConfiguration; + +@Getter +@Setter +public class WebSocketProxyConfiguration implements PulsarConfiguration { +    @FieldContext(required = true, doc = "Name of the cluster to which this broker belongs to") +    private String clusterName; + +    @FieldContext(doc = "The HTTPS REST service URL to connect to broker") +    private String serviceUrl; + +    @FieldContext(doc = "The HTTPS REST service TLS URL") +    private String serviceUrlTls; + +    @FieldContext(doc = "The broker binary service URL (for produce and consume operations)") +    private String brokerServiceUrl; + +    @FieldContext(doc = "The secured broker binary service URL (for produce and consume operations)") +    private String brokerServiceUrlTls; + +    @FieldContext(doc = "Path for the file used to determine the rotation status for the broker " +            + "when responding to service discovery health checks") +    private String statusFilePath; + +    @Deprecated +    @FieldContext( +            doc = "Configuration Store connection string", +            deprecated = true +    ) +    private String globalZookeeperServers; + +    @Deprecated +    @FieldContext( +            deprecated = true, +            doc = "Configuration store connection string (as a comma-separated list). Deprecated in favor of " +                    + "`configurationMetadataStoreUrl`" +    ) +    private String configurationStoreServers; + +    @FieldContext(doc = "Connection string of configuration metadata store servers") +    private String configurationMetadataStoreUrl; + +    @FieldContext(doc = "Metadata store session timeout in milliseconds.") +    private long metadataStoreSessionTimeoutMillis = 30_000; + +    @FieldContext(doc = "Metadata store cache expiry time in seconds.") +    private int metadataStoreCacheExpirySeconds = 300; + +    @FieldContext( +            deprecated = true, +            doc = "ZooKeeper session timeout in milliseconds. " +                        + "@deprecated - Use metadataStoreSessionTimeoutMillis instead.") +    private long zooKeeperSessionTimeoutMillis = -1; + +    @FieldContext( +            deprecated = true, +            doc = "ZooKeeper cache expiry time in seconds. " +                        + "@deprecated - Use metadataStoreCacheExpirySeconds instead.") +    private int zooKeeperCacheExpirySeconds = -1; + +    @FieldContext(doc = "Port to use to server HTTP request") +    private Optional<Integer> webServicePort = Optional.of(8080); + +    @FieldContext(doc = "Port to use to server HTTPS request") +    private Optional<Integer> webServicePortTls = Optional.empty(); + +    @FieldContext(doc = "Hostname or IP address the service binds on, default is 0.0.0.0.") +    private String bindAddress = "0.0.0.0"; + +    @FieldContext(doc = "Enable or disable the use of HA proxy protocol for resolving the client IP for http/https " +                    + "requests. Default is false.") +    private boolean webServiceHaProxyProtocolEnabled = false; + +    @FieldContext(doc = "Trust X-Forwarded-For header for resolving the client IP for http/https requests.\n" +                    + "Default is false.") +    private boolean webServiceTrustXForwardedFor = false; + +    @FieldContext(doc = +            "Add detailed client/remote and server/local addresses and ports to http/https request logging.\n" +                    + "Defaults to true when either webServiceHaProxyProtocolEnabled or webServiceTrustXForwardedFor " +                    + "is enabled.") +    private Boolean webServiceLogDetailedAddresses; + +    @FieldContext(doc = "Maximum size of a text message during parsing in WebSocket proxy") +    private int webSocketMaxTextFrameSize = 1024 * 1024; +    // --- Authentication --- +    @FieldContext(doc = "Enable authentication") +    private boolean authenticationEnabled; + +    @FieldContext(doc = "Authentication provider name list, which is a list of class names") +    private Set<String> authenticationProviders = new TreeSet<>(); + +    @FieldContext(doc = "Enforce authorization") +    private boolean authorizationEnabled; + +    @FieldContext(doc = "Authorization provider fully qualified class name") +    private String authorizationProvider = PulsarAuthorizationProvider.class.getName(); + +    @FieldContext(doc = "Role names that are treated as \"super-user\", " +            + "which means they can do all admin operations and publish to or consume from all topics") +    private Set<String> superUserRoles = new TreeSet<>(); + +    @FieldContext(doc = "Allow wildcard matching in authorization " +            + "(wildcard matching only applicable if wildcard-char: " +            + "presents at first or last position. For example: *.pulsar.service,pulsar.service.*)") +    private boolean authorizationAllowWildcardsMatching = false; + +    @FieldContext(doc = "Proxy authentication settings used to connect to brokers") +    private String brokerClientAuthenticationPlugin; + +    @FieldContext(doc = "Proxy authentication parameters used to connect to brokers") +    private String brokerClientAuthenticationParameters; + +    @FieldContext(doc = "Path for the trusted TLS certificate file for outgoing connection to a server (broker)") +    private String brokerClientTrustCertsFilePath = ""; + +    // Note: name matches the ServiceConfiguration name to ensure correct mapping +    @FieldContext(doc = "Enable TLS hostname verification when connecting to broker") +    private boolean tlsHostnameVerificationEnabled = false; + +    @FieldContext(doc = "Number of IO threads in Pulsar client used in WebSocket proxy") +    private int webSocketNumIoThreads = Runtime.getRuntime().availableProcessors(); + +    @FieldContext(doc = "Number of threads to used in HTTP server") +    private int numHttpServerThreads = Math.max(6, Runtime.getRuntime().availableProcessors()); + +    @FieldContext(doc = "Number of threads used by Websocket service") +    private int webSocketNumServiceThreads = 20; + +    @FieldContext(doc = "Max concurrent web requests") +    private int maxConcurrentHttpRequests = 1024; + +    @FieldContext(doc = "Capacity for thread pool queue in the HTTP server" +                    + " Default is set to 8192." +    ) +    private int httpServerThreadPoolQueueSize = 8192; + +    @FieldContext(doc = "Capacity for accept queue in the HTTP server" +                    + " Default is set to 8192." +    ) +    private int httpServerAcceptQueueSize = 8192; + +    @FieldContext(doc = "Maximum number of inbound http connections. " +            + "(0 to disable limiting)") +    private int maxHttpServerConnections = 2048; + +    @FieldContext(doc = "Number of connections per broker in Pulsar client used in WebSocket proxy") +    private int webSocketConnectionsPerBroker = Runtime.getRuntime().availableProcessors(); + +    @FieldContext(doc = "Memory limit in MBs for direct memory in Pulsar Client used in WebSocket proxy") +    private int webSocketPulsarClientMemoryLimitInMB = 0; + +    @FieldContext(doc = "Timeout of idling WebSocket session (in milliseconds)") +    private int webSocketSessionIdleTimeoutMillis = 300000; + +    @FieldContext(doc = "Interval of time to sending the ping to keep alive. This value greater than 0 means enabled") +    private int webSocketPingDurationSeconds = -1; + +    @FieldContext(doc = "When this parameter is not empty, unauthenticated users perform as anonymousUserRole") +    private String anonymousUserRole = null; + +    /* --- TLS --- */ +    @Deprecated +    private boolean tlsEnabled = false; + +    @FieldContext(doc = "Enable TLS of broker client") +    private boolean brokerClientTlsEnabled = false; + +    @FieldContext(doc = "Path for the TLS certificate file") +    private String tlsCertificateFilePath; + +    @FieldContext(doc = "Path for the TLS private key file") +    private String tlsKeyFilePath; + +    @FieldContext(doc = "Path for the trusted TLS certificate file") +    private String tlsTrustCertsFilePath = ""; + +    @FieldContext(doc = "Accept untrusted TLS certificate from client and broker") +    private boolean tlsAllowInsecureConnection = false; + +    @FieldContext(doc = "Specify whether client certificates are required for " +            + "TLS rejecting the connection if the client certificate is not trusted") +    private boolean tlsRequireTrustedClientCertOnConnect = false; + +    @FieldContext(doc = "TLS cert refresh duration (in seconds). 0 means checking every new connection.") +    private long tlsCertRefreshCheckDurationSec = 300; + +    /**** --- KeyStore TLS config variables. --- ****/ +    @FieldContext( +            doc = "Enable TLS with KeyStore type configuration for WebSocket" +    ) +    private boolean tlsEnabledWithKeyStore = false; + +    @FieldContext( +            doc = "Specify the TLS provider for the WebSocket service: SunJSSE, Conscrypt and etc." +    ) +    private String tlsProvider = "Conscrypt"; + +    @FieldContext( +            doc = "TLS KeyStore type configuration in WebSocket: JKS, PKCS12" +    ) +    private String tlsKeyStoreType = "JKS"; + +    @FieldContext( +            doc = "TLS KeyStore path in WebSocket" +    ) +    private String tlsKeyStore = null; + +    @FieldContext( +            doc = "TLS KeyStore password for WebSocket" +    ) +    @ToString.Exclude +    private String tlsKeyStorePassword = null; + +    @FieldContext( +            doc = "TLS TrustStore type configuration in WebSocket: JKS, PKCS12" +    ) +    private String tlsTrustStoreType = "JKS"; + +    @FieldContext( +            doc = "TLS TrustStore path in WebSocket" +    ) +    private String tlsTrustStore = null; + +    @FieldContext( +            doc = "TLS TrustStore password for WebSocket, null means empty password." +    ) +    @ToString.Exclude +    private String tlsTrustStorePassword = null; + +    @FieldContext( +            doc = "Specify the tls protocols the proxy's web service will use to negotiate during TLS Handshake.\n\n" +                    + "Example:- [TLSv1.3, TLSv1.2]" +    ) +    private Set<String> webServiceTlsProtocols = new TreeSet<>(); + +    @FieldContext( +            doc = "Specify the tls cipher the proxy's web service will use to negotiate during TLS Handshake.\n\n" +                    + "Example:- [TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256]" +    ) +    private Set<String> webServiceTlsCiphers = new TreeSet<>(); + +    @FieldContext( +            doc = "CryptoKeyReader factory classname to support encryption at websocket." +    ) +    private String cryptoKeyReaderFactoryClassName; + +    @FieldContext(doc = "Key-value properties. Types are all String") +    private Properties properties = new Properties(); + +    public long getMetadataStoreSessionTimeoutMillis() { +        return zooKeeperSessionTimeoutMillis > 0 ? zooKeeperSessionTimeoutMillis : metadataStoreSessionTimeoutMillis; +    } + +    public int getMetadataStoreCacheExpirySeconds() { +        return zooKeeperCacheExpirySeconds > 0 ? zooKeeperCacheExpirySeconds : metadataStoreCacheExpirySeconds; +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketServiceStarter.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketServiceStarter.java index 0a445aebe3..bc142d4968 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketServiceStarter.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/WebSocketServiceStarter.java @@ -1,123 +1,123 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; - -import static com.google.common.base.Preconditions.checkArgument; -import static org.apache.pulsar.websocket.admin.WebSocketWebResource.ADMIN_PATH_V1; -import static org.apache.pulsar.websocket.admin.WebSocketWebResource.ADMIN_PATH_V2; -import static org.apache.pulsar.websocket.admin.WebSocketWebResource.ATTRIBUTE_PROXY_SERVICE_NAME; -import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; -import org.apache.pulsar.common.configuration.VipStatus; -import org.apache.pulsar.common.util.ShutdownUtil; -import org.apache.pulsar.docs.tools.CmdGenerateDocs; -import org.apache.pulsar.websocket.WebSocketConsumerServlet; -import org.apache.pulsar.websocket.WebSocketMultiTopicConsumerServlet; -import org.apache.pulsar.websocket.WebSocketProducerServlet; -import org.apache.pulsar.websocket.WebSocketReaderServlet; -import org.apache.pulsar.websocket.WebSocketService; -import org.apache.pulsar.websocket.admin.v1.WebSocketProxyStatsV1; -import org.apache.pulsar.websocket.admin.v2.WebSocketProxyStatsV2; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; -import picocli.CommandLine; -import picocli.CommandLine.Command; -import picocli.CommandLine.Option; -import picocli.CommandLine.Parameters; -import picocli.CommandLine.ScopeType; - -public class WebSocketServiceStarter { -    @Command(name = "websocket", showDefaultValues = true, scope = ScopeType.INHERIT) -    private static class Arguments { -        @Parameters(description = "config file", arity = "0..1") -        private String configFile = ""; - -        @Option(names = {"-h", "--help"}, usageHelp = true, description = "Show this help message") -        private boolean help = false; - -        @Option(names = {"-g", "--generate-docs"}, description = "Generate docs") -        private boolean generateDocs = false; -    } - -    public static void main(String[] args) throws Exception { -        Arguments arguments = new Arguments(); -        CommandLine commander = new CommandLine(arguments); -        try { -            commander.parseArgs(args); -            if (arguments.help) { -                commander.usage(commander.getOut()); -                return; -            } -            if (arguments.generateDocs && arguments.configFile != null) { -                CmdGenerateDocs cmd = new CmdGenerateDocs("pulsar"); -                cmd.addCommand("websocket", commander); -                cmd.run(null); -                return; -            } -        } catch (Exception e) { -            commander.getErr().println(e); -            return; -        } - -        checkArgument(args.length == 1, "Need to specify a configuration file"); -        try { -            // load config file and start proxy service -            String configFile = args[0]; -            WebSocketProxyConfiguration config = loadConfig(configFile); -            ProxyServer proxyServer = new ProxyServer(config); -            WebSocketService service = new WebSocketService(config); -            start(proxyServer, service); -        } catch (Exception e) { -            log.error("Failed to start WebSocket service", e); -            ShutdownUtil.triggerImmediateForcefulShutdown(); -        } -    } - -    public static void start(ProxyServer proxyServer, WebSocketService service) throws Exception { -        proxyServer.addWebSocketServlet(WebSocketProducerServlet.SERVLET_PATH, new WebSocketProducerServlet(service)); -        proxyServer.addWebSocketServlet(WebSocketConsumerServlet.SERVLET_PATH, new WebSocketConsumerServlet(service)); -        proxyServer.addWebSocketServlet(WebSocketReaderServlet.SERVLET_PATH, new WebSocketReaderServlet(service)); - -        proxyServer.addWebSocketServlet(WebSocketProducerServlet.SERVLET_PATH_V2, -                new WebSocketProducerServlet(service)); -        proxyServer.addWebSocketServlet(WebSocketConsumerServlet.SERVLET_PATH_V2, -                new WebSocketConsumerServlet(service)); -        proxyServer.addWebSocketServlet(WebSocketMultiTopicConsumerServlet.SERVLET_PATH, -                new WebSocketMultiTopicConsumerServlet(service)); -        proxyServer.addWebSocketServlet(WebSocketReaderServlet.SERVLET_PATH_V2, -                new WebSocketReaderServlet(service)); - -        proxyServer.addRestResource(ADMIN_PATH_V1, ATTRIBUTE_PROXY_SERVICE_NAME, service, WebSocketProxyStatsV1.class); -        proxyServer.addRestResource(ADMIN_PATH_V2, ATTRIBUTE_PROXY_SERVICE_NAME, service, WebSocketProxyStatsV2.class); -        proxyServer.addRestResource("/", VipStatus.ATTRIBUTE_STATUS_FILE_PATH, service.getConfig().getStatusFilePath(), -                VipStatus.class); -        proxyServer.start(); -        service.start(); -    } - -    private static WebSocketProxyConfiguration loadConfig(String configFile) throws Exception { -        log.info("Loading configuration from {}", configFile); -        WebSocketProxyConfiguration config = PulsarConfigurationLoader.create(configFile, -                WebSocketProxyConfiguration.class); -        PulsarConfigurationLoader.isComplete(config); -        return config; -    } - -    private static final Logger log = LoggerFactory.getLogger(WebSocketServiceStarter.class); - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; + +import static com.google.common.base.Preconditions.checkArgument; +import static org.apache.pulsar.websocket.admin.WebSocketWebResource.ADMIN_PATH_V1; +import static org.apache.pulsar.websocket.admin.WebSocketWebResource.ADMIN_PATH_V2; +import static org.apache.pulsar.websocket.admin.WebSocketWebResource.ATTRIBUTE_PROXY_SERVICE_NAME; +import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; +import org.apache.pulsar.common.configuration.VipStatus; +import org.apache.pulsar.common.util.ShutdownUtil; +import org.apache.pulsar.docs.tools.CmdGenerateDocs; +import org.apache.pulsar.websocket.WebSocketConsumerServlet; +import org.apache.pulsar.websocket.WebSocketMultiTopicConsumerServlet; +import org.apache.pulsar.websocket.WebSocketProducerServlet; +import org.apache.pulsar.websocket.WebSocketReaderServlet; +import org.apache.pulsar.websocket.WebSocketService; +import org.apache.pulsar.websocket.admin.v1.WebSocketProxyStatsV1; +import org.apache.pulsar.websocket.admin.v2.WebSocketProxyStatsV2; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; +import picocli.CommandLine; +import picocli.CommandLine.Command; +import picocli.CommandLine.Option; +import picocli.CommandLine.Parameters; +import picocli.CommandLine.ScopeType; + +public class WebSocketServiceStarter { +    @Command(name = "websocket", showDefaultValues = true, scope = ScopeType.INHERIT) +    private static class Arguments { +        @Parameters(description = "config file", arity = "0..1") +        private String configFile = ""; + +        @Option(names = {"-h", "--help"}, usageHelp = true, description = "Show this help message") +        private boolean help = false; + +        @Option(names = {"-g", "--generate-docs"}, description = "Generate docs") +        private boolean generateDocs = false; +    } + +    public static void main(String[] args) throws Exception { +        Arguments arguments = new Arguments(); +        CommandLine commander = new CommandLine(arguments); +        try { +            commander.parseArgs(args); +            if (arguments.help) { +                commander.usage(commander.getOut()); +                return; +            } +            if (arguments.generateDocs && arguments.configFile != null) { +                CmdGenerateDocs cmd = new CmdGenerateDocs("pulsar"); +                cmd.addCommand("websocket", commander); +                cmd.run(null); +                return; +            } +        } catch (Exception e) { +            commander.getErr().println(e); +            return; +        } + +        checkArgument(args.length == 1, "Need to specify a configuration file"); +        try { +            // load config file and start proxy service +            String configFile = args[0]; +            WebSocketProxyConfiguration config = loadConfig(configFile); +            ProxyServer proxyServer = new ProxyServer(config); +            WebSocketService service = new WebSocketService(config); +            start(proxyServer, service); +        } catch (Exception e) { +            log.error("Failed to start WebSocket service", e); +            ShutdownUtil.triggerImmediateForcefulShutdown(); +        } +    } + +    public static void start(ProxyServer proxyServer, WebSocketService service) throws Exception { +        proxyServer.addWebSocketServlet(WebSocketProducerServlet.SERVLET_PATH, new WebSocketProducerServlet(service)); +        proxyServer.addWebSocketServlet(WebSocketConsumerServlet.SERVLET_PATH, new WebSocketConsumerServlet(service)); +        proxyServer.addWebSocketServlet(WebSocketReaderServlet.SERVLET_PATH, new WebSocketReaderServlet(service)); + +        proxyServer.addWebSocketServlet(WebSocketProducerServlet.SERVLET_PATH_V2, +                new WebSocketProducerServlet(service)); +        proxyServer.addWebSocketServlet(WebSocketConsumerServlet.SERVLET_PATH_V2, +                new WebSocketConsumerServlet(service)); +        proxyServer.addWebSocketServlet(WebSocketMultiTopicConsumerServlet.SERVLET_PATH, +                new WebSocketMultiTopicConsumerServlet(service)); +        proxyServer.addWebSocketServlet(WebSocketReaderServlet.SERVLET_PATH_V2, +                new WebSocketReaderServlet(service)); + +        proxyServer.addRestResource(ADMIN_PATH_V1, ATTRIBUTE_PROXY_SERVICE_NAME, service, WebSocketProxyStatsV1.class); +        proxyServer.addRestResource(ADMIN_PATH_V2, ATTRIBUTE_PROXY_SERVICE_NAME, service, WebSocketProxyStatsV2.class); +        proxyServer.addRestResource("/", VipStatus.ATTRIBUTE_STATUS_FILE_PATH, service.getConfig().getStatusFilePath(), +                VipStatus.class); +        proxyServer.start(); +        service.start(); +    } + +    private static WebSocketProxyConfiguration loadConfig(String configFile) throws Exception { +        log.info("Loading configuration from {}", configFile); +        WebSocketProxyConfiguration config = PulsarConfigurationLoader.create(configFile, +                WebSocketProxyConfiguration.class); +        PulsarConfigurationLoader.isComplete(config); +        return config; +    } + +    private static final Logger log = LoggerFactory.getLogger(WebSocketServiceStarter.class); + +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/package-info.java index dd719b7f36..d14ee69f91 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/service/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyStats.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyStats.java index 4660340e9c..2d36d60c8d 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyStats.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyStats.java @@ -1,168 +1,168 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.stats; - -import static org.apache.pulsar.common.util.Runnables.catchingAndLoggingThrowables; -import static org.apache.pulsar.websocket.ProducerHandler.ENTRY_LATENCY_BUCKETS_USEC; -import java.util.ArrayList; -import java.util.HashMap; -import java.util.List; -import java.util.Map; -import java.util.concurrent.ConcurrentHashMap; -import java.util.concurrent.TimeUnit; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.stats.JvmMetrics; -import org.apache.pulsar.common.stats.Metrics; -import org.apache.pulsar.websocket.WebSocketService; -import org.slf4j.Logger; -import org.slf4j.LoggerFactory; - -/** - * It periodically generates stats metrics of proxy service. - * - */ -public class ProxyStats { - -    private final WebSocketService service; -    private final JvmMetrics jvmMetrics; -    private final Map<String, ProxyNamespaceStats> topicStats = new ConcurrentHashMap<>(); -    private List<Metrics> metricsCollection; -    private List<Metrics> tempMetricsCollection; - -    public ProxyStats(WebSocketService service) { -        super(); -        this.service = service; -        this.jvmMetrics = JvmMetrics.create( -                service.getExecutor(), "prx", service.getConfig().getJvmGCMetricsLoggerClassName()); -        this.metricsCollection = new ArrayList<>(); -        this.tempMetricsCollection = new ArrayList<>(); -        // schedule stat generation task every 1 minute -        service.getExecutor() -                .scheduleAtFixedRate(catchingAndLoggingThrowables(this::generate), 120, 60, TimeUnit.SECONDS); -    } - -    /** -     * generates stats-metrics of proxy service and updates metricsCollection cache with latest stats. -     */ -    public synchronized void generate() { -        if (log.isDebugEnabled()) { -            log.debug("Start generating proxy metrics"); -        } - -        topicStats.clear(); - -        service.getProducers().forEach((topic, handlers) -> { -            if (log.isDebugEnabled()) { -                log.debug("Collect stats from {} producer handlers for topic {}", handlers.size(), topic); -            } - -            final String namespaceName = TopicName.get(topic).getNamespace(); -            ProxyNamespaceStats nsStat = topicStats.computeIfAbsent(namespaceName, ns -> new ProxyNamespaceStats()); -            handlers.forEach(handler -> { -                nsStat.numberOfMsgPublished += handler.getAndResetNumMsgsSent(); -                nsStat.numberOfBytesPublished += handler.getAndResetNumBytesSent(); -                nsStat.numberOfPublishFailure += handler.getAndResetNumMsgsFailed(); -                handler.getPublishLatencyStatsUSec().refresh(); -                nsStat.publishMsgLatency.addAll(handler.getPublishLatencyStatsUSec()); -            }); -        }); -        service.getConsumers().forEach((topic, handlers) -> { -            if (log.isDebugEnabled()) { -                log.debug("Collect stats from {} consumer handlers for topic {}", handlers.size(), topic); -            } - -            final String namespaceName = TopicName.get(topic).getNamespace(); -            ProxyNamespaceStats nsStat = topicStats.computeIfAbsent(namespaceName, ns -> new ProxyNamespaceStats()); -            handlers.forEach(handler -> { -                nsStat.numberOfMsgDelivered += handler.getAndResetNumMsgsAcked(); -                nsStat.numberOfBytesDelivered += handler.getAndResetNumBytesDelivered(); -                nsStat.numberOfMsgsAcked += handler.getAndResetNumMsgsAcked(); -            }); -        }); - -        tempMetricsCollection.clear(); -        topicStats.forEach((namespace, stats) -> { -            if (log.isDebugEnabled()) { -                log.debug("Add ns-stats of namespace {} to metrics", namespace); -            } -            tempMetricsCollection.add(stats.add(namespace)); -        }); - -        // add jvm-metrics -        if (log.isDebugEnabled()) { -            log.debug("Add jvm-stats to metrics"); -        } -        tempMetricsCollection.add(jvmMetrics.generate().get(0)); - -        // swap tempmetrics to stat-metrics -        List<Metrics> tempRef = metricsCollection; -        metricsCollection = tempMetricsCollection; -        tempMetricsCollection = tempRef; - -        if (log.isDebugEnabled()) { -            log.debug("Complete generating proxy metrics"); -        } -    } - -    public List<Metrics> getMetrics() { -        return metricsCollection; -    } - -    private static class ProxyNamespaceStats { - -        public long numberOfMsgPublished; -        public long numberOfBytesPublished; -        public long numberOfPublishFailure; -        public StatsBuckets publishMsgLatency; - -        public long numberOfMsgDelivered; -        public long numberOfBytesDelivered; -        public long numberOfMsgsAcked; - -        public ProxyNamespaceStats() { -            this.publishMsgLatency = new StatsBuckets(ENTRY_LATENCY_BUCKETS_USEC); -        } - -        public Metrics add(String namespace) { - -            publishMsgLatency.refresh(); -            long[] latencyBuckets = publishMsgLatency.getBuckets(); - -            Map<String, String> dimensionMap = new HashMap<>(); -            dimensionMap.put("namespace", namespace); -            Metrics dMetrics = Metrics.create(dimensionMap); -            dMetrics.put("ns_msg_publish_rate", numberOfMsgPublished); -            dMetrics.put("ns_byte_publish_rate", numberOfBytesPublished); -            dMetrics.put("ns_msg_failure_rate", numberOfPublishFailure); -            dMetrics.put("ns_msg_deliver_rate", numberOfMsgDelivered); -            dMetrics.put("ns_byte_deliver_rate", numberOfBytesDelivered); -            dMetrics.put("ns_msg_ack_rate", numberOfMsgsAcked); -            for (int i = 0; i < latencyBuckets.length; i++) { -                final String latencyBucket = i >= ENTRY_LATENCY_BUCKETS_USEC.size() -                        ? ENTRY_LATENCY_BUCKETS_USEC.get(ENTRY_LATENCY_BUCKETS_USEC.size() - 1) + "_higher" -                        : Long.toString(ENTRY_LATENCY_BUCKETS_USEC.get(i)); -                dMetrics.put("ns_msg_publish_latency_" + latencyBucket, latencyBuckets[i]); -            } -            return dMetrics; -        } -    } - -    private static final Logger log = LoggerFactory.getLogger(ProxyStats.class); - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.stats; + +import static org.apache.pulsar.common.util.Runnables.catchingAndLoggingThrowables; +import static org.apache.pulsar.websocket.ProducerHandler.ENTRY_LATENCY_BUCKETS_USEC; +import java.util.ArrayList; +import java.util.HashMap; +import java.util.List; +import java.util.Map; +import java.util.concurrent.ConcurrentHashMap; +import java.util.concurrent.TimeUnit; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.stats.JvmMetrics; +import org.apache.pulsar.common.stats.Metrics; +import org.apache.pulsar.websocket.WebSocketService; +import org.slf4j.Logger; +import org.slf4j.LoggerFactory; + +/** + * It periodically generates stats metrics of proxy service. + * + */ +public class ProxyStats { + +    private final WebSocketService service; +    private final JvmMetrics jvmMetrics; +    private final Map<String, ProxyNamespaceStats> topicStats = new ConcurrentHashMap<>(); +    private List<Metrics> metricsCollection; +    private List<Metrics> tempMetricsCollection; + +    public ProxyStats(WebSocketService service) { +        super(); +        this.service = service; +        this.jvmMetrics = JvmMetrics.create( +                service.getExecutor(), "prx", service.getConfig().getJvmGCMetricsLoggerClassName()); +        this.metricsCollection = new ArrayList<>(); +        this.tempMetricsCollection = new ArrayList<>(); +        // schedule stat generation task every 1 minute +        service.getExecutor() +                .scheduleAtFixedRate(catchingAndLoggingThrowables(this::generate), 120, 60, TimeUnit.SECONDS); +    } + +    /** +     * generates stats-metrics of proxy service and updates metricsCollection cache with latest stats. +     */ +    public synchronized void generate() { +        if (log.isDebugEnabled()) { +            log.debug("Start generating proxy metrics"); +        } + +        topicStats.clear(); + +        service.getProducers().forEach((topic, handlers) -> { +            if (log.isDebugEnabled()) { +                log.debug("Collect stats from {} producer handlers for topic {}", handlers.size(), topic); +            } + +            final String namespaceName = TopicName.get(topic).getNamespace(); +            ProxyNamespaceStats nsStat = topicStats.computeIfAbsent(namespaceName, ns -> new ProxyNamespaceStats()); +            handlers.forEach(handler -> { +                nsStat.numberOfMsgPublished += handler.getAndResetNumMsgsSent(); +                nsStat.numberOfBytesPublished += handler.getAndResetNumBytesSent(); +                nsStat.numberOfPublishFailure += handler.getAndResetNumMsgsFailed(); +                handler.getPublishLatencyStatsUSec().refresh(); +                nsStat.publishMsgLatency.addAll(handler.getPublishLatencyStatsUSec()); +            }); +        }); +        service.getConsumers().forEach((topic, handlers) -> { +            if (log.isDebugEnabled()) { +                log.debug("Collect stats from {} consumer handlers for topic {}", handlers.size(), topic); +            } + +            final String namespaceName = TopicName.get(topic).getNamespace(); +            ProxyNamespaceStats nsStat = topicStats.computeIfAbsent(namespaceName, ns -> new ProxyNamespaceStats()); +            handlers.forEach(handler -> { +                nsStat.numberOfMsgDelivered += handler.getAndResetNumMsgsAcked(); +                nsStat.numberOfBytesDelivered += handler.getAndResetNumBytesDelivered(); +                nsStat.numberOfMsgsAcked += handler.getAndResetNumMsgsAcked(); +            }); +        }); + +        tempMetricsCollection.clear(); +        topicStats.forEach((namespace, stats) -> { +            if (log.isDebugEnabled()) { +                log.debug("Add ns-stats of namespace {} to metrics", namespace); +            } +            tempMetricsCollection.add(stats.add(namespace)); +        }); + +        // add jvm-metrics +        if (log.isDebugEnabled()) { +            log.debug("Add jvm-stats to metrics"); +        } +        tempMetricsCollection.add(jvmMetrics.generate().get(0)); + +        // swap tempmetrics to stat-metrics +        List<Metrics> tempRef = metricsCollection; +        metricsCollection = tempMetricsCollection; +        tempMetricsCollection = tempRef; + +        if (log.isDebugEnabled()) { +            log.debug("Complete generating proxy metrics"); +        } +    } + +    public List<Metrics> getMetrics() { +        return metricsCollection; +    } + +    private static class ProxyNamespaceStats { + +        public long numberOfMsgPublished; +        public long numberOfBytesPublished; +        public long numberOfPublishFailure; +        public StatsBuckets publishMsgLatency; + +        public long numberOfMsgDelivered; +        public long numberOfBytesDelivered; +        public long numberOfMsgsAcked; + +        public ProxyNamespaceStats() { +            this.publishMsgLatency = new StatsBuckets(ENTRY_LATENCY_BUCKETS_USEC); +        } + +        public Metrics add(String namespace) { + +            publishMsgLatency.refresh(); +            long[] latencyBuckets = publishMsgLatency.getBuckets(); + +            Map<String, String> dimensionMap = new HashMap<>(); +            dimensionMap.put("namespace", namespace); +            Metrics dMetrics = Metrics.create(dimensionMap); +            dMetrics.put("ns_msg_publish_rate", numberOfMsgPublished); +            dMetrics.put("ns_byte_publish_rate", numberOfBytesPublished); +            dMetrics.put("ns_msg_failure_rate", numberOfPublishFailure); +            dMetrics.put("ns_msg_deliver_rate", numberOfMsgDelivered); +            dMetrics.put("ns_byte_deliver_rate", numberOfBytesDelivered); +            dMetrics.put("ns_msg_ack_rate", numberOfMsgsAcked); +            for (int i = 0; i < latencyBuckets.length; i++) { +                final String latencyBucket = i >= ENTRY_LATENCY_BUCKETS_USEC.size() +                        ? ENTRY_LATENCY_BUCKETS_USEC.get(ENTRY_LATENCY_BUCKETS_USEC.size() - 1) + "_higher" +                        : Long.toString(ENTRY_LATENCY_BUCKETS_USEC.get(i)); +                dMetrics.put("ns_msg_publish_latency_" + latencyBucket, latencyBuckets[i]); +            } +            return dMetrics; +        } +    } + +    private static final Logger log = LoggerFactory.getLogger(ProxyStats.class); + +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyTopicStat.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyTopicStat.java index 96a1b43add..d2fe43ddf2 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyTopicStat.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/ProxyTopicStat.java @@ -1,83 +1,83 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.stats; - -import java.util.HashSet; -import java.util.Set; -import org.apache.pulsar.client.api.SubscriptionMode; -import org.apache.pulsar.client.api.SubscriptionType; -import org.apache.pulsar.websocket.ConsumerHandler; -import org.apache.pulsar.websocket.ProducerHandler; -import org.apache.pulsar.websocket.ReaderHandler; - -/** - * Stats of topic served by web-socket proxy. It shows current stats of producers and consumers connected to proxy for a - * given topic - */ -public class ProxyTopicStat { - -    public final Set<ProducerStats> producerStats; -    public final Set<ConsumerStats> consumerStats; - -    public ProxyTopicStat() { -        this.producerStats = new HashSet<>(); -        this.consumerStats = new HashSet<>(); -    } - -    public static class ProducerStats { -        public ProducerStats() { -        } - -        public ProducerStats(ProducerHandler handler) { -            this.remoteConnection = handler.getRemote().getInetSocketAddress().toString(); -            this.numberOfMsgPublished = handler.getMsgPublishedCounter(); -        } - -        public String remoteConnection; -        public long numberOfMsgPublished; -    } - -    public static class ConsumerStats { - -        public ConsumerStats() { -        } - -        public ConsumerStats(ConsumerHandler handler) { -            this.subscriptionName = handler.getSubscription(); -            this.subscriptionType = handler.getSubscriptionType(); -            this.subscriptionMode = handler.getSubscriptionMode(); -            this.remoteConnection = handler.getRemote().getInetSocketAddress().toString(); -            this.numberOfMsgDelivered = handler.getMsgDeliveredCounter(); -        } - -        public ConsumerStats(ReaderHandler handler) { -            this.subscriptionName = handler.getSubscription(); -            this.subscriptionType = handler.getSubscriptionType(); -            this.remoteConnection = handler.getRemote().getInetSocketAddress().toString(); -            this.numberOfMsgDelivered = handler.getMsgDeliveredCounter(); -        } - -        public String remoteConnection; -        public String subscriptionName; -        public SubscriptionType subscriptionType; -        public SubscriptionMode subscriptionMode; -        public long numberOfMsgDelivered; -    } - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.stats; + +import java.util.HashSet; +import java.util.Set; +import org.apache.pulsar.client.api.SubscriptionMode; +import org.apache.pulsar.client.api.SubscriptionType; +import org.apache.pulsar.websocket.ConsumerHandler; +import org.apache.pulsar.websocket.ProducerHandler; +import org.apache.pulsar.websocket.ReaderHandler; + +/** + * Stats of topic served by web-socket proxy. It shows current stats of producers and consumers connected to proxy for a + * given topic + */ +public class ProxyTopicStat { + +    public final Set<ProducerStats> producerStats; +    public final Set<ConsumerStats> consumerStats; + +    public ProxyTopicStat() { +        this.producerStats = new HashSet<>(); +        this.consumerStats = new HashSet<>(); +    } + +    public static class ProducerStats { +        public ProducerStats() { +        } + +        public ProducerStats(ProducerHandler handler) { +            this.remoteConnection = handler.getRemote().getInetSocketAddress().toString(); +            this.numberOfMsgPublished = handler.getMsgPublishedCounter(); +        } + +        public String remoteConnection; +        public long numberOfMsgPublished; +    } + +    public static class ConsumerStats { + +        public ConsumerStats() { +        } + +        public ConsumerStats(ConsumerHandler handler) { +            this.subscriptionName = handler.getSubscription(); +            this.subscriptionType = handler.getSubscriptionType(); +            this.subscriptionMode = handler.getSubscriptionMode(); +            this.remoteConnection = handler.getRemote().getInetSocketAddress().toString(); +            this.numberOfMsgDelivered = handler.getMsgDeliveredCounter(); +        } + +        public ConsumerStats(ReaderHandler handler) { +            this.subscriptionName = handler.getSubscription(); +            this.subscriptionType = handler.getSubscriptionType(); +            this.remoteConnection = handler.getRemote().getInetSocketAddress().toString(); +            this.numberOfMsgDelivered = handler.getMsgDeliveredCounter(); +        } + +        public String remoteConnection; +        public String subscriptionName; +        public SubscriptionType subscriptionType; +        public SubscriptionMode subscriptionMode; +        public long numberOfMsgDelivered; +    } + +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/StatsBuckets.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/StatsBuckets.java index 31d90de160..3cb74d935b 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/StatsBuckets.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/StatsBuckets.java @@ -1,119 +1,119 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.stats; - -import static com.google.common.base.Preconditions.checkArgument; -import java.util.Arrays; -import java.util.List; -import java.util.concurrent.atomic.LongAdder; - -/** - * Create stats buckets to have frequency distribution of samples. - * - */ -public class StatsBuckets { -    private final long[] boundaries; -    private final LongAdder sumCounter; -    private final LongAdder[] buckets; - -    private final long[] values; -    private long count = 0; -    private long sum = 0; - -    public StatsBuckets(List<Long> boundaries) { -        this(boundaries.stream().mapToLong(l -> l).toArray()); -    } - -    public StatsBuckets(long... boundaries) { -        checkArgument(boundaries.length > 0); -        checkArgument(isSorted(boundaries), "Boundaries array must be sorted"); -        this.boundaries = boundaries; -        this.sumCounter = new LongAdder(); -        this.buckets = new LongAdder[boundaries.length + 1]; - -        for (int i = 0; i < buckets.length; i++) { -            buckets[i] = new LongAdder(); -        } - -        this.values = new long[buckets.length]; -    } - -    public void addAll(StatsBuckets other) { -        checkArgument(boundaries.length == other.boundaries.length); -        checkArgument(isSorted(other.boundaries), "Boundaries array must be sorted"); -        for (int i = 0; i < buckets.length; i++) { -            buckets[i].add(other.values[i]); -        } -        sumCounter.add(other.sum); -    } - -    public void addValue(long value) { -        int idx = Arrays.binarySearch(boundaries, value); -        if (idx < 0) { -            // If the precise value is not found, binary search is returning the negated insertion point -            idx = ~idx; -        } - -        buckets[idx].increment(); -        sumCounter.add(value); -    } - -    public void refresh() { -        long count = 0; -        sum = sumCounter.sumThenReset(); - -        for (int i = 0; i < buckets.length; i++) { -            long value = buckets[i].sumThenReset(); -            count += value; -            values[i] = value; -        } - -        this.count = count; -    } - -    public long[] getBuckets() { -        return values.clone(); -    } - -    public long getCount() { -        return count; -    } - -    public long getSum() { -        return sum; -    } - -    public double getAvg() { -        return sum / (double) count; -    } - -    private boolean isSorted(long[] array) { -        long previous = Long.MIN_VALUE; - -        for (long value : array) { -            if (value < previous) { -                return false; -            } - -            previous = value; -        } - -        return true; -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.stats; + +import static com.google.common.base.Preconditions.checkArgument; +import java.util.Arrays; +import java.util.List; +import java.util.concurrent.atomic.LongAdder; + +/** + * Create stats buckets to have frequency distribution of samples. + * + */ +public class StatsBuckets { +    private final long[] boundaries; +    private final LongAdder sumCounter; +    private final LongAdder[] buckets; + +    private final long[] values; +    private long count = 0; +    private long sum = 0; + +    public StatsBuckets(List<Long> boundaries) { +        this(boundaries.stream().mapToLong(l -> l).toArray()); +    } + +    public StatsBuckets(long... boundaries) { +        checkArgument(boundaries.length > 0); +        checkArgument(isSorted(boundaries), "Boundaries array must be sorted"); +        this.boundaries = boundaries; +        this.sumCounter = new LongAdder(); +        this.buckets = new LongAdder[boundaries.length + 1]; + +        for (int i = 0; i < buckets.length; i++) { +            buckets[i] = new LongAdder(); +        } + +        this.values = new long[buckets.length]; +    } + +    public void addAll(StatsBuckets other) { +        checkArgument(boundaries.length == other.boundaries.length); +        checkArgument(isSorted(other.boundaries), "Boundaries array must be sorted"); +        for (int i = 0; i < buckets.length; i++) { +            buckets[i].add(other.values[i]); +        } +        sumCounter.add(other.sum); +    } + +    public void addValue(long value) { +        int idx = Arrays.binarySearch(boundaries, value); +        if (idx < 0) { +            // If the precise value is not found, binary search is returning the negated insertion point +            idx = ~idx; +        } + +        buckets[idx].increment(); +        sumCounter.add(value); +    } + +    public void refresh() { +        long count = 0; +        sum = sumCounter.sumThenReset(); + +        for (int i = 0; i < buckets.length; i++) { +            long value = buckets[i].sumThenReset(); +            count += value; +            values[i] = value; +        } + +        this.count = count; +    } + +    public long[] getBuckets() { +        return values.clone(); +    } + +    public long getCount() { +        return count; +    } + +    public long getSum() { +        return sum; +    } + +    public double getAvg() { +        return sum / (double) count; +    } + +    private boolean isSorted(long[] array) { +        long previous = Long.MIN_VALUE; + +        for (long value : array) { +            if (value < previous) { +                return false; +            } + +            previous = value; +        } + +        return true; +    } +} diff --git a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/package-info.java b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/package-info.java index 924c507808..a4c5ab91a7 100644 --- a/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/package-info.java +++ b/pulsar-websocket/src/main/java/org/apache/pulsar/websocket/stats/package-info.java @@ -1,19 +1,19 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.stats; +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.stats; diff --git a/pulsar-websocket/src/main/resources/findbugsExclude.xml b/pulsar-websocket/src/main/resources/findbugsExclude.xml index c2b0d7dac0..cef07c926d 100644 --- a/pulsar-websocket/src/main/resources/findbugsExclude.xml +++ b/pulsar-websocket/src/main/resources/findbugsExclude.xml @@ -1,212 +1,212 @@ -<!-- - -    Licensed to the Apache Software Foundation (ASF) under one -    or more contributor license agreements.  See the NOTICE file -    distributed with this work for additional information -    regarding copyright ownership.  The ASF licenses this file -    to you under the Apache License, Version 2.0 (the -    "License"); you may not use this file except in compliance -    with the License.  You may obtain a copy of the License at - -      http://www.apache.org/licenses/LICENSE-2.0 - -    Unless required by applicable law or agreed to in writing, -    software distributed under the License is distributed on an -    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -    KIND, either express or implied.  See the License for the -    specific language governing permissions and limitations -    under the License. - ---> -<FindBugsFilter> -  <!-- these public fields may be used in other modules --> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ConsumerMessage"/> -    <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.stats.ProxyTopicStat$ConsumerStats"/> -    <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.stats.ProxyTopicStat$ProducerStats"/> -    <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/> -  </Match> - -  <!-- ignore existing violations when the rule was enabled --> -  <Match> -    <Class name="org.apache.pulsar.websocket.AbstractWebSocketHandler"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.admin.WebSocketWebResource"/> -    <Method name="authData"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ProducerAcks"/> -    <Method name="getMessagePublishResults"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ProducerAcks"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ProducerAcks"/> -    <Method name="setMessagePublishResults"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ProducerMessages"/> -    <Method name="getMessages"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ProducerMessages"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.data.ProducerMessages"/> -    <Method name="setMessages"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.ProducerHandler"/> -    <Method name="onWebSocketText"/> -    <Bug pattern="DCN_NULLPOINTER_EXCEPTION"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.ProducerHandler"/> -    <Method name="getPublishLatencyStatsUSec"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.ProducerHandler"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.ProxyServer"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="getAuthenticationProviders"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="getProperties"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="getSuperUserRoles"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="getWebServiceTlsCiphers"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="getWebServiceTlsProtocols"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="setAuthenticationProviders"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="setProperties"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="setSuperUserRoles"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="setWebServiceTlsCiphers"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> -    <Method name="setWebServiceTlsProtocols"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.stats.ProxyStats"/> -    <Method name="getMetrics"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.stats.ProxyStats"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketConsumerServlet"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketMultiTopicConsumerServlet"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketPingPongServlet"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketProducerServlet"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketReaderServlet"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketService"/> -    <Method name="getConfig"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketService"/> -    <Method name="getConsumers"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketService"/> -    <Method name="getProducers"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketService"/> -    <Method name="getReaders"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketService"/> -    <Method name="&lt;init&gt;"/> -    <Bug pattern="EI_EXPOSE_REP2"/> -  </Match> -  <Match> -    <Class name="org.apache.pulsar.websocket.WebSocketService"/> -    <Method name="getAuthorizationService"/> -    <Bug pattern="EI_EXPOSE_REP"/> -  </Match> +<!-- + +    Licensed to the Apache Software Foundation (ASF) under one +    or more contributor license agreements.  See the NOTICE file +    distributed with this work for additional information +    regarding copyright ownership.  The ASF licenses this file +    to you under the Apache License, Version 2.0 (the +    "License"); you may not use this file except in compliance +    with the License.  You may obtain a copy of the License at + +      http://www.apache.org/licenses/LICENSE-2.0 + +    Unless required by applicable law or agreed to in writing, +    software distributed under the License is distributed on an +    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY +    KIND, either express or implied.  See the License for the +    specific language governing permissions and limitations +    under the License. + +--> +<FindBugsFilter> +  <!-- these public fields may be used in other modules --> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ConsumerMessage"/> +    <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.stats.ProxyTopicStat$ConsumerStats"/> +    <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.stats.ProxyTopicStat$ProducerStats"/> +    <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"/> +  </Match> + +  <!-- ignore existing violations when the rule was enabled --> +  <Match> +    <Class name="org.apache.pulsar.websocket.AbstractWebSocketHandler"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.admin.WebSocketWebResource"/> +    <Method name="authData"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ProducerAcks"/> +    <Method name="getMessagePublishResults"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ProducerAcks"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ProducerAcks"/> +    <Method name="setMessagePublishResults"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ProducerMessages"/> +    <Method name="getMessages"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ProducerMessages"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.data.ProducerMessages"/> +    <Method name="setMessages"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.ProducerHandler"/> +    <Method name="onWebSocketText"/> +    <Bug pattern="DCN_NULLPOINTER_EXCEPTION"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.ProducerHandler"/> +    <Method name="getPublishLatencyStatsUSec"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.ProducerHandler"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.ProxyServer"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="getAuthenticationProviders"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="getProperties"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="getSuperUserRoles"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="getWebServiceTlsCiphers"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="getWebServiceTlsProtocols"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="setAuthenticationProviders"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="setProperties"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="setSuperUserRoles"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="setWebServiceTlsCiphers"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.service.WebSocketProxyConfiguration"/> +    <Method name="setWebServiceTlsProtocols"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.stats.ProxyStats"/> +    <Method name="getMetrics"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.stats.ProxyStats"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketConsumerServlet"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketMultiTopicConsumerServlet"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketPingPongServlet"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketProducerServlet"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketReaderServlet"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketService"/> +    <Method name="getConfig"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketService"/> +    <Method name="getConsumers"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketService"/> +    <Method name="getProducers"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketService"/> +    <Method name="getReaders"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketService"/> +    <Method name="&lt;init&gt;"/> +    <Bug pattern="EI_EXPOSE_REP2"/> +  </Match> +  <Match> +    <Class name="org.apache.pulsar.websocket.WebSocketService"/> +    <Method name="getAuthorizationService"/> +    <Bug pattern="EI_EXPOSE_REP"/> +  </Match>  </FindBugsFilter> \ No newline at end of file diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/AbstractWebSocketHandlerTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/AbstractWebSocketHandlerTest.java index e072ad5acd..01b29c8837 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/AbstractWebSocketHandlerTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/AbstractWebSocketHandlerTest.java @@ -1,471 +1,471 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static com.google.common.base.Preconditions.checkArgument; -import static org.mockito.Mockito.mock; -import static org.mockito.Mockito.when; -import static org.testng.Assert.assertEquals; -import static org.testng.Assert.assertFalse; -import static org.testng.Assert.assertNotNull; -import static org.testng.Assert.assertTrue; -import com.google.common.base.Splitter; -import java.io.IOException; -import java.net.URLEncoder; -import java.nio.charset.StandardCharsets; -import java.util.ArrayList; -import java.util.Collections; -import java.util.HashMap; -import java.util.List; -import java.util.Map; -import java.util.concurrent.ScheduledFuture; -import java.util.concurrent.TimeUnit; -import java.util.stream.Collectors; -import javax.servlet.http.HttpServletRequest; -import javax.servlet.http.HttpServletResponse; -import lombok.Cleanup; -import lombok.Getter; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.client.api.CompressionType; -import org.apache.pulsar.client.api.HashingScheme; -import org.apache.pulsar.client.api.MessageRoutingMode; -import org.apache.pulsar.client.api.PulsarClient; -import org.apache.pulsar.client.api.PulsarClientException; -import org.apache.pulsar.client.api.SubscriptionMode; -import org.apache.pulsar.client.api.SubscriptionType; -import org.apache.pulsar.client.impl.ConsumerBuilderImpl; -import org.apache.pulsar.client.impl.ProducerBuilderImpl; -import org.apache.pulsar.client.impl.conf.ConsumerConfigurationData; -import org.apache.pulsar.client.impl.conf.ProducerConfigurationData; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.util.Codec; -import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; -import org.eclipse.jetty.http.HttpStatus; -import org.eclipse.jetty.websocket.api.RemoteEndpoint; -import org.eclipse.jetty.websocket.api.Session; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.mockito.Mock; -import org.testng.annotations.AfterClass; -import org.testng.annotations.Test; - -public class AbstractWebSocketHandlerTest { -    List<PulsarClient> createdClients = Collections.synchronizedList(new ArrayList<>()); - -    @Mock -    private HttpServletRequest httpServletRequest; - -    @AfterClass(alwaysRun = true) -    final void cleanupCreatedClients() { -        for (PulsarClient createdClient : createdClients) { -            try { -                createdClient.shutdown(); -            } catch (PulsarClientException e) { -                // ignore -            } -        } -        createdClients.clear(); -    } - -    @Test -    public void topicNameUrlEncodingTest() throws Exception { -        String producerV1 = "/ws/producer/persistent/my-property/my-cluster/my-ns/"; -        String producerV1Topic = "my-topic[]<>"; -        String consumerV1 = "/ws/consumer/persistent/my-property/my-cluster/my-ns/"; -        String consumerV1Topic = "my-topic!@#!@@!#"; -        String consumerV1Sub = "my-subscription[]<>!@#$%^&*( )"; - -        String readerV1 = "/ws/reader/persistent/my-property/my-cluster/my-ns/"; -        String readerV1Topic = "my-topic[]!) (*&^%$#@"; - -        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/"; -        String producerV2Topic = "my-topic[]<>"; -        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/"; -        String consumerV2Topic = "my-topic"; -        String consumerV2Sub = "my-subscription[][]<>"; -        String readerV2 = "/ws/v2/reader/persistent/my-property/my-ns/"; -        String readerV2Topic = "my-topic/ / /@!$#^&*( /)1 /_`-</>[]"; - -        httpServletRequest = mock(HttpServletRequest.class); - -        when(httpServletRequest.getRequestURI()).thenReturn(producerV1 -                + URLEncoder.encode(producerV1Topic, StandardCharsets.UTF_8.name())); -        WebSocketHandlerImpl webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        TopicName topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/" + producerV1Topic); - -        when(httpServletRequest.getRequestURI()).thenReturn(consumerV1 -                + URLEncoder.encode(consumerV1Topic, StandardCharsets.UTF_8.name()) + "/" -                + URLEncoder.encode(consumerV1Sub, StandardCharsets.UTF_8.name())); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/" + consumerV1Topic); - -        when(httpServletRequest.getRequestURI()).thenReturn(readerV1 -                + URLEncoder.encode(readerV1Topic, StandardCharsets.UTF_8.name())); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/" + readerV1Topic); - -        when(httpServletRequest.getRequestURI()).thenReturn(producerV2 -                + URLEncoder.encode(producerV2Topic, StandardCharsets.UTF_8.name())); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-ns/" + producerV2Topic); - -        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2 -                + URLEncoder.encode(consumerV2Topic, StandardCharsets.UTF_8.name()) + "/" -                + URLEncoder.encode(consumerV2Sub, StandardCharsets.UTF_8.name())); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-ns/" + consumerV2Topic); -        String sub = extractSubscription(httpServletRequest); -        assertEquals(sub, consumerV2Sub); - -        when(httpServletRequest.getRequestURI()).thenReturn(readerV2 -                + URLEncoder.encode(readerV2Topic, StandardCharsets.UTF_8.name())); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-ns/" + readerV2Topic); -    } - -    public String extractSubscription(HttpServletRequest request) { -        String uri = request.getRequestURI(); -        List<String> parts = Splitter.on("/").splitToList(uri); - -        // v1 Format must be like : -        // /ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription - -        // v2 Format must be like : -        // /ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription -        checkArgument(parts.size() == 9, "Invalid topic name format"); -        checkArgument(parts.get(1).equals("ws")); - -        final boolean isV2Format = parts.get(2).equals("v2"); -        final int domainIndex = isV2Format ? 4 : 3; -        checkArgument(parts.get(domainIndex).equals("persistent") -                || parts.get(domainIndex).equals("non-persistent")); -        checkArgument(parts.get(8).length() > 0, "Empty subscription name"); - -        return Codec.decode(parts.get(8)); -    } - -    @Test -    public void parseTopicNameTest() { -        String producerV1 = "/ws/producer/persistent/my-property/my-cluster/my-ns/my-topic"; -        String consumerV1 = "/ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription"; -        String readerV1 = "/ws/reader/persistent/my-property/my-cluster/my-ns/my-topic"; - -        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/my-topic"; -        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription"; -        String consumerLongTopicNameV2 = "/ws/v2/consumer/persistent/my-tenant/my-ns/some/topic/with/slashes/my-sub"; -        String readerV2 = "/ws/v2/reader/persistent/my-property/my-ns/my-topic/ / /@!$#^&*( /)1 /_`-</>"; - -        httpServletRequest = mock(HttpServletRequest.class); - -        when(httpServletRequest.getRequestURI()).thenReturn(producerV1); -        WebSocketHandlerImpl webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        TopicName topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/my-topic"); - -        when(httpServletRequest.getRequestURI()).thenReturn(consumerV1); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/my-topic"); - -        when(httpServletRequest.getRequestURI()).thenReturn(readerV1); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/my-topic"); - -        when(httpServletRequest.getRequestURI()).thenReturn(producerV2); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-ns/my-topic"); - -        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-ns/my-topic"); - -        when(httpServletRequest.getRequestURI()).thenReturn(consumerLongTopicNameV2); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-tenant/my-ns/some/topic/with/slashes"); - -        when(httpServletRequest.getRequestURI()).thenReturn(readerV2); -        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); -        topicName = webSocketHandler.getTopic(); -        assertEquals(topicName.toString(), "persistent://my-property/my-ns/my-topic/ / /@!$#^&*( /)1 /_`-</>"); - -    } - -    static class WebSocketHandlerImpl extends AbstractWebSocketHandler { - -        public WebSocketHandlerImpl(WebSocketService service, HttpServletRequest request, -                                    ServletUpgradeResponse response) { -            super(service, request, response); -        } - -        @Override -        protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) { -            return null; -        } - -        @Override -        public void close() throws IOException { - -        } - -        public TopicName getTopic() { -            return super.topic; -        } - -    } - -    static class MockedServletUpgradeResponse extends ServletUpgradeResponse { - -        @Getter -        private int statusCode; -        @Getter -        private String message; - -        public MockedServletUpgradeResponse(HttpServletResponse response) { -            super(response); -        } - -        public void sendError(int statusCode, String message) { -            this.statusCode = statusCode; -            this.message = message; -        } -    } - -    PulsarClient newPulsarClient() throws PulsarClientException { -        PulsarClient client = PulsarClient.builder() -                .serviceUrl("pulsar://localhost:6650") -                .operationTimeout(1, TimeUnit.SECONDS) -                .build(); -        createdClients.add(client); -        return client; -    } - -    class MockedProducerHandler extends ProducerHandler { - -        public MockedProducerHandler(WebSocketService service, HttpServletRequest request, -                                     ServletUpgradeResponse response) { -            super(service, request, response); -        } - -        public ProducerConfigurationData getConf() throws PulsarClientException { -            return ((ProducerBuilderImpl<byte[]>) getProducerBuilder(newPulsarClient())).getConf(); -        } - -        public void clearQueryParams() { -            queryParams.clear(); -        } - -        public void putQueryParam(String key, String value) { -            queryParams.put(key, value); -        } -    } - -    @Test -    public void producerBuilderTest() throws IOException { -        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/my-topic"; -        // the params are all different with the default value -        Map<String, String[]> queryParams = new HashMap<String, String>(){{ -            put("producerName", "my-producer"); -            put("initialSequenceId", "1"); -            put("hashingScheme", "Murmur3_32Hash"); -            put("sendTimeoutMillis", "30001"); -            put("batchingEnabled", "true"); -            put("batchingMaxMessages", "1001"); -            put("maxPendingMessages", "1001"); -            put("batchingMaxPublishDelay", "2"); -            put("messageRoutingMode", "RoundRobinPartition"); -            put("compressionType", "LZ4"); -        }}.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> new String[]{ entry.getValue() })); - -        httpServletRequest = mock(HttpServletRequest.class); -        when(httpServletRequest.getRequestURI()).thenReturn(producerV2); -        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); - -        WebSocketService service = mock(WebSocketService.class); -        when(service.isAuthenticationEnabled()).thenReturn(false); -        when(service.isAuthorizationEnabled()).thenReturn(false); -        when(service.getPulsarClient()).thenReturn(newPulsarClient()); - -        MockedServletUpgradeResponse response = new MockedServletUpgradeResponse(null); - -        MockedProducerHandler producerHandler = new MockedProducerHandler(service, httpServletRequest, response); -        assertEquals(response.getStatusCode(), 500); -        assertTrue(response.getMessage().contains("Connection refused")); - -        ProducerConfigurationData conf = producerHandler.getConf(); -        assertEquals(conf.getProducerName(), "my-producer"); -        assertEquals(conf.getInitialSequenceId().longValue(), 1L); -        assertEquals(conf.getHashingScheme(), HashingScheme.Murmur3_32Hash); -        assertEquals(conf.getSendTimeoutMs(), 30001); -        assertTrue(conf.isBatchingEnabled()); -        assertEquals(conf.getBatchingMaxMessages(), 1001); -        assertEquals(conf.getMaxPendingMessages(), 1001); -        assertEquals(conf.getBatchingMaxPublishDelayMicros(), 2000); -        assertEquals(conf.getMessageRoutingMode(), MessageRoutingMode.RoundRobinPartition); -        assertEquals(conf.getCompressionType(), CompressionType.LZ4); - -        producerHandler.clearQueryParams(); -        conf = producerHandler.getConf(); -        // By default batching is disabled, which is different with ProducerBuilder -        assertFalse(conf.isBatchingEnabled()); - -        // The default message routing mode is SinglePartition, which is different with ProducerBuilder -        assertEquals(conf.getMessageRoutingMode(), MessageRoutingMode.SinglePartition); - -        producerHandler.putQueryParam("messageRoutingMode", "CustomPartition"); -        conf = producerHandler.getConf(); -        // ProducerHandler doesn't support CustomPartition -        assertEquals(conf.getMessageRoutingMode(), MessageRoutingMode.SinglePartition); -    } - -    class MockedConsumerHandler extends ConsumerHandler { - -        public MockedConsumerHandler(WebSocketService service, HttpServletRequest request, -                                     ServletUpgradeResponse response) { -            super(service, request, response); -        } - -        public ConsumerConfigurationData<byte[]> getConf() throws PulsarClientException { -            return ((ConsumerBuilderImpl<byte[]>) getConsumerConfiguration(newPulsarClient())).getConf(); -        } - -        public void clearQueryParams() { -            queryParams.clear(); -        } - -        public void putQueryParam(String key, String value) { -            queryParams.put(key, value); -        } -    } - -    @Test -    public void consumerBuilderTest() throws IOException { -        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription"; -        // the params are all different with the default value -        Map<String, String[]> queryParams = new HashMap<String, String>(){{ -            put("ackTimeoutMillis", "1001"); -            put("subscriptionType", "Key_Shared"); -            put("subscriptionMode", "NonDurable"); -            put("receiverQueueSize", "999"); -            put("consumerName", "my-consumer"); -            put("priorityLevel", "1"); -            put("maxRedeliverCount", "5"); -        }}.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> new String[]{ entry.getValue() })); - -        httpServletRequest = mock(HttpServletRequest.class); -        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2); -        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); - -        WebSocketService service = mock(WebSocketService.class); -        when(service.isAuthenticationEnabled()).thenReturn(false); -        when(service.isAuthorizationEnabled()).thenReturn(false); -        when(service.getPulsarClient()).thenReturn(newPulsarClient()); - -        MockedServletUpgradeResponse response = new MockedServletUpgradeResponse(null); - -        MockedConsumerHandler consumerHandler = new MockedConsumerHandler(service, httpServletRequest, response); -        assertEquals(response.getStatusCode(), 500); -        assertTrue(response.getMessage().contains("Connection refused")); -        assertEquals(consumerHandler.getSubscriptionMode(), SubscriptionMode.NonDurable); -        assertEquals(consumerHandler.getSubscriptionType(), SubscriptionType.Key_Shared); - -        ConsumerConfigurationData<byte[]> conf = consumerHandler.getConf(); -        assertEquals(conf.getAckTimeoutMillis(), 1001); -        assertEquals(conf.getSubscriptionType(), SubscriptionType.Key_Shared); -        assertEquals(conf.getSubscriptionMode(), SubscriptionMode.NonDurable); -        assertEquals(conf.getReceiverQueueSize(), 999); -        assertEquals(conf.getConsumerName(), "my-consumer"); -        assertEquals(conf.getPriorityLevel(), 1); -        assertEquals(conf.getDeadLetterPolicy().getDeadLetterTopic(), -                "persistent://my-property/my-ns/my-topic-my-subscription-DLQ"); -        assertEquals(conf.getDeadLetterPolicy().getMaxRedeliverCount(), 5); - -        consumerHandler.clearQueryParams(); -        consumerHandler.putQueryParam("receiverQueueSize", "1001"); -        consumerHandler.putQueryParam("deadLetterTopic", "dead-letter-topic"); -        consumerHandler.putQueryParam("maxRedeliverCount", "3"); - -        conf = consumerHandler.getConf(); -        // receive queue size is the minimum value of default value (1000) and user defined value(1001) -        assertEquals(conf.getReceiverQueueSize(), 1000); -        assertEquals(conf.getDeadLetterPolicy().getDeadLetterTopic(), "dead-letter-topic"); -        assertEquals(conf.getDeadLetterPolicy().getMaxRedeliverCount(), 3); -    } - -    @Test -    public void testPingFuture() throws IOException { -        WebSocketProxyConfiguration webSocketProxyConfiguration = new WebSocketProxyConfiguration(); -        webSocketProxyConfiguration.setWebSocketPingDurationSeconds(5); - -        @Cleanup -        WebSocketService webSocketService = new WebSocketService(webSocketProxyConfiguration); - -        HttpServletRequest httpServletRequest = mock(HttpServletRequest.class); -        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription"; -        Map<String, String[]> queryParams = new HashMap<String, String>(){{ -            put("ackTimeoutMillis", "1001"); -            put("subscriptionType", "Key_Shared"); -            put("subscriptionMode", "NonDurable"); -            put("receiverQueueSize", "999"); -            put("consumerName", "my-consumer"); -            put("priorityLevel", "1"); -            put("maxRedeliverCount", "5"); -        }}.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> new String[]{ entry.getValue() })); - -        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2); -        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); - -        MockedServletUpgradeResponse response = new MockedServletUpgradeResponse(null); -        AbstractWebSocketHandler webSocketHandler = -                new WebSocketHandlerImpl(webSocketService, httpServletRequest, response); - -        Session session = mock(Session.class); -        RemoteEndpoint remoteEndpoint = mock(RemoteEndpoint.class); -        when(session.getRemote()).thenReturn(remoteEndpoint); - -        // onWebSocketClose -        webSocketHandler.onWebSocketConnect(session); - -        ScheduledFuture<?> pingFuture = webSocketHandler.getPingFuture(); -        assertNotNull(pingFuture); -        assertFalse(pingFuture.isDone()); - -        webSocketHandler.onWebSocketClose(HttpStatus.INTERNAL_SERVER_ERROR_500, "INTERNAL_SERVER_ERROR_500"); -        assertTrue(pingFuture.isDone()); - - -        // onWebSocketError -        webSocketHandler.onWebSocketConnect(session); - -        pingFuture = webSocketHandler.getPingFuture(); -        assertNotNull(pingFuture); -        assertFalse(pingFuture.isDone()); - -        webSocketHandler.onWebSocketError(new RuntimeException("INTERNAL_SERVER_ERROR_500")); -        assertTrue(pingFuture.isDone()); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static com.google.common.base.Preconditions.checkArgument; +import static org.mockito.Mockito.mock; +import static org.mockito.Mockito.when; +import static org.testng.Assert.assertEquals; +import static org.testng.Assert.assertFalse; +import static org.testng.Assert.assertNotNull; +import static org.testng.Assert.assertTrue; +import com.google.common.base.Splitter; +import java.io.IOException; +import java.net.URLEncoder; +import java.nio.charset.StandardCharsets; +import java.util.ArrayList; +import java.util.Collections; +import java.util.HashMap; +import java.util.List; +import java.util.Map; +import java.util.concurrent.ScheduledFuture; +import java.util.concurrent.TimeUnit; +import java.util.stream.Collectors; +import javax.servlet.http.HttpServletRequest; +import javax.servlet.http.HttpServletResponse; +import lombok.Cleanup; +import lombok.Getter; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.client.api.CompressionType; +import org.apache.pulsar.client.api.HashingScheme; +import org.apache.pulsar.client.api.MessageRoutingMode; +import org.apache.pulsar.client.api.PulsarClient; +import org.apache.pulsar.client.api.PulsarClientException; +import org.apache.pulsar.client.api.SubscriptionMode; +import org.apache.pulsar.client.api.SubscriptionType; +import org.apache.pulsar.client.impl.ConsumerBuilderImpl; +import org.apache.pulsar.client.impl.ProducerBuilderImpl; +import org.apache.pulsar.client.impl.conf.ConsumerConfigurationData; +import org.apache.pulsar.client.impl.conf.ProducerConfigurationData; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.util.Codec; +import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; +import org.eclipse.jetty.http.HttpStatus; +import org.eclipse.jetty.websocket.api.RemoteEndpoint; +import org.eclipse.jetty.websocket.api.Session; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.mockito.Mock; +import org.testng.annotations.AfterClass; +import org.testng.annotations.Test; + +public class AbstractWebSocketHandlerTest { +    List<PulsarClient> createdClients = Collections.synchronizedList(new ArrayList<>()); + +    @Mock +    private HttpServletRequest httpServletRequest; + +    @AfterClass(alwaysRun = true) +    final void cleanupCreatedClients() { +        for (PulsarClient createdClient : createdClients) { +            try { +                createdClient.shutdown(); +            } catch (PulsarClientException e) { +                // ignore +            } +        } +        createdClients.clear(); +    } + +    @Test +    public void topicNameUrlEncodingTest() throws Exception { +        String producerV1 = "/ws/producer/persistent/my-property/my-cluster/my-ns/"; +        String producerV1Topic = "my-topic[]<>"; +        String consumerV1 = "/ws/consumer/persistent/my-property/my-cluster/my-ns/"; +        String consumerV1Topic = "my-topic!@#!@@!#"; +        String consumerV1Sub = "my-subscription[]<>!@#$%^&*( )"; + +        String readerV1 = "/ws/reader/persistent/my-property/my-cluster/my-ns/"; +        String readerV1Topic = "my-topic[]!) (*&^%$#@"; + +        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/"; +        String producerV2Topic = "my-topic[]<>"; +        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/"; +        String consumerV2Topic = "my-topic"; +        String consumerV2Sub = "my-subscription[][]<>"; +        String readerV2 = "/ws/v2/reader/persistent/my-property/my-ns/"; +        String readerV2Topic = "my-topic/ / /@!$#^&*( /)1 /_`-</>[]"; + +        httpServletRequest = mock(HttpServletRequest.class); + +        when(httpServletRequest.getRequestURI()).thenReturn(producerV1 +                + URLEncoder.encode(producerV1Topic, StandardCharsets.UTF_8.name())); +        WebSocketHandlerImpl webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        TopicName topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/" + producerV1Topic); + +        when(httpServletRequest.getRequestURI()).thenReturn(consumerV1 +                + URLEncoder.encode(consumerV1Topic, StandardCharsets.UTF_8.name()) + "/" +                + URLEncoder.encode(consumerV1Sub, StandardCharsets.UTF_8.name())); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/" + consumerV1Topic); + +        when(httpServletRequest.getRequestURI()).thenReturn(readerV1 +                + URLEncoder.encode(readerV1Topic, StandardCharsets.UTF_8.name())); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/" + readerV1Topic); + +        when(httpServletRequest.getRequestURI()).thenReturn(producerV2 +                + URLEncoder.encode(producerV2Topic, StandardCharsets.UTF_8.name())); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-ns/" + producerV2Topic); + +        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2 +                + URLEncoder.encode(consumerV2Topic, StandardCharsets.UTF_8.name()) + "/" +                + URLEncoder.encode(consumerV2Sub, StandardCharsets.UTF_8.name())); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-ns/" + consumerV2Topic); +        String sub = extractSubscription(httpServletRequest); +        assertEquals(sub, consumerV2Sub); + +        when(httpServletRequest.getRequestURI()).thenReturn(readerV2 +                + URLEncoder.encode(readerV2Topic, StandardCharsets.UTF_8.name())); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-ns/" + readerV2Topic); +    } + +    public String extractSubscription(HttpServletRequest request) { +        String uri = request.getRequestURI(); +        List<String> parts = Splitter.on("/").splitToList(uri); + +        // v1 Format must be like : +        // /ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription + +        // v2 Format must be like : +        // /ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription +        checkArgument(parts.size() == 9, "Invalid topic name format"); +        checkArgument(parts.get(1).equals("ws")); + +        final boolean isV2Format = parts.get(2).equals("v2"); +        final int domainIndex = isV2Format ? 4 : 3; +        checkArgument(parts.get(domainIndex).equals("persistent") +                || parts.get(domainIndex).equals("non-persistent")); +        checkArgument(parts.get(8).length() > 0, "Empty subscription name"); + +        return Codec.decode(parts.get(8)); +    } + +    @Test +    public void parseTopicNameTest() { +        String producerV1 = "/ws/producer/persistent/my-property/my-cluster/my-ns/my-topic"; +        String consumerV1 = "/ws/consumer/persistent/my-property/my-cluster/my-ns/my-topic/my-subscription"; +        String readerV1 = "/ws/reader/persistent/my-property/my-cluster/my-ns/my-topic"; + +        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/my-topic"; +        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription"; +        String consumerLongTopicNameV2 = "/ws/v2/consumer/persistent/my-tenant/my-ns/some/topic/with/slashes/my-sub"; +        String readerV2 = "/ws/v2/reader/persistent/my-property/my-ns/my-topic/ / /@!$#^&*( /)1 /_`-</>"; + +        httpServletRequest = mock(HttpServletRequest.class); + +        when(httpServletRequest.getRequestURI()).thenReturn(producerV1); +        WebSocketHandlerImpl webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        TopicName topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/my-topic"); + +        when(httpServletRequest.getRequestURI()).thenReturn(consumerV1); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/my-topic"); + +        when(httpServletRequest.getRequestURI()).thenReturn(readerV1); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-cluster/my-ns/my-topic"); + +        when(httpServletRequest.getRequestURI()).thenReturn(producerV2); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-ns/my-topic"); + +        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-ns/my-topic"); + +        when(httpServletRequest.getRequestURI()).thenReturn(consumerLongTopicNameV2); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-tenant/my-ns/some/topic/with/slashes"); + +        when(httpServletRequest.getRequestURI()).thenReturn(readerV2); +        webSocketHandler = new WebSocketHandlerImpl(null, httpServletRequest, null); +        topicName = webSocketHandler.getTopic(); +        assertEquals(topicName.toString(), "persistent://my-property/my-ns/my-topic/ / /@!$#^&*( /)1 /_`-</>"); + +    } + +    static class WebSocketHandlerImpl extends AbstractWebSocketHandler { + +        public WebSocketHandlerImpl(WebSocketService service, HttpServletRequest request, +                                    ServletUpgradeResponse response) { +            super(service, request, response); +        } + +        @Override +        protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) { +            return null; +        } + +        @Override +        public void close() throws IOException { + +        } + +        public TopicName getTopic() { +            return super.topic; +        } + +    } + +    static class MockedServletUpgradeResponse extends ServletUpgradeResponse { + +        @Getter +        private int statusCode; +        @Getter +        private String message; + +        public MockedServletUpgradeResponse(HttpServletResponse response) { +            super(response); +        } + +        public void sendError(int statusCode, String message) { +            this.statusCode = statusCode; +            this.message = message; +        } +    } + +    PulsarClient newPulsarClient() throws PulsarClientException { +        PulsarClient client = PulsarClient.builder() +                .serviceUrl("pulsar://localhost:6650") +                .operationTimeout(1, TimeUnit.SECONDS) +                .build(); +        createdClients.add(client); +        return client; +    } + +    class MockedProducerHandler extends ProducerHandler { + +        public MockedProducerHandler(WebSocketService service, HttpServletRequest request, +                                     ServletUpgradeResponse response) { +            super(service, request, response); +        } + +        public ProducerConfigurationData getConf() throws PulsarClientException { +            return ((ProducerBuilderImpl<byte[]>) getProducerBuilder(newPulsarClient())).getConf(); +        } + +        public void clearQueryParams() { +            queryParams.clear(); +        } + +        public void putQueryParam(String key, String value) { +            queryParams.put(key, value); +        } +    } + +    @Test +    public void producerBuilderTest() throws IOException { +        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/my-topic"; +        // the params are all different with the default value +        Map<String, String[]> queryParams = new HashMap<String, String>(){{ +            put("producerName", "my-producer"); +            put("initialSequenceId", "1"); +            put("hashingScheme", "Murmur3_32Hash"); +            put("sendTimeoutMillis", "30001"); +            put("batchingEnabled", "true"); +            put("batchingMaxMessages", "1001"); +            put("maxPendingMessages", "1001"); +            put("batchingMaxPublishDelay", "2"); +            put("messageRoutingMode", "RoundRobinPartition"); +            put("compressionType", "LZ4"); +        }}.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> new String[]{ entry.getValue() })); + +        httpServletRequest = mock(HttpServletRequest.class); +        when(httpServletRequest.getRequestURI()).thenReturn(producerV2); +        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); + +        WebSocketService service = mock(WebSocketService.class); +        when(service.isAuthenticationEnabled()).thenReturn(false); +        when(service.isAuthorizationEnabled()).thenReturn(false); +        when(service.getPulsarClient()).thenReturn(newPulsarClient()); + +        MockedServletUpgradeResponse response = new MockedServletUpgradeResponse(null); + +        MockedProducerHandler producerHandler = new MockedProducerHandler(service, httpServletRequest, response); +        assertEquals(response.getStatusCode(), 500); +        assertTrue(response.getMessage().contains("Connection refused")); + +        ProducerConfigurationData conf = producerHandler.getConf(); +        assertEquals(conf.getProducerName(), "my-producer"); +        assertEquals(conf.getInitialSequenceId().longValue(), 1L); +        assertEquals(conf.getHashingScheme(), HashingScheme.Murmur3_32Hash); +        assertEquals(conf.getSendTimeoutMs(), 30001); +        assertTrue(conf.isBatchingEnabled()); +        assertEquals(conf.getBatchingMaxMessages(), 1001); +        assertEquals(conf.getMaxPendingMessages(), 1001); +        assertEquals(conf.getBatchingMaxPublishDelayMicros(), 2000); +        assertEquals(conf.getMessageRoutingMode(), MessageRoutingMode.RoundRobinPartition); +        assertEquals(conf.getCompressionType(), CompressionType.LZ4); + +        producerHandler.clearQueryParams(); +        conf = producerHandler.getConf(); +        // By default batching is disabled, which is different with ProducerBuilder +        assertFalse(conf.isBatchingEnabled()); + +        // The default message routing mode is SinglePartition, which is different with ProducerBuilder +        assertEquals(conf.getMessageRoutingMode(), MessageRoutingMode.SinglePartition); + +        producerHandler.putQueryParam("messageRoutingMode", "CustomPartition"); +        conf = producerHandler.getConf(); +        // ProducerHandler doesn't support CustomPartition +        assertEquals(conf.getMessageRoutingMode(), MessageRoutingMode.SinglePartition); +    } + +    class MockedConsumerHandler extends ConsumerHandler { + +        public MockedConsumerHandler(WebSocketService service, HttpServletRequest request, +                                     ServletUpgradeResponse response) { +            super(service, request, response); +        } + +        public ConsumerConfigurationData<byte[]> getConf() throws PulsarClientException { +            return ((ConsumerBuilderImpl<byte[]>) getConsumerConfiguration(newPulsarClient())).getConf(); +        } + +        public void clearQueryParams() { +            queryParams.clear(); +        } + +        public void putQueryParam(String key, String value) { +            queryParams.put(key, value); +        } +    } + +    @Test +    public void consumerBuilderTest() throws IOException { +        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription"; +        // the params are all different with the default value +        Map<String, String[]> queryParams = new HashMap<String, String>(){{ +            put("ackTimeoutMillis", "1001"); +            put("subscriptionType", "Key_Shared"); +            put("subscriptionMode", "NonDurable"); +            put("receiverQueueSize", "999"); +            put("consumerName", "my-consumer"); +            put("priorityLevel", "1"); +            put("maxRedeliverCount", "5"); +        }}.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> new String[]{ entry.getValue() })); + +        httpServletRequest = mock(HttpServletRequest.class); +        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2); +        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); + +        WebSocketService service = mock(WebSocketService.class); +        when(service.isAuthenticationEnabled()).thenReturn(false); +        when(service.isAuthorizationEnabled()).thenReturn(false); +        when(service.getPulsarClient()).thenReturn(newPulsarClient()); + +        MockedServletUpgradeResponse response = new MockedServletUpgradeResponse(null); + +        MockedConsumerHandler consumerHandler = new MockedConsumerHandler(service, httpServletRequest, response); +        assertEquals(response.getStatusCode(), 500); +        assertTrue(response.getMessage().contains("Connection refused")); +        assertEquals(consumerHandler.getSubscriptionMode(), SubscriptionMode.NonDurable); +        assertEquals(consumerHandler.getSubscriptionType(), SubscriptionType.Key_Shared); + +        ConsumerConfigurationData<byte[]> conf = consumerHandler.getConf(); +        assertEquals(conf.getAckTimeoutMillis(), 1001); +        assertEquals(conf.getSubscriptionType(), SubscriptionType.Key_Shared); +        assertEquals(conf.getSubscriptionMode(), SubscriptionMode.NonDurable); +        assertEquals(conf.getReceiverQueueSize(), 999); +        assertEquals(conf.getConsumerName(), "my-consumer"); +        assertEquals(conf.getPriorityLevel(), 1); +        assertEquals(conf.getDeadLetterPolicy().getDeadLetterTopic(), +                "persistent://my-property/my-ns/my-topic-my-subscription-DLQ"); +        assertEquals(conf.getDeadLetterPolicy().getMaxRedeliverCount(), 5); + +        consumerHandler.clearQueryParams(); +        consumerHandler.putQueryParam("receiverQueueSize", "1001"); +        consumerHandler.putQueryParam("deadLetterTopic", "dead-letter-topic"); +        consumerHandler.putQueryParam("maxRedeliverCount", "3"); + +        conf = consumerHandler.getConf(); +        // receive queue size is the minimum value of default value (1000) and user defined value(1001) +        assertEquals(conf.getReceiverQueueSize(), 1000); +        assertEquals(conf.getDeadLetterPolicy().getDeadLetterTopic(), "dead-letter-topic"); +        assertEquals(conf.getDeadLetterPolicy().getMaxRedeliverCount(), 3); +    } + +    @Test +    public void testPingFuture() throws IOException { +        WebSocketProxyConfiguration webSocketProxyConfiguration = new WebSocketProxyConfiguration(); +        webSocketProxyConfiguration.setWebSocketPingDurationSeconds(5); + +        @Cleanup +        WebSocketService webSocketService = new WebSocketService(webSocketProxyConfiguration); + +        HttpServletRequest httpServletRequest = mock(HttpServletRequest.class); +        String consumerV2 = "/ws/v2/consumer/persistent/my-property/my-ns/my-topic/my-subscription"; +        Map<String, String[]> queryParams = new HashMap<String, String>(){{ +            put("ackTimeoutMillis", "1001"); +            put("subscriptionType", "Key_Shared"); +            put("subscriptionMode", "NonDurable"); +            put("receiverQueueSize", "999"); +            put("consumerName", "my-consumer"); +            put("priorityLevel", "1"); +            put("maxRedeliverCount", "5"); +        }}.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> new String[]{ entry.getValue() })); + +        when(httpServletRequest.getRequestURI()).thenReturn(consumerV2); +        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); + +        MockedServletUpgradeResponse response = new MockedServletUpgradeResponse(null); +        AbstractWebSocketHandler webSocketHandler = +                new WebSocketHandlerImpl(webSocketService, httpServletRequest, response); + +        Session session = mock(Session.class); +        RemoteEndpoint remoteEndpoint = mock(RemoteEndpoint.class); +        when(session.getRemote()).thenReturn(remoteEndpoint); + +        // onWebSocketClose +        webSocketHandler.onWebSocketConnect(session); + +        ScheduledFuture<?> pingFuture = webSocketHandler.getPingFuture(); +        assertNotNull(pingFuture); +        assertFalse(pingFuture.isDone()); + +        webSocketHandler.onWebSocketClose(HttpStatus.INTERNAL_SERVER_ERROR_500, "INTERNAL_SERVER_ERROR_500"); +        assertTrue(pingFuture.isDone()); + + +        // onWebSocketError +        webSocketHandler.onWebSocketConnect(session); + +        pingFuture = webSocketHandler.getPingFuture(); +        assertNotNull(pingFuture); +        assertFalse(pingFuture.isDone()); + +        webSocketHandler.onWebSocketError(new RuntimeException("INTERNAL_SERVER_ERROR_500")); +        assertTrue(pingFuture.isDone()); +    } +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/LookupProtocolTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/LookupProtocolTest.java index 67dff01e1c..a79c83ff49 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/LookupProtocolTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/LookupProtocolTest.java @@ -1,99 +1,99 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import io.netty.channel.epoll.Epoll; -import java.lang.reflect.Field; -import org.apache.pulsar.client.impl.PulsarClientImpl; -import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; -import org.testng.Assert; -import org.testng.annotations.Test; - -public class LookupProtocolTest { - -    static { -        // Trigger the loading of Epoll immediately, to avoid race condition in test -        Epoll.isAvailable(); -    } - -    @Test(timeOut = 10000) -    public void httpLookupTest() throws Exception{ -        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); -        conf.setServiceUrl("http://localhost:8080"); -        conf.setServiceUrlTls("https://localhost:8443"); -        WebSocketService service  = new WebSocketService(conf); -        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); -        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); -        lookupField.setAccessible(true); -        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), -                "org.apache.pulsar.client.impl.HttpLookupService"); -        service.close(); -    } - -    @Test(timeOut = 10000) -    public void httpsLookupTest() throws Exception{ -        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); -        conf.setServiceUrl("http://localhost:8080"); -        conf.setServiceUrlTls("https://localhost:8443"); -        conf.setBrokerServiceUrl("pulsar://localhost:6650"); -        conf.setBrokerClientTlsEnabled(true); -        WebSocketService service  = new WebSocketService(conf); -        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); -        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); -        lookupField.setAccessible(true); -        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), -                "org.apache.pulsar.client.impl.HttpLookupService"); -        Assert.assertTrue(testClient.getConfiguration().isUseTls()); -        service.close(); -    } - -    @Test(timeOut = 10000) -    public void binaryLookupTest() throws Exception{ -        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); -        conf.setServiceUrl("http://localhost:8080"); -        conf.setServiceUrlTls("https://localhost:8443"); -        conf.setBrokerServiceUrl("pulsar://localhost:6650"); -        conf.setBrokerServiceUrlTls("pulsar+ssl://localhost:6651"); -        WebSocketService service  = new WebSocketService(conf); -        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); -        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); -        lookupField.setAccessible(true); -        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), -                "org.apache.pulsar.client.impl.BinaryProtoLookupService"); -        service.close(); -    } - -    @Test(timeOut = 10000) -    public void binaryTlsLookupTest() throws Exception{ -        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); -        conf.setServiceUrl("http://localhost:8080"); -        conf.setServiceUrlTls("https://localhost:8443"); -        conf.setBrokerServiceUrl("pulsar://localhost:6650"); -        conf.setBrokerServiceUrlTls("pulsar+ssl://localhost:6651"); -        conf.setBrokerClientTlsEnabled(true); -        WebSocketService service  = new WebSocketService(conf); -        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); -        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); -        lookupField.setAccessible(true); -        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), -                "org.apache.pulsar.client.impl.BinaryProtoLookupService"); -        Assert.assertTrue(testClient.getConfiguration().isUseTls()); -        service.close(); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import io.netty.channel.epoll.Epoll; +import java.lang.reflect.Field; +import org.apache.pulsar.client.impl.PulsarClientImpl; +import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; +import org.testng.Assert; +import org.testng.annotations.Test; + +public class LookupProtocolTest { + +    static { +        // Trigger the loading of Epoll immediately, to avoid race condition in test +        Epoll.isAvailable(); +    } + +    @Test(timeOut = 10000) +    public void httpLookupTest() throws Exception{ +        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); +        conf.setServiceUrl("http://localhost:8080"); +        conf.setServiceUrlTls("https://localhost:8443"); +        WebSocketService service  = new WebSocketService(conf); +        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); +        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); +        lookupField.setAccessible(true); +        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), +                "org.apache.pulsar.client.impl.HttpLookupService"); +        service.close(); +    } + +    @Test(timeOut = 10000) +    public void httpsLookupTest() throws Exception{ +        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); +        conf.setServiceUrl("http://localhost:8080"); +        conf.setServiceUrlTls("https://localhost:8443"); +        conf.setBrokerServiceUrl("pulsar://localhost:6650"); +        conf.setBrokerClientTlsEnabled(true); +        WebSocketService service  = new WebSocketService(conf); +        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); +        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); +        lookupField.setAccessible(true); +        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), +                "org.apache.pulsar.client.impl.HttpLookupService"); +        Assert.assertTrue(testClient.getConfiguration().isUseTls()); +        service.close(); +    } + +    @Test(timeOut = 10000) +    public void binaryLookupTest() throws Exception{ +        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); +        conf.setServiceUrl("http://localhost:8080"); +        conf.setServiceUrlTls("https://localhost:8443"); +        conf.setBrokerServiceUrl("pulsar://localhost:6650"); +        conf.setBrokerServiceUrlTls("pulsar+ssl://localhost:6651"); +        WebSocketService service  = new WebSocketService(conf); +        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); +        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); +        lookupField.setAccessible(true); +        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), +                "org.apache.pulsar.client.impl.BinaryProtoLookupService"); +        service.close(); +    } + +    @Test(timeOut = 10000) +    public void binaryTlsLookupTest() throws Exception{ +        WebSocketProxyConfiguration conf = new WebSocketProxyConfiguration(); +        conf.setServiceUrl("http://localhost:8080"); +        conf.setServiceUrlTls("https://localhost:8443"); +        conf.setBrokerServiceUrl("pulsar://localhost:6650"); +        conf.setBrokerServiceUrlTls("pulsar+ssl://localhost:6651"); +        conf.setBrokerClientTlsEnabled(true); +        WebSocketService service  = new WebSocketService(conf); +        PulsarClientImpl testClient = (PulsarClientImpl) service.getPulsarClient(); +        Field lookupField = PulsarClientImpl.class.getDeclaredField("lookup"); +        lookupField.setAccessible(true); +        Assert.assertEquals(lookupField.get(testClient).getClass().getName(), +                "org.apache.pulsar.client.impl.BinaryProtoLookupService"); +        Assert.assertTrue(testClient.getConfiguration().isUseTls()); +        service.close(); +    } +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/PingPongSupportTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/PingPongSupportTest.java index 0bcb8b25ef..73c183b980 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/PingPongSupportTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/PingPongSupportTest.java @@ -1,188 +1,188 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static org.mockito.Mockito.mock; -import static org.mockito.Mockito.when; -import static org.testng.Assert.assertTrue; -import java.io.IOException; -import java.net.URI; -import java.nio.ByteBuffer; -import java.util.ArrayList; -import java.util.List; -import java.util.concurrent.ArrayBlockingQueue; -import java.util.concurrent.Future; -import javax.servlet.http.HttpServletRequest; -import lombok.Cleanup; -import org.apache.pulsar.broker.ServiceConfiguration; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.web.WebExecutorThreadPool; -import org.eclipse.jetty.client.HttpClient; -import org.eclipse.jetty.server.Server; -import org.eclipse.jetty.server.ServerConnector; -import org.eclipse.jetty.servlet.ServletContextHandler; -import org.eclipse.jetty.servlet.ServletHolder; -import org.eclipse.jetty.util.BufferUtil; -import org.eclipse.jetty.websocket.api.Session; -import org.eclipse.jetty.websocket.api.WebSocketAdapter; -import org.eclipse.jetty.websocket.api.WebSocketPingPongListener; -import org.eclipse.jetty.websocket.api.annotations.WebSocket; -import org.eclipse.jetty.websocket.client.WebSocketClient; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.eclipse.jetty.websocket.servlet.WebSocketServlet; -import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; -import org.testng.annotations.AfterClass; -import org.testng.annotations.BeforeClass; -import org.testng.annotations.DataProvider; -import org.testng.annotations.Test; - -/** - * Test to ensure {@link AbstractWebSocketHandler} has ping/pong support. - */ -public class PingPongSupportTest { - -    private Server server; - -    private WebExecutorThreadPool executor; - -    @BeforeClass -    public void setup() throws Exception { -        executor = new WebExecutorThreadPool(6, "pulsar-websocket-web-test"); -        server = new Server(executor); -        List<ServerConnector> connectors = new ArrayList<>(); -        ServerConnector connector = new ServerConnector(server); -        connector.setPort(8080); -        connectors.add(connector); -        connectors.forEach(c -> c.setAcceptQueueSize(1024 / connectors.size())); -        server.setConnectors(connectors.toArray(new ServerConnector[connectors.size()])); - -        WebSocketService service = mock(WebSocketService.class); -        ServiceConfiguration config = mock(ServiceConfiguration.class); - -        when(service.getConfig()).thenReturn(config); -        when(config.getWebSocketMaxTextFrameSize()).thenReturn(1048576); -        when(config.getWebSocketSessionIdleTimeoutMillis()).thenReturn(300000); - -        ServletHolder servletHolder = new ServletHolder("ws-events", new GenericWebSocketServlet(service)); -        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); -        context.setContextPath("/ws"); -        context.addServlet(servletHolder, "/*"); -        server.setHandler(context); -        try { -            server.start(); -        } catch (Exception e) { -            e.printStackTrace(); -        } -    } - -    @AfterClass(alwaysRun = true) -    public void tearDown() throws Exception { -        if (server != null) { -            server.stop(); -        } -        executor.stop(); -    } - -    /** -     * We test these different endpoints because they are parsed in the AbstractWebSocketHandler. Technically, we are -     * not testing these implementations, but the ping/pong support is guaranteed as part of the framework. -     */ -    @DataProvider(name = "endpoint") -    public static Object[][] cacheEnable() { -        return new Object[][] { { "producer" }, { "consumer" }, { "reader" } }; -    } - -    @Test(dataProvider = "endpoint") -    public void testPingPong(String endpoint) throws Exception { -        @Cleanup("stop") -        HttpClient httpClient = new HttpClient(); -        WebSocketClient webSocketClient = new WebSocketClient(httpClient); -        webSocketClient.start(); -        MyWebSocket myWebSocket = new MyWebSocket(); -        String webSocketUri = "ws://localhost:8080/ws/v2/" + endpoint + "/persistent/my-property/my-ns/my-topic"; -        Future<Session> sessionFuture = webSocketClient.connect(myWebSocket, URI.create(webSocketUri)); -        sessionFuture.get().getRemote().sendPing(ByteBuffer.wrap("test".getBytes())); -        assertTrue(myWebSocket.getResponse().contains("test")); -    } - -    public static class GenericWebSocketHandler extends AbstractWebSocketHandler { - -        public GenericWebSocketHandler(WebSocketService service, HttpServletRequest request, -                                       ServletUpgradeResponse response) { -            super(service, request, response); -        } - -        @Override -        protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { -            return true; -        } - -        @Override -        public void close() throws IOException { - -        } -    } - -    public static class GenericWebSocketServlet extends WebSocketServlet { - -        private static final long serialVersionUID = 1L; -        private final WebSocketService service; - -        public GenericWebSocketServlet(WebSocketService service) { -            this.service = service; -        } - -        @Override -        public void configure(WebSocketServletFactory factory) { -            factory.setCreator((request, response) -> -                    new GenericWebSocketHandler(service, request.getHttpServletRequest(), response)); -        } -    } - -    @WebSocket -    public static class MyWebSocket extends WebSocketAdapter implements WebSocketPingPongListener { - -        ArrayBlockingQueue<String> incomingMessages = new ArrayBlockingQueue<>(10); - -        @Override -        public void onWebSocketClose(int i, String s) { -        } - -        @Override -        public void onWebSocketConnect(Session session) { -        } - -        @Override -        public void onWebSocketError(Throwable throwable) { -        } - -        @Override -        public void onWebSocketPing(ByteBuffer payload) { -        } - -        @Override -        public void onWebSocketPong(ByteBuffer payload) { -            incomingMessages.add(BufferUtil.toDetailString(payload)); -        } - -        public String getResponse() throws InterruptedException { -            return incomingMessages.take(); -        } -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static org.mockito.Mockito.mock; +import static org.mockito.Mockito.when; +import static org.testng.Assert.assertTrue; +import java.io.IOException; +import java.net.URI; +import java.nio.ByteBuffer; +import java.util.ArrayList; +import java.util.List; +import java.util.concurrent.ArrayBlockingQueue; +import java.util.concurrent.Future; +import javax.servlet.http.HttpServletRequest; +import lombok.Cleanup; +import org.apache.pulsar.broker.ServiceConfiguration; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.web.WebExecutorThreadPool; +import org.eclipse.jetty.client.HttpClient; +import org.eclipse.jetty.server.Server; +import org.eclipse.jetty.server.ServerConnector; +import org.eclipse.jetty.servlet.ServletContextHandler; +import org.eclipse.jetty.servlet.ServletHolder; +import org.eclipse.jetty.util.BufferUtil; +import org.eclipse.jetty.websocket.api.Session; +import org.eclipse.jetty.websocket.api.WebSocketAdapter; +import org.eclipse.jetty.websocket.api.WebSocketPingPongListener; +import org.eclipse.jetty.websocket.api.annotations.WebSocket; +import org.eclipse.jetty.websocket.client.WebSocketClient; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.eclipse.jetty.websocket.servlet.WebSocketServlet; +import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory; +import org.testng.annotations.AfterClass; +import org.testng.annotations.BeforeClass; +import org.testng.annotations.DataProvider; +import org.testng.annotations.Test; + +/** + * Test to ensure {@link AbstractWebSocketHandler} has ping/pong support. + */ +public class PingPongSupportTest { + +    private Server server; + +    private WebExecutorThreadPool executor; + +    @BeforeClass +    public void setup() throws Exception { +        executor = new WebExecutorThreadPool(6, "pulsar-websocket-web-test"); +        server = new Server(executor); +        List<ServerConnector> connectors = new ArrayList<>(); +        ServerConnector connector = new ServerConnector(server); +        connector.setPort(8080); +        connectors.add(connector); +        connectors.forEach(c -> c.setAcceptQueueSize(1024 / connectors.size())); +        server.setConnectors(connectors.toArray(new ServerConnector[connectors.size()])); + +        WebSocketService service = mock(WebSocketService.class); +        ServiceConfiguration config = mock(ServiceConfiguration.class); + +        when(service.getConfig()).thenReturn(config); +        when(config.getWebSocketMaxTextFrameSize()).thenReturn(1048576); +        when(config.getWebSocketSessionIdleTimeoutMillis()).thenReturn(300000); + +        ServletHolder servletHolder = new ServletHolder("ws-events", new GenericWebSocketServlet(service)); +        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); +        context.setContextPath("/ws"); +        context.addServlet(servletHolder, "/*"); +        server.setHandler(context); +        try { +            server.start(); +        } catch (Exception e) { +            e.printStackTrace(); +        } +    } + +    @AfterClass(alwaysRun = true) +    public void tearDown() throws Exception { +        if (server != null) { +            server.stop(); +        } +        executor.stop(); +    } + +    /** +     * We test these different endpoints because they are parsed in the AbstractWebSocketHandler. Technically, we are +     * not testing these implementations, but the ping/pong support is guaranteed as part of the framework. +     */ +    @DataProvider(name = "endpoint") +    public static Object[][] cacheEnable() { +        return new Object[][] { { "producer" }, { "consumer" }, { "reader" } }; +    } + +    @Test(dataProvider = "endpoint") +    public void testPingPong(String endpoint) throws Exception { +        @Cleanup("stop") +        HttpClient httpClient = new HttpClient(); +        WebSocketClient webSocketClient = new WebSocketClient(httpClient); +        webSocketClient.start(); +        MyWebSocket myWebSocket = new MyWebSocket(); +        String webSocketUri = "ws://localhost:8080/ws/v2/" + endpoint + "/persistent/my-property/my-ns/my-topic"; +        Future<Session> sessionFuture = webSocketClient.connect(myWebSocket, URI.create(webSocketUri)); +        sessionFuture.get().getRemote().sendPing(ByteBuffer.wrap("test".getBytes())); +        assertTrue(myWebSocket.getResponse().contains("test")); +    } + +    public static class GenericWebSocketHandler extends AbstractWebSocketHandler { + +        public GenericWebSocketHandler(WebSocketService service, HttpServletRequest request, +                                       ServletUpgradeResponse response) { +            super(service, request, response); +        } + +        @Override +        protected Boolean isAuthorized(String authRole, AuthenticationDataSource authenticationData) throws Exception { +            return true; +        } + +        @Override +        public void close() throws IOException { + +        } +    } + +    public static class GenericWebSocketServlet extends WebSocketServlet { + +        private static final long serialVersionUID = 1L; +        private final WebSocketService service; + +        public GenericWebSocketServlet(WebSocketService service) { +            this.service = service; +        } + +        @Override +        public void configure(WebSocketServletFactory factory) { +            factory.setCreator((request, response) -> +                    new GenericWebSocketHandler(service, request.getHttpServletRequest(), response)); +        } +    } + +    @WebSocket +    public static class MyWebSocket extends WebSocketAdapter implements WebSocketPingPongListener { + +        ArrayBlockingQueue<String> incomingMessages = new ArrayBlockingQueue<>(10); + +        @Override +        public void onWebSocketClose(int i, String s) { +        } + +        @Override +        public void onWebSocketConnect(Session session) { +        } + +        @Override +        public void onWebSocketError(Throwable throwable) { +        } + +        @Override +        public void onWebSocketPing(ByteBuffer payload) { +        } + +        @Override +        public void onWebSocketPong(ByteBuffer payload) { +            incomingMessages.add(BufferUtil.toDetailString(payload)); +        } + +        public String getResponse() throws InterruptedException { +            return incomingMessages.take(); +        } +    } +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ProducerHandlerTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ProducerHandlerTest.java index bca3671b73..1e1f723ae3 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ProducerHandlerTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ProducerHandlerTest.java @@ -1,94 +1,94 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static org.mockito.ArgumentMatchers.any; -import static org.mockito.ArgumentMatchers.anyBoolean; -import static org.mockito.ArgumentMatchers.anyString; -import static org.mockito.Mockito.mock; -import static org.mockito.Mockito.times; -import static org.mockito.Mockito.verify; -import static org.mockito.Mockito.when; -import java.io.IOException; -import java.util.Base64; -import java.util.HashMap; -import java.util.Map; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.TimeUnit; -import javax.servlet.http.HttpServletRequest; -import org.apache.pulsar.client.api.Producer; -import org.apache.pulsar.client.api.ProducerBuilder; -import org.apache.pulsar.client.api.PulsarClient; -import org.apache.pulsar.client.api.TypedMessageBuilder; -import org.apache.pulsar.client.impl.MessageIdImpl; -import org.apache.pulsar.client.impl.TypedMessageBuilderImpl; -import org.apache.pulsar.common.util.ObjectMapperFactory; -import org.apache.pulsar.websocket.data.ProducerMessage; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.testng.annotations.Test; - -public class ProducerHandlerTest { - -    @Test -    public void testProduceMessageAttributes() throws IOException { -        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/my-topic"; -        HttpServletRequest httpServletRequest = mock(HttpServletRequest.class); -        PulsarClient pulsarClient = mock(PulsarClient.class); -        ProducerBuilder producerBuilder = mock(ProducerBuilder.class); -        Producer producer = mock(Producer.class); -        TypedMessageBuilder messageBuilder = mock(TypedMessageBuilderImpl.class); -        ProducerMessage produceRequest = new ProducerMessage(); - -        produceRequest.setDeliverAfterMs(11111); -        produceRequest.setDeliverAt(22222); -        produceRequest.setContext("context"); -        produceRequest.setPayload(Base64.getEncoder().encodeToString("my payload".getBytes())); - -        // the params are all different with the default value -        Map<String, String[]> queryParams = new HashMap<>(); - -        httpServletRequest = mock(HttpServletRequest.class); -        when(httpServletRequest.getRequestURI()).thenReturn(producerV2); -        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); - -        WebSocketService service = mock(WebSocketService.class); -        when(service.isAuthenticationEnabled()).thenReturn(false); -        when(service.isAuthorizationEnabled()).thenReturn(false); -        when(service.getPulsarClient()).thenReturn(pulsarClient); - -        when(pulsarClient.newProducer()).thenReturn(producerBuilder); -        when(producerBuilder.enableBatching(anyBoolean())).thenReturn(producerBuilder); -        when(producerBuilder.messageRoutingMode(any())).thenReturn(producerBuilder); -        when(producerBuilder.blockIfQueueFull(anyBoolean())).thenReturn(producerBuilder); -        when(producerBuilder.topic(anyString())).thenReturn(producerBuilder); -        when(producerBuilder.create()).thenReturn(producer); - -        when(producer.newMessage()).thenReturn(messageBuilder); -        when(messageBuilder.sendAsync()).thenReturn(CompletableFuture.completedFuture(new MessageIdImpl(1, 2, 3))); - -        ServletUpgradeResponse response = mock(ServletUpgradeResponse.class); - -        ProducerHandler producerHandler = new ProducerHandler(service, httpServletRequest, response); -        producerHandler.onWebSocketText(ObjectMapperFactory.getMapper().writer().writeValueAsString(produceRequest)); - -        verify(messageBuilder, times(1)).deliverAfter(11111, TimeUnit.MILLISECONDS); -        verify(messageBuilder, times(1)).deliverAt(22222); -    } - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static org.mockito.ArgumentMatchers.any; +import static org.mockito.ArgumentMatchers.anyBoolean; +import static org.mockito.ArgumentMatchers.anyString; +import static org.mockito.Mockito.mock; +import static org.mockito.Mockito.times; +import static org.mockito.Mockito.verify; +import static org.mockito.Mockito.when; +import java.io.IOException; +import java.util.Base64; +import java.util.HashMap; +import java.util.Map; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.TimeUnit; +import javax.servlet.http.HttpServletRequest; +import org.apache.pulsar.client.api.Producer; +import org.apache.pulsar.client.api.ProducerBuilder; +import org.apache.pulsar.client.api.PulsarClient; +import org.apache.pulsar.client.api.TypedMessageBuilder; +import org.apache.pulsar.client.impl.MessageIdImpl; +import org.apache.pulsar.client.impl.TypedMessageBuilderImpl; +import org.apache.pulsar.common.util.ObjectMapperFactory; +import org.apache.pulsar.websocket.data.ProducerMessage; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.testng.annotations.Test; + +public class ProducerHandlerTest { + +    @Test +    public void testProduceMessageAttributes() throws IOException { +        String producerV2 = "/ws/v2/producer/persistent/my-property/my-ns/my-topic"; +        HttpServletRequest httpServletRequest = mock(HttpServletRequest.class); +        PulsarClient pulsarClient = mock(PulsarClient.class); +        ProducerBuilder producerBuilder = mock(ProducerBuilder.class); +        Producer producer = mock(Producer.class); +        TypedMessageBuilder messageBuilder = mock(TypedMessageBuilderImpl.class); +        ProducerMessage produceRequest = new ProducerMessage(); + +        produceRequest.setDeliverAfterMs(11111); +        produceRequest.setDeliverAt(22222); +        produceRequest.setContext("context"); +        produceRequest.setPayload(Base64.getEncoder().encodeToString("my payload".getBytes())); + +        // the params are all different with the default value +        Map<String, String[]> queryParams = new HashMap<>(); + +        httpServletRequest = mock(HttpServletRequest.class); +        when(httpServletRequest.getRequestURI()).thenReturn(producerV2); +        when(httpServletRequest.getParameterMap()).thenReturn(queryParams); + +        WebSocketService service = mock(WebSocketService.class); +        when(service.isAuthenticationEnabled()).thenReturn(false); +        when(service.isAuthorizationEnabled()).thenReturn(false); +        when(service.getPulsarClient()).thenReturn(pulsarClient); + +        when(pulsarClient.newProducer()).thenReturn(producerBuilder); +        when(producerBuilder.enableBatching(anyBoolean())).thenReturn(producerBuilder); +        when(producerBuilder.messageRoutingMode(any())).thenReturn(producerBuilder); +        when(producerBuilder.blockIfQueueFull(anyBoolean())).thenReturn(producerBuilder); +        when(producerBuilder.topic(anyString())).thenReturn(producerBuilder); +        when(producerBuilder.create()).thenReturn(producer); + +        when(producer.newMessage()).thenReturn(messageBuilder); +        when(messageBuilder.sendAsync()).thenReturn(CompletableFuture.completedFuture(new MessageIdImpl(1, 2, 3))); + +        ServletUpgradeResponse response = mock(ServletUpgradeResponse.class); + +        ProducerHandler producerHandler = new ProducerHandler(service, httpServletRequest, response); +        producerHandler.onWebSocketText(ObjectMapperFactory.getMapper().writer().writeValueAsString(produceRequest)); + +        verify(messageBuilder, times(1)).deliverAfter(11111, TimeUnit.MILLISECONDS); +        verify(messageBuilder, times(1)).deliverAt(22222); +    } + +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ReaderHandlerTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ReaderHandlerTest.java index be2fa241e1..ed9f54f263 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ReaderHandlerTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/ReaderHandlerTest.java @@ -1,230 +1,230 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static org.mockito.Mockito.any; -import static org.mockito.Mockito.anyInt; -import static org.mockito.Mockito.anyString; -import static org.mockito.Mockito.mock; -import static org.mockito.Mockito.spy; -import static org.mockito.Mockito.times; -import static org.mockito.Mockito.verify; -import static org.mockito.Mockito.when; -import java.io.IOException; -import java.util.List; -import java.util.concurrent.CompletableFuture; -import java.util.concurrent.TimeUnit; -import java.util.function.Function; -import javax.servlet.http.HttpServletRequest; -import javax.servlet.http.HttpServletResponse; -import org.apache.pulsar.client.api.Message; -import org.apache.pulsar.client.api.MessageId; -import org.apache.pulsar.client.api.PulsarClient; -import org.apache.pulsar.client.api.PulsarClientException; -import org.apache.pulsar.client.api.Reader; -import org.apache.pulsar.client.api.ReaderBuilder; -import org.apache.pulsar.client.api.TopicMessageId; -import org.apache.pulsar.client.impl.ConsumerImpl; -import org.apache.pulsar.client.impl.MultiTopicsConsumerImpl; -import org.apache.pulsar.client.impl.MultiTopicsReaderImpl; -import org.apache.pulsar.client.impl.ReaderImpl; -import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; -import org.testng.Assert; -import org.testng.annotations.Test; - -public class ReaderHandlerTest { - -    @Test -    @SuppressWarnings("unchecked") -    public void testCreateReaderImp() throws IOException { -        final String subName = "readerImpSubscription"; -        // mock data -        WebSocketService wss = mock(WebSocketService.class); -        PulsarClient mockedClient = mock(PulsarClient.class); -        when(wss.getPulsarClient()).thenReturn(mockedClient); -        ReaderBuilder<byte[]> mockedReaderBuilder = mock(ReaderBuilder.class); -        when(mockedClient.newReader()).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.topic(any())).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.startMessageId(any())).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.receiverQueueSize(anyInt())).thenReturn(mockedReaderBuilder); -        ReaderImpl<byte[]> mockedReader = mock(ReaderImpl.class); -        when(mockedReaderBuilder.create()).thenReturn(mockedReader); -        ConsumerImpl<byte[]> consumerImp = mock(ConsumerImpl.class); -        when(consumerImp.getSubscription()).thenReturn(subName); -        when(mockedReader.getConsumer()).thenReturn(consumerImp); -        HttpServletRequest request = mock(HttpServletRequest.class); -        when(request.getRequestURI()).thenReturn("/ws/v2/producer/persistent/my-property/my-ns/my-topic"); -        // create reader handler -        HttpServletResponse response = spy(HttpServletResponse.class); -        ServletUpgradeResponse servletUpgradeResponse = new ServletUpgradeResponse(response); -        ReaderHandler readerHandler = new ReaderHandler(wss, request, servletUpgradeResponse); -        // verify success -        Assert.assertEquals(readerHandler.getSubscription(), subName); -        // Verify consumer is returned -        readerHandler.getConsumer(); -    } - -    @Test -    @SuppressWarnings("unchecked") -    public void testCreateMultipleTopicReaderImp() throws IOException { -        final String subName = "multipleTopicReaderImpSubscription"; -        // mock data -        WebSocketService wss = mock(WebSocketService.class); -        PulsarClient mockedClient = mock(PulsarClient.class); -        when(wss.getPulsarClient()).thenReturn(mockedClient); -        ReaderBuilder<byte[]> mockedReaderBuilder = mock(ReaderBuilder.class); -        when(mockedClient.newReader()).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.topic(any())).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.startMessageId(any())).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.receiverQueueSize(anyInt())).thenReturn(mockedReaderBuilder); -        MultiTopicsReaderImpl<byte[]> mockedReader = mock(MultiTopicsReaderImpl.class); -        when(mockedReaderBuilder.create()).thenReturn(mockedReader); -        MultiTopicsConsumerImpl<byte[]> consumerImp = mock(MultiTopicsConsumerImpl.class); -        when(consumerImp.getSubscription()).thenReturn(subName); -        when(mockedReader.getMultiTopicsConsumer()).thenReturn(consumerImp); -        HttpServletRequest request = mock(HttpServletRequest.class); -        when(request.getRequestURI()).thenReturn("/ws/v2/producer/persistent/my-property/my-ns/my-topic"); -        // create reader handler -        HttpServletResponse response = spy(HttpServletResponse.class); -        ServletUpgradeResponse servletUpgradeResponse = new ServletUpgradeResponse(response); -        ReaderHandler readerHandler = new ReaderHandler(wss, request, servletUpgradeResponse); -        // verify success -        Assert.assertEquals(readerHandler.getSubscription(), subName); -        // Verify consumer is successfully returned -        readerHandler.getConsumer(); -    } - -    @Test -    @SuppressWarnings("unchecked") -    public void testCreateIllegalReaderImp() throws IOException { -        // mock data -        WebSocketService wss = mock(WebSocketService.class); -        PulsarClient mockedClient = mock(PulsarClient.class); -        when(wss.getPulsarClient()).thenReturn(mockedClient); -        ReaderBuilder<byte[]> mockedReaderBuilder = mock(ReaderBuilder.class); -        when(mockedClient.newReader()).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.topic(any())).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.startMessageId(any())).thenReturn(mockedReaderBuilder); -        when(mockedReaderBuilder.receiverQueueSize(anyInt())).thenReturn(mockedReaderBuilder); -        IllegalReader illegalReader = new IllegalReader(); -        when(mockedReaderBuilder.create()).thenReturn(illegalReader); -        HttpServletRequest request = mock(HttpServletRequest.class); -        when(request.getRequestURI()).thenReturn("/ws/v2/producer/persistent/my-property/my-ns/my-topic"); -        // create reader handler -        HttpServletResponse response = spy(HttpServletResponse.class); -        ServletUpgradeResponse servletUpgradeResponse = new ServletUpgradeResponse(response); -        new ReaderHandler(wss, request, servletUpgradeResponse); -        // verify get error -        verify(response, times(1)).sendError(anyInt(), anyString()); -    } - - -    static class IllegalReader implements Reader<byte[]> { - -        @Override -        public String getTopic() { -            return null; -        } - -        @Override -        public Message<byte[]> readNext() throws PulsarClientException { -            return null; -        } - -        @Override -        public Message<byte[]> readNext(int timeout, TimeUnit unit) throws PulsarClientException { -            return null; -        } - -        @Override -        public CompletableFuture<Message<byte[]>> readNextAsync() { -            return null; -        } - -        @Override -        public CompletableFuture<Void> closeAsync() { -            return null; -        } - -        @Override -        public boolean hasReachedEndOfTopic() { -            return false; -        } - -        @Override -        public boolean hasMessageAvailable() { -            return false; -        } - -        @Override -        public CompletableFuture<Boolean> hasMessageAvailableAsync() { -            return null; -        } - -        @Override -        public boolean isConnected() { -            return false; -        } - -        @Override -        public void seek(MessageId messageId) throws PulsarClientException { - -        } - -        @Override -        public void seek(long timestamp) throws PulsarClientException { - -        } - -        @Override -        public void seek(Function<String, Object> function) throws PulsarClientException { - -        } - -        @Override -        public CompletableFuture<Void> seekAsync(Function<String, Object> function) { -            return null; -        } - -        @Override -        public CompletableFuture<Void> seekAsync(MessageId messageId) { -            return null; -        } - -        @Override -        public CompletableFuture<Void> seekAsync(long timestamp) { -            return null; -        } - -        @Override -        public void close() throws IOException { - -        } - -        @Override -        public List<TopicMessageId> getLastMessageIds() throws PulsarClientException { -            return null; -        } - -        @Override -        public CompletableFuture<List<TopicMessageId>> getLastMessageIdsAsync() { -            return null; -        } -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static org.mockito.Mockito.any; +import static org.mockito.Mockito.anyInt; +import static org.mockito.Mockito.anyString; +import static org.mockito.Mockito.mock; +import static org.mockito.Mockito.spy; +import static org.mockito.Mockito.times; +import static org.mockito.Mockito.verify; +import static org.mockito.Mockito.when; +import java.io.IOException; +import java.util.List; +import java.util.concurrent.CompletableFuture; +import java.util.concurrent.TimeUnit; +import java.util.function.Function; +import javax.servlet.http.HttpServletRequest; +import javax.servlet.http.HttpServletResponse; +import org.apache.pulsar.client.api.Message; +import org.apache.pulsar.client.api.MessageId; +import org.apache.pulsar.client.api.PulsarClient; +import org.apache.pulsar.client.api.PulsarClientException; +import org.apache.pulsar.client.api.Reader; +import org.apache.pulsar.client.api.ReaderBuilder; +import org.apache.pulsar.client.api.TopicMessageId; +import org.apache.pulsar.client.impl.ConsumerImpl; +import org.apache.pulsar.client.impl.MultiTopicsConsumerImpl; +import org.apache.pulsar.client.impl.MultiTopicsReaderImpl; +import org.apache.pulsar.client.impl.ReaderImpl; +import org.eclipse.jetty.websocket.servlet.ServletUpgradeResponse; +import org.testng.Assert; +import org.testng.annotations.Test; + +public class ReaderHandlerTest { + +    @Test +    @SuppressWarnings("unchecked") +    public void testCreateReaderImp() throws IOException { +        final String subName = "readerImpSubscription"; +        // mock data +        WebSocketService wss = mock(WebSocketService.class); +        PulsarClient mockedClient = mock(PulsarClient.class); +        when(wss.getPulsarClient()).thenReturn(mockedClient); +        ReaderBuilder<byte[]> mockedReaderBuilder = mock(ReaderBuilder.class); +        when(mockedClient.newReader()).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.topic(any())).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.startMessageId(any())).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.receiverQueueSize(anyInt())).thenReturn(mockedReaderBuilder); +        ReaderImpl<byte[]> mockedReader = mock(ReaderImpl.class); +        when(mockedReaderBuilder.create()).thenReturn(mockedReader); +        ConsumerImpl<byte[]> consumerImp = mock(ConsumerImpl.class); +        when(consumerImp.getSubscription()).thenReturn(subName); +        when(mockedReader.getConsumer()).thenReturn(consumerImp); +        HttpServletRequest request = mock(HttpServletRequest.class); +        when(request.getRequestURI()).thenReturn("/ws/v2/producer/persistent/my-property/my-ns/my-topic"); +        // create reader handler +        HttpServletResponse response = spy(HttpServletResponse.class); +        ServletUpgradeResponse servletUpgradeResponse = new ServletUpgradeResponse(response); +        ReaderHandler readerHandler = new ReaderHandler(wss, request, servletUpgradeResponse); +        // verify success +        Assert.assertEquals(readerHandler.getSubscription(), subName); +        // Verify consumer is returned +        readerHandler.getConsumer(); +    } + +    @Test +    @SuppressWarnings("unchecked") +    public void testCreateMultipleTopicReaderImp() throws IOException { +        final String subName = "multipleTopicReaderImpSubscription"; +        // mock data +        WebSocketService wss = mock(WebSocketService.class); +        PulsarClient mockedClient = mock(PulsarClient.class); +        when(wss.getPulsarClient()).thenReturn(mockedClient); +        ReaderBuilder<byte[]> mockedReaderBuilder = mock(ReaderBuilder.class); +        when(mockedClient.newReader()).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.topic(any())).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.startMessageId(any())).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.receiverQueueSize(anyInt())).thenReturn(mockedReaderBuilder); +        MultiTopicsReaderImpl<byte[]> mockedReader = mock(MultiTopicsReaderImpl.class); +        when(mockedReaderBuilder.create()).thenReturn(mockedReader); +        MultiTopicsConsumerImpl<byte[]> consumerImp = mock(MultiTopicsConsumerImpl.class); +        when(consumerImp.getSubscription()).thenReturn(subName); +        when(mockedReader.getMultiTopicsConsumer()).thenReturn(consumerImp); +        HttpServletRequest request = mock(HttpServletRequest.class); +        when(request.getRequestURI()).thenReturn("/ws/v2/producer/persistent/my-property/my-ns/my-topic"); +        // create reader handler +        HttpServletResponse response = spy(HttpServletResponse.class); +        ServletUpgradeResponse servletUpgradeResponse = new ServletUpgradeResponse(response); +        ReaderHandler readerHandler = new ReaderHandler(wss, request, servletUpgradeResponse); +        // verify success +        Assert.assertEquals(readerHandler.getSubscription(), subName); +        // Verify consumer is successfully returned +        readerHandler.getConsumer(); +    } + +    @Test +    @SuppressWarnings("unchecked") +    public void testCreateIllegalReaderImp() throws IOException { +        // mock data +        WebSocketService wss = mock(WebSocketService.class); +        PulsarClient mockedClient = mock(PulsarClient.class); +        when(wss.getPulsarClient()).thenReturn(mockedClient); +        ReaderBuilder<byte[]> mockedReaderBuilder = mock(ReaderBuilder.class); +        when(mockedClient.newReader()).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.topic(any())).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.startMessageId(any())).thenReturn(mockedReaderBuilder); +        when(mockedReaderBuilder.receiverQueueSize(anyInt())).thenReturn(mockedReaderBuilder); +        IllegalReader illegalReader = new IllegalReader(); +        when(mockedReaderBuilder.create()).thenReturn(illegalReader); +        HttpServletRequest request = mock(HttpServletRequest.class); +        when(request.getRequestURI()).thenReturn("/ws/v2/producer/persistent/my-property/my-ns/my-topic"); +        // create reader handler +        HttpServletResponse response = spy(HttpServletResponse.class); +        ServletUpgradeResponse servletUpgradeResponse = new ServletUpgradeResponse(response); +        new ReaderHandler(wss, request, servletUpgradeResponse); +        // verify get error +        verify(response, times(1)).sendError(anyInt(), anyString()); +    } + + +    static class IllegalReader implements Reader<byte[]> { + +        @Override +        public String getTopic() { +            return null; +        } + +        @Override +        public Message<byte[]> readNext() throws PulsarClientException { +            return null; +        } + +        @Override +        public Message<byte[]> readNext(int timeout, TimeUnit unit) throws PulsarClientException { +            return null; +        } + +        @Override +        public CompletableFuture<Message<byte[]>> readNextAsync() { +            return null; +        } + +        @Override +        public CompletableFuture<Void> closeAsync() { +            return null; +        } + +        @Override +        public boolean hasReachedEndOfTopic() { +            return false; +        } + +        @Override +        public boolean hasMessageAvailable() { +            return false; +        } + +        @Override +        public CompletableFuture<Boolean> hasMessageAvailableAsync() { +            return null; +        } + +        @Override +        public boolean isConnected() { +            return false; +        } + +        @Override +        public void seek(MessageId messageId) throws PulsarClientException { + +        } + +        @Override +        public void seek(long timestamp) throws PulsarClientException { + +        } + +        @Override +        public void seek(Function<String, Object> function) throws PulsarClientException { + +        } + +        @Override +        public CompletableFuture<Void> seekAsync(Function<String, Object> function) { +            return null; +        } + +        @Override +        public CompletableFuture<Void> seekAsync(MessageId messageId) { +            return null; +        } + +        @Override +        public CompletableFuture<Void> seekAsync(long timestamp) { +            return null; +        } + +        @Override +        public void close() throws IOException { + +        } + +        @Override +        public List<TopicMessageId> getLastMessageIds() throws PulsarClientException { +            return null; +        } + +        @Override +        public CompletableFuture<List<TopicMessageId>> getLastMessageIdsAsync() { +            return null; +        } +    } +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapperTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapperTest.java index 187e382367..624fe0c21a 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapperTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketHttpServletRequestWrapperTest.java @@ -1,90 +1,90 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import lombok.Cleanup; -import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; -import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; -import org.eclipse.jetty.websocket.servlet.UpgradeHttpServletRequest; -import org.mockito.Mockito; -import org.testng.Assert; -import org.testng.annotations.Test; - -/** - * WebSocketHttpServletRequestWrapper test. - */ -public class WebSocketHttpServletRequestWrapperTest { - -    private static final String TOKEN = "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ0ZXN0LXVzZXIifQ.U387jG" -            + "-gmpEXNmTjbnnnk24jCXnfy7OTiQhhhOdXPgV2wEvZYr83KRSmH54wJQr4V2FCWIFb_6mBc_" -            + "E2acpfpfBOTTzrtietfhd6wE5uOP2NXaLpy_kUDsE3ZQGKPEsn18cWQUw54GAzS1oRcG9TnoqSCSFFGabvo" -            + "FTiOMHoBQ3ZHO3TqAGqlJlRF5ZXMkRtQ9vwbPC-mlwIfRrRIJfK5_ijPRkpgFSEvAwp0rX6roz08SyTj_" -            + "d4UNT96nsEL6sRNTpZMQ0qNj2_LMKFnwF3O_xe43-Uen3TllkAzhNd9Z6qIxyJyFbaFyWAVgiAfoFWQD0v4EmV96ZzKZvv3CbGjw"; -    private static final String BEARER_TOKEN = WebSocketHttpServletRequestWrapper.HTTP_HEADER_VALUE_PREFIX + TOKEN; - -    @Test -    public void testTokenParamWithBearerPrefix() { -        UpgradeHttpServletRequest httpServletRequest = Mockito.mock(UpgradeHttpServletRequest.class); -        Mockito.when(httpServletRequest.getParameter(WebSocketHttpServletRequestWrapper.TOKEN)) -                .thenReturn(BEARER_TOKEN); - -        WebSocketHttpServletRequestWrapper webSocketHttpServletRequestWrapper = -                new WebSocketHttpServletRequestWrapper(httpServletRequest); -        Assert.assertEquals( -                webSocketHttpServletRequestWrapper.getHeader(WebSocketHttpServletRequestWrapper.HTTP_HEADER_NAME), -                BEARER_TOKEN); -    } - -    @Test -    public void testTokenParamWithOutBearerPrefix() { -        UpgradeHttpServletRequest httpServletRequest = Mockito.mock(UpgradeHttpServletRequest.class); -        Mockito.when(httpServletRequest.getParameter(WebSocketHttpServletRequestWrapper.TOKEN)) -                .thenReturn(TOKEN); - -        WebSocketHttpServletRequestWrapper webSocketHttpServletRequestWrapper = -                new WebSocketHttpServletRequestWrapper(httpServletRequest); -        Assert.assertEquals( -                webSocketHttpServletRequestWrapper.getHeader(WebSocketHttpServletRequestWrapper.HTTP_HEADER_NAME), -                BEARER_TOKEN); -    } - -    @Test -    public void mockRequestTest() throws Exception { -        WebSocketProxyConfiguration config = PulsarConfigurationLoader.create( -                this.getClass().getClassLoader().getResource("websocket.conf").getFile(), -                WebSocketProxyConfiguration.class); -        String publicKeyPath = "file://" + this.getClass().getClassLoader().getResource("my-public.key").getFile(); -        config.getProperties().setProperty("tokenPublicKey", publicKeyPath); -        @Cleanup -        WebSocketService service = new WebSocketService(config); -        service.start(); - -        UpgradeHttpServletRequest httpServletRequest = Mockito.mock(UpgradeHttpServletRequest.class); -        Mockito.when(httpServletRequest.getRemoteAddr()).thenReturn("localhost"); -        Mockito.when(httpServletRequest.getRemotePort()).thenReturn(8080); -        Mockito.when(httpServletRequest.getParameter(WebSocketHttpServletRequestWrapper.TOKEN)) -                .thenReturn(TOKEN); -        WebSocketHttpServletRequestWrapper webSocketHttpServletRequestWrapper = -                new WebSocketHttpServletRequestWrapper(httpServletRequest); - -        Assert.assertEquals(service.getAuthenticationService() -                        .authenticateHttpRequest(webSocketHttpServletRequestWrapper), "test-user"); -    } - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import lombok.Cleanup; +import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; +import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; +import org.eclipse.jetty.websocket.servlet.UpgradeHttpServletRequest; +import org.mockito.Mockito; +import org.testng.Assert; +import org.testng.annotations.Test; + +/** + * WebSocketHttpServletRequestWrapper test. + */ +public class WebSocketHttpServletRequestWrapperTest { + +    private static final String TOKEN = "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ0ZXN0LXVzZXIifQ.U387jG" +            + "-gmpEXNmTjbnnnk24jCXnfy7OTiQhhhOdXPgV2wEvZYr83KRSmH54wJQr4V2FCWIFb_6mBc_" +            + "E2acpfpfBOTTzrtietfhd6wE5uOP2NXaLpy_kUDsE3ZQGKPEsn18cWQUw54GAzS1oRcG9TnoqSCSFFGabvo" +            + "FTiOMHoBQ3ZHO3TqAGqlJlRF5ZXMkRtQ9vwbPC-mlwIfRrRIJfK5_ijPRkpgFSEvAwp0rX6roz08SyTj_" +            + "d4UNT96nsEL6sRNTpZMQ0qNj2_LMKFnwF3O_xe43-Uen3TllkAzhNd9Z6qIxyJyFbaFyWAVgiAfoFWQD0v4EmV96ZzKZvv3CbGjw"; +    private static final String BEARER_TOKEN = WebSocketHttpServletRequestWrapper.HTTP_HEADER_VALUE_PREFIX + TOKEN; + +    @Test +    public void testTokenParamWithBearerPrefix() { +        UpgradeHttpServletRequest httpServletRequest = Mockito.mock(UpgradeHttpServletRequest.class); +        Mockito.when(httpServletRequest.getParameter(WebSocketHttpServletRequestWrapper.TOKEN)) +                .thenReturn(BEARER_TOKEN); + +        WebSocketHttpServletRequestWrapper webSocketHttpServletRequestWrapper = +                new WebSocketHttpServletRequestWrapper(httpServletRequest); +        Assert.assertEquals( +                webSocketHttpServletRequestWrapper.getHeader(WebSocketHttpServletRequestWrapper.HTTP_HEADER_NAME), +                BEARER_TOKEN); +    } + +    @Test +    public void testTokenParamWithOutBearerPrefix() { +        UpgradeHttpServletRequest httpServletRequest = Mockito.mock(UpgradeHttpServletRequest.class); +        Mockito.when(httpServletRequest.getParameter(WebSocketHttpServletRequestWrapper.TOKEN)) +                .thenReturn(TOKEN); + +        WebSocketHttpServletRequestWrapper webSocketHttpServletRequestWrapper = +                new WebSocketHttpServletRequestWrapper(httpServletRequest); +        Assert.assertEquals( +                webSocketHttpServletRequestWrapper.getHeader(WebSocketHttpServletRequestWrapper.HTTP_HEADER_NAME), +                BEARER_TOKEN); +    } + +    @Test +    public void mockRequestTest() throws Exception { +        WebSocketProxyConfiguration config = PulsarConfigurationLoader.create( +                this.getClass().getClassLoader().getResource("websocket.conf").getFile(), +                WebSocketProxyConfiguration.class); +        String publicKeyPath = "file://" + this.getClass().getClassLoader().getResource("my-public.key").getFile(); +        config.getProperties().setProperty("tokenPublicKey", publicKeyPath); +        @Cleanup +        WebSocketService service = new WebSocketService(config); +        service.start(); + +        UpgradeHttpServletRequest httpServletRequest = Mockito.mock(UpgradeHttpServletRequest.class); +        Mockito.when(httpServletRequest.getRemoteAddr()).thenReturn("localhost"); +        Mockito.when(httpServletRequest.getRemotePort()).thenReturn(8080); +        Mockito.when(httpServletRequest.getParameter(WebSocketHttpServletRequestWrapper.TOKEN)) +                .thenReturn(TOKEN); +        WebSocketHttpServletRequestWrapper webSocketHttpServletRequestWrapper = +                new WebSocketHttpServletRequestWrapper(httpServletRequest); + +        Assert.assertEquals(service.getAuthenticationService() +                        .authenticateHttpRequest(webSocketHttpServletRequestWrapper), "test-user"); +    } + +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketProxyConfigurationTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketProxyConfigurationTest.java index 2d1831d9b2..c5ead8a5f2 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketProxyConfigurationTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/WebSocketProxyConfigurationTest.java @@ -1,108 +1,108 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket; - -import static org.testng.Assert.assertEquals; -import static org.testng.Assert.assertNull; -import java.io.File; -import java.io.FileInputStream; -import java.io.FileOutputStream; -import java.io.IOException; -import java.io.InputStream; -import java.io.OutputStreamWriter; -import java.io.PrintWriter; -import org.apache.pulsar.broker.ServiceConfiguration; -import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; -import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; -import org.testng.Assert; -import org.testng.annotations.Test; - -public class WebSocketProxyConfigurationTest { - -    @Test -    public void testBackwardCompatibility() throws IOException { -        File testConfigFile = new File("tmp." + System.currentTimeMillis() + ".properties"); -        if (testConfigFile.exists()) { -            testConfigFile.delete(); -        } -        try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(testConfigFile)))) { -            printWriter.println("zooKeeperSessionTimeoutMillis=60"); -            printWriter.println("zooKeeperCacheExpirySeconds=500"); -        } -        testConfigFile.deleteOnExit(); -        InputStream stream = new FileInputStream(testConfigFile); -        WebSocketProxyConfiguration serviceConfig = PulsarConfigurationLoader.create(stream, -                WebSocketProxyConfiguration.class); -        stream.close(); -        assertEquals(serviceConfig.getMetadataStoreSessionTimeoutMillis(), 60); -        assertEquals(serviceConfig.getMetadataStoreCacheExpirySeconds(), 500); - -        testConfigFile = new File("tmp." + System.currentTimeMillis() + ".properties"); -        if (testConfigFile.exists()) { -            testConfigFile.delete(); -        } -        try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(testConfigFile)))) { -            printWriter.println("metadataStoreSessionTimeoutMillis=60"); -            printWriter.println("metadataStoreCacheExpirySeconds=500"); -            printWriter.println("zooKeeperSessionTimeoutMillis=-1"); -            printWriter.println("zooKeeperCacheExpirySeconds=-1"); -            printWriter.println("cryptoKeyReaderFactoryClassName="); -        } -        testConfigFile.deleteOnExit(); -        stream = new FileInputStream(testConfigFile); -        serviceConfig = PulsarConfigurationLoader.create(stream, WebSocketProxyConfiguration.class); -        stream.close(); -        assertEquals(serviceConfig.getMetadataStoreSessionTimeoutMillis(), 60); -        assertEquals(serviceConfig.getMetadataStoreCacheExpirySeconds(), 500); -        assertNull(serviceConfig.getCryptoKeyReaderFactoryClassName()); - -        testConfigFile = new File("tmp." + System.currentTimeMillis() + ".properties"); -        if (testConfigFile.exists()) { -            testConfigFile.delete(); -        } -        try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(testConfigFile)))) { -            printWriter.println("metadataStoreSessionTimeoutMillis=10"); -            printWriter.println("metadataStoreCacheExpirySeconds=30"); -            printWriter.println("zooKeeperSessionTimeoutMillis=100"); -            printWriter.println("zooKeeperCacheExpirySeconds=300"); -            printWriter.println("cryptoKeyReaderFactoryClassName=A.class"); -        } -        testConfigFile.deleteOnExit(); -        stream = new FileInputStream(testConfigFile); -        serviceConfig = PulsarConfigurationLoader.create(stream, WebSocketProxyConfiguration.class); -        stream.close(); -        assertEquals(serviceConfig.getMetadataStoreSessionTimeoutMillis(), 100); -        assertEquals(serviceConfig.getMetadataStoreCacheExpirySeconds(), 300); -        assertEquals(serviceConfig.getCryptoKeyReaderFactoryClassName(), "A.class"); -    } - -    @Test -    public void testConfigurationConversionUsedByWebSocketProxyStarter() { -        WebSocketProxyConfiguration config = new WebSocketProxyConfiguration(); -        // Use non-default values for testing -        config.setTlsAllowInsecureConnection(true); -        Assert.assertFalse(config.isTlsHostnameVerificationEnabled(), "Update me when default changes."); -        config.setTlsHostnameVerificationEnabled(true); -        ServiceConfiguration brokerConf = PulsarConfigurationLoader.convertFrom(config); -        Assert.assertTrue(brokerConf.isTlsAllowInsecureConnection(), -                "TlsAllowInsecureConnection should convert correctly"); -        Assert.assertTrue(brokerConf.isTlsHostnameVerificationEnabled(), -                "TlsHostnameVerificationEnabled should convert correctly"); -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket; + +import static org.testng.Assert.assertEquals; +import static org.testng.Assert.assertNull; +import java.io.File; +import java.io.FileInputStream; +import java.io.FileOutputStream; +import java.io.IOException; +import java.io.InputStream; +import java.io.OutputStreamWriter; +import java.io.PrintWriter; +import org.apache.pulsar.broker.ServiceConfiguration; +import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; +import org.apache.pulsar.websocket.service.WebSocketProxyConfiguration; +import org.testng.Assert; +import org.testng.annotations.Test; + +public class WebSocketProxyConfigurationTest { + +    @Test +    public void testBackwardCompatibility() throws IOException { +        File testConfigFile = new File("tmp." + System.currentTimeMillis() + ".properties"); +        if (testConfigFile.exists()) { +            testConfigFile.delete(); +        } +        try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(testConfigFile)))) { +            printWriter.println("zooKeeperSessionTimeoutMillis=60"); +            printWriter.println("zooKeeperCacheExpirySeconds=500"); +        } +        testConfigFile.deleteOnExit(); +        InputStream stream = new FileInputStream(testConfigFile); +        WebSocketProxyConfiguration serviceConfig = PulsarConfigurationLoader.create(stream, +                WebSocketProxyConfiguration.class); +        stream.close(); +        assertEquals(serviceConfig.getMetadataStoreSessionTimeoutMillis(), 60); +        assertEquals(serviceConfig.getMetadataStoreCacheExpirySeconds(), 500); + +        testConfigFile = new File("tmp." + System.currentTimeMillis() + ".properties"); +        if (testConfigFile.exists()) { +            testConfigFile.delete(); +        } +        try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(testConfigFile)))) { +            printWriter.println("metadataStoreSessionTimeoutMillis=60"); +            printWriter.println("metadataStoreCacheExpirySeconds=500"); +            printWriter.println("zooKeeperSessionTimeoutMillis=-1"); +            printWriter.println("zooKeeperCacheExpirySeconds=-1"); +            printWriter.println("cryptoKeyReaderFactoryClassName="); +        } +        testConfigFile.deleteOnExit(); +        stream = new FileInputStream(testConfigFile); +        serviceConfig = PulsarConfigurationLoader.create(stream, WebSocketProxyConfiguration.class); +        stream.close(); +        assertEquals(serviceConfig.getMetadataStoreSessionTimeoutMillis(), 60); +        assertEquals(serviceConfig.getMetadataStoreCacheExpirySeconds(), 500); +        assertNull(serviceConfig.getCryptoKeyReaderFactoryClassName()); + +        testConfigFile = new File("tmp." + System.currentTimeMillis() + ".properties"); +        if (testConfigFile.exists()) { +            testConfigFile.delete(); +        } +        try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(testConfigFile)))) { +            printWriter.println("metadataStoreSessionTimeoutMillis=10"); +            printWriter.println("metadataStoreCacheExpirySeconds=30"); +            printWriter.println("zooKeeperSessionTimeoutMillis=100"); +            printWriter.println("zooKeeperCacheExpirySeconds=300"); +            printWriter.println("cryptoKeyReaderFactoryClassName=A.class"); +        } +        testConfigFile.deleteOnExit(); +        stream = new FileInputStream(testConfigFile); +        serviceConfig = PulsarConfigurationLoader.create(stream, WebSocketProxyConfiguration.class); +        stream.close(); +        assertEquals(serviceConfig.getMetadataStoreSessionTimeoutMillis(), 100); +        assertEquals(serviceConfig.getMetadataStoreCacheExpirySeconds(), 300); +        assertEquals(serviceConfig.getCryptoKeyReaderFactoryClassName(), "A.class"); +    } + +    @Test +    public void testConfigurationConversionUsedByWebSocketProxyStarter() { +        WebSocketProxyConfiguration config = new WebSocketProxyConfiguration(); +        // Use non-default values for testing +        config.setTlsAllowInsecureConnection(true); +        Assert.assertFalse(config.isTlsHostnameVerificationEnabled(), "Update me when default changes."); +        config.setTlsHostnameVerificationEnabled(true); +        ServiceConfiguration brokerConf = PulsarConfigurationLoader.convertFrom(config); +        Assert.assertTrue(brokerConf.isTlsAllowInsecureConnection(), +                "TlsAllowInsecureConnection should convert correctly"); +        Assert.assertTrue(brokerConf.isTlsHostnameVerificationEnabled(), +                "TlsHostnameVerificationEnabled should convert correctly"); +    } +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/admin/WebSocketWebResourceTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/admin/WebSocketWebResourceTest.java index 1e127e5c9c..6a5da6ec9e 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/admin/WebSocketWebResourceTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/admin/WebSocketWebResourceTest.java @@ -1,244 +1,244 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.admin; - -import static org.mockito.Mockito.any; -import static org.mockito.Mockito.anyString; -import static org.mockito.Mockito.doReturn; -import static org.mockito.Mockito.eq; -import static org.mockito.Mockito.mock; -import static org.mockito.Mockito.when; -import com.google.common.collect.Sets; -import java.lang.reflect.Method; -import javax.naming.AuthenticationException; -import javax.servlet.ServletContext; -import javax.servlet.http.HttpServletRequest; -import javax.ws.rs.core.Response.Status; -import javax.ws.rs.core.UriInfo; -import org.apache.pulsar.broker.ServiceConfiguration; -import org.apache.pulsar.broker.authentication.AuthenticationDataHttps; -import org.apache.pulsar.broker.authentication.AuthenticationDataSource; -import org.apache.pulsar.broker.authentication.AuthenticationService; -import org.apache.pulsar.broker.authorization.AuthorizationService; -import org.apache.pulsar.common.naming.TopicName; -import org.apache.pulsar.common.util.RestException; -import org.apache.pulsar.websocket.WebSocketService; -import org.mockito.InjectMocks; -import org.mockito.Mock; -import org.mockito.MockitoAnnotations; -import org.mockito.Spy; -import org.testng.Assert; -import org.testng.annotations.AfterMethod; -import org.testng.annotations.BeforeMethod; -import org.testng.annotations.Test; - -public class WebSocketWebResourceTest { - -    private static final String SUPER_USER = "super"; -    private static final String AUTHORIZED_USER = "authorized"; -    private static final String UNAUTHORIZED_USER = "unauthorized"; - -    private TopicName topicName; - -    @InjectMocks -    @Spy -    private WebSocketWebResource webResource; -    @Mock -    private ServletContext servletContext; -    @Mock -    private HttpServletRequest httpRequest; -    @Mock -    private UriInfo uri; - -    @BeforeMethod -    public void setup(Method method) throws Exception { -        MockitoAnnotations.openMocks(this); - -        ServiceConfiguration config = new ServiceConfiguration(); -        config.setSuperUserRoles(Sets.newHashSet(SUPER_USER)); -        if ("testAuthenticationDisabled".equals(method.getName())) { -            config.setAuthenticationEnabled(false); -            config.setAuthorizationEnabled(false); -        } else { -            config.setAuthenticationEnabled(true); -            config.setAuthorizationEnabled(true); -        } - -        AuthenticationService authnService = mock(AuthenticationService.class); -        if ("testSuperUserAccess".equals(method.getName())) { -            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(SUPER_USER); -        } else if ("testUnauthorizedUserAccess".equals(method.getName())) { -            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(UNAUTHORIZED_USER); -        } else if ("testBlankUserAccess".equals(method.getName())) { -            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(""); -        } else if ("testUnauthenticatedUserAccess".equals(method.getName())) { -            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))) -                    .thenThrow(new AuthenticationException()); -        } else { -            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(AUTHORIZED_USER); -        } - -        AuthorizationService authzService = mock(AuthorizationService.class); -        when(authzService.canLookup(any(TopicName.class), eq(SUPER_USER), any(AuthenticationDataSource.class))) -                .thenReturn(true); -        when(authzService.canLookup(any(TopicName.class), eq(AUTHORIZED_USER), any(AuthenticationDataSource.class))) -                .thenReturn(true); -        when(authzService.canLookup(any(TopicName.class), eq(UNAUTHORIZED_USER), any(AuthenticationDataSource.class))) -                .thenReturn(false); -        when(authzService.canLookup(any(TopicName.class), eq(""), any(AuthenticationDataSource.class))) -                .thenReturn(false); - -        WebSocketService socketService = mock(WebSocketService.class); -        when(socketService.getConfig()).thenReturn(config); -        when(socketService.isAuthorizationEnabled()).thenReturn(config.isAuthorizationEnabled()); -        when(socketService.getAuthenticationService()).thenReturn(authnService); -        when(socketService.getAuthorizationService()).thenReturn(authzService); - -        // Mock WebSocketWebResource -        doReturn(mock(AuthenticationDataHttps.class)).when(webResource).authData(); - -        // Mock ServletContext -        when(servletContext.getAttribute(anyString())).thenReturn(socketService); - -        // Mock HttpServletRequest -        when(httpRequest.getRemoteAddr()).thenReturn("127.0.0.1"); -        when(httpRequest.getRemotePort()).thenReturn(8080); - -        // Mock UriInfo -        when(uri.getRequestUri()).thenReturn(null); - -        topicName = TopicName.get("persistent://tenant/cluster/ns/dest"); -    } - -    @AfterMethod(alwaysRun = true) -    public void cleanup() throws Exception { -        this.webResource = null; -    } - -    @Test -    public void testAuthenticationDisabled() throws Exception { -        try { -            Assert.assertEquals(webResource.clientAppId(), AUTHORIZED_USER); -            webResource.validateSuperUserAccess(); -            webResource.validateUserAccess(topicName); -        } catch (RestException e) { -            Assert.fail("Should not fail", e); -        } -    } - -    @Test -    public void testSuperUserAccess() throws Exception { -        try { -            Assert.assertEquals(webResource.clientAppId(), SUPER_USER); -            webResource.validateSuperUserAccess(); -            webResource.validateUserAccess(topicName); -        } catch (RestException e) { -            Assert.fail("Should not fail", e); -        } -    } - -    @Test -    public void testAuthorizedUserAccess() throws Exception { -        try { -            webResource.validateSuperUserAccess(); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } - -        try { -            Assert.assertEquals(webResource.clientAppId(), AUTHORIZED_USER); -            webResource.validateUserAccess(topicName); -        } catch (RestException e) { -            Assert.fail("Should not fail", e); -        } -    } - -    @Test -    public void testUnauthorizedUserAccess() throws Exception { -        try { -            Assert.assertEquals(webResource.clientAppId(), UNAUTHORIZED_USER); -        } catch (RestException e) { -            Assert.fail("Should not fail", e); -        } - -        try { -            webResource.validateSuperUserAccess(); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } - -        try { -            webResource.validateUserAccess(topicName); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } -    } - -    @Test -    public void testBlankUserAccess() throws Exception { -        try { -            webResource.clientAppId(); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } - -        try { -            webResource.validateSuperUserAccess(); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } - -        try { -            webResource.validateUserAccess(topicName); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } -    } - -    @Test -    public void testUnauthenticatedUserAccess() throws Exception { -        try { -            webResource.clientAppId(); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } - -        try { -            webResource.validateSuperUserAccess(); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } - -        try { -            webResource.validateUserAccess(topicName); -            Assert.fail("Should fail"); -        } catch (RestException e) { -            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); -        } -    } - -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.admin; + +import static org.mockito.Mockito.any; +import static org.mockito.Mockito.anyString; +import static org.mockito.Mockito.doReturn; +import static org.mockito.Mockito.eq; +import static org.mockito.Mockito.mock; +import static org.mockito.Mockito.when; +import com.google.common.collect.Sets; +import java.lang.reflect.Method; +import javax.naming.AuthenticationException; +import javax.servlet.ServletContext; +import javax.servlet.http.HttpServletRequest; +import javax.ws.rs.core.Response.Status; +import javax.ws.rs.core.UriInfo; +import org.apache.pulsar.broker.ServiceConfiguration; +import org.apache.pulsar.broker.authentication.AuthenticationDataHttps; +import org.apache.pulsar.broker.authentication.AuthenticationDataSource; +import org.apache.pulsar.broker.authentication.AuthenticationService; +import org.apache.pulsar.broker.authorization.AuthorizationService; +import org.apache.pulsar.common.naming.TopicName; +import org.apache.pulsar.common.util.RestException; +import org.apache.pulsar.websocket.WebSocketService; +import org.mockito.InjectMocks; +import org.mockito.Mock; +import org.mockito.MockitoAnnotations; +import org.mockito.Spy; +import org.testng.Assert; +import org.testng.annotations.AfterMethod; +import org.testng.annotations.BeforeMethod; +import org.testng.annotations.Test; + +public class WebSocketWebResourceTest { + +    private static final String SUPER_USER = "super"; +    private static final String AUTHORIZED_USER = "authorized"; +    private static final String UNAUTHORIZED_USER = "unauthorized"; + +    private TopicName topicName; + +    @InjectMocks +    @Spy +    private WebSocketWebResource webResource; +    @Mock +    private ServletContext servletContext; +    @Mock +    private HttpServletRequest httpRequest; +    @Mock +    private UriInfo uri; + +    @BeforeMethod +    public void setup(Method method) throws Exception { +        MockitoAnnotations.openMocks(this); + +        ServiceConfiguration config = new ServiceConfiguration(); +        config.setSuperUserRoles(Sets.newHashSet(SUPER_USER)); +        if ("testAuthenticationDisabled".equals(method.getName())) { +            config.setAuthenticationEnabled(false); +            config.setAuthorizationEnabled(false); +        } else { +            config.setAuthenticationEnabled(true); +            config.setAuthorizationEnabled(true); +        } + +        AuthenticationService authnService = mock(AuthenticationService.class); +        if ("testSuperUserAccess".equals(method.getName())) { +            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(SUPER_USER); +        } else if ("testUnauthorizedUserAccess".equals(method.getName())) { +            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(UNAUTHORIZED_USER); +        } else if ("testBlankUserAccess".equals(method.getName())) { +            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(""); +        } else if ("testUnauthenticatedUserAccess".equals(method.getName())) { +            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))) +                    .thenThrow(new AuthenticationException()); +        } else { +            when(authnService.authenticateHttpRequest(any(HttpServletRequest.class))).thenReturn(AUTHORIZED_USER); +        } + +        AuthorizationService authzService = mock(AuthorizationService.class); +        when(authzService.canLookup(any(TopicName.class), eq(SUPER_USER), any(AuthenticationDataSource.class))) +                .thenReturn(true); +        when(authzService.canLookup(any(TopicName.class), eq(AUTHORIZED_USER), any(AuthenticationDataSource.class))) +                .thenReturn(true); +        when(authzService.canLookup(any(TopicName.class), eq(UNAUTHORIZED_USER), any(AuthenticationDataSource.class))) +                .thenReturn(false); +        when(authzService.canLookup(any(TopicName.class), eq(""), any(AuthenticationDataSource.class))) +                .thenReturn(false); + +        WebSocketService socketService = mock(WebSocketService.class); +        when(socketService.getConfig()).thenReturn(config); +        when(socketService.isAuthorizationEnabled()).thenReturn(config.isAuthorizationEnabled()); +        when(socketService.getAuthenticationService()).thenReturn(authnService); +        when(socketService.getAuthorizationService()).thenReturn(authzService); + +        // Mock WebSocketWebResource +        doReturn(mock(AuthenticationDataHttps.class)).when(webResource).authData(); + +        // Mock ServletContext +        when(servletContext.getAttribute(anyString())).thenReturn(socketService); + +        // Mock HttpServletRequest +        when(httpRequest.getRemoteAddr()).thenReturn("127.0.0.1"); +        when(httpRequest.getRemotePort()).thenReturn(8080); + +        // Mock UriInfo +        when(uri.getRequestUri()).thenReturn(null); + +        topicName = TopicName.get("persistent://tenant/cluster/ns/dest"); +    } + +    @AfterMethod(alwaysRun = true) +    public void cleanup() throws Exception { +        this.webResource = null; +    } + +    @Test +    public void testAuthenticationDisabled() throws Exception { +        try { +            Assert.assertEquals(webResource.clientAppId(), AUTHORIZED_USER); +            webResource.validateSuperUserAccess(); +            webResource.validateUserAccess(topicName); +        } catch (RestException e) { +            Assert.fail("Should not fail", e); +        } +    } + +    @Test +    public void testSuperUserAccess() throws Exception { +        try { +            Assert.assertEquals(webResource.clientAppId(), SUPER_USER); +            webResource.validateSuperUserAccess(); +            webResource.validateUserAccess(topicName); +        } catch (RestException e) { +            Assert.fail("Should not fail", e); +        } +    } + +    @Test +    public void testAuthorizedUserAccess() throws Exception { +        try { +            webResource.validateSuperUserAccess(); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } + +        try { +            Assert.assertEquals(webResource.clientAppId(), AUTHORIZED_USER); +            webResource.validateUserAccess(topicName); +        } catch (RestException e) { +            Assert.fail("Should not fail", e); +        } +    } + +    @Test +    public void testUnauthorizedUserAccess() throws Exception { +        try { +            Assert.assertEquals(webResource.clientAppId(), UNAUTHORIZED_USER); +        } catch (RestException e) { +            Assert.fail("Should not fail", e); +        } + +        try { +            webResource.validateSuperUserAccess(); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } + +        try { +            webResource.validateUserAccess(topicName); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } +    } + +    @Test +    public void testBlankUserAccess() throws Exception { +        try { +            webResource.clientAppId(); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } + +        try { +            webResource.validateSuperUserAccess(); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } + +        try { +            webResource.validateUserAccess(topicName); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } +    } + +    @Test +    public void testUnauthenticatedUserAccess() throws Exception { +        try { +            webResource.clientAppId(); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } + +        try { +            webResource.validateSuperUserAccess(); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } + +        try { +            webResource.validateUserAccess(topicName); +            Assert.fail("Should fail"); +        } catch (RestException e) { +            Assert.assertEquals(e.getResponse().getStatus(), Status.UNAUTHORIZED.getStatusCode()); +        } +    } + +} diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketProxyConfigurationTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketProxyConfigurationTest.java index d72e1ba824..abd89f8737 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketProxyConfigurationTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketProxyConfigurationTest.java @@ -1,57 +1,57 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; - -import static org.testng.Assert.assertEquals; -import java.beans.Introspector; -import java.beans.PropertyDescriptor; -import java.io.FileInputStream; -import java.util.Arrays; -import java.util.List; -import java.util.Properties; -import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; -import org.testng.annotations.Test; - -@Test(groups = "broker") -public class WebSocketProxyConfigurationTest { - -    @Test -    public void testConfigFileDefaults() throws Exception { -        try (FileInputStream stream = new FileInputStream("../conf/websocket.conf")) { -            final WebSocketProxyConfiguration javaConfig = -                    PulsarConfigurationLoader.create(new Properties(), WebSocketProxyConfiguration.class); -            final WebSocketProxyConfiguration fileConfig = -                    PulsarConfigurationLoader.create(stream, WebSocketProxyConfiguration.class); -            List<String> toSkip = Arrays.asList("properties", "class"); -            for (PropertyDescriptor pd : Introspector.getBeanInfo( -                    WebSocketProxyConfiguration.class).getPropertyDescriptors()) { -                if (pd.getReadMethod() == null || toSkip.contains(pd.getName())) { -                    continue; -                } -                final String key = pd.getName(); -                final Object javaValue = pd.getReadMethod().invoke(javaConfig); -                final Object fileValue = pd.getReadMethod().invoke(fileConfig); -                assertEquals(fileValue, javaValue, "property '" -                        + key + "' conf/websocket.conf default value doesn't match java default value\nConf: " -                        + fileValue + "\nJava: " + javaValue); -            } -        } -    } - +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; + +import static org.testng.Assert.assertEquals; +import java.beans.Introspector; +import java.beans.PropertyDescriptor; +import java.io.FileInputStream; +import java.util.Arrays; +import java.util.List; +import java.util.Properties; +import org.apache.pulsar.common.configuration.PulsarConfigurationLoader; +import org.testng.annotations.Test; + +@Test(groups = "broker") +public class WebSocketProxyConfigurationTest { + +    @Test +    public void testConfigFileDefaults() throws Exception { +        try (FileInputStream stream = new FileInputStream("../conf/websocket.conf")) { +            final WebSocketProxyConfiguration javaConfig = +                    PulsarConfigurationLoader.create(new Properties(), WebSocketProxyConfiguration.class); +            final WebSocketProxyConfiguration fileConfig = +                    PulsarConfigurationLoader.create(stream, WebSocketProxyConfiguration.class); +            List<String> toSkip = Arrays.asList("properties", "class"); +            for (PropertyDescriptor pd : Introspector.getBeanInfo( +                    WebSocketProxyConfiguration.class).getPropertyDescriptors()) { +                if (pd.getReadMethod() == null || toSkip.contains(pd.getName())) { +                    continue; +                } +                final String key = pd.getName(); +                final Object javaValue = pd.getReadMethod().invoke(javaConfig); +                final Object fileValue = pd.getReadMethod().invoke(fileConfig); +                assertEquals(fileValue, javaValue, "property '" +                        + key + "' conf/websocket.conf default value doesn't match java default value\nConf: " +                        + fileValue + "\nJava: " + javaValue); +            } +        } +    } +  } \ No newline at end of file diff --git a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketServiceStarterTest.java b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketServiceStarterTest.java index f9a190cf86..9da28700c0 100644 --- a/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketServiceStarterTest.java +++ b/pulsar-websocket/src/test/java/org/apache/pulsar/websocket/service/WebSocketServiceStarterTest.java @@ -1,62 +1,62 @@ -/* - * Licensed to the Apache Software Foundation (ASF) under one - * or more contributor license agreements.  See the NOTICE file - * distributed with this work for additional information - * regarding copyright ownership.  The ASF licenses this file - * to you under the Apache License, Version 2.0 (the - * "License"); you may not use this file except in compliance - * with the License.  You may obtain a copy of the License at - * - *   http://www.apache.org/licenses/LICENSE-2.0 - * - * Unless required by applicable law or agreed to in writing, - * software distributed under the License is distributed on an - * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY - * KIND, either express or implied.  See the License for the - * specific language governing permissions and limitations - * under the License. - */ -package org.apache.pulsar.websocket.service; - -import static org.testng.Assert.assertTrue; -import java.io.ByteArrayOutputStream; -import java.io.PrintStream; -import java.lang.reflect.Field; -import java.util.Arrays; -import org.testng.annotations.Test; -import picocli.CommandLine.Option; - -public class WebSocketServiceStarterTest { -    @Test -    public void testMainGenerateDocs() throws Exception { -        PrintStream oldStream = System.out; -        try { -            ByteArrayOutputStream baoStream = new ByteArrayOutputStream(); -            System.setOut(new PrintStream(baoStream)); - -            Class argumentsClass = -                    Class.forName("org.apache.pulsar.websocket.service.WebSocketServiceStarter$Arguments"); - -            WebSocketServiceStarter.main(new String[]{"-g"}); - -            String message = baoStream.toString(); - -            Field[] fields = argumentsClass.getDeclaredFields(); -            for (Field field : fields) { -                boolean fieldHasAnno = field.isAnnotationPresent(Option.class); -                if (fieldHasAnno) { -                    Option fieldAnno = field.getAnnotation(Option.class); -                    String[] names = fieldAnno.names(); -                    if (names.length == 0) { -                        continue; -                    } -                    String nameStr = Arrays.asList(names).toString(); -                    nameStr = nameStr.substring(1, nameStr.length() - 1); -                    assertTrue(message.indexOf(nameStr) > 0); -                } -            } -        } finally { -            System.setOut(oldStream); -        } -    } -} +/* + * Licensed to the Apache Software Foundation (ASF) under one + * or more contributor license agreements.  See the NOTICE file + * distributed with this work for additional information + * regarding copyright ownership.  The ASF licenses this file + * to you under the Apache License, Version 2.0 (the + * "License"); you may not use this file except in compliance + * with the License.  You may obtain a copy of the License at + * + *   http://www.apache.org/licenses/LICENSE-2.0 + * + * Unless required by applicable law or agreed to in writing, + * software distributed under the License is distributed on an + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY + * KIND, either express or implied.  See the License for the + * specific language governing permissions and limitations + * under the License. + */ +package org.apache.pulsar.websocket.service; + +import static org.testng.Assert.assertTrue; +import java.io.ByteArrayOutputStream; +import java.io.PrintStream; +import java.lang.reflect.Field; +import java.util.Arrays; +import org.testng.annotations.Test; +import picocli.CommandLine.Option; + +public class WebSocketServiceStarterTest { +    @Test +    public void testMainGenerateDocs() throws Exception { +        PrintStream oldStream = System.out; +        try { +            ByteArrayOutputStream baoStream = new ByteArrayOutputStream(); +            System.setOut(new PrintStream(baoStream)); + +            Class argumentsClass = +                    Class.forName("org.apache.pulsar.websocket.service.WebSocketServiceStarter$Arguments"); + +            WebSocketServiceStarter.main(new String[]{"-g"}); + +            String message = baoStream.toString(); + +            Field[] fields = argumentsClass.getDeclaredFields(); +            for (Field field : fields) { +                boolean fieldHasAnno = field.isAnnotationPresent(Option.class); +                if (fieldHasAnno) { +                    Option fieldAnno = field.getAnnotation(Option.class); +                    String[] names = fieldAnno.names(); +                    if (names.length == 0) { +                        continue; +                    } +                    String nameStr = Arrays.asList(names).toString(); +                    nameStr = nameStr.substring(1, nameStr.length() - 1); +                    assertTrue(message.indexOf(nameStr) > 0); +                } +            } +        } finally { +            System.setOut(oldStream); +        } +    } +} diff --git a/pulsar-websocket/src/test/resources/websocket.conf b/pulsar-websocket/src/test/resources/websocket.conf index ba4175d47e..1324634275 100644 --- a/pulsar-websocket/src/test/resources/websocket.conf +++ b/pulsar-websocket/src/test/resources/websocket.conf @@ -1,127 +1,127 @@ -# -# Licensed to the Apache Software Foundation (ASF) under one -# or more contributor license agreements.  See the NOTICE file -# distributed with this work for additional information -# regarding copyright ownership.  The ASF licenses this file -# to you under the Apache License, Version 2.0 (the -# "License"); you may not use this file except in compliance -# with the License.  You may obtain a copy of the License at -# -#   http://www.apache.org/licenses/LICENSE-2.0 -# -# Unless required by applicable law or agreed to in writing, -# software distributed under the License is distributed on an -# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -# KIND, either express or implied.  See the License for the -# specific language governing permissions and limitations -# under the License. -# - -### --- Web Socket proxy settings --- ### - -# Configuration Store connection string -configurationStoreServers=memory:127.0.0.1:2181 - -# Zookeeper session timeout in milliseconds -zooKeeperSessionTimeoutMillis=30000 -# ZooKeeper cache expiry time in seconds -zooKeeperCacheExpirySeconds=300 - -# Pulsar cluster url to connect to broker (optional if configurationStoreServers present) -serviceUrl=localhost:6650 -serviceUrlTls= -brokerServiceUrl= -brokerServiceUrlTls= - -# Port to use to server HTTP request -webServicePort=8080 -# Port to use to server HTTPS request -webServicePortTls= - -# Path for the file used to determine the rotation status for the proxy-instance when responding -# to service discovery health checks -statusFilePath= - -# Hostname or IP address the service binds on, default is 0.0.0.0. -bindAddress=0.0.0.0 - -# Name of the pulsar cluster to connect to -clusterName=standalone - -# Number of IO threads in Pulsar Client used in WebSocket proxy -webSocketNumIoThreads=8 - -# Number of threads to use in HTTP server. Default is Runtime.getRuntime().availableProcessors() -numHttpServerThreads= - -# Number of connections per Broker in Pulsar Client used in WebSocket proxy -webSocketConnectionsPerBroker=8 - -# Time in milliseconds that idle WebSocket session times out -webSocketSessionIdleTimeoutMillis=300000 - -# The maximum size of a text message during parsing in WebSocket proxy -webSocketMaxTextFrameSize=1048576 - -### --- Authentication --- ### - -# Enable authentication -authenticationEnabled=true - -# Authentication provider name list, which is comma separated list of class names -authenticationProviders=org.apache.pulsar.broker.authentication.AuthenticationProviderToken - -# Enforce authorization -authorizationEnabled=true - -# Authorization provider fully qualified class-name -authorizationProvider=org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider - -# Allow wildcard matching in authorization -# (wildcard matching only applicable if wildcard-char: -# * presents at first or last position eg: *.pulsar.service, pulsar.service.*) -authorizationAllowWildcardsMatching=false - -# Role names that are treated as "super-user", meaning they will be able to do all admin -# operations and publish/consume from all topics -superUserRoles=test-user - -tokenPublicKey=./my-public.key - -# Authentication settings of the proxy itself. Used to connect to brokers -brokerClientTlsEnabled=false -brokerClientAuthenticationPlugin= -brokerClientAuthenticationParameters= -brokerClientTrustCertsFilePath= - -# When this parameter is not empty, unauthenticated users perform as anonymousUserRole -anonymousUserRole= - -### --- TLS --- ### - -# Deprecated - use webServicePortTls and brokerClientTlsEnabled instead -tlsEnabled=false - -# Accept untrusted TLS certificate from client -tlsAllowInsecureConnection=false - -# Path for the TLS certificate file -tlsCertificateFilePath= - -# Path for the TLS private key file -tlsKeyFilePath= - -# Path for the trusted TLS certificate file -tlsTrustCertsFilePath= - -# Specify whether Client certificates are required for TLS -# Reject the Connection if the Client Certificate is not trusted. -tlsRequireTrustedClientCertOnConnect=false - -# Tls cert refresh duration in seconds (set 0 to check on every new connection)  -tlsCertRefreshCheckDurationSec=300 - -### --- Deprecated config variables --- ### - -# Deprecated. Use configurationStoreServers -globalZookeeperServers= +# +# Licensed to the Apache Software Foundation (ASF) under one +# or more contributor license agreements.  See the NOTICE file +# distributed with this work for additional information +# regarding copyright ownership.  The ASF licenses this file +# to you under the Apache License, Version 2.0 (the +# "License"); you may not use this file except in compliance +# with the License.  You may obtain a copy of the License at +# +#   http://www.apache.org/licenses/LICENSE-2.0 +# +# Unless required by applicable law or agreed to in writing, +# software distributed under the License is distributed on an +# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY +# KIND, either express or implied.  See the License for the +# specific language governing permissions and limitations +# under the License. +# + +### --- Web Socket proxy settings --- ### + +# Configuration Store connection string +configurationStoreServers=memory:127.0.0.1:2181 + +# Zookeeper session timeout in milliseconds +zooKeeperSessionTimeoutMillis=30000 +# ZooKeeper cache expiry time in seconds +zooKeeperCacheExpirySeconds=300 + +# Pulsar cluster url to connect to broker (optional if configurationStoreServers present) +serviceUrl=localhost:6650 +serviceUrlTls= +brokerServiceUrl= +brokerServiceUrlTls= + +# Port to use to server HTTP request +webServicePort=8080 +# Port to use to server HTTPS request +webServicePortTls= + +# Path for the file used to determine the rotation status for the proxy-instance when responding +# to service discovery health checks +statusFilePath= + +# Hostname or IP address the service binds on, default is 0.0.0.0. +bindAddress=0.0.0.0 + +# Name of the pulsar cluster to connect to +clusterName=standalone + +# Number of IO threads in Pulsar Client used in WebSocket proxy +webSocketNumIoThreads=8 + +# Number of threads to use in HTTP server. Default is Runtime.getRuntime().availableProcessors() +numHttpServerThreads= + +# Number of connections per Broker in Pulsar Client used in WebSocket proxy +webSocketConnectionsPerBroker=8 + +# Time in milliseconds that idle WebSocket session times out +webSocketSessionIdleTimeoutMillis=300000 + +# The maximum size of a text message during parsing in WebSocket proxy +webSocketMaxTextFrameSize=1048576 + +### --- Authentication --- ### + +# Enable authentication +authenticationEnabled=true + +# Authentication provider name list, which is comma separated list of class names +authenticationProviders=org.apache.pulsar.broker.authentication.AuthenticationProviderToken + +# Enforce authorization +authorizationEnabled=true + +# Authorization provider fully qualified class-name +authorizationProvider=org.apache.pulsar.broker.authorization.PulsarAuthorizationProvider + +# Allow wildcard matching in authorization +# (wildcard matching only applicable if wildcard-char: +# * presents at first or last position eg: *.pulsar.service, pulsar.service.*) +authorizationAllowWildcardsMatching=false + +# Role names that are treated as "super-user", meaning they will be able to do all admin +# operations and publish/consume from all topics +superUserRoles=test-user + +tokenPublicKey=./my-public.key + +# Authentication settings of the proxy itself. Used to connect to brokers +brokerClientTlsEnabled=false +brokerClientAuthenticationPlugin= +brokerClientAuthenticationParameters= +brokerClientTrustCertsFilePath= + +# When this parameter is not empty, unauthenticated users perform as anonymousUserRole +anonymousUserRole= + +### --- TLS --- ### + +# Deprecated - use webServicePortTls and brokerClientTlsEnabled instead +tlsEnabled=false + +# Accept untrusted TLS certificate from client +tlsAllowInsecureConnection=false + +# Path for the TLS certificate file +tlsCertificateFilePath= + +# Path for the TLS private key file +tlsKeyFilePath= + +# Path for the trusted TLS certificate file +tlsTrustCertsFilePath= + +# Specify whether Client certificates are required for TLS +# Reject the Connection if the Client Certificate is not trusted. +tlsRequireTrustedClientCertOnConnect=false + +# Tls cert refresh duration in seconds (set 0 to check on every new connection)  +tlsCertRefreshCheckDurationSec=300 + +### --- Deprecated config variables --- ### + +# Deprecated. Use configurationStoreServers +globalZookeeperServers=