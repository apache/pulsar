<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pulsar Java 客户端 · Apache Pulsar</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="可以使用 Pulsar Java 客户端来创建消息的 Java [生产者](#producer), [消费者](#consumer), 以及 [Reader](#reader) ，还可以执行 [管理任务](/docs/zh-CN/next/admin-api-overview)。 Java 客户端的当前版本是 **2.9.1**。"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="Pulsar Java 客户端 · Apache Pulsar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pulsar.apache.org/"/><meta property="og:description" content="可以使用 Pulsar Java 客户端来创建消息的 Java [生产者](#producer), [消费者](#consumer), 以及 [Reader](#reader) ，还可以执行 [管理任务](/docs/zh-CN/next/admin-api-overview)。 Java 客户端的当前版本是 **2.9.1**。"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://pulsar.apache.org/img/pulsar.svg"/><link rel="shortcut icon" href="/img/pulsar.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://pulsar.apache.org/blog/atom.xml" title="Apache Pulsar Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://pulsar.apache.org/blog/feed.xml" title="Apache Pulsar Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-102219959-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/custom.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/pulsar.svg" alt="Apache Pulsar"/></a><a href="/zh-CN/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/standalone" target="_self">文档</a></li><li class=""><a href="/zh-CN/download" target="_self">下载</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/client-libraries" target="_self">客户端</a></li><li class=""><a href="#restapis" target="_self">REST API</a></li><li class=""><a href="#cli" target="_self">命令行</a></li><li class=""><a href="/blog/" target="_self">博客</a></li><li class=""><a href="#community" target="_self">社区</a></li><li class=""><a href="#apache" target="_self">Apache</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/next/client-libraries-java">English</a></li><li><a href="/docs/ja/next/client-libraries-java">日本語</a></li><li><a href="/docs/fr/next/client-libraries-java">Français</a></li><li><a href="/docs/ko/next/client-libraries-java">한국어</a></li><li><a href="/docs/zh-TW/next/client-libraries-java">繁體中文</a></li><li><a href="https://crowdin.com/project/apache-pulsar" target="_blank" rel="noreferrer noopener">参与翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>客户端库</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Get Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone">本地运行 Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone-docker">在 Docker 中运行 Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/kubernetes-helm">在 Kubernetes 中运行 Pulsar</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">概念和架构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-messaging">消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-architecture-overview">架构</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-clients">客户端</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-replication">跨机房复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multi-tenancy">多租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-authentication">认证和授权</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-topic-compaction">消息压缩</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-proxy-sni-routing">Pulsar Proxy 支持 SNI 路由</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multiple-advertised-listeners">配置 Advertised 监听器</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Schema</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-get-started">开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-understand">理解 schema</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-evolution-compatibility">Schema 演化和兼容</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-manage">管理 Schema</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-runtime">设置：配置 Pulsar Functions 运行时</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-worker">设置：Pulsar Functions Worker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-develop">操作：开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-package">如何打包</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-debug">操作：调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-deploy">操作：部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-cli">参考：命令</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/window-functions-context">窗口函数：上下文</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar IO</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-quickstart">开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-use">使用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-debug">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-connectors">内置 connector</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cdc">CDC connector</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-develop">开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cli">CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar SQL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-getting-started">查询数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-deployment-configurations">配置和部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-rest-api">REST API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">层级存储</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-aws">亚马逊 AWS S3 offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-gcs">GCS offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-filesystem">Filesystem offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-azure">Azure BlobStore offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-aliyun">阿里云 OSS offloader</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">事务</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-why">为什么需要事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-what">什么是事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-how">事务运行原理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-use">如何使用事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-monitor">如何监控事务？</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Kubernetes (Helm)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-prepare">准备</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-install">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-deploy">部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-upgrade">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-tools">所需工具</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">部署</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-aws">Amazon Web Services (Aws)</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-kubernetes">Kubernetes</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal">裸机</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal-multi-cluster">裸机多集群部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-dcos">DC/OS</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-docker">Docker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-monitoring">Monitor</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">系统管理</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-zk-bk">ZooKeeper 和 BookKeeper</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-geo">跨地域复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-pulsar-manager">Pulsar Manager</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-stats">Pulsar 统计数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-load-balance">负载均衡</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-proxy">Pulsar 代理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-upgrade">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-isolation">Pulsar 隔离</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">安全</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-transport">使用TLS进行传输加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-authentication">使用TLS进行认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-keystore">使用 TLS 配置KeyStore</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-jwt">使用 JWT 认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-athenz">使用 Athenz 验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-kerberos">使用 Kerberos 进行身份验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-oauth2">使用 OAuth 2.0 访问令牌进行身份验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-authorization">授权和ACL</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-encryption">端到端加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-extending">扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-bouncy-castle">Bouncy Castle Providers</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">性能</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/performance-pulsar-perf">Pulsar Perf 性能测试</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">客户端库</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries">概述</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/next/client-libraries-java">Java</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-go">Go</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-python">Python</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-cpp">C++</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-node">Node.js
</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-websocket">WebSocket</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-dotnet">C#</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-rest">REST</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Admin API</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-clusters">集群</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-tenants">租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-brokers">Brokers</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-namespaces">命名空间</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-permissions">权限管理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-topics">Topic</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-functions">Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-packages">Package</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">适配器</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-kafka">Kafka 客户端封装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-spark">Apache Spark</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-storm">Apache Storm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考手册</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-compaction">Topic compaction</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-deduplication">消息去重</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-non-persistent">非持久化消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-retention-expiry">消息保留和过期</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-encryption">加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-message-queue">消息队列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-bookkeepermetadata">BookKeeper Ledger 元数据</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">开发</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-tools">模拟工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-binary-protocol">二进制协议</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-load-manager">模块化负载管理器</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-terminology">术语</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-cli-tools">Pulsar 命令行工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-configuration">Pulsar configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-metrics">Pulsar Metrics</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/apache-pulsar/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Pulsar Java 客户端</h1></header><article><div><span><p>可以使用 Pulsar Java 客户端来创建消息的 Java <a href="#producer">生产者</a>, <a href="#consumer">消费者</a>, 以及 <a href="#reader">Reader</a> ，还可以执行 <a href="/docs/zh-CN/next/admin-api-overview">管理任务</a>。 Java 客户端的当前版本是 <strong>2.9.1</strong>。</p>
<p>在利用 Java 客户端所创建的<a href="#producer">生产者</a>，<a href="#consumer">消费者</a>和<a href="#reader">读者</a>中所提供的方法都是线程安全的。</p>
<p>Pulsar 客户端的Javadoc 分为如下两个包：</p>
<table>
<thead>
<tr><th style="text-align:left">包</th><th style="text-align:left">说明</th><th style="text-align:left">Maven Artifact</th></tr>
</thead>
<tbody>
<tr><td style="text-align:left"><a href="/api/client/2.9.0-SNAPSHOT"><code>org.apache.pulsar.client.api</code></a></td><td style="text-align:left">生产者和消费者 API</td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client:2.9.1</a></td></tr>
<tr><td style="text-align:left"><a href="/api/admin/2.9.0-SNAPSHOT"><code>org.apache.pulsar.client.admin</code></a></td><td style="text-align:left">Java <a href="/docs/zh-CN/next/admin-api-overview">管理API</a></td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-admin%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client-admin:2.9.1</a></td></tr>
<tr><td style="text-align:left"><code>org.apache.pulsar.client.all</code></td><td style="text-align:left">包含 <code>pulsar-client</code> 和 <code>pulsar-client-admin</code>。</td></tr>
</tbody>
</table>
<p><code>pulsar-client</code> 和 <code>pulsar-client-admin</code> 二者都是被 shade 的包，并且它们是独立地 shade 依赖项的。 因此，同时使用 <code>pulsar-client</code> 和 <code>pulsar-client-admin</code> 的应用程序会有冗余的 shade 类。 如果您引入了新的依赖项，但忘记更新 shade 规则，就会引起问题。<br>
在这种情况下，可以使用 <code>pulsar-client-all</code>，它只对依赖项 shade 一次，并减少了依赖项的大小。 | <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-all%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client-all:2.9.1</a>     |</p>
<p>本文档仅关注 Pulsar 主题消息的生产和消费的客户端 API。 如果想使用Java版本的管理客户端，可以查看 <a href="/docs/zh-CN/next/admin-api-overview">Pulsar 管理接口</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="安装"></a><a href="#安装" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装</h2>
<p>最新版本的Pulsar Java 客户端库可从 <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.9.1%7Cjar">Maven中央仓库</a> 安装。 要使用最新版本, 请将 <code>pulsar-client</code> 库添加到构建配置中。</p>
<h3><a class="anchor" aria-hidden="true" id="maven"></a><a href="#maven" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maven</h3>
<p>如果你使用Maven，添加下面信息到 <code>pom.xml</code> 文件中。</p>
<pre><code class="hljs css language-xml"><span class="hljs-comment">&lt;!-- 在你的 &lt;properties&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pulsar.version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">pulsar.version</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 在你的 &lt;dependencies&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.pulsar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pulsar-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${pulsar.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="gradle"></a><a href="#gradle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gradle</h3>
<p>如果你使用Gradle，添加下面内容到<code>build.gradle</code> 文件。</p>
<pre><code class="hljs css language-groovy"><span class="hljs-keyword">def</span> pulsarVersion = <span class="hljs-string">'2.9.1'</span>

dependencies {
    compile <span class="hljs-string">group:</span> <span class="hljs-string">'org.apache.pulsar'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'pulsar-client'</span>, <span class="hljs-string">version:</span> pulsarVersion
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="连接-url"></a><a href="#连接-url" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>连接 URL</h2>
<p>要使用客户端连接到 Pulsar，你需要指定<a href="/docs/zh-CN/next/develop-binary-protocol">Pulsar 协议</a>URL。</p>
<p>可以给特定集群分配 Pulsar 协议格式的 URL，并使用 <code>Pulsar</code> Scheme。默认端口号为 <code>6650</code> 。下面是一个 <code>localhost</code> 例子。</p>
<pre><code class="hljs css language-http">pulsar://localhost:6650
</code></pre>
<p>If you have multiple brokers, the URL is as follows.</p>
<pre><code class="hljs css language-http">pulsar://localhost:6550,localhost:6651,localhost:6652
</code></pre>
<p>A URL for a production Pulsar cluster is as follows.</p>
<pre><code class="hljs css language-http">pulsar://pulsar.us-west.example.com:6650
</code></pre>
<p>If you use <a href="/docs/zh-CN/next/security-tls-authentication">TLS</a> authentication, the URL is as follows.</p>
<pre><code class="hljs css language-http">pulsar+ssl://pulsar.us-west.example.com:6651
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="client"></a><a href="#client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Client</h2>
<p>You can instantiate a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 object using just a URL for the target Pulsar <a href="/docs/zh-CN/next/reference-terminology#cluster">cluster</a> like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650"</span>)
        .build();
</code></pre>
<p>If you have multiple brokers, you can initiate a PulsarClient like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650,localhost:6651,localhost:6652"</span>)
        .build();
</code></pre>
<blockquote>
<h3><a class="anchor" aria-hidden="true" id="默认的broker-url是单机集群"></a><a href="#默认的broker-url是单机集群" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认的broker URL是单机集群。</h3>
<p>如果运行的是 <a href="/docs/zh-CN/next/standalone">standalone </a> 模式的集群，则默认可以通过 <code>pulsar://localhost:6650</code> 这个 URL 来访问 broker。</p>
</blockquote>
<p>在创建客户端时，可以采用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 可用的参数如下。</p>
<p>| 名称 | 类型 |</p>
<div style="width:260px">
  说明
</div>
<p>| 默认值 |---|---|---|--- <code>serviceUrl</code> | String | Pulsar服务的服务 URL 提供者 | 无 <code>authPluginClassName</code> | String | 认证插件的名称 | 无 <code>authParams</code> | String | 认证插件的参数</p>
<p><strong>例如</strong>  <br>
key1:val1,key2:val2 | 无 <code>operationTimeoutMs</code> | long | <code>operationTimeoutMs</code> | 操作超时时长（毫秒） | 30000 <code>statsIntervalSeconds</code> | long | 每个统计信息之间的时间间隔（秒）</p>
<p>当 <code>statsInterval</code>为正数时统计信息才被激活。</p>
<p>请将 <code>statsIntervalSeconds</code> 设置为至少 1 秒。 | 60 <code>numIoThreads</code> | int | 用于处理 broker 连接的线程数 | 1 <code>numListenerThreads</code> | int | 用于处理消息监听器的线程数。 所有的消费者和读者共享监听器线程池，并使用 “监听器”模式获取消息。 对于某个消费者来说，为了保证有序性，总在同一线程中调用监听器。 如果想用多线程处理单个 topic，需要采用 <a href="https://pulsar.apache.org/docs/en/next/concepts-messaging/#shared"><code>shared</code></a> 订阅模式，并为这个订阅创建多个消费者。 这样不能保证有序。| 1 <code>useTcpNoDelay</code>| boolean | 是否在连接上使用 TCP 无延迟标志来禁用 Nagle 算法 | true <code>useTls</code> | boolean | 是否在连接上使用 TLS 加密 | false <code>tlsTrustCertsFilePath</code> | string | 受信 TLS 证书文件的路径 | 无 <code>tlsAllowInsecureConnection</code> | boolean | Pulsar 客户端是否接受来自 broker 的非受信 TLS 证书 | false <code>tlsHostnameVerificationEnable</code> | boolean | 是否启用 TLS 主机名验证 | false <code>concurrentLookupRequest</code> | int | 每个 Broker 连接上允许发送的并发查找请求数，以防止 Broker 过载 | 5000 <code>maxLookupRequest</code> | int | 每个 Broker 连接上允许的最大查找请求数，以防止Broker过载 | 50000 <code>maxNumberOfRejectedRequestPerConnection</code> | int | 在当前连接关闭且客户端创建新连接以连接到另一个 broker 之后的特定时间段 (30秒) 内，broker 请求被拒绝的最大次数 | 50 <code>keepAliveIntervalSeconds</code> | int | 每个客户端 broker 连接的保活间隔的秒数 | 30 <code>connectionTimeoutMs</code> | int | 与 broker 建立连接的等待超时时间</p>
<p>如果持续时间过去了还没有收到 broker 响应，则连接尝试将被丢弃 | 10000 <code>requestTimeoutMs</code> | int | 完成请求的最长持续时间 | 60000 <code>defaultBackoffIntervalNanos</code> | int | Backoff 间隔的默认持续时间 | TimeUnit.MILLISECONDS.toNanos(100); <code>maxBackoffIntervalNanos</code> | long |Backoff 间隔的最大持续时间 | TimeUnit.SECONDS.toNanos(30) <code>socks5ProxyAddress</code> | SocketAddress | SOCKS5 代理地址 | 无 <code>socks5ProxyUsername</code> | string | SOCKS5 代理用户账号 | 无 <code>socks5ProxyPassword</code> | string | SOCKS5 代理用户密码 | 无</p>
<p>Check out the Javadoc for the <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 class for a full list of configurable parameters.</p>
<blockquote>
<p>除了客户端级别的配置，你还可以使用特定于 <a href="#configure-producer">生产者</a>和<a href="#configure-consumer">消费者</a>的配置，下面的章节将会讲述。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="客户端内存分配器配置"></a><a href="#客户端内存分配器配置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端内存分配器配置</h3>
<p>您可以通过 Java 属性来设置客户端内存分配器的配置。</p>
<p>| 属性 | 类型 |</p>
<div>
  说明
</div>
<p>| 默认值 | 可用值 |---|---|---|---|----- <code>pulsar.allocator.pooled</code> | String | 如果设置为 true <code>true</code>，则客户端使用直接内存池。 </br> 如果设置为 false <code>false</code>，则客户端使用堆内存，而不是内存池 | true |</p>
<ul>
<li><p>true</p></li>
<li><p>false
<code>pulsar.allocator.exit_on_oom</code> | String | 当 OOM 出现的时候是否直接退出 JVM | false |</p></li>
<li><p>true</p></li>
<li><p>false
<code>pulsar.allocator.leak_detection</code> | String | Pulsar 服务的服务 URL 提供者 | Disabled |</p></li>
<li><p>Disabled</p></li>
<li><p>Simple</p></li>
<li><p>Advanced</p></li>
<li><p>Paranoid
<code>pulsar.allocator.out_of_memory_policy</code> | String | 当出现 OOM 时，客户端是抛出异常，还是退回使用堆 | FallbackToHeap |</p></li>
<li><p>ThrowException</p></li>
<li><p>FallbackToHeap</p></li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="hljs">-Dpulsar.allocator.pooled=true
-Dpulsar.allocator.exit_on_oom=false
-Dpulsar.allocator.leak_detection=Disabled
-Dpulsar.allocator.out_of_memory_policy=ThrowException
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="生产者producer"></a><a href="#生产者producer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产者（Producer）</h2>
<p>在Pulsar中，生产者写消息到主题中。 一旦你实例化一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
客户端对象(在<a href="#client-configuration">如上</a>z章节)，你可以创建一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/Producer">Producer</a>
生产者用于特定的<a href="/docs/zh-CN/next/reference-terminology#topic">主题</a>。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();

<span class="hljs-comment">// 然后你就可以发送消息到指定的broker 和topic上：</span>
producer.send(<span class="hljs-string">"My message"</span>.getBytes());
</code></pre>
<p>默认情况下，生产者生产的消息为字节数组类型。可以通过指定消息的<a href="#schema">schema</a> 来生产不同类型的消息。</p>
<pre><code class="hljs css language-java">Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();
stringProducer.send(<span class="hljs-string">"My message"</span>);
</code></pre>
<blockquote>
<p>当不再需要生产者、消费者和客户端时，请确保将其关闭。</p>
<pre><code class="hljs css language-java">producer.close();
consumer.close();
client.close();
</code></pre>
<p>关闭操作也可以是异步的：</p>
<pre><code class="hljs css language-java">producer.closeAsync()
   .thenRun(() -&gt; System.out.println(<span class="hljs-string">"Producer closed"</span>))
   .exceptionally((ex) -&gt; {
       System.err.println(<span class="hljs-string">"Failed to close producer: "</span> + ex);
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   });
</code></pre>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="配置producer生产者"></a><a href="#配置producer生产者" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置Producer（生产者）</h3>
<p>如上例，在实例化 <code>Producer</code> 对象时只指定主题名称的话，生产者将使用默认配置。</p>
<p>创建生产者时可以用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 的可用参数如下所示。</p>
<p>名称 | 类型 |</p>
<div style="width:300px">
  说明
</div>| 默认值 |\---|\---|\---|\--- 
<p><code>topicName</code>| string | 主题名称 | null | <code>producerName</code>| string | 生产者名称 | null <code>sendTimeoutMs</code>| long | 消息发送的超时时间，单位是毫秒。<br>
如果在超时时间之内消息未被服务端确认 <code>sendTimeout</code> 就会产生错误。| 30000 <code>blockIfQueueFull</code>| boolean | 如果设置为 true <code>true</code>，当传出消息队列已满时， <code>Send</code> and <code>SendAsync</code> 方法会阻塞生产者，而不是失败或抛出错误。<br>
If it is set to <code>false</code>，当传出消息队列已满时， <code>Send</code> and <code>SendAsync</code> 方法会失败，并且 <code>ProducerQueueIsFullError</code> 异常会被抛出。</p>
<p>这个 <code>MaxPendingMessages</code> 参数决定传出消息队列的大小。| false <code>maxPendingMessages</code>| int | 保存待处理消息的队列的最大长度。</p>
<p>例如，一个消息正在等待接收 broker 的确认 <a href="/docs/zh-CN/next/reference-terminology#broker">broker</a>.</p>
<p>默认情况下，当队列已满时，所有调用 <code>Send</code> and <code>SendAsync</code> 方法将会失败， <strong>除非</strong> 你设置 <code>BlockIfQueueFull</code> 为 <code>true</code>。| 1000 <code>maxPendingMessagesAcrossPartitions</code>| int | 跨分区待处理消息的最大数量。</p>
<p>如果待处理消息的总数超过了所配置的值，则使用该设置降低每个分区的最大待处理消息数 ({@link #setMaxPendingMessages(int)}) | 50000 <code>messageRoutingMode</code>| MessageRoutingMode | 分区主题生产者的消息路由逻辑 <a href="/docs/zh-CN/next/concepts-architecture-overview#partitioned-topics"> </a>.<br>
仅当没有设置消息 key 时才应用这个逻辑。<br>
可用选项如下所示：</p>
<ul>
<li><code>pulsar.RoundRobinDistribution</code>: round robin</li>
<li><code>pulsar.UseSinglePartition</code>: publish all messages to a single partition</li>
<li><code>pulsar.CustomPartition</code>：自定义的分区 scheme |<code>pulsar.RoundRobinDistribution</code>
<code>hashingScheme</code>| HashingScheme | 生产消息时用来决定分区的哈希函数 (<strong>仅适用于分区主题</strong>).<br>
可用选项如下所示：</li>
</ul>
<ul>
<li><code>pulsar.JavastringHash</code>：等同于 Java 中的 <code>String.hashCode()</code></li>
<li><code>pulsar.Murmur3_32Hash</code>: applies the <a href="https://en.wikipedia.org/wiki/MurmurHash">Murmur3</a> hashing function</li>
<li><code>pulsar.BoostHash</code>：应用 C++ <a href="https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html">Boost</a> 库中的哈希函数 |
<code>HashingScheme.JavastringHash</code> <code>cryptoFailureAction</code>| ProducerCryptoFailureAction | 当加密失败时生产者需要采取的行动。</li>
</ul>
<ul>
<li><p><strong>FAIL</strong>：如果加密失败，则未加密的消息将会发送失败。</p></li>
<li><p><strong>SEND</strong>：如果加密失败，则未加密的消息将会发送成功。 |
<code>ProducerCryptoFailureAction.FAIL</code> <code>batchingMaxPublishDelayMicros</code>| long | 发送消息时的批处理时间。| TimeUnit.MILLISECONDS.toMicros(1) <code>batchingMaxMessages</code> | int | 一批消息中允许的最大消息个数。| 1000 <code>batchingEnabled</code>| boolean | 启用消息批处理。| true <code>compressionType</code>| CompressionType | 生产者使用的消息数据压缩类型。<br>
可用选项：</p></li>
<li><p><a href="https://github.com/lz4/lz4"><code>LZ4</code></a></p></li>
<li><p><a href="https://zlib.net/"><code>ZLIB</code></a></p>
<ul>
<li><a href="https://facebook.github.io/zstd/"><code>ZSTD</code></a></li>
<li><a href="https://google.github.io/snappy/"><code>SNAPPY</code></a>| 无压缩</p>
You can configure parameters if you do not want to use the default configuration.</li>
</ul>
<p>如需查看所有参数，可参考 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/ProducerBuilder">ProducerBuilder</a>
 类的 Javadoc 文档。下面是一个示例。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
    .topic(<span class="hljs-string">"my-topic"</span>)
    .batchingMaxPublishDelay(<span class="hljs-number">10</span>, TimeUnit.MILLISECONDS)
    .sendTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS)
    .blockIfQueueFull(<span class="hljs-keyword">true</span>)
    .create();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="消息路由"></a><a href="#消息路由" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息路由</h3>
<p>当使用分区主题时，当你使用生产者发布消息时你可以指定路由模式。 关于如何使用 Java 客户端指定路由模式的更多内容，可参考 <a href="/docs/zh-CN/next/cookbooks-partitioned">Partitioned Topics cookbook</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="异步发送"></a><a href="#异步发送" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步发送</h3>
<p>You can publish messages <a href="/docs/zh-CN/next/concepts-messaging#send-modes">asynchronously</a> using the Java client. With async send, the producer puts the message in a blocking queue and returns it immediately. Then the client library sends the message to the broker in the background. If the queue is full (max size configurable), the producer is blocked or fails immediately when calling the API, depending on arguments passed to the producer.</p>
<p>The following is an example.</p>
<pre><code class="hljs css language-java">producer.sendAsync(<span class="hljs-string">"my-async-message"</span>.getBytes()).thenAccept(msgId -&gt; {
    System.out.println(<span class="hljs-string">"Message with ID "</span> + msgId + <span class="hljs-string">" successfully sent"</span>);
});
</code></pre>
<p>As you can see from the example above, async send operations return a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/MessageId">MessageId</a>
 wrapped in a <a href="http://www.baeldung.com/java-completablefuture"><code>CompletableFuture</code></a>.</p>
<h3><a class="anchor" aria-hidden="true" id="配置消息"></a><a href="#配置消息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置消息</h3>
<p>In addition to a value, you can set additional items on a given message:</p>
<pre><code class="hljs css language-java">producer.newMessage()
    .key(<span class="hljs-string">"my-message-key"</span>)
    .value(<span class="hljs-string">"my-async-message"</span>.getBytes())
    .property(<span class="hljs-string">"my-key"</span>, <span class="hljs-string">"my-value"</span>)
    .property(<span class="hljs-string">"my-other-key"</span>, <span class="hljs-string">"my-other-value"</span>)
    .send();
</code></pre>
<p>You can terminate the builder chain with <code>sendAsync()</code> and get a future return.</p>
<h2><a class="anchor" aria-hidden="true" id="消费者consumer"></a><a href="#消费者consumer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消费者（Consumer）</h2>
<p>在Pulsar中，消费者订阅topic主题并处理生产者发布到这些主题的消息。 你可以首先实例化一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
对象并传递给他一个borker(<a href="#client-configuration">如上所示</a>) URL来实例化一个<a href="/docs/zh-CN/next/reference-terminology#consumer">消费者</a>。</p>
<p>当 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 对象实例化完成后，您可以创建一个 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/Consumer">Consumer</a>
 对象，并指定一个 <a href="/docs/zh-CN/next/reference-terminology#topic">主题</a> 和 <a href="/docs/zh-CN/next/concepts-messaging#subscription-types">订阅</a>.</p>
<pre><code class="hljs css language-java">Consumer consumer = client.newConsumer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .subscriptionName(<span class="hljs-string">"my-subscription"</span>)
        .subscribe();
</code></pre>
<p>The <code>subscribe</code> method will auto subscribe the consumer to the specified topic and subscription. 一种让消费者监听主题的方法是使用<code>while</code>循环。 In this example loop, the consumer listens for messages, prints the contents of any received message, and then <a href="/docs/zh-CN/next/reference-terminology#acknowledgment-ack">acknowledges</a> that the message has been processed. If the processing logic fails, you can use <a href="/docs/zh-CN/next/reference-terminology#acknowledgment-ack">negative acknowledgement</a> to redeliver the message later.</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
  <span class="hljs-comment">// Wait for a message</span>
  Message msg = consumer.receive();

  <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Do something with the message</span>
      System.out.println(<span class="hljs-string">"Message received: "</span> + <span class="hljs-keyword">new</span> String(msg.getData()));

      <span class="hljs-comment">// Acknowledge the message so that it can be deleted by the message broker</span>
      consumer.acknowledge(msg);
  } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-comment">// Message failed to process, redeliver later</span>
      consumer.negativeAcknowledge(msg);
  }
}
</code></pre>
<p>If you don't want to block your main thread and rather listen constantly for new messages, consider using a <code>MessageListener</code>.</p>
<pre><code class="hljs css language-java">MessageListener myMessageListener = (consumer, msg) -&gt; {
  <span class="hljs-keyword">try</span> {
      System.out.println(<span class="hljs-string">"Message received: "</span> + <span class="hljs-keyword">new</span> String(msg.getData()));
      consumer.acknowledge(msg);
  } <span class="hljs-keyword">catch</span> (Exception e) {
      consumer.negativeAcknowledge(msg);
  }
}

Consumer consumer = client.newConsumer()
     .topic(<span class="hljs-string">"my-topic"</span>)
     .subscriptionName(<span class="hljs-string">"my-subscription"</span>)
     .messageListener(myMessageListener)
     .subscribe();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="配置消费者"></a><a href="#配置消费者" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置消费者</h3>
<p>If you instantiate a <code>Consumer</code> object by specifying only a topic and subscription name as in the example above, the consumer uses the default configuration.</p>
<p>当您创建消费者时，可以采用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 可用的参数如下。</p>
<p>名称 | 类型 |</p>
<p><div style="width:300px">
说明
</div>
| 默认值 |---|---|---|--- <code>topicNames</code>| Set<String>| 主题名称 | Sets.newTreeSet() <code>topicsPattern</code>| Pattern | 主题模式 | 无 <code>subscriptionName</code>| String | 订阅名称 | 无 <code>subscriptionType</code>| SubscriptionType | 订阅模式<br>
共有四种订阅模式：</p>
<ul>
<li>Exclusive</li>
<li>Failover（灾备）</li>
<li>Shared（共享）</li>
<li>Key_Shared| SubscriptionType.Exclusive
<code>receiverQueueSize</code> | int | 消费者接收队列的大小。</li>
</ul>
<p>例如，在应用程序调用 Receive 方法之前消费者累积的消息数量。 <code></code>.</p>
<p>设置为高于默认值会提高消费者吞吐量，但会增加内存开销。| 1000 <code>acknowledgementsGroupTimeMicros</code>| long | 将消费者确认按指定时间分组。</p>
<p>默认情况下，消费者使用 100ms 分组时间向 broker 发送确认。</p>
<p>如果分组时间设置为 0，则会立即发送确认。</p>
<p>分组时间越长则越有效率，而代价是消息失败后的重传次数会略有增加。| TimeUnit.MILLISECONDS.toMicros(100) <code>negativeAckRedeliveryDelayMicros</code>| long | 在重新发送处理失败的消息之前的延迟等待时间。</p>
<p>当应用程序使用 {@link Consumer#negativeAcknowledge(Message)}，失败的消息会在一个固定的超时时间之后重传。| TimeUnit.MINUTES.toMicros(1) <code>maxTotalReceiverQueueSizeAcrossPartitions</code>| int | 跨分区的接收队列最大总长度。</p>
<p>如果接收队列总长度超过此值，则此设置会降低单个分区的接收队列长度。| 50000 <code>consumerName</code>| String | 消费者名称 | null <code>ackTimeoutMillis</code>| long | 未确认消息的超时时间 | 0 <code>tickDurationMillis</code>| ack-timeout 重传粒度。</p>
<p>使用更高的 <code>tickDurationMillis</code> 在将确认超时设置为较大值时 (例如1小时)，增大 tickDurationMillis 会降低追踪消息是的内存开销。|1000 <code>priorityLevel</code>| int | 在共享订阅模式下，broker 分发消息时给予消费者的优先级别。</p>
<p>Broker 按照优先级降序排序。例如 0 表示最大优先级，其次是 1，2……</p>
<p>在共享订阅模式下，broker <strong>优先将消息分发给优先级最高的消费者，只要他们有许可。</strong>否则，broker 会分发给下一个优先级别的消费者。</p>
<p><strong>示例 1</strong>  <br>
如果一个订阅有消费者 consumerA <code>priorityLevel</code> 为0，另一个消费者 consumerB <code>priorityLevel</code> 为 1，则 broker <strong>只会向 consumerA 分发消息，直到其用完许可，</strong> 然后才会开始向 consumerB 分发消息。</p>
<p><strong>示例 2</strong>  <br>
消费者，优先级别，许可<br>
C1, 0, 2<br>
C2, 0, 1<br>
C3, 0, 1<br>
C4, 1, 2<br>
C5, 1, 1</p>
<p>Broker 分发消息给消费者的顺序是：C1, C2, C3, C1, C4, C5, C4。| 0 <code>cryptoFailureAction</code>| ConsumerCryptoFailureAction | 当接收到无法解密的消息时，消费者应该采取的行动。</p></li>
</ul>
<pre><code class="hljs">* **FAIL**：这是在加密成功之前对于失败消息采取的默认选项。
* **DISCARD**：静默地确认消息，而不将消息分发给应用程序。
* **CONSUME**：向应用程序分发加密的消息。而由应用程序负责解密消息。
  
消息解压失败。   
  
如果消息包含批处理消息，则客户端无法在 batch 中检索单条消息。  
  
分发的加密消息包含 {@link EncryptionContext}，其中包含加密和压缩信息，应用程序可以利用这些信息解密消息载荷。| ConsumerCryptoFailureAction.FAIL&lt;/li&gt; `properties`| SortedMap&lt;String, String&gt; | 此消费者的名称或值属性。  
  
`properties` 是附加到消费者上的应用程序定义的元数据。   
  
获取主题统计信息时，可以将此元数据与消费者统计信息相关联，以便于识别。| new TreeMap&lt;&gt;() `readCompacted`| boolean | 如果启用 `readCompacted`，则消费者从压缩主题中读取消息，而不是读取主题的完整消息 backlog。  
  
消费者只能看到压缩主题中每个 key 的最新值，直到压缩 backlog 时主题消息中对应的位点。 超过这一位点，消息照常发送。  
  
仅启用 `readCompacted` 在持久化主题的订阅上，持久化主题仅有单个活跃消费者 (类似故障或独占订阅模式)。   
  
如果试图在非持久化主题或者共享订阅上开启该功能，则会导致订阅调用抛出 `PulsarClientException`。|false `subscriptionInitialPosition`| SubscriptionInitialPosition | 首次订阅主题时游标的初始位置。| SubscriptionInitialPosition.Latest `patternAutoDiscoveryPeriod`| int | 当主题消费者使用模式匹配时，自动发现主题的时间周期。  
  
默认值和最小值都为 1 分钟。| 1 `regexSubscriptionMode`| RegexSubscriptionMode | 当使用正则表达式订阅主题时，可以选择特定类型的主题。  
  


* **PersistentOnly**：只订阅持久化主题。
* **NonPersistentOnly**：只订阅非持久化主题。
* **AllTopics**：同时订阅持久化和非持久化主题。|RegexSubscriptionMode.PersistentOnly 
`deadLetterPolicy`| DeadLetterPolicy | 消费者的死信策略。  
  
默认情况下，一些消息可能会被多次重传，甚至达到从不停止的程度。  
  
利用死信机制，可以限制消息的最大重传次数。 **当超过最大重传次数时，消息会被发送到死信主题并自动确认。**.  
  
如果要启动死信机制，可以配置 `deadLetterPolicy`.  
  
**示例**  
  
`client.newConsumer()&lt;br /&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10).build())&lt;br /&gt;.subscribe();`  
  
默认的死信主题名称是 `{TopicName}-{Subscription}-DLQ`.  
  
设置自定义的死信主题名称：  
`client.newConsumer()&lt;br /&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10)&lt;br /&gt;.deadLetterTopic(&quot;your-topic-name&quot;).build())&lt;br /&gt;.subscribe();`  
  
如果设置了死信策略，但没有指定 `ackTimeoutMillis`，则可以将确认超时时间设置为 30000 毫秒。| 无 `autoUpdatePartitions`| boolean | 如果 `autoUpdatePartitions` 被启动，则消费者会自动订阅新增分区。  
  
**Note**：仅适用于分区消费者。| true `replicateSubscriptionState`| boolean | 如果 `replicateSubscriptionState`  被启动，则订阅状态会被复制到跨地域复制的集群中。| false `negativeAckRedeliveryBackoff`| NegativeAckRedeliveryBackoff | 自定义消息的接口是 negativeAcked 策略。可以指定 `NegativeAckRedeliveryBackoff` 为一个消费者。| `NegativeAckRedeliveryExponentialBackoff`

You can configure parameters if you do not want to use the default configuration. For a full list, see the Javadoc for the {@inject: javadoc:ConsumerBuilder:/client/org/apache/pulsar/client/api/ConsumerBuilder} class.

The following is an example.

```java
Consumer consumer = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .ackTimeout(10, TimeUnit.SECONDS)
        .subscriptionType(SubscriptionType.Exclusive)
        .subscribe();
```

### 异步接收

The `receive` method receives messages synchronously (the consumer process is blocked until a message is available). You can also use [async receive](/docs/zh-CN/next/concepts-messaging#receive-modes), which returns a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) object immediately once a new message is available.

The following is an example.

```java
CompletableFuture&lt;Message&gt; asyncMessage = consumer.receiveAsync();
```

Async receive operations return a {@inject: javadoc:Message:/client/org/apache/pulsar/client/api/Message} wrapped inside of a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).

### 批量接收

Use `batchReceive` to receive multiple messages for each call.

The following is an example.

```java
Messages messages = consumer.batchReceive();
for (Object message : messages) {
  // do something
}
consumer.acknowledge(messages)
```

&gt; 注意：
&gt; 
&gt; 批量接收策略会限制每个批次中消息的数量和字节大小。可以指定一个超时时间以等待足够的消息。
&gt; 
&gt; 如果满足以下任一条件，则批量接收完成：足够的消息数量、足够的消息字节数、等待超时。
&gt; 
&gt; ```java
&gt; Consumer consumer = client.newConsumer()
&gt;         .topic(&quot;my-topic&quot;)
&gt;         .subscriptionName(&quot;my-subscription&quot;)
&gt;         .batchReceivePolicy(BatchReceivePolicy.builder()
&gt;              .maxNumMessages(100)
&gt;              .maxNumBytes(1024 * 1024)
&gt;              .timeout(200, TimeUnit.MILLISECONDS)
&gt;              .build())
&gt;         .subscribe();
&gt; ```
&gt; 
&gt; 默认批量接收策略是：
&gt; 
&gt; ```java
&gt; BatchReceivePolicy.builder()
&gt;     .maxNumMessage(-1)
&gt;     .maxNumBytes(10 * 1024 * 1024)
&gt;     .timeout(100, TimeUnit.MILLISECONDS)
&gt;     .build();
&gt; ```

### 否定确认重传退避

`NegativeAckRedeliveryBackoff` 引入了一种重传退避机制。可以通过设置消息的 `redeliveryCount` 来实现不同延迟时间的重传。

```java
Consumer consumer =  client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .negativeAckRedeliveryBackoff(NegativeAckRedeliveryExponentialBackoff.builder()
                .minNackTimeMs(1000)
                .maxNackTimeMs(60 * 1000)
                .build())
        .subscribe();
```

&gt; **注意** - `negativeAckRedeliveryBackoff` 不适用于 `consumer.negativeAcknowledge(MessageId messageId)`，因为无法通过消息 ID 获取重传次数。 - 如果消费者崩溃，则会触发重传未确认的消息。 在这种情况下，`NegativeAckRedeliveryBackoff` 不会生效，消息可能会比退避延迟时间更早地重传。

### 多主题订阅

消费者除了订阅单个Pulsar主题外，你还可以使用[多主题订阅](/docs/zh-CN/next/concepts-messaging#multi-topic-subscriptions)订阅多个主题。 若要使用多主题订阅, 可以提供一个topic正则表达式 (regex) 或 主题`List` 。 如果通过 regex 选择主题, 则所有主题都必须位于同一Pulsar命名空间中。

The followings are some examples.

```java
import org.apache.pulsar.client.api.Consumer;
import org.apache.pulsar.client.api.PulsarClient;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

ConsumerBuilder consumerBuilder = pulsarClient.newConsumer()
        .subscriptionName(subscription);

// Subscribe to all topics in a namespace
Pattern allTopicsInNamespace = Pattern.compile(&quot;public/default/.*&quot;);
Consumer allTopicsConsumer = consumerBuilder
        .topicsPattern(allTopicsInNamespace)
        .subscribe();

// Subscribe to a subsets of topics in a namespace, based on regex
Pattern someTopicsInNamespace = Pattern.compile(&quot;public/default/foo.*&quot;);
Consumer allTopicsConsumer = consumerBuilder
        .topicsPattern(someTopicsInNamespace)
        .subscribe();
```

In the above example, the consumer subscribes to the `persistent` topics that can match the topic name pattern. If you want the consumer subscribes to all `persistent` and `non-persistent` topics that can match the topic name pattern, set `subscriptionTopicsMode` to `RegexSubscriptionMode.AllTopics`.

```java
Pattern pattern = Pattern.compile(&quot;public/default/.*&quot;);
pulsarClient.newConsumer()
        .subscriptionName(&quot;my-sub&quot;)
        .topicsPattern(pattern)
        .subscriptionTopicsMode(RegexSubscriptionMode.AllTopics)
        .subscribe();
```

&gt; **注意**  
&gt; 默认情况下，消费者的 `subscriptionTopicsMode` 是 `PersistentOnly`。 `subscriptionTopicsMode` 的可用选项为： `PersistentOnly`，`NonPersistentOnly`，以及 `AllTopics`。

你还可以订阅明确的主题列表 (如果愿意, 可跨命名空间):

```java
List&lt;String&gt; topics = Arrays.asList(
        &quot;topic-1&quot;,
        &quot;topic-2&quot;,
        &quot;topic-3&quot;
);

Consumer multiTopicConsumer = consumerBuilder
        .topics(topics)
        .subscribe();

// Alternatively:
Consumer multiTopicConsumer = consumerBuilder
        .topic(
            &quot;topic-1&quot;,
            &quot;topic-2&quot;,
            &quot;topic-3&quot;
        )
        .subscribe();
```

还可以使用 `subscribeAsync` 方法异步地订阅多个主题，而不使用同步的 `subscribe` 方法。示例如下。

```java
Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default.*&quot;);
consumerBuilder
        .topics(topics)
        .subscribeAsync()
        .thenAccept(this::receiveMessageFromConsumer);

private void receiveMessageFromConsumer(Object consumer) {
    ((Consumer)consumer).receiveAsync().thenAccept(message -&gt; {
                // Do something with the received message
                receiveMessageFromConsumer(consumer);
            });
}
```

### Subscription types

Pulsar has various [subscription types](concepts-messaging#subscription-types) to match different scenarios. A topic can have multiple subscriptions with different subscription types. However, a subscription can only have one subscription type at a time.

A subscription is identical with the subscription name; a subscription name can specify only one subscription type at a time. To change the subscription type, you should first stop all consumers of this subscription.

不同的订阅模式对应不同的消息分发类型。本节介绍订阅模式的区别和使用方法。

In order to better describe their differences, assuming you have a topic named &quot;my-topic&quot;, and the producer has published 10 messages.

```java
Producer&lt;String&gt; producer = client.newProducer(Schema.STRING)
        .topic(&quot;my-topic&quot;)
        .enableBatching(false)
        .create();
// 3 messages with &quot;key-1&quot;, 3 messages with &quot;key-2&quot;, 2 messages with &quot;key-3&quot; and 2 messages with &quot;key-4&quot;
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-1&quot;).send();
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-2&quot;).send();
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-3&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-1&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-2&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-3&quot;).send();
producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-1&quot;).send();
producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-2&quot;).send();
producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-1&quot;).send();
producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-2&quot;).send();
```

#### Exclusive

Create a new consumer and subscribe with the `Exclusive` subscription type.

```java
Consumer consumer = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Exclusive)
        .subscribe()
```

只有第一个消费者被允许订阅，其他消费者会收到一个错误信息。第一个消费者收到所有的 10 条消息，并且消费的顺序与生产顺序一致。

&gt; 注意：
&gt; 
&gt; 如果是分区主题，则第一个消费者订阅所有的分区主题，其他消费者不会被分配分区并会收到错误。

#### Failover（灾备）

Create new consumers and subscribe with the`Failover` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Failover)
        .subscribe()
Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Failover)
        .subscribe()
//conumser1 is the active consumer, consumer2 is the standby consumer.
//consumer1 receives 5 messages and then crashes, consumer2 takes over as an  active consumer.


```

Multiple consumers can attach to the same subscription, yet only the first consumer is active, and others are standby. When the active consumer is disconnected, messages will be dispatched to one of standby consumers, and the standby consumer then becomes active consumer.

如果第一个活跃消费者在收到 5 条消息后断开连接，则备用消费者将成为活跃消费者。Consumer1 会收到：

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    

consumer2 will receive:

    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

&gt; 注意：
&gt; 
&gt; 如果是分区主题，则每个分区只有一个活跃消费者， 一个分区的消息只分发给一个消费者，多个分区的消息分发给多个消费者。

#### Shared（共享）

Create new consumers and subscribe with `Shared` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Shared)
        .subscribe()

Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Shared)
        .subscribe()
//Both consumer1 and consumer 2 is active consumers.
```

在共享订阅模式中，多个消费者可以附加到同一个订阅，消息会跨多个消费者以 round robin 的方式分发。

If a broker dispatches only one message at a time, consumer1 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    

consumer2 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

`Shared` subscription is different from `Exclusive` and `Failover` subscription types. `Shared` subscription has better flexibility, but cannot provide order guarantee.

#### Key_shared

这是2.4.0版本新增的一个订阅模式。创建新的消费者并以 `Key_Shared` 订阅模式订阅。

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Key_Shared)
        .subscribe()

Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Key_Shared)
        .subscribe()
//Both consumer1 and consumer2 are active consumers.
```

与 `Shared` 订阅模式类似，`Key_Shared` 订阅模式中的所有消费者都可以附加到同一个订阅。 但 `Key_Shared` 订阅模式又不同于 `Shared` 订阅模式。 在 `Key_Shared` 订阅类型中，相同 key 的消息按顺仅发送给一个消费者。 The possible distribution of messages between different consumers (by default we do not know in advance which keys will be assigned to a consumer, but a key will only be assigned to a consumer at the same time).

consumer1 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    

consumer2 receives the following information.

    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

If batching is enabled at the producer side, messages with different keys are added to a batch by default. The broker will dispatch the batch to the consumer, so the default batch mechanism may break the Key_Shared subscription guaranteed message distribution semantics. The producer needs to use the `KeyBasedBatcher`.

```java
Producer producer = client.newProducer()
        .topic(&quot;my-topic&quot;)
        .batcherBuilder(BatcherBuilder.KEY_BASED)
        .create();
```

Or the producer can disable batching.

```java
Producer producer = client.newProducer()
        .topic(&quot;my-topic&quot;)
        .enableBatching(false)
        .create();
```

&gt; 注意：
&gt; 
&gt; 如果未指定消息 key，则默认情况下无 key 的消息会按顺序分发给一个消费者。

## Reader

With the [reader interface](/docs/zh-CN/next/concepts-clients#reader-interface), Pulsar clients can &quot;manually position&quot; themselves within a topic and reading all messages from a specified message onward. The Pulsar API for Java enables you to create {@inject: javadoc:Reader:/client/org/apache/pulsar/client/api/Reader} objects by specifying a topic and a {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId}.

The following is an example.

```java
byte[] msgIdBytes = // Some message ID byte array
MessageId id = MessageId.fromByteArray(msgIdBytes);
Reader reader = pulsarClient.newReader()
        .topic(topic)
        .startMessageId(id)
        .create();

while (true) {
    Message message = reader.readNext();
    // Process message
}
```

In the example above, a `Reader` object is instantiated for a specific topic and message (by ID); the reader iterates over each message in the topic after the message is identified by `msgIdBytes` (how that value is obtained depends on the application).

上面的示例代码展示了`Reader`对象指向特定的消息(ID)，但你也可以使用`MessageId.earliest`来指向topic上最早可用的消息，使用`MessageId.latest`指向最新的消息。

### 配置读者

在创建 Reader 时，可以采用 `loadConf` 方式进行配置。`loadConf` 可用的参数如下。

| 名称 | 类型 |

&lt;div style=&quot;width:300px&quot;&gt;
  说明
&lt;/div&gt;
| 默认值 |\---|\---|\---|\--- `topicName`| String | 主题名称。| 无 `receiverQueueSize`| int | 消费者接收队列的大小。  
  
例如，在应用程序调用 Receive 方法之前，消费者可以累积的消息数量。 ` `.  
  
设置高于默认值的值会提高消费者吞吐量，但代价是会增加内存开销。| 1000 `readerListener`| ReaderListener&lt;T&gt; | 收到消息时会被调用的监听器。| 无 `readerName`| String | Reader 名称。|null `subscriptionName`| String | 订阅名称 | 当只有一个主题时，默认的订阅名称是 `&quot;reader-&quot; + 10 位数字的 UUID`.  
当有多个主题时，默认订阅名称是 `&quot;multiTopicsReader-&quot; + 10 位数字的 UUID`. `subscriptionRolePrefix`| String | 订阅角色的前缀。| null `cryptoKeyReader`| CryptoKeyReader | 抽象访问密钥库的接口。| null `cryptoFailureAction`| ConsumerCryptoFailureAction | 当接收到无法解密的消息时，消费者应该采取的行动。  


* **FAIL**：这是在加密成功之前对于失败消息采取的默认选项。
* **DISCARD**：静默地确认消息，而不分发给应用程序。
* **CONSUME**：向应用程序分发加密的消息。而由应用程序负责解密消息。
  
消息解压失败。   
  
如果消息包含批处理消息，则客户端无法在 batch 中检索单条消息。  
  
分发的加密消息包含 {@link EncryptionContext}，其中包含加密和压缩信息，应用程序可以利用这些信息解密消息载荷。| ConsumerCryptoFailureAction.FAIL&lt;/li&gt; `readCompacted`| boolean | 如果启用 `readCompacted`，则消费者从压缩主题中读取消息，而不读取主题的完整消息 backlog。  
  
消费者只能看到压缩主题中每个 key 的最新值，直到压缩 backlog 时主题消息中对应的位点。 超过这一位点，消息照常发送。  
  
`readCompacted` 只能在订阅持久化主题时可以开启，这些主题仅有单个主消费者 (例如，故障或独占订阅模式)。   
  
如果试图在非持久化主题或者共享订阅上开启该功能，则会导致订阅调用抛出 `PulsarClientException`。|false `resetIncludeHead`| boolean | 如果设置为 true，则返回的第一条消息是 messageId 指定的那条。 `messageId`.  
  
如果设置为 false，则返回的第一条消息是 messageId 指定的那条消息的下一条。 `messageId`。|false

### Sticky key range reader

对于黏性 key 范围 Reader，broker 将只分发 key 哈希值在指定范围内的消息。可以在 Reader 上指定多个 key 哈希值范围。

The following is an example to create a sticky key range reader.

```java
pulsarClient.newReader()
        .topic(topic)
        .startMessageId(MessageId.earliest)
        .keyHashRange(Range.of(0, 10000), Range.of(20001, 30000))
        .create();
```

Total hash range size is 65536, so the max end of the range should be less than or equal to 65535.

## Schema

In Pulsar, all message data consists of byte arrays &quot;under the hood.&quot; [Message schemas](/docs/zh-CN/next/schema-get-started) enable you to use other types of data when constructing and handling messages (from simple types like strings to more complex, application-specific types). 如果在不指定 schema 的情况下构造 [生产者](#producer)，那么生产者只能生产 `byte[]` 类型的消息。 The following is an example.

```java
Producer&lt;byte[]&gt; producer = client.newProducer()
        .topic(topic)
        .create();
```

上面的生产者相当于 `Producer&lt;byte[]&gt;` (实际上, 你应该 *总是* 显式指定类型)。 如果你想让产生者使用不同类型的数据，你需要指定一个**schema**来通知Pulsar 在[topic](/docs/zh-CN/next/reference-terminology#topic)上传输哪种类型的数据。

### AvroBaseStructSchema example

假设您有一个 `SensorReading` 类, 你想通过Pulsar主题进行传输:

```java
public class SensorReading {
    public float temperature;

    public SensorReading(float temperature) {
        this.temperature = temperature;
    }

    // A no-arg constructor is required
    public SensorReading() {
    }

    public float getTemperature() {
        return temperature;
    }

    public void setTemperature(float temperature) {
        this.temperature = temperature;
    }
}
```

You could then create a `Producer&lt;SensorReading&gt;` (or `Consumer&lt;SensorReading&gt;`) like this:

```java
Producer&lt;SensorReading&gt; producer = client.newProducer(JSONSchema.of(SensorReading.class))
        .topic(&quot;sensor-readings&quot;)
        .create();
```

以下schema格式目前可用于 Java:

* 无schema 或者字节数组schema(可以使用`Schema.BYTES`)：
    
    ```java
    Producer&lt;byte[]&gt; bytesProducer = client.newProducer(Schema.BYTES)
        .topic(&quot;some-raw-bytes-topic&quot;)
        .create();
    ```
    
    或者:
    
    ```java
    Producer&lt;byte[]&gt; bytesProducer = client.newProducer()
        .topic(&quot;some-raw-bytes-topic&quot;)
        .create();
    ```

* 普通 UTF-8 编码字符串数据的 `String`。使用 `Schema.STRING` 应用该 schema：
    
    ```java
    Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(&quot;some-string-topic&quot;)
        .create();
    ```

* 使用 `Schema.JSON` 为 POJO 创建 JSON schema。下面是一个例子。
    
    ```java
    Producer&lt;MyPojo&gt; pojoProducer = client.newProducer(Schema.JSON(MyPojo.class))
        .topic(&quot;some-pojo-topic&quot;)
        .create();
    ```

* 使用 `Schema.PROTOBUF` 生成 Protobuf schema。 下面的示例演示如何创建 Protobuf schema，并用它来实例化一个新的生产者：
    
    ```java
    Producer&lt;MyProtobuf&gt; protobufProducer = client.newProducer(Schema.PROTOBUF(MyProtobuf.class))
        .topic(&quot;some-protobuf-topic&quot;)
        .create();
    ```

* 使用 `Schema.AVRO` 定义 Avro schema。下面的代码片段演示了如何创建和使用 Avro schema。
    
    ```java
    Producer&lt;MyAvro&gt; avroProducer = client.newProducer(Schema.AVRO(MyAvro.class))
        .topic(&quot;some-avro-topic&quot;)
        .create();
    ```

### ProtobufNativeSchema example

For example of ProtobufNativeSchema, see [`SchemaDefinition` in `Complex type`](/docs/zh-CN/next/schema-understand#complex-type).

## 身份验证

Pulsar currently supports three authentication schemes: [TLS](/docs/zh-CN/next/security-tls-authentication), [Athenz](/docs/zh-CN/next/security-athenz), and [Oauth2](/docs/zh-CN/next/security-oauth2). You can use the Pulsar Java client with all of them.

### TLS 认证

要使用[TLS](/docs/zh-CN/next/security-tls-authentication)，你需要使用`setUseTls`方法设置TLS为`true`，将您的Pulsar客户端指向TLS证书路径，并提供证书和密钥文件的路径。

The following is an example.

```java
Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
authParams.put(&quot;tlsCertFile&quot;, &quot;/path/to/client-cert.pem&quot;);
authParams.put(&quot;tlsKeyFile&quot;, &quot;/path/to/client-key.pem&quot;);

Authentication tlsAuth = AuthenticationFactory
        .create(AuthenticationTls.class.getName(), authParams);

PulsarClient client = PulsarClient.builder()
        .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
        .enableTls(true)
        .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
        .authentication(tlsAuth)
        .build();
```

### Athenz

要使用[Athenz](/docs/zh-CN/next/security-athenz)做为身份认证提供者，你需要[use TLS](#tls-authentication)并且在hash提供如下四个参数的值：

* `tenantDomain`
* `tenantService`
* `providerDomain`
* `privateKey`

还可以设置一个可选的 `keyId`。下面是一个例子。

```java
Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
authParams.put(&quot;tenantDomain&quot;, &quot;shopping&quot;); // Tenant domain name
authParams.put(&quot;tenantService&quot;, &quot;some_app&quot;); // Tenant service name
authParams.put(&quot;providerDomain&quot;, &quot;pulsar&quot;); // Provider domain name
authParams.put(&quot;privateKey&quot;, &quot;file:///path/to/private.pem&quot;); // Tenant private key path
authParams.put(&quot;keyId&quot;, &quot;v1&quot;); // Key id for the tenant private key (optional, default: &quot;0&quot;)

Authentication athenzAuth = AuthenticationFactory
        .create(AuthenticationAthenz.class.getName(), authParams);

PulsarClient client = PulsarClient.builder()
        .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
        .enableTls(true)
        .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
        .authentication(athenzAuth)
        .build();
```

&gt; #### 支持的格式：
&gt; 
&gt; `privateKey`参数支持如下三种格式： * `file:///path/to/file` * `file:/path/to/file` * `data:application/x-pem-file;base64,&lt;base64-encoded value&gt;`

### Oauth2

The following example shows how to use [Oauth2](/docs/zh-CN/next/security-oauth2) as an authentication provider for the Pulsar Java client.

你可以在 Pulsar Java 客户端中使用工厂方法配置身份认证操作。

```java
PulsarClient client = PulsarClient.builder()
    .serviceUrl(&quot;pulsar://broker.example.com:6650/&quot;)
    .authentication(
        AuthenticationFactoryOAuth2.clientCredentials(this.issuerUrl, this.credentialsUrl, this.audience))
    .build();
```

此外，你也可以在 Pulsar 客户端中使用编码参数来配置身份认证。

```java
Authentication auth = AuthenticationFactory
    .create(AuthenticationOAuth2.class.getName(), &quot;{&quot;type&quot;:&quot;client_credentials&quot;,&quot;privateKey&quot;:&quot;...&quot;,&quot;issuerUrl&quot;:&quot;...&quot;,&quot;audience&quot;:&quot;...&quot;}&quot;);
PulsarClient client = PulsarClient.builder()
    .serviceUrl(&quot;pulsar://broker.example.com:6650/&quot;)
    .authentication(auth)
    .build();
```</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/next/client-libraries"><span class="arrow-prev">← </span><span>概述</span></a><a class="docs-next button" href="/docs/zh-CN/next/client-libraries-go"><span>Go</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#安装">安装</a><ul class="toc-headings"><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ul></li><li><a href="#连接-url">连接 URL</a></li><li><a href="#client">Client</a><ul class="toc-headings"><li><a href="#默认的broker-url是单机集群">默认的broker URL是单机集群。</a></li><li><a href="#客户端内存分配器配置">客户端内存分配器配置</a></li></ul></li><li><a href="#生产者producer">生产者（Producer）</a><ul class="toc-headings"><li><a href="#配置producer生产者">配置Producer（生产者）</a></li><li><a href="#消息路由">消息路由</a></li><li><a href="#异步发送">异步发送</a></li><li><a href="#配置消息">配置消息</a></li></ul></li><li><a href="#消费者consumer">消费者（Consumer）</a><ul class="toc-headings"><li><a href="#配置消费者">配置消费者</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2022 The Apache Software Foundation. All Rights Reserved. Apache, Apache Pulsar and the Apache feather logo are trademarks of The Apache Software Foundation.</section><span><script>
      const community = document.querySelector("a[href='#community']").parentNode;
      const communityMenu =
        '<li>' +
        '<a id="community-menu" href="#">Community <span style="font-size: 0.75em">&nbsp;▼</span></a>' +
        '<div id="community-dropdown" class="hide">' +
          '<ul id="community-dropdown-items">' +
            '<li><a href="/zh-CN/contact">Contact</a></li>' +
            '<li><a href="/zh-CN/contributing">Contributing</a></li>' +
            '<li><a href="/zh-CN/coding-guide">Coding guide</a></li>' +
            '<li><a href="/zh-CN/events">Events</a></li>' +
            '<li><a href="https://twitter.com/Apache_Pulsar" target="_blank">Twitter &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/wiki" target="_blank">Wiki &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/issues" target="_blank">Issue tracking &#x2750</a></li>' +
            '<li><a href="https://pulsar-summit.org/" target="_blank">Pulsar Summit &#x2750</a></li>' +
            '<li>&nbsp;</li>' +
            '<li><a href="/zh-CN/resources">Resources</a></li>' +
            '<li><a href="/zh-CN/team">Team</a></li>' +
            '<li><a href="/zh-CN/powered-by">Powered By</a></li>' +
          '</ul>' +
        '</div>' +
        '</li>';

      community.innerHTML = communityMenu;

      const communityMenuItem = document.getElementById("community-menu");
      const communityDropDown = document.getElementById("community-dropdown");
      communityMenuItem.addEventListener("click", function(event) {
        event.preventDefault();

        if (communityDropDown.className == 'hide') {
          communityDropDown.className = 'visible';
        } else {
          communityDropDown.className = 'hide';
        }
      });
    </script></span></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'd226a455cecdd4bc18a554c1b47e5b52',
                indexName: 'apache_pulsar',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN","version:next"]}
              });
            </script></body></html>