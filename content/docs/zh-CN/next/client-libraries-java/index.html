<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Pulsar Java 客户端 · Apache Pulsar</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="可以使用 Pulsar Java 客户端来创建消息的 Java [生产者](#producer), [消费者](#consumer), 以及 [Reader](#reader) ，还可以执行 [管理任务](/docs/zh-CN/next/admin-api-overview)。 Java 客户端的当前版本是 **2.9.1**。"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="zh-CN"/><meta property="og:title" content="Pulsar Java 客户端 · Apache Pulsar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pulsar.apache.org/"/><meta property="og:description" content="可以使用 Pulsar Java 客户端来创建消息的 Java [生产者](#producer), [消费者](#consumer), 以及 [Reader](#reader) ，还可以执行 [管理任务](/docs/zh-CN/next/admin-api-overview)。 Java 客户端的当前版本是 **2.9.1**。"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://pulsar.apache.org/img/pulsar.svg"/><link rel="shortcut icon" href="/img/pulsar.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://pulsar.apache.org/blog/atom.xml" title="Apache Pulsar Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://pulsar.apache.org/blog/feed.xml" title="Apache Pulsar Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-102219959-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/custom.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-CN"><img class="logo" src="/img/pulsar.svg" alt="Apache Pulsar"/></a><a href="/zh-CN/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/standalone" target="_self">文档</a></li><li class=""><a href="/zh-CN/download" target="_self">下载</a></li><li class="siteNavGroupActive"><a href="/docs/zh-CN/next/client-libraries" target="_self">客户端</a></li><li class=""><a href="#restapis" target="_self">REST API</a></li><li class=""><a href="#cli" target="_self">命令行</a></li><li class=""><a href="/blog/" target="_self">博客</a></li><li class=""><a href="#community" target="_self">社区</a></li><li class=""><a href="#apache" target="_self">Apache</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/next/client-libraries-java">English</a></li><li><a href="/docs/ja/next/client-libraries-java">日本語</a></li><li><a href="/docs/fr/next/client-libraries-java">Français</a></li><li><a href="/docs/ko/next/client-libraries-java">한국어</a></li><li><a href="/docs/zh-TW/next/client-libraries-java">繁體中文</a></li><li><a href="https://crowdin.com/project/apache-pulsar" target="_blank" rel="noreferrer noopener">参与翻译</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>客户端库</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Get Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone">本地运行 Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/standalone-docker">在 Docker 中运行 Pulsar</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/kubernetes-helm">在 Kubernetes 中运行 Pulsar</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">概念和架构</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-messaging">消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-architecture-overview">架构</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-clients">客户端</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-replication">跨机房复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multi-tenancy">多租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-authentication">认证和授权</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-topic-compaction">消息压缩</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-proxy-sni-routing">Pulsar Proxy 支持 SNI 路由</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/concepts-multiple-advertised-listeners">配置 Advertised 监听器</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Schema</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-get-started">开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-understand">理解 schema</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-evolution-compatibility">Schema 演化和兼容</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/schema-manage">管理 Schema</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-runtime">设置：配置 Pulsar Functions 运行时</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-worker">设置：Pulsar Functions Worker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-develop">操作：开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-package">如何打包</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-debug">操作：调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-deploy">操作：部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/functions-cli">参考：命令</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/window-functions-context">窗口函数：上下文</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar IO</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-quickstart">开始</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-use">使用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-debug">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-connectors">内置 connector</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cdc">CDC connector</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-develop">开发</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/io-cli">CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar SQL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-getting-started">查询数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-deployment-configurations">配置和部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/sql-rest-api">REST API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">层级存储</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-aws">亚马逊 AWS S3 offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-gcs">GCS offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-filesystem">Filesystem offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-azure">Azure BlobStore offloader</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/tiered-storage-aliyun">阿里云 OSS offloader</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">事务</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-why">为什么需要事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-what">什么是事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-how">事务运行原理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-use">如何使用事务？</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/txn-monitor">如何监控事务？</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Kubernetes (Helm)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-prepare">准备</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-install">安装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-deploy">部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-upgrade">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/helm-tools">所需工具</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">部署</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-aws">Amazon Web Services (Aws)</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-kubernetes">Kubernetes</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal">裸机</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-bare-metal-multi-cluster">裸机多集群部署</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-docker">Docker</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/deploy-monitoring">Monitor</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">系统管理</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-zk-bk">ZooKeeper 和 BookKeeper</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-geo">跨地域复制</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-pulsar-manager">Pulsar Manager</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-stats">Pulsar 统计数据</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-load-balance">负载均衡</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-proxy">Pulsar 代理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-upgrade">升级</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/administration-isolation">Pulsar 隔离</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">安全</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-policy-and-supported-versions">Security Policy and Supported Versions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-transport">使用TLS进行传输加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-authentication">使用TLS进行认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-tls-keystore">使用 TLS 配置KeyStore</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-jwt">使用 JWT 认证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-athenz">使用 Athenz 验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-kerberos">使用 Kerberos 进行身份验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-oauth2">使用 OAuth 2.0 访问令牌进行身份验证</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-authorization">授权和ACL</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-encryption">端到端加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-extending">扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/security-bouncy-castle">Bouncy Castle Providers</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">性能</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/performance-pulsar-perf">Pulsar Perf 性能测试</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">客户端库</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries">概述</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-CN/next/client-libraries-java">Java</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-go">Go</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-python">Python</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-cpp">C++</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-node">Node.js
</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-websocket">WebSocket</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-dotnet">C#</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/client-libraries-rest">REST</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Admin API</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-clusters">集群</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-tenants">租户</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-brokers">Brokers</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-namespaces">命名空间</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-permissions">权限管理</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-topics">Topic</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-functions">Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/admin-api-packages">Package</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">适配器</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-kafka">Kafka 客户端封装</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-spark">Apache Spark</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/adaptors-storm">Apache Storm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考手册</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-compaction">Topic compaction</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-deduplication">消息去重</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-non-persistent">非持久化消息</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-retention-expiry">消息保留和过期</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-encryption">加密</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-message-queue">消息队列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/cookbooks-bookkeepermetadata">BookKeeper Ledger 元数据</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">开发</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-tools">模拟工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-binary-protocol">二进制协议</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-load-manager">模块化负载管理器</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/develop-plugin">Plugin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">参考</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-terminology">术语</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-cli-tools">Pulsar 命令行工具</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-configuration">Pulsar configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-CN/next/reference-metrics">Pulsar Metrics</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/apache-pulsar/zh-CN" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Pulsar Java 客户端</h1></header><article><div><span><p>可以使用 Pulsar Java 客户端来创建消息的 Java <a href="#producer">生产者</a>, <a href="#consumer">消费者</a>, 以及 <a href="#reader">Reader</a> ，还可以执行 <a href="/docs/zh-CN/next/admin-api-overview">管理任务</a>。 Java 客户端的当前版本是 <strong>2.9.1</strong>。</p>
<p>在利用 Java 客户端所创建的<a href="#producer">生产者</a>，<a href="#consumer">消费者</a>和<a href="#reader">读者</a>中所提供的方法都是线程安全的。</p>
<p>Pulsar 客户端的Javadoc 分为如下两个包：</p>
<table>
<thead>
<tr><th style="text-align:left">包</th><th style="text-align:left">说明</th><th style="text-align:left">Maven Artifact</th></tr>
</thead>
<tbody>
<tr><td style="text-align:left"><a href="/api/client/2.9.0-SNAPSHOT"><code>org.apache.pulsar.client.api</code></a></td><td style="text-align:left">生产者和消费者 API</td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client:2.9.1</a></td></tr>
<tr><td style="text-align:left"><a href="/api/admin/2.9.0-SNAPSHOT"><code>org.apache.pulsar.client.admin</code></a></td><td style="text-align:left">Java <a href="/docs/zh-CN/next/admin-api-overview">管理API</a></td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-admin%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client-admin:2.9.1</a></td></tr>
<tr><td style="text-align:left"><code>org.apache.pulsar.client.all</code></td><td style="text-align:left">包含 <code>pulsar-client</code> 和 <code>pulsar-client-admin</code>。</td></tr>
</tbody>
</table>
<p><code>pulsar-client</code> 和 <code>pulsar-client-admin</code> 二者都是被 shade 的包，并且它们是独立地 shade 依赖项的。 因此，同时使用 <code>pulsar-client</code> 和 <code>pulsar-client-admin</code> 的应用程序会有冗余的 shade 类。 如果您引入了新的依赖项，但忘记更新 shade 规则，就会引起问题。<br>
在这种情况下，可以使用 <code>pulsar-client-all</code>，它只对依赖项 shade 一次，并减少了依赖项的大小。 | <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-all%7C2.9.1%7Cjar">org.apache.pulsar:pulsar-client-all:2.9.1</a>     |</p>
<p>本文档仅关注 Pulsar 主题消息的生产和消费的客户端 API。 如果想使用Java版本的管理客户端，可以查看 <a href="/docs/zh-CN/next/admin-api-overview">Pulsar 管理接口</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="安装"></a><a href="#安装" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装</h2>
<p>最新版本的Pulsar Java 客户端库可从 <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.9.1%7Cjar">Maven中央仓库</a> 安装。 要使用最新版本, 请将 <code>pulsar-client</code> 库添加到构建配置中。</p>
<h3><a class="anchor" aria-hidden="true" id="maven"></a><a href="#maven" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maven</h3>
<p>如果你使用Maven，添加下面信息到 <code>pom.xml</code> 文件中。</p>
<pre><code class="hljs css language-xml"><span class="hljs-comment">&lt;!-- 在你的 &lt;properties&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pulsar.version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">pulsar.version</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 在你的 &lt;dependencies&gt; 部分--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.pulsar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pulsar-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${pulsar.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="gradle"></a><a href="#gradle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gradle</h3>
<p>如果你使用Gradle，添加下面内容到<code>build.gradle</code> 文件。</p>
<pre><code class="hljs css language-groovy"><span class="hljs-keyword">def</span> pulsarVersion = <span class="hljs-string">'2.9.1'</span>

dependencies {
    compile <span class="hljs-string">group:</span> <span class="hljs-string">'org.apache.pulsar'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'pulsar-client'</span>, <span class="hljs-string">version:</span> pulsarVersion
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="连接-url"></a><a href="#连接-url" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>连接 URL</h2>
<p>要使用客户端连接到 Pulsar，你需要指定<a href="/docs/zh-CN/next/develop-binary-protocol">Pulsar 协议</a>URL。</p>
<p>可以给特定集群分配 Pulsar 协议格式的 URL，并使用 <code>Pulsar</code> Scheme。默认端口号为 <code>6650</code> 。下面是一个 <code>localhost</code> 例子。</p>
<pre><code class="hljs css language-http">pulsar://localhost:6650
</code></pre>
<p>If you have multiple brokers, the URL is as follows.</p>
<pre><code class="hljs css language-http">pulsar://localhost:6550,localhost:6651,localhost:6652
</code></pre>
<p>A URL for a production Pulsar cluster is as follows.</p>
<pre><code class="hljs css language-http">pulsar://pulsar.us-west.example.com:6650
</code></pre>
<p>If you use <a href="/docs/zh-CN/next/security-tls-authentication">TLS</a> authentication, the URL is as follows.</p>
<pre><code class="hljs css language-http">pulsar+ssl://pulsar.us-west.example.com:6651
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="client"></a><a href="#client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Client</h2>
<p>You can instantiate a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 object using just a URL for the target Pulsar <a href="/docs/zh-CN/next/reference-terminology#cluster">cluster</a> like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650"</span>)
        .build();
</code></pre>
<p>If you have multiple brokers, you can initiate a PulsarClient like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650,localhost:6651,localhost:6652"</span>)
        .build();
</code></pre>
<blockquote>
<h3><a class="anchor" aria-hidden="true" id="默认的broker-url是单机集群"></a><a href="#默认的broker-url是单机集群" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认的broker URL是单机集群。</h3>
<p>如果运行的是 <a href="/docs/zh-CN/next/standalone">standalone </a> 模式的集群，则默认可以通过 <code>pulsar://localhost:6650</code> 这个 URL 来访问 broker。</p>
</blockquote>
<p>在创建客户端时，可以采用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 可用的参数如下。</p>
<p>| 名称 | 类型 |</p>
<div style="width:260px">
  说明
</div>
<p>| 默认值 |---|---|---|--- <code>serviceUrl</code> | String | Pulsar服务的服务 URL 提供者 | 无 <code>authPluginClassName</code> | String | 认证插件的名称 | 无 <code>authParams</code> | String | 认证插件的参数</p>
<p><strong>例如</strong>  <br>
key1:val1,key2:val2 | 无 <code>operationTimeoutMs</code> | long | <code>operationTimeoutMs</code> | 操作超时时长（毫秒） | 30000 <code>statsIntervalSeconds</code> | long | 每个统计信息之间的时间间隔（秒）</p>
<p>当 <code>statsInterval</code>为正数时统计信息才被激活。</p>
<p>请将 <code>statsIntervalSeconds</code> 设置为至少 1 秒。 | 60 <code>numIoThreads</code> | int | 用于处理 broker 连接的线程数 | 1 <code>numListenerThreads</code> | int | 用于处理消息监听器的线程数。 所有的消费者和读者共享监听器线程池，并使用 “监听器”模式获取消息。 对于某个消费者来说，为了保证有序性，总在同一线程中调用监听器。 如果想用多线程处理单个 topic，需要采用 <a href="https://pulsar.apache.org/docs/en/next/concepts-messaging/#shared"><code>shared</code></a> 订阅模式，并为这个订阅创建多个消费者。 这样不能保证有序。| 1 <code>useTcpNoDelay</code>| boolean | 是否在连接上使用 TCP 无延迟标志来禁用 Nagle 算法 | true <code>useTls</code> | boolean | 是否在连接上使用 TLS 加密 | false <code>tlsTrustCertsFilePath</code> | string | 受信 TLS 证书文件的路径 | 无 <code>tlsAllowInsecureConnection</code> | boolean | Pulsar 客户端是否接受来自 broker 的非受信 TLS 证书 | false <code>tlsHostnameVerificationEnable</code> | boolean | 是否启用 TLS 主机名验证 | false <code>concurrentLookupRequest</code> | int | 每个 Broker 连接上允许发送的并发查找请求数，以防止 Broker 过载 | 5000 <code>maxLookupRequest</code> | int | 每个 Broker 连接上允许的最大查找请求数，以防止Broker过载 | 50000 <code>maxNumberOfRejectedRequestPerConnection</code> | int | 在当前连接关闭且客户端创建新连接以连接到另一个 broker 之后的特定时间段 (30秒) 内，broker 请求被拒绝的最大次数 | 50 <code>keepAliveIntervalSeconds</code> | int | 每个客户端 broker 连接的保活间隔的秒数 | 30 <code>connectionTimeoutMs</code> | int | 与 broker 建立连接的等待超时时间</p>
<p>如果持续时间过去了还没有收到 broker 响应，则连接尝试将被丢弃 | 10000 <code>requestTimeoutMs</code> | int | 完成请求的最长持续时间 | 60000 <code>defaultBackoffIntervalNanos</code> | int | Backoff 间隔的默认持续时间 | TimeUnit.MILLISECONDS.toNanos(100); <code>maxBackoffIntervalNanos</code> | long |Backoff 间隔的最大持续时间 | TimeUnit.SECONDS.toNanos(30) <code>socks5ProxyAddress</code> | SocketAddress | SOCKS5 代理地址 | 无 <code>socks5ProxyUsername</code> | string | SOCKS5 代理用户账号 | 无 <code>socks5ProxyPassword</code> | string | SOCKS5 代理用户密码 | 无</p>
<p>Check out the Javadoc for the <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 class for a full list of configurable parameters.</p>
<blockquote>
<p>除了客户端级别的配置，你还可以使用特定于 <a href="#configure-producer">生产者</a>和<a href="#configure-consumer">消费者</a>的配置，下面的章节将会讲述。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="客户端内存分配器配置"></a><a href="#客户端内存分配器配置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>客户端内存分配器配置</h3>
<p>您可以通过 Java 属性来设置客户端内存分配器的配置。</p>
<p>| 属性 | 类型 |</p>
<div>
  说明
</div>
<p>| 默认值 | 可用值 |---|---|---|---|----- <code>pulsar.allocator.pooled</code> | String | 如果设置为 true <code>true</code>，则客户端使用直接内存池。 </br> 如果设置为 false <code>false</code>，则客户端使用堆内存，而不是内存池 | true |</p>
<ul>
<li><p>true</p></li>
<li><p>false
<code>pulsar.allocator.exit_on_oom</code> | String | 当 OOM 出现的时候是否直接退出 JVM | false |</p></li>
<li><p>true</p></li>
<li><p>false
<code>pulsar.allocator.leak_detection</code> | String | Pulsar 服务的服务 URL 提供者 | Disabled |</p></li>
<li><p>Disabled</p></li>
<li><p>Simple</p></li>
<li><p>Advanced</p></li>
<li><p>Paranoid
<code>pulsar.allocator.out_of_memory_policy</code> | String | 当出现 OOM 时，客户端是抛出异常，还是退回使用堆 | FallbackToHeap |</p></li>
<li><p>ThrowException</p></li>
<li><p>FallbackToHeap</p></li>
</ul>
<p><strong>例子</strong>：</p>
<pre><code class="hljs">-Dpulsar.allocator.pooled=true
-Dpulsar.allocator.exit_on_oom=false
-Dpulsar.allocator.leak_detection=Disabled
-Dpulsar.allocator.out_of_memory_policy=ThrowException
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="生产者producer"></a><a href="#生产者producer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生产者（Producer）</h2>
<p>在Pulsar中，生产者写消息到主题中。 一旦你实例化一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
客户端对象(在<a href="#client-configuration">如上</a>z章节)，你可以创建一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/Producer">Producer</a>
生产者用于特定的<a href="/docs/zh-CN/next/reference-terminology#topic">主题</a>。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();

<span class="hljs-comment">// 然后你就可以发送消息到指定的broker 和topic上：</span>
producer.send(<span class="hljs-string">"My message"</span>.getBytes());
</code></pre>
<p>默认情况下，生产者生产的消息为字节数组类型。可以通过指定消息的<a href="#schema">schema</a> 来生产不同类型的消息。</p>
<pre><code class="hljs css language-java">Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();
stringProducer.send(<span class="hljs-string">"My message"</span>);
</code></pre>
<blockquote>
<p>当不再需要生产者、消费者和客户端时，请确保将其关闭。</p>
<pre><code class="hljs css language-java">producer.close();
consumer.close();
client.close();
</code></pre>
<p>关闭操作也可以是异步的：</p>
<pre><code class="hljs css language-java">producer.closeAsync()
   .thenRun(() -&gt; System.out.println(<span class="hljs-string">"Producer closed"</span>))
   .exceptionally((ex) -&gt; {
       System.err.println(<span class="hljs-string">"Failed to close producer: "</span> + ex);
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
   });
</code></pre>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="配置producer生产者"></a><a href="#配置producer生产者" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置Producer（生产者）</h3>
<p>如上例，在实例化 <code>Producer</code> 对象时只指定主题名称的话，生产者将使用默认配置。</p>
<p>创建生产者时可以用 <code>loadConf</code> 方式进行配置。<code>loadConf</code> 的可用参数如下所示。</p>
<p>名称 | 类型 |</p>
<div style="width:300px">
  说明
</div>| 默认值 |\---|\---|\---|\--- 
<p><code>topicName</code>| string | 主题名称 | null | <code>producerName</code>| string | 生产者名称 | null <code>sendTimeoutMs</code>| long | 消息发送的超时时间，单位是毫秒。<br>
如果在超时时间之内消息未被服务端确认 <code>sendTimeout</code> 就会产生错误。| 30000 <code>blockIfQueueFull</code>| boolean | 如果设置为 true <code>true</code>，当传出消息队列已满时， <code>Send</code> and <code>SendAsync</code> 方法会阻塞生产者，而不是失败或抛出错误。<br>
If it is set to <code>false</code>，当传出消息队列已满时， <code>Send</code> and <code>SendAsync</code> 方法会失败，并且 <code>ProducerQueueIsFullError</code> 异常会被抛出。</p>
<p>这个 <code>MaxPendingMessages</code> 参数决定传出消息队列的大小。| false <code>maxPendingMessages</code>| int | 保存待处理消息的队列的最大长度。</p>
<p>例如，一个消息正在等待接收 broker 的确认 <a href="/docs/zh-CN/next/reference-terminology#broker">broker</a>.</p>
<p>默认情况下，当队列已满时，所有调用 <code>Send</code> and <code>SendAsync</code> 方法将会失败， <strong>除非</strong> 你设置 <code>BlockIfQueueFull</code> 为 <code>true</code>。| 1000 <code>maxPendingMessagesAcrossPartitions</code>| int | 跨分区待处理消息的最大数量。</p>
<p>如果待处理消息的总数超过了所配置的值，则使用该设置降低每个分区的最大待处理消息数 ({@link #setMaxPendingMessages(int)}) | 50000 <code>messageRoutingMode</code>| MessageRoutingMode | 分区主题生产者的消息路由逻辑 <a href="/docs/zh-CN/next/concepts-architecture-overview#partitioned-topics"> </a>.<br>
仅当没有设置消息 key 时才应用这个逻辑。<br>
可用选项如下所示：</p>
<ul>
<li><code>pulsar.RoundRobinDistribution</code>: round robin</li>
<li><code>pulsar.UseSinglePartition</code>: publish all messages to a single partition</li>
<li><code>pulsar.CustomPartition</code>：自定义的分区 scheme |<code>pulsar.RoundRobinDistribution</code>
<code>hashingScheme</code>| HashingScheme | 生产消息时用来决定分区的哈希函数 (<strong>仅适用于分区主题</strong>).<br>
可用选项如下所示：</li>
</ul>
<ul>
<li><code>pulsar.JavastringHash</code>：等同于 Java 中的 <code>String.hashCode()</code></li>
<li><code>pulsar.Murmur3_32Hash</code>: applies the <a href="https://en.wikipedia.org/wiki/MurmurHash">Murmur3</a> hashing function</li>
<li><code>pulsar.BoostHash</code>：应用 C++ <a href="https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html">Boost</a> 库中的哈希函数 |
<code>HashingScheme.JavastringHash</code> <code>cryptoFailureAction</code>| ProducerCryptoFailureAction | 当加密失败时生产者需要采取的行动。</li>
</ul>
<ul>
<li><p><strong>FAIL</strong>：如果加密失败，则未加密的消息将会发送失败。</p></li>
<li><p><strong>SEND</strong>：如果加密失败，则未加密的消息将会发送成功。 |
<code>ProducerCryptoFailureAction.FAIL</code> <code>batchingMaxPublishDelayMicros</code>| long | 发送消息时的批处理时间。| TimeUnit.MILLISECONDS.toMicros(1) <code>batchingMaxMessages</code> | int | 一批消息中允许的最大消息个数。| 1000 <code>batchingEnabled</code>| boolean | 启用消息批处理。| true <code>compressionType</code>|CompressionType|Message data compression type used by a producer.<br>
Available options:</p></li>
<li><p><a href="https://github.com/lz4/lz4"><code>LZ4</code></a></p></li>
<li><p><a href="https://zlib.net/"><code>ZLIB</code></a></p>
<ul>
<li><a href="https://facebook.github.io/zstd/"><code>ZSTD</code></a></li>
<li><a href="https://google.github.io/snappy/"><code>SNAPPY</code></a>| No compression</p>
You can configure parameters if you do not want to use the default configuration.</li>
</ul>
<p>如需查看所有参数，可参考 <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/ProducerBuilder">ProducerBuilder</a>
 类的 Javadoc 文档。下面是一个示例。</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
    .topic(<span class="hljs-string">"my-topic"</span>)
    .batchingMaxPublishDelay(<span class="hljs-number">10</span>, TimeUnit.MILLISECONDS)
    .sendTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS)
    .blockIfQueueFull(<span class="hljs-keyword">true</span>)
    .create();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="消息路由"></a><a href="#消息路由" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息路由</h3>
<p>当使用分区主题时，当你使用生产者发布消息时你可以指定路由模式。 关于如何使用 Java 客户端指定路由模式的更多内容，可参考 <a href="/docs/zh-CN/next/cookbooks-partitioned">Partitioned Topics cookbook</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="异步发送"></a><a href="#异步发送" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步发送</h3>
<p>You can publish messages <a href="/docs/zh-CN/next/concepts-messaging#send-modes">asynchronously</a> using the Java client. With async send, the producer puts the message in a blocking queue and returns it immediately. Then the client library sends the message to the broker in the background. If the queue is full (max size configurable), the producer is blocked or fails immediately when calling the API, depending on arguments passed to the producer.</p>
<p>The following is an example.</p>
<pre><code class="hljs css language-java">producer.sendAsync(<span class="hljs-string">"my-async-message"</span>.getBytes()).thenAccept(msgId -&gt; {
    System.out.println(<span class="hljs-string">"Message with ID "</span> + msgId + <span class="hljs-string">" successfully sent"</span>);
});
</code></pre>
<p>As you can see from the example above, async send operations return a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/MessageId">MessageId</a>
 wrapped in a <a href="http://www.baeldung.com/java-completablefuture"><code>CompletableFuture</code></a>.</p>
<h3><a class="anchor" aria-hidden="true" id="配置消息"></a><a href="#配置消息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置消息</h3>
<p>In addition to a value, you can set additional items on a given message:</p>
<pre><code class="hljs css language-java">producer.newMessage()
    .key(<span class="hljs-string">"my-message-key"</span>)
    .value(<span class="hljs-string">"my-async-message"</span>.getBytes())
    .property(<span class="hljs-string">"my-key"</span>, <span class="hljs-string">"my-value"</span>)
    .property(<span class="hljs-string">"my-other-key"</span>, <span class="hljs-string">"my-other-value"</span>)
    .send();
</code></pre>
<p>You can terminate the builder chain with <code>sendAsync()</code> and get a future return.</p>
<h2><a class="anchor" aria-hidden="true" id="消费者consumer"></a><a href="#消费者consumer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消费者（Consumer）</h2>
<p>在Pulsar中，消费者订阅topic主题并处理生产者发布到这些主题的消息。 你可以首先实例化一个<a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
对象并传递给他一个borker(<a href="#client-configuration">如上所示</a>) URL来实例化一个<a href="/docs/zh-CN/next/reference-terminology#consumer">消费者</a>。</p>
<p>Once you've instantiated a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 object, you can create a <a href="https://pulsar.apache.org/api/client/2.9.0-SNAPSHOT/org/apache/pulsar/client/api/Consumer">Consumer</a>
 by specifying a <a href="/docs/zh-CN/next/reference-terminology#topic">topic</a> and a <a href="/docs/zh-CN/next/concepts-messaging#subscription-types">subscription</a>.</p>
<pre><code class="hljs css language-java">Consumer consumer = client.newConsumer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .subscriptionName(<span class="hljs-string">"my-subscription"</span>)
        .subscribe();
</code></pre>
<p>The <code>subscribe</code> method will auto subscribe the consumer to the specified topic and subscription. 一种让消费者监听主题的方法是使用<code>while</code>循环。 In this example loop, the consumer listens for messages, prints the contents of any received message, and then <a href="/docs/zh-CN/next/reference-terminology#acknowledgment-ack">acknowledges</a> that the message has been processed. If the processing logic fails, you can use <a href="/docs/zh-CN/next/reference-terminology#acknowledgment-ack">negative acknowledgement</a> to redeliver the message later.</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
  <span class="hljs-comment">// Wait for a message</span>
  Message msg = consumer.receive();

  <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Do something with the message</span>
      System.out.println(<span class="hljs-string">"Message received: "</span> + <span class="hljs-keyword">new</span> String(msg.getData()));

      <span class="hljs-comment">// Acknowledge the message so that it can be deleted by the message broker</span>
      consumer.acknowledge(msg);
  } <span class="hljs-keyword">catch</span> (Exception e) {
      <span class="hljs-comment">// Message failed to process, redeliver later</span>
      consumer.negativeAcknowledge(msg);
  }
}
</code></pre>
<p>If you don't want to block your main thread and rather listen constantly for new messages, consider using a <code>MessageListener</code>.</p>
<pre><code class="hljs css language-java">MessageListener myMessageListener = (consumer, msg) -&gt; {
  <span class="hljs-keyword">try</span> {
      System.out.println(<span class="hljs-string">"Message received: "</span> + <span class="hljs-keyword">new</span> String(msg.getData()));
      consumer.acknowledge(msg);
  } <span class="hljs-keyword">catch</span> (Exception e) {
      consumer.negativeAcknowledge(msg);
  }
}

Consumer consumer = client.newConsumer()
     .topic(<span class="hljs-string">"my-topic"</span>)
     .subscriptionName(<span class="hljs-string">"my-subscription"</span>)
     .messageListener(myMessageListener)
     .subscribe();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="配置消费者"></a><a href="#配置消费者" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置消费者</h3>
<p>If you instantiate a <code>Consumer</code> object by specifying only a topic and subscription name as in the example above, the consumer uses the default configuration.</p>
<p>When you create a consumer, you can use the <code>loadConf</code> configuration. The following parameters are available in <code>loadConf</code>.</p>
<p>名称 | 类型 |</p>
<p><div style="width:300px">
说明
</div>
| 默认值 |---|---|---|--- <code>topicNames</code>| Set<String>| Topic name| Sets.newTreeSet() <code>topicsPattern</code>|Pattern| Topic pattern |None <code>subscriptionName</code>|String| Subscription name| None <code>subscriptionType</code>|SubscriptionType| Subscription type<br>
Four subscription types are available:</p>
<ul>
<li>Exclusive</li>
<li>Failover（灾备）</li>
<li>Shared（共享）</li>
<li>Key_Shared|SubscriptionType.Exclusive
<code>receiverQueueSize</code> |int | Size of a consumer's receiver queue.</li>
</ul>
<p>For example, the number of messages accumulated by a consumer before an application calls <code>Receive</code>.</p>
<p>A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.| 1000 <code>acknowledgementsGroupTimeMicros</code>|long|Group a consumer acknowledgment for a specified time.</p>
<p>By default, a consumer uses 100ms grouping time to send out acknowledgments to a broker.</p>
<p>Setting a group time of 0 sends out acknowledgments immediately.</p>
<p>A longer ack group time is more efficient at the expense of a slight increase in message re-deliveries after a failure.|TimeUnit.MILLISECONDS.toMicros(100) <code>negativeAckRedeliveryDelayMicros</code>|long|Delay to wait before redelivering messages that failed to be processed.</p>
<p>When an application uses {@link Consumer#negativeAcknowledge(Message)}, failed messages are redelivered after a fixed timeout. |TimeUnit.MINUTES.toMicros(1) <code>maxTotalReceiverQueueSizeAcrossPartitions</code>|int |The max total receiver queue size across partitions.</p>
<p>This setting reduces the receiver queue size for individual partitions if the total receiver queue size exceeds this value.|50000 <code>consumerName</code>|String|Consumer name|null <code>ackTimeoutMillis</code>|long|Timeout of unacked messages|0 <code>tickDurationMillis</code>|long|Granularity of the ack-timeout redelivery.</p>
<p>Using an higher <code>tickDurationMillis</code> reduces the memory overhead to track messages when setting ack-timeout to a bigger value (for example, 1 hour).|1000 <code>priorityLevel</code>|int|Priority level for a consumer to which a broker gives more priority while dispatching messages in Shared subscription type.</p>
<p>The broker follows descending priorities. For example, 0=max-priority, 1, 2,...</p>
<p>In Shared subscription type, the broker <strong>first dispatches messages to the max priority level consumers if they have permits</strong>. Otherwise, the broker considers next priority level consumers.</p>
<p><strong>示例 1</strong>  <br>
If a subscription has consumerA with <code>priorityLevel</code> 0 and consumerB with <code>priorityLevel</code> 1, then the broker <strong>only dispatches messages to consumerA until it runs out permits</strong> and then starts dispatching messages to consumerB.</p>
<p><strong>示例 2</strong>  <br>
Consumer Priority, Level, Permits<br>
C1, 0, 2<br>
C2, 0, 1<br>
C3, 0, 1<br>
C4, 1, 2<br>
C5, 1, 1</p>
<p>Order in which a broker dispatches messages to consumers is: C1, C2, C3, C1, C4, C5, C4.|0 <code>cryptoFailureAction</code>|ConsumerCryptoFailureAction|Consumer should take action when it receives a message that can not be decrypted.</p></li>
</ul>
<pre><code class="hljs">* **FAIL**: this is the default option to fail messages until crypto succeeds.
* **DISCARD**:silently acknowledge and not deliver message to an application.
* **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.
  
消息解压失败。   
  
If messages contain batch messages, a client is not be able to retrieve individual messages in batch.  
  
Delivered encrypted message contains {@link EncryptionContext} which contains encryption and compression information in it using which application can decrypt consumed message payload.|ConsumerCryptoFailureAction.FAIL&lt;/li&gt; `properties`|SortedMap&lt;String, String&gt;|A name or value property of this consumer.  
  
`properties` is application defined metadata attached to a consumer.   
  
When getting a topic stats, associate this metadata with the consumer stats for easier identification.|new TreeMap&lt;&gt;() `readCompacted`|boolean|If enabling `readCompacted`, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.  
  
A consumer only sees the latest value for each key in the compacted topic, up until reaching the point in the topic message when compacting backlog. Beyond that point, send messages as normal.  
  
Only enabling `readCompacted` on subscriptions to persistent topics, which have a single active consumer (like failure or exclusive subscriptions).   
  
Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.|false `subscriptionInitialPosition`|SubscriptionInitialPosition|Initial position at which to set cursor when subscribing to a topic at first time.|SubscriptionInitialPosition.Latest `patternAutoDiscoveryPeriod`|int|Topic auto discovery period when using a pattern for topic's consumer.  
  
The default and minimum value is 1 minute.|1 `regexSubscriptionMode`|RegexSubscriptionMode|When subscribing to a topic using a regular expression, you can pick a certain type of topics.  
  


* **PersistentOnly**: only subscribe to persistent topics.
* **NonPersistentOnly**: only subscribe to non-persistent topics.
* **AllTopics**: subscribe to both persistent and non-persistent topics.|RegexSubscriptionMode.PersistentOnly 
`deadLetterPolicy`|DeadLetterPolicy|Dead letter policy for consumers.  
  
By default, some messages are probably redelivered many times, even to the extent that it never stops.  
  
By using the dead letter mechanism, messages have the max redelivery count. **When exceeding the maximum number of redeliveries, messages are sent to the Dead Letter Topic and acknowledged automatically**.  
  
You can enable the dead letter mechanism by setting `deadLetterPolicy`.  
  
**示例**  
  
`client.newConsumer()&lt;br /&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10).build())&lt;br /&gt;.subscribe();`  
  
Default dead letter topic name is `{TopicName}-{Subscription}-DLQ`.  
  
To set a custom dead letter topic name:  
`client.newConsumer()&lt;br /&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10)&lt;br /&gt;.deadLetterTopic(&quot;your-topic-name&quot;).build())&lt;br /&gt;.subscribe();`  
  
When specifying the dead letter policy while not specifying `ackTimeoutMillis`, you can set the ack timeout to 30000 millisecond.|None `autoUpdatePartitions`|boolean|If `autoUpdatePartitions` is enabled, a consumer subscribes to partition increasement automatically.  
  
**Note**: this is only for partitioned consumers.|true `replicateSubscriptionState`|boolean|If `replicateSubscriptionState` is enabled, a subscription state is replicated to geo-replicated clusters.|false `negativeAckRedeliveryBackoff`|NegativeAckRedeliveryBackoff|Interface for custom message is negativeAcked policy. You can specify `NegativeAckRedeliveryBackoff` for a consumer.| `NegativeAckRedeliveryExponentialBackoff`

You can configure parameters if you do not want to use the default configuration. For a full list, see the Javadoc for the {@inject: javadoc:ConsumerBuilder:/client/org/apache/pulsar/client/api/ConsumerBuilder} class.

The following is an example.

```java
Consumer consumer = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .ackTimeout(10, TimeUnit.SECONDS)
        .subscriptionType(SubscriptionType.Exclusive)
        .subscribe();
```

### 异步接收

The `receive` method receives messages synchronously (the consumer process is blocked until a message is available). You can also use [async receive](/docs/zh-CN/next/concepts-messaging#receive-modes), which returns a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) object immediately once a new message is available.

The following is an example.

```java
CompletableFuture&lt;Message&gt; asyncMessage = consumer.receiveAsync();
```

Async receive operations return a {@inject: javadoc:Message:/client/org/apache/pulsar/client/api/Message} wrapped inside of a [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).

### 批量接收

Use `batchReceive` to receive multiple messages for each call.

The following is an example.

```java
Messages messages = consumer.batchReceive();
for (Object message : messages) {
  // do something
}
consumer.acknowledge(messages)
```

&gt; 注意：
&gt; 
&gt; Batch receive policy limits the number and bytes of messages in a single batch. You can specify a timeout to wait for enough messages.
&gt; 
&gt; 如果满足以下任一条件，则批量接收完成：足够的消息数量、足够的消息字节数、等待超时。
&gt; 
&gt; ```java
&gt; Consumer consumer = client.newConsumer()
&gt;         .topic(&quot;my-topic&quot;)
&gt;         .subscriptionName(&quot;my-subscription&quot;)
&gt;         .batchReceivePolicy(BatchReceivePolicy.builder()
&gt;              .maxNumMessages(100)
&gt;              .maxNumBytes(1024 * 1024)
&gt;              .timeout(200, TimeUnit.MILLISECONDS)
&gt;              .build())
&gt;         .subscribe();
&gt; ```
&gt; 
&gt; 默认批量接收策略是：
&gt; 
&gt; ```java
&gt; BatchReceivePolicy.builder()
&gt;     .maxNumMessage(-1)
&gt;     .maxNumBytes(10 * 1024 * 1024)
&gt;     .timeout(100, TimeUnit.MILLISECONDS)
&gt;     .build();
&gt; ```

### Negative acknowledgment redelivery backoff

The `NegativeAckRedeliveryBackoff` introduces a redelivery backoff mechanism. You can achieve redelivery with different delays by setting `redeliveryCount` of messages.

```java
Consumer consumer =  client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .negativeAckRedeliveryBackoff(NegativeAckRedeliveryExponentialBackoff.builder()
                .minNackTimeMs(1000)
                .maxNackTimeMs(60 * 1000)
                .build())
        .subscribe();
```

&gt; **Note** - The `negativeAckRedeliveryBackoff` does not work with `consumer.negativeAcknowledge(MessageId messageId)` because you are not able to get the redelivery count from the message ID. - If a consumer crashes, it triggers the redelivery of unacked messages. In this case, `NegativeAckRedeliveryBackoff` does not take effect and the messages might get redelivered earlier than the delay time from the backoff.

### 多主题订阅

消费者除了订阅单个Pulsar主题外，你还可以使用[多主题订阅](/docs/zh-CN/next/concepts-messaging#multi-topic-subscriptions)订阅多个主题。 若要使用多主题订阅, 可以提供一个topic正则表达式 (regex) 或 主题`List` 。 如果通过 regex 选择主题, 则所有主题都必须位于同一Pulsar命名空间中。

The followings are some examples.

```java
import org.apache.pulsar.client.api.Consumer;
import org.apache.pulsar.client.api.PulsarClient;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

ConsumerBuilder consumerBuilder = pulsarClient.newConsumer()
        .subscriptionName(subscription);

// Subscribe to all topics in a namespace
Pattern allTopicsInNamespace = Pattern.compile(&quot;public/default/.*&quot;);
Consumer allTopicsConsumer = consumerBuilder
        .topicsPattern(allTopicsInNamespace)
        .subscribe();

// Subscribe to a subsets of topics in a namespace, based on regex
Pattern someTopicsInNamespace = Pattern.compile(&quot;public/default/foo.*&quot;);
Consumer allTopicsConsumer = consumerBuilder
        .topicsPattern(someTopicsInNamespace)
        .subscribe();
```

In the above example, the consumer subscribes to the `persistent` topics that can match the topic name pattern. If you want the consumer subscribes to all `persistent` and `non-persistent` topics that can match the topic name pattern, set `subscriptionTopicsMode` to `RegexSubscriptionMode.AllTopics`.

```java
Pattern pattern = Pattern.compile(&quot;public/default/.*&quot;);
pulsarClient.newConsumer()
        .subscriptionName(&quot;my-sub&quot;)
        .topicsPattern(pattern)
        .subscriptionTopicsMode(RegexSubscriptionMode.AllTopics)
        .subscribe();
```

&gt; **Note**  
&gt; By default, the `subscriptionTopicsMode` of the consumer is `PersistentOnly`. `subscriptionTopicsMode` 的可用选项为： `PersistentOnly`，`NonPersistentOnly`，以及 `AllTopics`。

你还可以订阅明确的主题列表 (如果愿意, 可跨命名空间):

```java
List&lt;String&gt; topics = Arrays.asList(
        &quot;topic-1&quot;,
        &quot;topic-2&quot;,
        &quot;topic-3&quot;
);

Consumer multiTopicConsumer = consumerBuilder
        .topics(topics)
        .subscribe();

// Alternatively:
Consumer multiTopicConsumer = consumerBuilder
        .topic(
            &quot;topic-1&quot;,
            &quot;topic-2&quot;,
            &quot;topic-3&quot;
        )
        .subscribe();
```

You can also subscribe to multiple topics asynchronously using the `subscribeAsync` method rather than the synchronous `subscribe` method. The following is an example.

```java
Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default.*&quot;);
consumerBuilder
        .topics(topics)
        .subscribeAsync()
        .thenAccept(this::receiveMessageFromConsumer);

private void receiveMessageFromConsumer(Object consumer) {
    ((Consumer)consumer).receiveAsync().thenAccept(message -&gt; {
                // Do something with the received message
                receiveMessageFromConsumer(consumer);
            });
}
```

### Subscription types

Pulsar has various [subscription types](concepts-messaging#subscription-types) to match different scenarios. A topic can have multiple subscriptions with different subscription types. However, a subscription can only have one subscription type at a time.

A subscription is identical with the subscription name; a subscription name can specify only one subscription type at a time. To change the subscription type, you should first stop all consumers of this subscription.

Different subscription types have different message distribution types. This section describes the differences of subscription types and how to use them.

In order to better describe their differences, assuming you have a topic named &quot;my-topic&quot;, and the producer has published 10 messages.

```java
Producer&lt;String&gt; producer = client.newProducer(Schema.STRING)
        .topic(&quot;my-topic&quot;)
        .enableBatching(false)
        .create();
// 3 messages with &quot;key-1&quot;, 3 messages with &quot;key-2&quot;, 2 messages with &quot;key-3&quot; and 2 messages with &quot;key-4&quot;
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-1&quot;).send();
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-2&quot;).send();
producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-3&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-1&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-2&quot;).send();
producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-3&quot;).send();
producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-1&quot;).send();
producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-2&quot;).send();
producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-1&quot;).send();
producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-2&quot;).send();
```

#### Exclusive

Create a new consumer and subscribe with the `Exclusive` subscription type.

```java
Consumer consumer = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Exclusive)
        .subscribe()
```

Only the first consumer is allowed to the subscription, other consumers receive an error. The first consumer receives all 10 messages, and the consuming order is the same as the producing order.

&gt; 注意：
&gt; 
&gt; 如果是分区主题，则第一个消费者订阅所有的分区主题，其他消费者不会被分配分区并会收到错误。

#### Failover（灾备）

Create new consumers and subscribe with the`Failover` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Failover)
        .subscribe()
Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Failover)
        .subscribe()
//conumser1 is the active consumer, consumer2 is the standby consumer.
//consumer1 receives 5 messages and then crashes, consumer2 takes over as an  active consumer.


```

Multiple consumers can attach to the same subscription, yet only the first consumer is active, and others are standby. When the active consumer is disconnected, messages will be dispatched to one of standby consumers, and the standby consumer then becomes active consumer.

If the first active consumer is disconnected after receiving 5 messages, the standby consumer becomes active consumer. Consumer1 will receive:

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    

consumer2 will receive:

    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

&gt; 注意：
&gt; 
&gt; 如果是分区主题，则每个分区只有一个活跃消费者， 一个分区的消息只分发给一个消费者，多个分区的消息分发给多个消费者。

#### Shared（共享）

Create new consumers and subscribe with `Shared` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Shared)
        .subscribe()

Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Shared)
        .subscribe()
//Both consumer1 and consumer 2 is active consumers.
```

In Shared subscription type, multiple consumers can attach to the same subscription and messages are delivered in a round robin distribution across consumers.

If a broker dispatches only one message at a time, consumer1 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    

consumer2 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

`Shared` subscription is different from `Exclusive` and `Failover` subscription types. `Shared` subscription has better flexibility, but cannot provide order guarantee.

#### Key_shared

This is a new subscription type since 2.4.0 release. Create new consumers and subscribe with `Key_Shared` subscription type.

```java
Consumer consumer1 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Key_Shared)
        .subscribe()

Consumer consumer2 = client.newConsumer()
        .topic(&quot;my-topic&quot;)
        .subscriptionName(&quot;my-subscription&quot;)
        .subscriptionType(SubscriptionType.Key_Shared)
        .subscribe()
//Both consumer1 and consumer2 are active consumers.
```

Just like in `Shared` subscription, all consumers in `Key_Shared` subscription type can attach to the same subscription. But `Key_Shared` subscription type is different from the `Shared` subscription. In `Key_Shared` subscription type, messages with the same key are delivered to only one consumer in order. The possible distribution of messages between different consumers (by default we do not know in advance which keys will be assigned to a consumer, but a key will only be assigned to a consumer at the same time).

consumer1 receives the following information.

    (&quot;key-1&quot;, &quot;message-1-1&quot;)
    (&quot;key-1&quot;, &quot;message-1-2&quot;)
    (&quot;key-1&quot;, &quot;message-1-3&quot;)
    (&quot;key-3&quot;, &quot;message-3-1&quot;)
    (&quot;key-3&quot;, &quot;message-3-2&quot;)
    

consumer2 receives the following information.

    (&quot;key-2&quot;, &quot;message-2-1&quot;)
    (&quot;key-2&quot;, &quot;message-2-2&quot;)
    (&quot;key-2&quot;, &quot;message-2-3&quot;)
    (&quot;key-4&quot;, &quot;message-4-1&quot;)
    (&quot;key-4&quot;, &quot;message-4-2&quot;)
    

If batching is enabled at the producer side, messages with different keys are added to a batch by default. The broker will dispatch the batch to the consumer, so the default batch mechanism may break the Key_Shared subscription guaranteed message distribution semantics. The producer needs to use the `KeyBasedBatcher`.

```java
Producer producer = client.newProducer()
        .topic(&quot;my-topic&quot;)
        .batcherBuilder(BatcherBuilder.KEY_BASED)
        .create();
```

Or the producer can disable batching.

```java
Producer producer = client.newProducer()
        .topic(&quot;my-topic&quot;)
        .enableBatching(false)
        .create();
```

&gt; 注意：
&gt; 
&gt; 如果未指定消息 key，则默认情况下无 key 的消息会按顺序分发给一个消费者。

## Reader

With the [reader interface](/docs/zh-CN/next/concepts-clients#reader-interface), Pulsar clients can &quot;manually position&quot; themselves within a topic and reading all messages from a specified message onward. The Pulsar API for Java enables you to create {@inject: javadoc:Reader:/client/org/apache/pulsar/client/api/Reader} objects by specifying a topic and a {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId}.

The following is an example.

```java
byte[] msgIdBytes = // Some message ID byte array
MessageId id = MessageId.fromByteArray(msgIdBytes);
Reader reader = pulsarClient.newReader()
        .topic(topic)
        .startMessageId(id)
        .create();

while (true) {
    Message message = reader.readNext();
    // Process message
}
```

In the example above, a `Reader` object is instantiated for a specific topic and message (by ID); the reader iterates over each message in the topic after the message is identified by `msgIdBytes` (how that value is obtained depends on the application).

上面的示例代码展示了`Reader`对象指向特定的消息(ID)，但你也可以使用`MessageId.earliest`来指向topic上最早可用的消息，使用`MessageId.latest`指向最新的消息。

### 配置读者

When you create a reader, you can use the `loadConf` configuration. The following parameters are available in `loadConf`.

| Name | Type|

&lt;div style=&quot;width:300px&quot;&gt;
  说明
&lt;/div&gt;
| Default |\---|\---|\---|\--- `topicName`|String|Topic name. |None `receiverQueueSize`|int|Size of a consumer's receiver queue.  
  
For example, the number of messages that can be accumulated by a consumer before an application calls `Receive`.  
  
A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.|1000 `readerListener`|ReaderListener&lt;T&gt;|A listener that is called for message received.|None `readerName`|String|Reader name.|null `subscriptionName`|String| Subscription name|When there is a single topic, the default subscription name is `&quot;reader-&quot; + 10-digit UUID`.  
When there are multiple topics, the default subscription name is `&quot;multiTopicsReader-&quot; + 10-digit UUID`. `subscriptionRolePrefix`|String|Prefix of subscription role. |null `cryptoKeyReader`|CryptoKeyReader|Interface that abstracts the access to a key store.|null `cryptoFailureAction`|ConsumerCryptoFailureAction|Consumer should take action when it receives a message that can not be decrypted.  


* **FAIL**: this is the default option to fail messages until crypto succeeds.
* **DISCARD**: silently acknowledge and not deliver message to an application.
* **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.
  
消息解压失败。   
  
If messages contain batch messages, a client is not be able to retrieve individual messages in batch.  
  
Delivered encrypted message contains {@link EncryptionContext} which contains encryption and compression information in it using which application can decrypt consumed message payload.|ConsumerCryptoFailureAction.FAIL&lt;/li&gt; `readCompacted`|boolean|If enabling `readCompacted`, a consumer reads messages from a compacted topic rather than a full message backlog of a topic.  
  
A consumer only sees the latest value for each key in the compacted topic, up until reaching the point in the topic message when compacting backlog. Beyond that point, send messages as normal.  
  
`readCompacted` can only be enabled on subscriptions to persistent topics, which have a single active consumer (for example, failure or exclusive subscriptions).   
  
Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.|false `resetIncludeHead`|boolean|If set to true, the first message to be returned is the one specified by `messageId`.  
  
If set to false, the first message to be returned is the one next to the message specified by `messageId`.|false

### Sticky key range reader

In sticky key range reader, broker will only dispatch messages which hash of the message key contains by the specified key hash range. Multiple key hash ranges can be specified on a reader.

The following is an example to create a sticky key range reader.

```java
pulsarClient.newReader()
        .topic(topic)
        .startMessageId(MessageId.earliest)
        .keyHashRange(Range.of(0, 10000), Range.of(20001, 30000))
        .create();
```

Total hash range size is 65536, so the max end of the range should be less than or equal to 65535.

## Schema

In Pulsar, all message data consists of byte arrays &quot;under the hood.&quot; [Message schemas](/docs/zh-CN/next/schema-get-started) enable you to use other types of data when constructing and handling messages (from simple types like strings to more complex, application-specific types). 如果在不指定 schema 的情况下构造 [生产者](#producer)，那么生产者只能生产 `byte[]` 类型的消息。 The following is an example.

```java
Producer&lt;byte[]&gt; producer = client.newProducer()
        .topic(topic)
        .create();
```

上面的生产者相当于 `Producer&lt;byte[]&gt;` (实际上, 你应该 *总是* 显式指定类型)。 如果你想让产生者使用不同类型的数据，你需要指定一个**schema**来通知Pulsar 在[topic](/docs/zh-CN/next/reference-terminology#topic)上传输哪种类型的数据。

### AvroBaseStructSchema example

假设您有一个 `SensorReading` 类, 你想通过Pulsar主题进行传输:

```java
public class SensorReading {
    public float temperature;

    public SensorReading(float temperature) {
        this.temperature = temperature;
    }

    // A no-arg constructor is required
    public SensorReading() {
    }

    public float getTemperature() {
        return temperature;
    }

    public void setTemperature(float temperature) {
        this.temperature = temperature;
    }
}
```

You could then create a `Producer&lt;SensorReading&gt;` (or `Consumer&lt;SensorReading&gt;`) like this:

```java
Producer&lt;SensorReading&gt; producer = client.newProducer(JSONSchema.of(SensorReading.class))
        .topic(&quot;sensor-readings&quot;)
        .create();
```

以下schema格式目前可用于 Java:

* 无schema 或者字节数组schema(可以使用`Schema.BYTES`)：
    
    ```java
    Producer&lt;byte[]&gt; bytesProducer = client.newProducer(Schema.BYTES)
        .topic(&quot;some-raw-bytes-topic&quot;)
        .create();
    ```
    
    或者:
    
    ```java
    Producer&lt;byte[]&gt; bytesProducer = client.newProducer()
        .topic(&quot;some-raw-bytes-topic&quot;)
        .create();
    ```

* 普通 UTF-8 编码字符串数据的 `String`。使用 `Schema.STRING` 应用该 schema：
    
    ```java
    Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(&quot;some-string-topic&quot;)
        .create();
    ```

* 使用 `Schema.JSON` 为 POJO 创建 JSON schema。下面是一个例子。
    
    ```java
    Producer&lt;MyPojo&gt; pojoProducer = client.newProducer(Schema.JSON(MyPojo.class))
        .topic(&quot;some-pojo-topic&quot;)
        .create();
    ```

* 使用 `Schema.PROTOBUF` 生成 Protobuf schema。 下面的示例演示如何创建 Protobuf schema，并用它来实例化一个新的生产者：
    
    ```java
    Producer&lt;MyProtobuf&gt; protobufProducer = client.newProducer(Schema.PROTOBUF(MyProtobuf.class))
        .topic(&quot;some-protobuf-topic&quot;)
        .create();
    ```

* 使用 `Schema.AVRO` 定义 Avro schema。下面的代码片段演示了如何创建和使用 Avro schema。
    
    ```java
    Producer&lt;MyAvro&gt; avroProducer = client.newProducer(Schema.AVRO(MyAvro.class))
        .topic(&quot;some-avro-topic&quot;)
        .create();
    ```

### ProtobufNativeSchema example

For example of ProtobufNativeSchema, see [`SchemaDefinition` in `Complex type`](/docs/zh-CN/next/schema-understand#complex-type).

## 认证

Pulsar currently supports three authentication schemes: [TLS](/docs/zh-CN/next/security-tls-authentication), [Athenz](/docs/zh-CN/next/security-athenz), and [Oauth2](/docs/zh-CN/next/security-oauth2). You can use the Pulsar Java client with all of them.

### TLS 认证

要使用[TLS](/docs/zh-CN/next/security-tls-authentication)，你需要使用`setUseTls`方法设置TLS为`true`，将您的Pulsar客户端指向TLS证书路径，并提供证书和密钥文件的路径。

The following is an example.

```java
Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
authParams.put(&quot;tlsCertFile&quot;, &quot;/path/to/client-cert.pem&quot;);
authParams.put(&quot;tlsKeyFile&quot;, &quot;/path/to/client-key.pem&quot;);

Authentication tlsAuth = AuthenticationFactory
        .create(AuthenticationTls.class.getName(), authParams);

PulsarClient client = PulsarClient.builder()
        .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
        .enableTls(true)
        .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
        .authentication(tlsAuth)
        .build();
```

### Athenz

要使用[Athenz](/docs/zh-CN/next/security-athenz)做为身份认证提供者，你需要[use TLS](#tls-authentication)并且在hash提供如下四个参数的值：

* `tenantDomain`
* `tenantService`
* `providerDomain`
* `privateKey`

You can also set an optional `keyId`. The following is an example.

```java
Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
authParams.put(&quot;tenantDomain&quot;, &quot;shopping&quot;); // Tenant domain name
authParams.put(&quot;tenantService&quot;, &quot;some_app&quot;); // Tenant service name
authParams.put(&quot;providerDomain&quot;, &quot;pulsar&quot;); // Provider domain name
authParams.put(&quot;privateKey&quot;, &quot;file:///path/to/private.pem&quot;); // Tenant private key path
authParams.put(&quot;keyId&quot;, &quot;v1&quot;); // Key id for the tenant private key (optional, default: &quot;0&quot;)

Authentication athenzAuth = AuthenticationFactory
        .create(AuthenticationAthenz.class.getName(), authParams);

PulsarClient client = PulsarClient.builder()
        .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
        .enableTls(true)
        .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
        .authentication(athenzAuth)
        .build();
```

&gt; #### 支持的格式：
&gt; 
&gt; `privateKey`参数支持如下三种格式： * `file:///path/to/file` * `file:/path/to/file` * `data:application/x-pem-file;base64,&lt;base64-encoded value&gt;`

### Oauth2

The following example shows how to use [Oauth2](/docs/zh-CN/next/security-oauth2) as an authentication provider for the Pulsar Java client.

你可以在 Pulsar Java 客户端中使用工厂方法配置身份认证操作。

```java
PulsarClient client = PulsarClient.builder()
    .serviceUrl(&quot;pulsar://broker.example.com:6650/&quot;)
    .authentication(
        AuthenticationFactoryOAuth2.clientCredentials(this.issuerUrl, this.credentialsUrl, this.audience))
    .build();
```

此外，你也可以在 Pulsar 客户端中使用编码参数来配置身份认证。

```java
Authentication auth = AuthenticationFactory
    .create(AuthenticationOAuth2.class.getName(), &quot;{&quot;type&quot;:&quot;client_credentials&quot;,&quot;privateKey&quot;:&quot;...&quot;,&quot;issuerUrl&quot;:&quot;...&quot;,&quot;audience&quot;:&quot;...&quot;}&quot;);
PulsarClient client = PulsarClient.builder()
    .serviceUrl(&quot;pulsar://broker.example.com:6650/&quot;)
    .authentication(auth)
    .build();
```</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-CN/next/client-libraries"><span class="arrow-prev">← </span><span>概述</span></a><a class="docs-next button" href="/docs/zh-CN/next/client-libraries-go"><span>Go</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#安装">安装</a><ul class="toc-headings"><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ul></li><li><a href="#连接-url">连接 URL</a></li><li><a href="#client">Client</a><ul class="toc-headings"><li><a href="#默认的broker-url是单机集群">默认的broker URL是单机集群。</a></li><li><a href="#客户端内存分配器配置">客户端内存分配器配置</a></li></ul></li><li><a href="#生产者producer">生产者（Producer）</a><ul class="toc-headings"><li><a href="#配置producer生产者">配置Producer（生产者）</a></li><li><a href="#消息路由">消息路由</a></li><li><a href="#异步发送">异步发送</a></li><li><a href="#配置消息">配置消息</a></li></ul></li><li><a href="#消费者consumer">消费者（Consumer）</a><ul class="toc-headings"><li><a href="#配置消费者">配置消费者</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2022 The Apache Software Foundation. All Rights Reserved. Apache, Apache Pulsar and the Apache feather logo are trademarks of The Apache Software Foundation.</section><span><script>
      const community = document.querySelector("a[href='#community']").parentNode;
      const communityMenu =
        '<li>' +
        '<a id="community-menu" href="#">Community <span style="font-size: 0.75em">&nbsp;▼</span></a>' +
        '<div id="community-dropdown" class="hide">' +
          '<ul id="community-dropdown-items">' +
            '<li><a href="/zh-CN/contact">Contact</a></li>' +
            '<li><a href="/zh-CN/contributing">Contributing</a></li>' +
            '<li><a href="/zh-CN/coding-guide">Coding guide</a></li>' +
            '<li><a href="/zh-CN/events">Events</a></li>' +
            '<li><a href="https://twitter.com/Apache_Pulsar" target="_blank">Twitter &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/wiki" target="_blank">Wiki &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/issues" target="_blank">Issue tracking &#x2750</a></li>' +
            '<li><a href="https://pulsar-summit.org/" target="_blank">Pulsar Summit &#x2750</a></li>' +
            '<li>&nbsp;</li>' +
            '<li><a href="/zh-CN/resources">Resources</a></li>' +
            '<li><a href="/zh-CN/team">Team</a></li>' +
            '<li><a href="/zh-CN/powered-by">Powered By</a></li>' +
          '</ul>' +
        '</div>' +
        '</li>';

      community.innerHTML = communityMenu;

      const communityMenuItem = document.getElementById("community-menu");
      const communityDropDown = document.getElementById("community-dropdown");
      communityMenuItem.addEventListener("click", function(event) {
        event.preventDefault();

        if (communityDropDown.className == 'hide') {
          communityDropDown.className = 'visible';
        } else {
          communityDropDown.className = 'hide';
        }
      });
    </script></span></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'd226a455cecdd4bc18a554c1b47e5b52',
                indexName: 'apache_pulsar',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:zh-CN","version:next"]}
              });
            </script></body></html>