<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Le client Java pour Pulsar · Apache Pulsar</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Le client Java Pulsar peut être utilisé à la fois pour créer des producteurs, des consommateurs et des [lecteurs](#reader-interface) de messages et pour effectuer des [tâches administratives](/docs/fr/next/admin-api-overview). La version courante du client Java est **2.4.2**."/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Le client Java pour Pulsar · Apache Pulsar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pulsar.incubator.apache.org/"/><meta property="og:description" content="Le client Java Pulsar peut être utilisé à la fois pour créer des producteurs, des consommateurs et des [lecteurs](#reader-interface) de messages et pour effectuer des [tâches administratives](/docs/fr/next/admin-api-overview). La version courante du client Java est **2.4.2**."/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://pulsar.incubator.apache.org/img/pulsar.svg"/><link rel="shortcut icon" href="/img/pulsar.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://pulsar.incubator.apache.org/blog/atom.xml" title="Apache Pulsar Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://pulsar.incubator.apache.org/blog/feed.xml" title="Apache Pulsar Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-102219959-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/custom.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/pulsar.svg" alt="Apache Pulsar"/></a><a href="/fr/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/next/standalone" target="_self">Docs</a></li><li class=""><a href="/fr/download" target="_self">Téléchargement</a></li><li class="siteNavGroupActive"><a href="/docs/fr/next/client-libraries" target="_self">Clients</a></li><li class=""><a href="#restapis" target="_self">API REST</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="#community" target="_self">Communauté</a></li><li class=""><a href="#apache" target="_self">Apache</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/next/client-libraries-java">English</a></li><li><a href="/docs/ja/next/client-libraries-java">日本語</a></li><li><a href="/docs/zh-CN/next/client-libraries-java">中文</a></li><li><a href="https://crowdin.com/project/apache-pulsar" target="_blank" rel="noreferrer noopener">Aidez à traduire</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Client libraries</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Get started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/pulsar-2.0">Pulsar 2.0</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/standalone">Run Pulsar locally</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/standalone-docker">Run Pulsar in Docker</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/client-libraries">Use Pulsar with client libraries</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concepts et architecture</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-messaging">Messaging</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-architecture-overview">Architecture</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-clients">Clients</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-replication">Geo Replication</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-multi-tenancy">Multi Tenancy</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-authentication">Authentication and Authorization</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-topic-compaction">Topic Compaction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-tiered-storage">Tiered Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/concepts-schema-registry">concepts-schema-registry</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Schema</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/schema-get-started">Get started</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/schema-understand">Understand schema</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/schema-evolution-compatibility">Schema evolution and compatibility</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/schema-manage">Manage schema</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar Functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-worker">Setup: Pulsar Functions Worker</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-runtime">Setup: Configure Functions runtime</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-develop">How-to: Develop</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-debug">How-to: Debug</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-deploy">How-to: Deploy</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/functions-cli">Reference: CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar IO</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-quickstart">Get started</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-use">Use</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-debug">Debug</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-connectors">Built-in connector</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-cdc">CDC connector</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-develop">Develop</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/io-cli">CLI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Pulsar SQL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/sql-overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/sql-getting-started">Query data</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/sql-deployment-configurations">Configuration and deployment</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/sql-rest-api">API REST</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deployment</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/deploy-aws">Amazon Web Services</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/deploy-kubernetes">Kubernetes</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/deploy-bare-metal">Bare metal</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/deploy-bare-metal-multi-cluster">Bare metal multi-cluster</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/deploy-dcos">DC/OS</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/deploy-monitoring">Monitoring</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Administration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-zk-bk">ZooKeeper and BookKeeper</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-geo">Geo-replication</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-dashboard">Dashboard</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-pulsar-manager">Pulsar Manager</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-stats">Pulsar statistics</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-load-balance">Load balance</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-proxy">Pulsar proxy</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/administration-upgrade">Upgrade</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Sécurité</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-tls-transport">Transport Encryption using TLS</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-tls-authentication">Authentication using TLS</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-jwt">Authentication using JWT</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-athenz">Authentication using Athenz</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-kerberos">Authentication using Kerberos</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-authorization">Authorization and ACLs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-encryption">End-to-End Encryption</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/security-extending">Extending</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Client libraries</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/next/client-libraries-java">Java</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/client-libraries-go">Go</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/client-libraries-python">Python</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/client-libraries-cpp">C++</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/client-libraries-node">Node.js</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/client-libraries-websocket">WebSocket</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Admin</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-clusters">Clusters</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-tenants">Tenants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-brokers">Brokers</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-namespaces">Espaces de nommage</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-permissions">Permissions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-persistent-topics">Persistent topics</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-non-persistent-topics">Topics non persistants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-partitioned-topics">Partitioned topics</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-non-partitioned-topics">Topics non partitionnés</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-schemas">Schémas</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/admin-api-functions">Functions</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Adaptateurs</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/adaptors-kafka">Wrapper de client Kafka</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/adaptors-spark">Apache Spark</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/adaptors-storm">Apache Storm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Cookbooks</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-tiered-storage">Tiered Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-compaction">Topic compaction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-deduplication">Message deduplication</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-non-persistent">Non-persistent messaging</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-partitioned">Partitioned Topics</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-retention-expiry">Message retention and expiry</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-encryption">Encryption</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-message-queue">Message queue</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/cookbooks-bookkeepermetadata">BookKeeper Ledger Metadata</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Développement</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/develop-tools">Simulation tools</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/develop-binary-protocol">Binary protocol</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/develop-load-manager">Modular load manager</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/develop-cpp">Building Pulsar C++ client</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Référence</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/next/reference-terminology">Terminology</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/reference-cli-tools">Pulsar CLI tools</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/pulsar-admin">Pulsar Admin CLI</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/reference-connector-admin">Connector Admin CLI</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/reference-configuration">Pulsar configuration</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/next/reference-metrics">Pulsar Metrics</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/apache-pulsar/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 id="__docusaurus" class="postHeaderTitle">Le client Java pour Pulsar</h1></header><article><div><span><p>Le client Java Pulsar peut être utilisé à la fois pour créer des producteurs, des consommateurs et des <a href="#reader-interface">lecteurs</a> de messages et pour effectuer des <a href="/docs/fr/next/admin-api-overview">tâches administratives</a>. La version courante du client Java est <strong>2.4.2</strong>.</p>
<p>La javadoc pour le client Pulsar est divisée en deux domaines, par package :</p>
<table>
<thead>
<tr><th style="text-align:left">Package</th><th style="text-align:left">Description</th><th style="text-align:left">Artifact Maven</th></tr>
</thead>
<tbody>
<tr><td style="text-align:left"><a href="/api/client"><code>org.apache.pulsar.client.api</code></a></td><td style="text-align:left">L'API du producteur et du consommateur</td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.4.2%7Cjar">org.apache.pulsar:pulsar-client:2.4.2</a></td></tr>
<tr><td style="text-align:left"><a href="/api/admin"><code>org.apache.pulsar.client.admin</code></a></td><td style="text-align:left">L'API d'administration Java <a href="/docs/fr/next/admin-api-overview"></a></td><td style="text-align:left"><a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client-admin%7C2.4.2%7Cjar">org.apache.pulsar:pulsar-client-admin:2.4.2</a></td></tr>
</tbody>
</table>
<p>Ce document ne se concentre que sur l'API de production et de consommation de messages de topics Pulsar. Pour un guide d'utilisation du client d'administration Java, voir <a href="/docs/fr/next/admin-api-overview">L'interface d'administration Pulsar</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="installation"></a><a href="#installation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>La dernière version de la bibliothèque des clients Pulsar en Java est disponible via <a href="http://search.maven.org/#artifactdetails%7Corg.apache.pulsar%7Cpulsar-client%7C2.4.2%7Cjar">Maven Central</a>. Pour utiliser la dernière version, ajoutez la librairie <code>pulsar-client</code> à votre configuration de build.</p>
<h3><a class="anchor" aria-hidden="true" id="maven"></a><a href="#maven" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Maven</h3>
<p>Si vous utilisez Maven, ajoutez ceci à votre <code>pom.xml</code>:</p>
<pre><code class="hljs css language-xml"><span class="hljs-comment">&lt;!-- dans la section &lt;properties&gt; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">pulsar.version</span>&gt;</span>2.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">pulsar.version</span>&gt;</span>

<span class="hljs-comment">&lt;!--dans la section &lt;dependencies&gt; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.pulsar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pulsar-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${pulsar.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="gradle"></a><a href="#gradle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gradle</h3>
<p>Si vous utilisez Gradle, ajoutez ceci à votre fichier <code>build.gradle</code>:</p>
<pre><code class="hljs css language-groovy"><span class="hljs-keyword">def</span> pulsarVersion = <span class="hljs-string">'2.4.2'</span>

dependencies {
    compile <span class="hljs-string">group:</span> <span class="hljs-string">'org.apache.pulsar'</span>, <span class="hljs-string">name:</span> <span class="hljs-string">'pulsar-client'</span>, <span class="hljs-string">version:</span> pulsarVersion
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="connection-urls"></a><a href="#connection-urls" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Connection URLs</h2>
<p>Pour se connecter à Pulsar en utilisant les bibliothèques clientes, vous devez spécifier une URL du <a href="/docs/fr/next/develop-binary-protocol">protocole Pulsar </a>.</p>
<p>Les URLs du protocole de Pulsar sont assignées à des clusters spécifiques, utilisent le schéma <code>pulsar</code> et ont comme port par défaut 6650. Voici un exemple pour <code>localhost</code>:</p>
<pre><code class="hljs css language-http">pulsar://localhost:6650
</code></pre>
<p>If you have more than one broker, the URL may look like this:</p>
<pre><code class="hljs css language-http">pulsar://localhost:6550,localhost:6651,localhost:6652
</code></pre>
<p>Une URL pour un cluster Pulsar de production peut ressembler à ceci :</p>
<pre><code class="hljs css language-http">pulsar://pulsar.us-west.example.com:6650
</code></pre>
<p>If you're using <a href="/docs/fr/next/security-tls-authentication">TLS</a> authentication, the URL will look like something like this:</p>
<pre><code class="hljs css language-http">pulsar+ssl://pulsar.us-west.example.com:6651
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="client"></a><a href="#client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Client</h2>
<p>Vous pouvez instancier un objet <a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 en fournissant simplement l'URL du <a href="/docs/fr/next/reference-terminology#cluster">cluster</a> Pulsar cible, comme ceci :</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650"</span>)
        .build();
</code></pre>
<p>If you have multiple brokers, you can initiate a PulsarClient like this:</p>
<pre><code class="hljs css language-java">PulsarClient client = PulsarClient.builder()
        .serviceUrl(<span class="hljs-string">"pulsar://localhost:6650,localhost:6651,localhost:6652"</span>)
        .build();
</code></pre>
<blockquote>
<h4><a class="anchor" aria-hidden="true" id="url-par-défaut-pour-les-clusters-en-mode-standalone"></a><a href="#url-par-défaut-pour-les-clusters-en-mode-standalone" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>URL par défaut pour les clusters en mode standalone</h4>
<p>Si vous exécutez un cluster en mode <a href="/docs/fr/next/standalone">standalone</a>, le broker sera disponible à l'URL <code>pulsar://localhost:6650</code> par défaut.</p>
</blockquote>
<p>If you create a client, you may use the <code>loadConf</code> configuration. Below are the available parameters used in <code>loadConf</code>.</p>
<p>| Type | Name |</p>
<div style="width:260px">
  Description
</div>
<p>| Default |---|---|---|--- String | <code>serviceUrl</code> |Service URL provider for Pulsar service | None String | <code>authPluginClassName</code> | Name of the authentication plugin | None String | <code>authParams</code> | String represents parameters for the authentication plugin</p>
<p><strong>Example</strong>  <br>
key1:val1,key2:val2|None long|<code>operationTimeoutMs</code>|Operation timeout |30000 long|<code>statsIntervalSeconds</code>|Interval between each stat info</p>
<p>Stats is activated with positive <code>statsInterval</code></p>
<p><code>statsIntervalSeconds</code> should be set to 1 second at least |60 int|<code>numIoThreads</code>| Number of threads used for handling connections to brokers | 1 int|<code>numListenerThreads</code>|Number of threads used for handling message listeners | 1 boolean|<code>useTcpNoDelay</code>|Whether to use TCP no-delay flag on the connection to disable Nagle algorithm |true boolean |<code>useTls</code> |Whether to use TLS encryption on the connection| false string | <code>tlsTrustCertsFilePath</code> |Path to the trusted TLS certificate file|None boolean|<code>tlsAllowInsecureConnection</code>|Whether the Pulsar client accepts untrusted TLS certificate from broker | false boolean | <code>tlsHostnameVerificationEnable</code> | Whether to enable TLS hostname verification|false int|<code>concurrentLookupRequest</code>|Number of concurrent lookup requests allowed to send on each broker connection to prevent overload on broker|5000 int|<code>maxLookupRequest</code>|Maximum number of lookup requests allowed on each broker connection to prevent overload on broker | 50000 int|<code>maxNumberOfRejectedRequestPerConnection</code>|Maximum number of rejected requests of a broker in a certain time frame (30 seconds) after the current connection is closed and the client creates a new connection to connect to a different broker|50 int|<code>keepAliveIntervalSeconds</code>|Seconds of keeping alive interval for each client broker connection|30 int|<code>connectionTimeoutMs</code>|Duration of waiting for a connection to a broker to be established</p>
<p>If the duration passes without a response from a broker, the connection attempt is dropped|10000 int|<code>requestTimeoutMs</code>|Maximum duration for completing a request |60000 int|<code>defaultBackoffIntervalNanos</code>| Default duration for a backoff interval | TimeUnit.MILLISECONDS.toNanos(100); long|<code>maxBackoffIntervalNanos</code>|Maximum duration for a backoff interval|TimeUnit.SECONDS.toNanos(30)</p>
<p>Consultez la javadoc pour la classe <a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 pour une liste complète des paramètres configurables.</p>
<blockquote>
<p>En plus de la configuration du niveau client, vous pouvez également appliquer une configuration spécifique aux <a href="#configuring-producers">producteurs</a> et aux <a href="#configuring-consumers">consommateurs</a> , comme vous le verrez dans les sections ci-dessous.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="producer"></a><a href="#producer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Producer</h2>
<p>Dans Pulsar, les producteurs écrivent des messages dans des topics. Une fois que vous avez instancié un objet <a href="https://pulsar.incubator.apache.org/api/client/org/apache/pulsar/client/api/PulsarClient">PulsarClient</a>
 (comme dans la section <a href="#client-configuration"> ci-dessus</a>), vous pouvez créer une instance de javadoc:Producteur:/client/org/apache/pulsar/client/api/Producer pour un <a href="/docs/fr/next/reference-terminology#topic">topic</a> Pulsar spécifique.</p>
<pre><code class="hljs css language-java">Producer&lt;<span class="hljs-keyword">byte</span>[]&gt; producer = client.newProducer()
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();

<span class="hljs-comment">// Vous pouvez ensuite envoyer des messages au broker et au topic que vous avez spécifié:</span>
producer.send(<span class="hljs-string">"My message"</span>.getBytes());
</code></pre>
<p>Par défaut, les producteurs produisent des messages qui sont des tableaux d'octets. Cependant, vous pouvez produire différents types en spécifiant un <a href="#schemas">schéma</a> de message.</p>
<pre><code class="hljs css language-java">Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
        .topic(<span class="hljs-string">"my-topic"</span>)
        .create();
stringProducer.send(<span class="hljs-string">"My message"</span>);
</code></pre>
<blockquote>
<p>Vous devriez toujours vous assurer de fermer vos producteurs, consommateurs et clients quand ils ne sont plus nécessaires :</p>
<pre><code class="hljs css language-java"></code></pre>
</blockquote>
<p>producer.close();
consumer.close();
client.close();</p>
<pre><code class="hljs">
Les opérations de fermeture peuvent également être asynchrones :

```java
producer.closeAsync()
   .thenRun(<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> System.out.println(<span class="hljs-string">"Producer closed"</span>))
   .exceptionally(<span class="hljs-function"><span class="hljs-params">(ex)</span> -&gt;</span> {
       System.err.println(<span class="hljs-string">"Failed to close producer: "</span> + ex);
       <span class="hljs-keyword">return</span> null;
   });
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="configure-producer"></a><a href="#configure-producer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Configure producer</h3>
<p>If you instantiate a <code>Producer</code> object specifying only a topic name, as in the example above, the producer uses the default configuration.</p>
<p>If you create a producer, you may use the <code>loadConf</code> configuration. Below are the available parameters used in <code>loadConf</code>.</p>
<p>Type | Name|</p>
<div style="width:300px">
  Description
</div>| Default |\---|\---|\---|\--- String| 
<p><code>topicName</code>| Topic name| null| String|<code>producerName</code>|Producer name| null long|<code>sendTimeoutMs</code>|Message send timeout in ms.</p>
<p>If a message is not acknowledged by a server before the <code>sendTimeout</code> expires, an error is triggered.|30000 boolean|<code>blockIfQueueFull</code>|If set to <code>true</code>, when the outgoing message queue is full, the <code>Send</code> and <code>SendAsync</code> methods of producer block rather than failing and throwing errors.</p>
<p>If set to <code>false</code>, when the outgoing message queue is full, the <code>Send</code> and <code>SendAsync</code> methods of producer fail and throw <code>ProducerQueueIsFullError</code> exceptions.</p>
<p>The size of the outgoing message queue is determined by the <code>MaxPendingMessages</code> parameter.|false int|<code>maxPendingMessages</code>|Maximum size of a queue holding pending messages.</p>
<p>For example, a message waiting to receive an acknowledgment from a <a href="reference-terminology.md#broker">broker</a>.</p>
<p>By default, when the queue is full, all calls to the <code>Send</code> and <code>SendAsync</code> methods fail <strong>unless</strong> <code>BlockIfQueueFull</code> is set to <code>true</code>.|1000 int|<code>maxPendingMessagesAcrossPartitions</code>|Maximum number of pending messages across partitions.</p>
<p>This setting is used to lower the max pending messages for each partition ({@link #setMaxPendingMessages(int)}) if the total exceeds the configured value.|50000 MessageRoutingMode|<code>messageRoutingMode</code>|Message routing logic for producers on <a href="concepts-architecture-overview.md#partitioned-topics">partitioned topics</a>.</p>
<p>This logic is applied only when no key is set on messages.</p>
<p>Below are the available options:</p>
<ul>
<li><p><code>pulsar.RoundRobinDistribution</code>: round robin</p>
<ul>
<li><p><code>pulsar.UseSinglePartition</code>: publish all messages to a single partition</p>
<ul>
<li><p><code>pulsar.CustomPartition</code>: a custom partitioning scheme|<code>pulsar.RoundRobinDistribution</code> HashingScheme|<code>hashingScheme</code>|Hashing function that determines the partition on which a particular message is published (<strong>partitioned topics only</strong>).</p>
<p>Below are the available options:</p>
<ul>
<li><p><code>pulsar.JavaStringHash</code>: the equivalent of <code>String.hashCode()</code> in Java</p>
<ul>
<li><p><code>pulsar.Murmur3_32Hash</code>: applies the <a href="https://en.wikipedia.org/wiki/MurmurHash">Murmur3</a> hashing function</p>
<ul>
<li><p><code>pulsar.BoostHash</code>: applies the hashing function from C++'s <a href="https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html">Boost</a> library |<code>HashingScheme.JavaStringHash</code> ProducerCryptoFailureAction|<code>cryptoFailureAction</code>|Producer should take action when encryption fails.</p>
<ul>
<li><p><strong>FAIL</strong>: if encryption fails, unencrypted messages fail to send.</p></li>
<li><p><strong>SEND</strong>: if encryption fails, unencrypted messages are sent. |<code>ProducerCryptoFailureAction.FAIL</code> long|<code>batchingMaxPublishDelayMicros</code>|Time period within which messages sent will be batched.|TimeUnit.MILLISECONDS.toMicros(1) int|<code>batchingPartitionSwitchFrequencyByPublishDelay</code>|Partition switch frequency while using round-robin routing mode. Time period of the switch is batchingPartitionSwitchFrequencyByPublishDelay * batchingMaxPublishDelayMicros.|10 int|batchingMaxMessages|Maximum number of messages permitted in a batch.|1000 boolean|<code>batchingEnabled</code>|Enable batching of messages. |true CompressionType|<code>compressionType</code>|Message data compression type used by a producer.</p>
<p>Below are the available options:</p>
<ul>
<li><a href="https://github.com/lz4/lz4"><code>LZ4</code></a>
<ul>
<li><a href="https://zlib.net/"><code>ZLIB</code></a>
<ul>
<li><p><a href="https://facebook.github.io/zstd/"><code>ZSTD</code></a>  <br>
* <a href="https://google.github.io/snappy/"><code>SNAPPY</code></a>| No compression</p>
Pour utiliser une configuration différente de celle par défaut, il existe une variété de paramètres configurables que vous pouvez définir.</p>
<pre><code class="hljs">  For a full listing, see the Javadoc for the {@inject: javadoc:ProducerBuilder:/client/org/apache/pulsar/client/api/ProducerBuilder} class. Here's an example:
  
  ```java
  Producer&lt;byte[]&gt; producer = client.newProducer()
      .topic(&quot;my-topic&quot;)
      .batchingMaxPublishDelay(10, TimeUnit.MILLISECONDS)
      .sendTimeout(10, TimeUnit.SECONDS)
      .blockIfQueueFull(true)
      .create();
  ```
  
  ### Routage des messages
  
  Lorsque vous utilisez des topics partitionnés, vous pouvez spécifier le mode de routage lorsque vous publiez des messages avec un producteur. Pour plus d'informations sur la spécification d'un mode de routage en utilisant le client Java, voir le cookbook [Topics Partitionnés](cookbooks-partitioned.md).
  
  ### Envoi Asynchrone
  
  Vous pouvez également publier des messages en mode [asynchrone](concepts-messaging.md#send-modes) avec le client Java. En mode asynchrone, le producteur mettra le message dans une file d'attente bloquante et retournera immédiatement. La bibliothèque cliente enverra ensuite le message au broker en arrière-plan. Si la file d'attente est pleine (taille max configurable), le producteur pourrait être bloqué ou échouer immédiatement lors de l'appel de l'API, selon les arguments passés au producteur.
  
  Voici un exemple d'opération d'envoi asynchrone :
  
  ```java
  producer.sendAsync(&quot;my-async-message&quot;.getBytes()).thenAccept(msgId -&gt; {
      System.out.printf(&quot;Message with ID %s successfully sent&quot;, msgId);
  });
  ```
  
  Comme vous pouvez le voir à partir de l'exemple ci-dessus, les opérations d'envoi asynchrone retournent un {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId} enveloppé dans un [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).
  
  ### Configure messages
  
  En plus d'une valeur, il est possible de définir des éléments supplémentaires sur un message donné :
  
  ```java
  producer.newMessage()
      .key(&quot;my-message-key&quot;)
      .value(&quot;my-async-message&quot;.getBytes())
      .property(&quot;my-key&quot;, &quot;my-value&quot;)
      .property(&quot;my-other-key&quot;, &quot;my-other-value&quot;)
      .send();
  ```
  
  Comme dans le cas précédent, il est également possible de mettre fin à la construction du message avec `sendAsync()` et d'obtenir une future en retour.
  
  ## Consumer
  
  Dans Pulsar, les consommateurs s'abonnent à des topics et traitent les messages que les producteurs publient sur ces topics. Vous pouvez instancier un nouveau [consommateur](reference-terminology.md#consumer) en instanciant d'abord un objet {@inject : javadoc:PulsarClient:/client/org/apache/pulsar/client/api/PulsarClient} et en lui passant l'URL d'un broker Pulsar (comme [ci-dessus](#client-configuration)).
  
  Une fois que vous avez instancié un objet {@inject : javadoc:PulsarClient:/client/org/apache/pulsar/client/api/PulsarClient}, vous pouvez créer un {@inject : javadoc:Consumer:/client/org/apache/pulsar/client/api/Consumer} en précisant un [topic](reference-terminology.md#topic) et un [abonnement](concepts-messaging.md#subscription-modes).
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscribe();
  ```
  
  La méthode d'`abonnement` va automatiquement souscrire le consommateur au topic et à l'abonnement spécifiés. Une façon de faire écouter le consommateur sur le topic est de configurer une boucle `while`. Dans cet exemple de boucle, le consommateur écoute les messages, imprime le contenu de tout message reçu, puis [confirme](reference-terminology.md#acknowledgment-ack) que le message a été traité. Si le traitement échoue, nous utilisons un [acquittement négatif](reference-terminology.md#acknowledgment-ack) pour que le message soit retransmis à une date ultérieure.
  
  ```java
  while (true) {
    // Attente d'un message
    Message msg = consumer.receive();
  
    try {
        // Traitement du message
        System.out.printf(&quot;Message received: %s&quot;, new String(msg.getData()));
  
        // Acquittement du message pour qu'il puisse être effacé par le broker de messages.
        consumer.acknowledge(msg);
    } catch (Exception e) {
        // Echec du traitement, relivraison plus tard
        consumer.negativeAcknowledge(msg);
    }
  }
  ```
  
  ### Configure consumer
  
  Si vous instanciez un objet `Consumer` spécifiant seulement un topic et un nom d'abonnement, comme dans l'exemple ci-dessus, le consommateur utilisera la configuration par défaut.
  
  If you create a consumer, you may use the `loadConf` configuration. Below are the available parameters used in `loadConf`.
  
  Type | Name|
  
  &lt;div style=&quot;width:300px&quot;&gt;
    Description
  &lt;/div&gt;
  | Default |\---|\---|\---|\--- Set&lt;String&gt;| `topicNames`| Topic name| Sets.newTreeSet() Pattern| `topicsPattern`| Topic pattern |None String| `subscriptionName`| Subscription name| None SubscriptionType| `subscriptionType`| Subscription type   
    
  There are three subscription types:
  
  * Exclusive
  * Failover
  * Shared|SubscriptionType.Exclusive int | 
  `receiverQueueSize` | Size of a consumer's receiver queue.   
    
  For example, the number of messages that can be accumulated by a consumer before an application calls `Receive`.   
    
  A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.| 1000 long|`acknowledgementsGroupTimeMicros`|Group a consumer acknowledgment for a specified time.  
    
  By default, a consumer uses 100ms grouping time to send out acknowledgments to a broker.  
    
  Setting a group time of 0 sends out acknowledgments immediately.   
    
  A longer ack group time is more efficient at the expense of a slight increase in message re-deliveries after a failure.|TimeUnit.MILLISECONDS.toMicros(100) long|`negativeAckRedeliveryDelayMicros`|Delay to wait before redelivering messages that have failed to be process.  
    
  When an application uses {@link Consumer#negativeAcknowledge(Message)}, failed messages are redelivered after a fixed timeout. |TimeUnit.MINUTES.toMicros(1) int |`maxTotalReceiverQueueSizeAcrossPartitions`|Max total receiver queue size across partitions.  
    
  This setting reduces the receiver queue size for individual partitions if the total receiver queue size exceeds this value.|50000 String|`consumerName`|Consumer name|null long|`ackTimeoutMillis`|Timeout of unacked messages|0 long|`tickDurationMillis`|Granularity of the ack-timeout redelivery.  
    
  Using an higher `tickDurationMillis` reduces the memory overhead to track messages when the ack-timeout is set to a bigger value (for example, 1 hour).|1000 int|`priorityLevel`|Priority level for a consumer to which a broker gives more priority while dispatching messages in the shared subscription mode.   
    
  Here, the broker follows descending priorities. For example, 0=max-priority, 1, 2,...  
    
  In the shared subscription mode, the broker **first dispatches messages to the max priority level consumers if they have permits**. Otherwise, the broker considers next priority level consumers.  
    
  **Example 1**  
    
  If a subscription has consumerA with `priorityLevel` 0 and consumerB with `priorityLevel` 1, then the broker **only dispatches messages to consumerA until it runs out permits** and then starts dispatching messages to consumerB.  
    
  **Example 2**  
    
  Consumer Priority, Level, Permits  
  C1, 0, 2  
  C2, 0, 1  
  C3, 0, 1  
  C4, 1, 2  
  C5, 1, 1  
    
  Order in which a broker dispatches messages to consumers is: C1, C2, C3, C1, C4, C5, C4.|0 ConsumerCryptoFailureAction|`cryptoFailureAction`|Consumer should take action when it receives a message that can not decrypt.  
    
  
  
  * **FAIL**: this is the default option to fail messages until crypto succeeds.
    
  
  
  * **DISCARD**: message is silently acknowledged and not delivered to an application.
    
  
  
  * **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.  
        
      If message are compressed, the decompression fails.   
        
      If messages contain batch messages, a client is not be able to retrieve individual messages in batch.  
        
      Delivered encrypted message contains {@link EncryptionContext} which contains encryption and compression information in it using which application can decrypt consumed message payload.|ConsumerCryptoFailureAction.FAIL SortedMap&lt;String, String&gt;|
  `properties`|A name or value property of this consumer.  
    
  `properties` is application defined metadata that can be attached to a consumer.   
    
  When getting a topic stats, this metadata is associated to the consumer stats for easier identification.|new TreeMap&lt;&gt;() boolean|`readCompacted`|If `readCompacted` is enabled, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.  
    
  This means if a topic has been compacted, a consumer only see the latest value for each key in the topic, up until the point in the topic message when backlog that has been compacted. Beyond that point, the messages are sent as normal.  
    
  `readCompacted` can only be enabled on subscriptions to persistent topics, which have a single active consumer (for example, failure or exclusive subscriptions).   
    
  Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.|false SubscriptionInitialPosition|`subscriptionInitialPosition`|Initial position at which to set cursor when subscribing to a topic at first time.|SubscriptionInitialPosition.Latest int|`patternAutoDiscoveryPeriod`|Topic auto discovery period when using a pattern for topic's consumer.  
    
  The default and minimum value is 1 minute.|1 RegexSubscriptionMode|`regexSubscriptionMode`|When subscribing to a topic using a regular expression, you can pick a certain type of topics.  
    
  
  
  * **PersistentOnly**: only subscribe to persistent topics.
    
  
  
  * **NonPersistentOnly**: only subscribe to non-persistent topics.
    
  
  
  * **AllTopics**: subscribe to both persistent and non-persistent topics.|RegexSubscriptionMode.PersistentOnly DeadLetterPolicy|
  `deadLetterPolicy`|Dead letter policy for consumers.  
    
  By default, some messages are redelivered many times possible, even to the extent that it can be never stop.  
    
  By using the dead letter mechanism, messages have the max redelivery count. **When message exceeding the maximum number of redeliveries, messages are sent to the Dead Letter Topic and acknowledged automatically**.  
    
  You can enable the dead letter mechanism by setting `deadLetterPolicy`.  
    
  **Example**  
    
  `client.newConsumer()&lt;br/&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10).build())&lt;br/&gt;.subscribe();`  
    
  Default dead letter topic name is `{TopicName}-{Subscription}-DLQ`.  
    
  To set a custom dead letter topic name:  
  `client.newConsumer()&lt;br/&gt;.deadLetterPolicy(DeadLetterPolicy.builder().maxRedeliverCount(10)&lt;br/&gt;.deadLetterTopic(&quot;your-topic-name&quot;).build())&lt;br/&gt;.subscribe();`  
    
  When the dead letter policy is specified and no `ackTimeoutMillis` is specified, then the ack timeout is set to 30000 millisecond.|None boolean|`autoUpdatePartitions`|If `autoUpdatePartitions` is enabled, a consumer subscribes to partition increasement automatically.  
    
  **Note**: this is only for partitioned consumers.|true boolean|`replicateSubscriptionState`|If `replicateSubscriptionState` is enabled, a subscription state is replicated to geo-replicated clusters.|false
  
  Pour utiliser une configuration différente de celle par défaut, il existe une variété de paramètres configurables que vous pouvez définir. Pour une liste complète, voir la javadoc pour la classe {@inject: javadoc:ConsumerBuilder:/client/org/apache/pulsar/client/api/ConsumerBuilder} . Here's an example:
  
  Voici un exemple de configuration :
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .ackTimeout(10, TimeUnit.SECONDS)
          .subscriptionType(SubscriptionType.Exclusive)
          .subscribe();
  ```
  
  ### Réception Asynchrone
  
  La méthode `receive` recevra des messages de manière synchrone (le processus de consommation sera bloqué jusqu'à ce qu'un message soit disponible). Vous pouvez également utiliser [async receive](concepts-messaging.md#receive-modes), qui retournera immédiatement un objet [`CompletableFuture`](http://www.baeldung.com/java-completablefuture) qui se termine une fois qu'un nouveau message est disponible.
  
  Here's an example:
  
  ```java
  CompletableFuture&lt;Message&gt; asyncMessage = consumer.receiveAsync();
  ```
  
  Les opérations de réception asynchrone retournent un {@inject: javadoc:Message:/client/org/apache/pulsar/client/api/Message} enveloppé dans un [`CompletableFuture`](http://www.baeldung.com/java-completablefuture).
  
  ### Batch receive
  
  Use `batchReceive` can receive multiple messages for each calls.
  
  Here's an example:
  
  ```java
  Messages messages = consumer.batchReceive();
  for (message in messages) {
    // do something
  }
  consumer.acknowledge(messages)
  ```
  
  &gt; Note:
  &gt; 
  &gt; Batch receive policy can limit the number and bytes of messages in a single batch, and can specify a timeout for waiting for enough messages.
  &gt; 
  &gt; The batch receive will be completed as long as any one of the conditions(has enough number of messages, has enough of bytes of messages, wait timeout) is met.
  &gt; 
  &gt; ```java
  &gt; Consumer consumer = client.newConsumer()
  &gt;         .topic(&quot;my-topic&quot;)
  &gt;         .subscriptionName(&quot;my-subscription&quot;)
  &gt;         .batchReceivePolicy(BatchReceivePolicy.builder()
  &gt;              .maxNumMessages(100)
  &gt;              .maxNumBytes(1024 * 1024)
  &gt;              .timeout(200, TimeUnit.MILLISECONDS)
  &gt;              .build())
  &gt;         .subscribe();
  &gt; ```
  &gt; 
  &gt; And the default batch receive policy is:
  &gt; 
  &gt; ```java
  &gt; BatchReceivePolicy.builder()
  &gt;     .maxNumMessage(-1)
  &gt;     .maxNumBytes(10 * 1024 * 1024)
  &gt;     .timeout(100, TimeUnit.MILLISECONDS)
  &gt;     .build();
  &gt; ```
  
  ### Abonnements multi-topics
  
  En plus d'abonner un consommateur à un unique topic Pulsar, vous pouvez également vous abonner à plusieurs topic simultanément en utilisant [les abonnements multi-topics](concepts-messaging.md#multi-topic-subscriptions). Pour utiliser les abonnements multi-topics, vous pouvez fournir une expression régulière (regex) ou une `List` de topics. Si vous sélectionnez des topics via des regex, tous les topics doivent être dans le même espace de nommage Pulsar.
  
  Voici quelques exemples :
  
  ```java
  import org.apache.pulsar.client.api.Consumer;
  import org.apache.pulsar.client.api.PulsarClient;
  
  import java.util.Arrays;
  import java.util.List;
  import java.util.regex.Pattern;
  
  ConsumerBuilder consumerBuilder = pulsarClient.newConsumer()
          .subscriptionName(subscription);
  
  // Abonnement à tous les topics d'un namespace
  Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default/.*&quot;);
  Consumer allTopicsConsumer = consumerBuilder
          .topicsPattern(allTopicsInNamespace)
          .subscribe();
  
  // Abonnement à un sous-ensemble des topics d'un namespace, basé sur une regex
  Pattern someTopicsInNamespace = Pattern.compile(&quot;persistent://public/default/foo.*&quot;);
  Consumer allTopicsConsumer = consumerBuilder
          .topicsPattern(someTopicsInNamespace)
          .subscribe();
  ```
  
  Vous pouvez également vous abonner à une liste explicite de topics (à travers les namespaces si vous le souhaitez) :
  
  ```java
  List&lt;String&gt; topics = Arrays.asList(
          &quot;topic-1&quot;,
          &quot;topic-2&quot;,
          &quot;topic-3&quot;
  );
  
  Consumer multiTopicConsumer = consumerBuilder
          .topics(topics)
          .subscribe();
  
  // Sinon, vous pouvez aussi:
  Consumer multiTopicConsumer = consumerBuilder
          .topics(
              &quot;topic-1&quot;,
              &quot;topic-2&quot;,
              &quot;topic-3&quot;
          )
          .subscribe();
  ```
  
  Vous pouvez également vous abonner à plusieurs topics de manière asynchrone en utilisant la méthode `subscribeAsync` plutôt que la méthode synchrone `subscribe`. Voici un exemple :
  
  ```java
  Pattern allTopicsInNamespace = Pattern.compile(&quot;persistent://public/default.*&quot;);
  consumerBuilder
          .topics(topics)
          .subscribeAsync()
          .thenAccept(this::receiveMessageFromConsumer);
  
  private void receiveMessageFromConsumer(Consumer consumer) {
      consumer.receiveAsync().thenAccept(message -&gt; {
                  // Do something with the received message
                  receiveMessageFromConsumer(consumer);
              });
  }
  ```
  
  ### Subscription modes
  
  Pulsar has various [subscription modes](concepts-messaging#subscription-modes) to match different scenarios. A topic can have multiple subscriptions with different subscription modes. However, a subscription can only have one subscription mode at a time.
  
  A subscription is identified with the subscription name, and a subscription name can specify only one subscription mode at a time. You can change the subscription mode, yet you have to let all existing consumers of this subscription offline first.
  
  Different subscription modes have different message distribution modes. This section describes the differences of subscription modes and how to use them.
  
  In order to better describe their differences, assuming you have a topic named &quot;my-topic&quot;, and the producer has published 10 messages.
  
  ```java
  Producer&lt;String&gt; producer = client.newProducer(Schema.STRING)
          .topic(&quot;my-topic&quot;)
          .enableBatching(false)
          .create();
  // 3 messages with &quot;key-1&quot;, 3 messages with &quot;key-2&quot;, 2 messages with &quot;key-3&quot; and 2 messages with &quot;key-4&quot;
  producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-1&quot;).send();
  producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-2&quot;).send();
  producer.newMessage().key(&quot;key-1&quot;).value(&quot;message-1-3&quot;).send();
  producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-1&quot;).send();
  producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-2&quot;).send();
  producer.newMessage().key(&quot;key-2&quot;).value(&quot;message-2-3&quot;).send();
  producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-1&quot;).send();
  producer.newMessage().key(&quot;key-3&quot;).value(&quot;message-3-2&quot;).send();
  producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-1&quot;).send();
  producer.newMessage().key(&quot;key-4&quot;).value(&quot;message-4-2&quot;).send();
  ```
  
  #### Exclusive
  
  Create a new consumer and subscribe with the `Exclusive` subscription mode.
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Exclusive)
          .subscribe()
  ```
  
  Only the first consumer is allowed to the subscription, other consumers receive an error. The first consumer receives all 10 messages, and the consuming order is the same as the producing order.
  
  &gt; Note:
  &gt; 
  &gt; If topic is a partitioned topic, the first consumer subscribes to all partitioned topics, other consumers are not assigned with partitions and receive an error.
  
  #### Failover
  
  Create new consumers and subscribe with the`Failover` subscription mode.
  
  ```java
  Consumer consumer1 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Failover)
          .subscribe()
  Consumer consumer2 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Failover)
          .subscribe()
  //conumser1 is the active consumer, consumer2 is the standby consumer.
  //consumer1 receives 5 messages and then crashes, consumer2 takes over as an  active consumer.
  
  
  ```
  
  Multiple consumers can attach to the same subscription, yet only the first consumer is active, and others are standby. When the active consumer is disconnected, messages will be dispatched to one of standby consumers, and the standby consumer becomes active consumer.
  
  If the first active consumer receives 5 messages and is disconnected, the standby consumer becomes active consumer. Consumer1 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-1&quot;)
      (&quot;key-1&quot;, &quot;message-1-2&quot;)
      (&quot;key-1&quot;, &quot;message-1-3&quot;)
      (&quot;key-2&quot;, &quot;message-2-1&quot;)
      (&quot;key-2&quot;, &quot;message-2-2&quot;)
      
  
  consumer2 will receive:
  
      (&quot;key-2&quot;, &quot;message-2-3&quot;)
      (&quot;key-3&quot;, &quot;message-3-1&quot;)
      (&quot;key-3&quot;, &quot;message-3-2&quot;)
      (&quot;key-4&quot;, &quot;message-4-1&quot;)
      (&quot;key-4&quot;, &quot;message-4-2&quot;)
      
  
  &gt; Note:
  &gt; 
  &gt; If a topic is a partitioned topic, each partition only has one active consumer, messages of one partition only distributed to one consumer, messages of multiple partitions are distributed to multiple consumers.
  
  #### Shared
  
  Create new consumers and subscribe with `Shared` subscription mode:
  
  ```java
  Consumer consumer1 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Shared)
          .subscribe()
  
  Consumer consumer2 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Shared)
          .subscribe()
  //Both consumer1 and consumer 2 is active consumers.
  ```
  
  In shared subscription mode, multiple consumers can attach to the same subscription and message are delivered in a round robin distribution across consumers.
  
  If a broker dispatches only one message at a time, consumer1 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-1&quot;)
      (&quot;key-1&quot;, &quot;message-1-3&quot;)
      (&quot;key-2&quot;, &quot;message-2-2&quot;)
      (&quot;key-3&quot;, &quot;message-3-1&quot;)
      (&quot;key-4&quot;, &quot;message-4-1&quot;)
      
  
  consumer 2 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-2&quot;)
      (&quot;key-2&quot;, &quot;message-2-1&quot;)
      (&quot;key-2&quot;, &quot;message-2-3&quot;)
      (&quot;key-3&quot;, &quot;message-3-2&quot;)
      (&quot;key-4&quot;, &quot;message-4-2&quot;)
      
  
  `Shared` subscription is different from `Exclusive` and `Failover` subscription modes. `Shared` subscription has better flexibility, but cannot provide order guarantee.
  
  #### Key_Shared
  
  This is a new subscription mode since 2.4.0 release, create new consumers and subscribe with `Key_Shared` subscription mode:
  
  ```java
  Consumer consumer1 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Key_Shared)
          .subscribe()
  
  Consumer consumer2 = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Key_Shared)
          .subscribe()
  //Both consumer1 and consumer2 are active consumers.
  ```
  
  `Key_Shared` subscription is like `Shared` subscription, all consumers can attach to the same subscription. But it is different from `Key_Shared` subscription, messages with the same key are delivered to only one consumer in order. The possible distribution of messages between different consumers(by default we do not know in advance which keys will be assigned to a consumer, but a key will only be assigned to a consumer at the same time. ) .
  
  consumer1 will receive:
  
      (&quot;key-1&quot;, &quot;message-1-1&quot;)
      (&quot;key-1&quot;, &quot;message-1-2&quot;)
      (&quot;key-1&quot;, &quot;message-1-3&quot;)
      (&quot;key-3&quot;, &quot;message-3-1&quot;)
      (&quot;key-3&quot;, &quot;message-3-2&quot;)
      
  
  consumer 2 will receive:
  
      (&quot;key-2&quot;, &quot;message-2-1&quot;)
      (&quot;key-2&quot;, &quot;message-2-2&quot;)
      (&quot;key-2&quot;, &quot;message-2-3&quot;)
      (&quot;key-4&quot;, &quot;message-4-1&quot;)
      (&quot;key-4&quot;, &quot;message-4-2&quot;)
      
  
  By default, a consumer in the `Key_Shared` subscription is assigned a fixed hash range of key automatically. If you want to specify the key hash ranges of a consumer, you can use the key shared policy:
  
  ```java
  Consumer consumer = client.newConsumer()
          .topic(&quot;my-topic&quot;)
          .subscriptionName(&quot;my-subscription&quot;)
          .subscriptionType(SubscriptionType.Key_Shared)
              .keySharedPolicy(KeySharedPolicy.sticky().ranges(Range.of(0, 10)))
          .subscribe()
  ```
  
  The consumer with specific key hash ranges can be called a **sticky consumer**. The available key hash range is [0, 65535]. Consumers of a subscription must cover the whole key hash range and can not overlap .
  
  &gt; Note:
  &gt; 
  &gt; If the message key is not specified, messages without key will be dispatched to one consumer in order by default.
  
  ## Reader
  
  Avec l'interface [reader](concepts-clients.md#reader-interface), les clients Pulsar peuvent se positionner manuellement dans un topic, en lisant tous les messages à partir d'un message spécifié. L'API Pulsar pour Java vous permet de créer des objets {@inject: javadoc:Reader:/client/org/apache/pulsar/client/api/Reader} en spécifiant un topic, un {@inject: javadoc:MessageId:/client/org/apache/pulsar/client/api/MessageId}, et un {@inject: javadoc:ReaderConfiguration:/client/org/apache/pulsar/client/api/ReaderConfiguration}.
  
  Here's an example:
  
  ```java
  ReaderConfiguration conf = new ReaderConfiguration();
  byte[] msgIdBytes = // ID d'un message 
  MessageId id = MessageId.fromByteArray(msgIdBytes);
  Reader reader = pulsarClient.newReader()
          .topic(topic)
          .startMessageId(id)
          .create();
  
  while (true) {
      Message message = reader.readNext();
      // Traitement du message
  }
  ```
  
  Dans l'exemple ci-dessus, un objet `Reader` est instancié avec un topic et un id de message spécifiques; le lecteur itère ensuite sur chaque message dans le topic après le message identifié par `msgIdBytes` (la façon dont cette valeur est obtenue dépend de l'application).
  
  L'exemple de code ci-dessus montre l'objet `Reader`pointant vers un message spécifique (identifié par un ID), mais vous pouvez également utiliser `MessageId.earliest` pour pointer vers le message disponible le plus ancien sur le topic ou `MessageId.latest` pour pointer vers le message disponible le plus récent.
  
  If you create a reader, you may use the `loadConf` configuration. Below are the available parameters used in `loadConf`.
  
  | Type | Name |
  
  &lt;div style=&quot;width:300px&quot;&gt;
    Description
  &lt;/div&gt;
  | Default |\---|\---|\---|\--- String|`topicName`|Topic name. |None int|`receiverQueueSize`|Size of a consumer's receiver queue.  
    
  For example, the number of messages that can be accumulated by a consumer before an application calls `Receive`.  
    
  A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.|1000 ReaderListener&lt;T&gt;|`readerListener`|A listener that is called for message received.|None String|`readerName`|Read name.|null String|`subscriptionRolePrefix`|Prefix of subscription role. |null CryptoKeyReader|`cryptoKeyReader`|Interface that abstracts the access to a key store.|null ConsumerCryptoFailureAction|`cryptoFailureAction`|Consumer should take action when it receives a message that can not decrypt.  
    
  
  
  * **FAIL**: this is the default option to fail messages until crypto succeeds.
    
  
  
  * **DISCARD**: message is silently acknowledged and not delivered to an application.
    
  
  
  * **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.  
        
      If message are compressed, the decompression fails.   
        
      If messages contain batch messages, a client is not be able to retrieve individual messages in batch.  
        
      Delivered encrypted message contains {@link EncryptionContext} which contains encryption and compression information in it using which application can decrypt consumed message payload.|ConsumerCryptoFailureAction.FAIL boolean|
  `readCompacted`|If `readCompacted` is enabled, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.  
    
  This means if a topic has been compacted, a consumer only see the latest value for each key in the topic, up until the point in the topic message when backlog that has been compacted. Beyond that point, the messages are sent as normal.  
    
  `readCompacted` can only be enabled on subscriptions to persistent topics, which have a single active consumer (for example, failure or exclusive subscriptions).   
    
  Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.|false boolean|`resetIncludeHead`|If set to true, the first message to be returned is the one specified by `messageId`.  
    
  If set to false, the first message to be returned is the one next to the message specified by `messageId`.|false
  
  ## Schema
  
  In Pulsar, all message data consists of byte arrays &quot;under the hood.&quot; [Message schemas](schema-get-started.md) enable you to use other types of data when constructing and handling messages (from simple types like strings to more complex, application-specific types). Si vous construisez, par exemple, un [producteur](#producers) sans spécifier un schéma, alors le producteur ne peut produire que des messages de type `byte[]`. Here's an example:
  
  ```java
  Producer&lt;byte[]&gt; producer = client.newProducer()
          .topic(topic)
          .create();
  ```
  
  Le producteur ci-dessus est équivalent à un `Producer&lt;byte[]&gt;` (en fait, vous devriez *toujours* spécifier explicitement le type). Si vous souhaitez utiliser un producteur pour un type de données différent, vous devrez spécifier un **schéma** qui informe Pulsar quel type de données sera transmis sur le [topic](reference-terminology.md#topic).
  
  ### Exemple de schéma
  
  Disons que vous avez une classe `SensorReading` que vous souhaitez transmettre sur un topic Pulsar :
  
  ```java
  public class SensorReading {
      public float temperature;
  
      public SensorReading(float temperature) {
          this.temperature = temperature;
      }
  
      // A no-arg constructor is required
      public SensorReading() {
      }
  
      public float getTemperature() {
          return temperature;
      }
  
      public void setTemperature(float temperature) {
          this.temperature = temperature;
      }
  }
  ```
  
  Vous pouvez alors créer un `Producer&lt;SensorReading&gt;` (ou `Consumer&lt;SensorReading&gt;`) ainsi :
  
  ```java
  Producer&lt;SensorReading&gt; producer = client.newProducer(JSONSchema.of(SensorReading.class))
          .topic(&quot;sensor-readings&quot;)
          .create();
  ```
  
  Les formats de schéma suivants sont actuellement disponibles pour Java :
  
  * Aucun schéma ou schéma de tableau d'octets (qui peut être appliqué en utilisant `Schema.BYTES`):
      
      ```java
      Producer&lt;byte[]&gt; bytesProducer = client.newProducer(Schema.BYTES)
          .topic(&quot;some-raw-bytes-topic&quot;)
          .create();
      ```
      
      Ou, de manière équivalente :
      
      ```java
      Producer&lt;byte[]&gt; bytesProducer = client.newProducer()
          .topic(&quot;some-raw-bytes-topic&quot;)
          .create();
      ```
  
  * `String` pour les chaînes de caractères encodées en UTF-8. Ce schéma peut être appliqué en utilisant `Schema.STRING`:
      
      ```java
      Producer&lt;String&gt; stringProducer = client.newProducer(Schema.STRING)
          .topic(&quot;some-string-topic&quot;)
          .create();
      ```
  
  * JSON schemas can be created for POJOs using `Schema.JSON`. Here's an example:
      
      ```java
      Producer&lt;MyPojo&gt; pojoProducer = client.newProducer(Schema.JSON(MyPojo.class))
          .topic(&quot;some-pojo-topic&quot;)
          .create();
      ```
  
  * Protobuf schemas can be generate using `Schema.PROTOBUF`. The following example shows how to create the Protobuf schema and use it to instantiate a new producer:
      
      ```java
      Producer&lt;MyProtobuf&gt; protobufProducer = client.newProducer(Schema.PROTOBUF(MyProtobuf.class))
          .topic(&quot;some-protobuf-topic&quot;)
          .create();
      ```
  
  * Avro schemas can be defined with the help of `Schema.AVRO`. The next code snippet demonstrates the creation and usage of the Avro schema:
      
      ```java
      Producer&lt;MyAvro&gt; avroProducer = client.newProducer(Schema.AVRO(MyAvro.class))
          .topic(&quot;some-avro-topic&quot;)
          .create();
      ```
  
  ## Autentification
  
  Pulsar supporte actuellement deux systèmes d'authentification : [TLS](security-tls-authentication.md) et [Athenz](security-athenz.md). Le client Java Pulsar peut être utilisé avec les deux.
  
  ### TLS Authentication
  
  Pour utiliser [TLS](security-tls-authentication.md), vous devez mettre TLS à `true` en utilisant la méthode `setUseTls` et faire pointer votre client Pulsar vers un cert path TLS, et fournir les chemins pour les fichiers des certificats et des clés.
  
  Voici un exemple de configuration :
  
  ```java
  Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
  authParams.put(&quot;tlsCertFile&quot;, &quot;/path/to/client-cert.pem&quot;);
  authParams.put(&quot;tlsKeyFile&quot;, &quot;/path/to/client-key.pem&quot;);
  
  Authentication tlsAuth = AuthenticationFactory
          .create(AuthenticationTls.class.getName(), authParams);
  
  PulsarClient client = PulsarClient.builder()
          .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
          .enableTls(true)
          .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
          .authentication(tlsAuth)
          .build();
  ```
  
  ### Athenz
  
  Pour utiliser [Athenz](security-athenz.md) comme fournisseur d'authentification, vous devez [utiliser TLS](#tls-authentication) et fournir des valeurs pour quatre paramètres dans une map :
  
  * `tenantDomain`
  * `tenantService`
  * `providerDomain`
  * `privateKey`
  
  Vous pouvez également définir un `keyId` optionnel. Voici un exemple de configuration :
  
  ```java
  Map&lt;String, String&gt; authParams = new HashMap&lt;&gt;();
  authParams.put(&quot;tenantDomain&quot;, &quot;shopping&quot;); // Tenant domain name
  authParams.put(&quot;tenantService&quot;, &quot;some_app&quot;); // Tenant service name
  authParams.put(&quot;providerDomain&quot;, &quot;pulsar&quot;); // Provider domain name
  authParams.put(&quot;privateKey&quot;, &quot;file:///path/to/private.pem&quot;); // Tenant private key path
  authParams.put(&quot;keyId&quot;, &quot;v1&quot;); // Key id for the tenant private key (optional, default: &quot;0&quot;)
  
  Authentication athenzAuth = AuthenticationFactory
          .create(AuthenticationAthenz.class.getName(), authParams);
  
  PulsarClient client = PulsarClient.builder()
          .serviceUrl(&quot;pulsar+ssl://my-broker.com:6651&quot;)
          .enableTls(true)
          .tlsTrustCertsFilePath(&quot;/path/to/cacert.pem&quot;)
          .authentication(athenzAuth)
          .build();
  ```
  
  &gt; #### Formats de modèle supportés
  &gt; 
  &gt; Le paramètre `privateKey` supporte les trois formats de schéma suivants : * `fichier:///chemin/vers/fichier`* * `fichier:/chemin/vers/fichier`* * `data:application/x-pem-file;base64,&lt;base64-encoded value&gt;`</code></pre></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/next/security-extending"><span class="arrow-prev">← </span><span>Extending</span></a><a class="docs-next button" href="/docs/fr/next/client-libraries-go"><span>Go</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#installation">Installation</a><ul class="toc-headings"><li><a href="#maven">Maven</a></li><li><a href="#gradle">Gradle</a></li></ul></li><li><a href="#connection-urls">Connection URLs</a></li><li><a href="#client">Client</a></li><li><a href="#producer">Producer</a><ul class="toc-headings"><li><a href="#configure-producer">Configure producer</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 The Apache Software Foundation. All Rights Reserved. Apache, Apache Pulsar and the Apache feather logo are trademarks of The Apache Software Foundation.</section><span><script>
      const community = document.querySelector("a[href='#community']").parentNode;
      const communityMenu =
        '<li>' +
        '<a id="community-menu" href="#">Community <span style="font-size: 0.75em">&nbsp;▼</span></a>' +
        '<div id="community-dropdown" class="hide">' +
          '<ul id="community-dropdown-items">' +
            '<li><a href="/fr/contact">Contact</a></li>' +
            '<li><a href="/fr/contributing">Contributing</a></li>' +
            '<li><a href="/fr/coding-guide">Coding guide</a></li>' +
            '<li><a href="/fr/events">Events</a></li>' +
            '<li><a href="https://twitter.com/Apache_Pulsar" target="_blank">Twitter &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/wiki" target="_blank">Wiki &#x2750</a></li>' +
            '<li><a href="https://github.com/apache/pulsar/issues" target="_blank">Issue tracking &#x2750</a></li>' +
            '<li>&nbsp;</li>' +
            '<li><a href="/fr/resources">Resources</a></li>' +
            '<li><a href="/fr/team">Team</a></li>' +
            '<li><a href="/fr/powered-by">Powered By</a></li>' +
          '</ul>' +
        '</div>' +
        '</li>';

      community.innerHTML = communityMenu;

      const communityMenuItem = document.getElementById("community-menu");
      const communityDropDown = document.getElementById("community-dropdown");
      communityMenuItem.addEventListener("click", function(event) {
        event.preventDefault();

        if (communityDropDown.className == 'hide') {
          communityDropDown.className = 'visible';
        } else {
          communityDropDown.className = 'hide';
        }
      });
    </script></span></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'd226a455cecdd4bc18a554c1b47e5b52',
                indexName: 'apache_pulsar',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:fr","version:next"]}
              });
            </script></body></html>